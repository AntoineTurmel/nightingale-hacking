
Property changes on: activex\axvlc.def
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\axvlc.idl
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\axvlc.inf.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\axvlc_idl.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\axvlc_idl.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\axvlc_rc.rc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\connectioncontainer.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\connectioncontainer.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\dataobject.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\dataobject.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\guiddef.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\main.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\objectsafety.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\objectsafety.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\olecontrol.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\olecontrol.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\oleinplaceactiveobject.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\oleinplaceactiveobject.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\oleinplaceobject.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\oleinplaceobject.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\oleobject.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\oleobject.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\persistpropbag.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\persistpropbag.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\persiststorage.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\persiststorage.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\persiststreaminit.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\persiststreaminit.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\plugin.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\plugin.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\provideclassinfo.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\provideclassinfo.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\README.TXT
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\supporterrorinfo.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\supporterrorinfo.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\test.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\utils.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\utils.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\viewobject.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\viewobject.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\vlccontrol.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\vlccontrol.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\vlccontrol2.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: activex\vlccontrol2.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: AUTHORS
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\AUTHORS
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\JVLC.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\JVLCBoolVariable.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\JVLCFloatVariable.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\JVLCIntVariable.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\JVLCStringVariable.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\JVLCTimeVariable.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\JVLCVariable.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\JVLCVarValue.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\JVLCVarVariable.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\Makefile
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\README
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\vlc-glue.cc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java-gcj\VlcClient.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\FAQ
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\javadoc.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\Audio.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\AudioIntf.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\GenericVideoWidget.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\Input.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\InputIntf.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\JLibVLC.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\JVLC.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\JVLCCanvas.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\JVLCPanel.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\Playlist.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\PlaylistIntf.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\Video.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\VideoIntf.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\VLCException.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\VLM.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\org\videolan\jvlc\VLMIntf.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\README
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\src\audio-jni.cc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\src\core-jni.cc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\src\graphics-jni.cc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\src\input-jni.cc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\src\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\src\playlist-jni.cc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\src\utils.cc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\src\utils.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\src\video-jni.cc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\src\vlm-jni.cc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\THANKS
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\TODO
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\VlcClient.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\java\VLCExample.java
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\mediacontrol-python\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\mediacontrol-python\setup.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\mediacontrol-python\vlcglue.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\mediacontrol-python\vlcglue.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bindings\mediacontrol-python\vlcwrapper.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: bootstrap
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: build-vlc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ChangeLog
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: config.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: configure.ac
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: COPYING
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: defconfig
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\arm-crosscompile-howto.sgml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\bugreport-howto.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\ChangeLog-1999
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\ChangeLog-2000
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\ChangeLog-2001
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\ChangeLog-2002
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\ChangeLog-2004
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\ChangeLog-2005
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\Configure.help
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\demo.sh
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\aout.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\build.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\coding.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\cpumisc.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\debugging.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\glossary.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\history.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\i18n.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\input.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\interface.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\libvlc.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\Makefile
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\messages.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\modulesobjects.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\playlist.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\porting.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\screen.css
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\sout.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\synopsys.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\threads.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\variables.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\videolan-doc.xsl
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\vlc-dev-doc.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer2\vout.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\audio_output.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\configure.ac
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\debugging.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\decoders.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\gfdl.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\glossary.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\history.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\input.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\interface.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\Makefile
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\Makefile.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\manual.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\manual.xml.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\modules.fig
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\overview.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\ports.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\ps.fig
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\screen.css
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\stream.fig
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\stylesheet-print-noicones.dsl
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\stylesheet-txt.dsl
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\ts.fig
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\video_output.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\videolan-doc-chunk.xsl
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\developer\videolan-doc.xsl
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\Doxyfile
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\Doxyfile.skins2
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\fortunes.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\intf-cdda.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\intf-vcd.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\lirc\example.lircrc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\mad\API
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\mad\DESIGN
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\mad\joe_drew.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\mad\rob_leslie.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\release-howto.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\rrd-howto.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\skins\curve_maker\Bezier.bas
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\skins\curve_maker\Bezier.frm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\skins\curve_maker\bezier.vbp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\skins\curve_maker\Bezier.vbw
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\skins\events-howto.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\skins\skins-howto.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\skins\skins2-howto.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\strings.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\subtitles\cvd-subtitles.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\subtitles\svcd-ogt-subtitles.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\transforms.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\translations.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\vlc-config.1
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\vlc.1
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\vlm.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: doc\win32\Cross-Compile-Howto.txt
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: evc\config.h.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: evc\errno.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: evc\libvlc.vcp.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: evc\modules_builtin_evc.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: evc\plugins.vcp.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: evc\vlc.vcp.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: evc\vlc.vcw
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\bootstrap
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\change_prefix.sh
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\Makefile
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\README
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Makefile
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\packages.mak
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\clinkcc_osx.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\daap.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\dirac-cross.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\dirac-osx.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\dvdnav.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\faac.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\faad2.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\ffmpeg-alignment.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\ffmpeg-svn-beos.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\ffmpeg-svn-wince.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\flac-cross.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\flac-mactel.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\fribidi-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\fribidi.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\fribidi.patch.real
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\gcrypt.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\gettext-macosx.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\glib.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\gnutls-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\goom.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\goom2k4-0-mmx.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\goom2k4-0-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libdc1394-noexamples.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libdvdnav-20050211-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libdvdnav-mactel.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libdvdread-20041028-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libdvdread-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libdvdread.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libebml-svn-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libgpg-error.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libiconv.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libmatroska-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libogg-1.1-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libogg-1.1.3.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libogg-1.1.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libogg-wince.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libpng-darwin-mactel.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libpng-makefile.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libpng-osx.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libpng-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libshout-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\libvorbis-1.1.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\live-osx.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\live.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\livedotcom-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\mpcdec.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\ogg.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\openslp.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\portaudio-cross.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\SDL.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\SDL_image.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\speex-BeOS.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\speex.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\theora-1.0a7.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\theora.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\tremor.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\twolame-BeOS.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\twolame-osx.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\vorbis.patch.cvs
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\wx-cvs-2005-02-09-patch.diff
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\wxMSW-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\wxwidgets_uri.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\x264-20050624-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\x264-svn-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\x264.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\xml2-win32.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\contrib\src\Patches\zlib.patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\emacs.init
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Delete_Preferences.app\Contents\Info.plist
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Delete_Preferences.app\Contents\PkgInfo
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Delete_Preferences.app\Contents\Resources\description.rtfd\TXT.rtf
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\fullscreen_panel.svg
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\plugin\Info.plist
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\plugin\InstallerDescription.plist
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\plugin\InstallerInfo.plist
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\plugin\pbdevelopment.plist
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\About.nib\classes.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\About.nib\info.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Bookmarks.nib\classes.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Bookmarks.nib\info.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Extended.nib\classes.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Extended.nib\info.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\InfoPlist.strings
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Interaction.nib\classes.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Interaction.nib\info.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\MainMenu.nib\classes.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\MainMenu.nib\info.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Open.nib\classes.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Open.nib\info.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Preferences.nib\classes.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Preferences.nib\info.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Update.nib\classes.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Update.nib\info.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Wizard.nib\classes.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\English.lproj\Wizard.nib\info.nib
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\README
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\vlc.scriptSuite
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\Resources\vlc.scriptTerminology
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\MacOSX\vlc.pbproj\project.pbxproj
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\make.pl
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\Makefile
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\valgrind.suppressions
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\vlc.vim
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: extras\zsh.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: HACKING
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\aout_internal.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\audio_output.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\beos_specific.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\charset.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\codecs.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\configuration.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\darwin_specific.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\intf_eject.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\iso_lang.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\libvlc_internal.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\main.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\mediacontrol_internal.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\mmx.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\modules.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\modules_inner.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\mtime.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\network.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\os_specific.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\snapshot.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\stream_output.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\variables.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\video_output.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc\aout.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc\decoder.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc\input.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc\intf.h
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: include/vlc/libvlc.h
===================================================================
--- include/vlc/libvlc.h	(revision 159)
+++ include/vlc/libvlc.h	(working copy)
@@ -1,695 +1,713 @@
-/*****************************************************************************
- * libvlc.h:  libvlc_* new external API
- *****************************************************************************
- * Copyright (C) 1998-2005 the VideoLAN team
- * $Id: vlc.h 13701 2005-12-12 17:58:56Z zorglub $
- *
- * Authors: Clément Stenac <zorglub@videolan.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/**
- * \defgroup libvlc Libvlc
- * This is libvlc, the base library of the VLC program.
- *
- * @{
- */
-
-
-#ifndef _LIBVLC_H
-#define _LIBVLC_H 1
-
-#include <vlc/vlc.h>
-
-# ifdef __cplusplus
-extern "C" {
-# endif
-
-/*****************************************************************************
- * Exception handling
- *****************************************************************************/
-/** defgroup libvlc_exception Exceptions
- * \ingroup libvlc
- * LibVLC Exceptions handling
- * @{
- */
-
-struct libvlc_exception_t
-{
-    int b_raised;
-    char *psz_message;
-};
-typedef struct libvlc_exception_t libvlc_exception_t;
-
-/**
- * Initialize an exception structure. This can be called several times to reuse
- * an exception structure.
- * \param p_exception the exception to initialize
- */
-void libvlc_exception_init( libvlc_exception_t *p_exception );
-
-/**
- * Has an exception been raised ?
- * \param p_exception the exception to query
- * \return 0 if no exception raised, 1 else
- */
-int libvlc_exception_raised( libvlc_exception_t *p_exception );
-
-/**
- * Raise an exception
- * \param p_exception the exception to raise
- * \param psz_message the exception message
- */
-void libvlc_exception_raise( libvlc_exception_t *p_exception, char *psz_format, ... );
-
-/**
- * Clear an exception object so it can be reused.
- * The exception object must be initialized
- * \param p_exception the exception to clear
- */
-void libvlc_exception_clear( libvlc_exception_t * );
-
-/**
- * Get exception message
- * \param p_exception the exception to query
- * \return the exception message or NULL if not applicable (exception not raised
- * for example)
- */
-char* libvlc_exception_get_message( libvlc_exception_t *p_exception );
-
-/**@} */
-
-/*****************************************************************************
- * Core handling
- *****************************************************************************/
-
-/** defgroup libvlc_core Core
- * \ingroup libvlc
- * LibVLC Core
- * @{
- */
-
-/** This structure is opaque. It represents a libvlc instance */
-typedef struct libvlc_instance_t libvlc_instance_t;
-
-/**
- * Create an initialized libvlc instance
- * \param argc the number of arguments
- * \param argv command-line-type arguments
- * \param exception an initialized exception pointer
- */
-libvlc_instance_t * libvlc_new( int , char **, libvlc_exception_t *);
-
-/**
- * Returns a libvlc instance identifier for legacy APIs. Use of this
- * function is discouraged, you should convert your program to use the
- * new API.
- * \param p_instance the instance
- */
-int libvlc_get_vlc_id( libvlc_instance_t *p_instance );
-
-/**
- * Destroy a libvlc instance
- * \param p_instance the instance to destroy
- */
-void libvlc_destroy( libvlc_instance_t *);
-
-/** @}*/
-
-/*****************************************************************************
- * Playlist
- *****************************************************************************/
-/** defgroup libvlc_playlist Playlist
- * \ingroup libvlc
- * LibVLC Playlist handling
- * @{
- */
-
-/**
- * Start playing. You can give some additionnal playlist item options
- * that will be added to the item before playing it.
- * \param p_instance the instance
- * \param i_id the item to play. If this is a negative number, the next
- * item will be selected. Else, the item with the given ID will be played
- * \param i_options the number of options to add to the item
- * \param ppsz_options the options to add to the item
- * \param p_exception an initialized exception
- */
-void libvlc_playlist_play( libvlc_instance_t*, int, int, char **,
-                           libvlc_exception_t * );
-
-/**
- * Pause a running playlist, resume if it was stopped
- * \param p_instance the instance to pause
- * \param p_exception an initialized exception
- */
-void libvlc_playlist_pause( libvlc_instance_t *, libvlc_exception_t * );
-
-/**
- * Checks if the playlist is running
- * \param p_instance the instance
- * \param p_exception an initialized exception
- * \return 0 if the playlist is stopped or paused, 1 if it is running
- */
-int libvlc_playlist_isplaying( libvlc_instance_t *, libvlc_exception_t * );
-
-/**
- * Get the number of items in the playlist
- * \param p_instance the instance
- * \param p_exception an initialized exception
- * \return the number of items
- */
-int libvlc_playlist_items_count( libvlc_instance_t *, libvlc_exception_t * );
-
-/**
- * Stop playing
- * \param p_instance the instance to stop
- * \param p_exception an initialized exception
- */
-void libvlc_playlist_stop( libvlc_instance_t *, libvlc_exception_t * );
-
-/**
- * Go to next playlist item (starts playback if it was stopped)
- * \param p_instance the instance to use
- * \param p_exception an initialized exception
- */
-void libvlc_playlist_next( libvlc_instance_t *, libvlc_exception_t * );
-
-/**
- * Go to previous playlist item (starts playback if it was stopped)
- * \param p_instance the instance to use
- * \param p_exception an initialized exception
- */
-void libvlc_playlist_prev( libvlc_instance_t *, libvlc_exception_t * );
-
-/**
- * Remove all playlist items
- * \param p_instance the instance
- * \param p_exception an initialized exception
- */
-void libvlc_playlist_clear( libvlc_instance_t *, libvlc_exception_t * );
-
-/**
- * Add an item at the end of the playlist
- * If you need more advanced options, \see libvlc_playlist_add_extended
- * \param p_instance the instance
- * \param psz_uri the URI to open, using VLC format
- * \param psz_name a name that you might want to give or NULL
- * \return the identifier of the new item
- */
-int libvlc_playlist_add( libvlc_instance_t *, const char *, const char *,
-                         libvlc_exception_t * );
-
-/**
- * Add an item at the end of the playlist, with additional input options
- * \param p_instance the instance
- * \param psz_uri the URI to open, using VLC format
- * \param psz_name a name that you might want to give or NULL
- * \param i_options the number of options to add
- * \param ppsz_options strings representing the options to add
- * \param p_exception an initialized exception
- * \return the identifier of the new item
- */
-int libvlc_playlist_add_extended( libvlc_instance_t *, const char *,
-                                  const char *, int, const char **,
-                                  libvlc_exception_t * );
-
-/** 
- * Delete the playlist item with the given ID.
- * \param p_instance the instance
- * \param i_id the id to remove
- * \param p_exception an initialized exception
- * \return
- */
-int libvlc_playlist_delete_item( libvlc_instance_t *, int,
-                                 libvlc_exception_t * );
-
-typedef struct libvlc_input_t libvlc_input_t;
-
-/* Get the input that is currently being played by the playlist
- * \param p_instance the instance to use
- * \param p_exception an initialized excecption
- * \return an input object
- */
-libvlc_input_t *libvlc_playlist_get_input( libvlc_instance_t *,
-                                           libvlc_exception_t * );
-
-/** @}*/
-
-/*****************************************************************************
- * Input
- *****************************************************************************/
-/** defgroup libvlc_input Input
- * \ingroup libvlc
- * LibVLC Input handling
- * @{
- */
-
-/** Free an input object
- * \param p_input the input to free
- */
-void libvlc_input_free( libvlc_input_t * );
-
-/// \bug This might go away ... to be replaced by a broader system
-vlc_int64_t libvlc_input_get_length     ( libvlc_input_t *, libvlc_exception_t *);
-vlc_int64_t libvlc_input_get_time       ( libvlc_input_t *, libvlc_exception_t *);
-void        libvlc_input_set_time       ( libvlc_input_t *, vlc_int64_t, libvlc_exception_t *);
-float       libvlc_input_get_position   ( libvlc_input_t *, libvlc_exception_t *);
-void        libvlc_input_set_position   ( libvlc_input_t *, float, libvlc_exception_t *);
-vlc_bool_t  libvlc_input_will_play      ( libvlc_input_t *, libvlc_exception_t *);
-float       libvlc_input_get_rate       ( libvlc_input_t *, libvlc_exception_t *);
-void        libvlc_input_set_rate       ( libvlc_input_t *, float, libvlc_exception_t *);
-int         libvlc_input_get_state      ( libvlc_input_t *, libvlc_exception_t *);
-
-/** @} */
-
-/** defgroup libvlc_video Video
- * \ingroup libvlc
- * LibVLC Video handling
- * @{
- */
-
-/**
- * Does this input have a video output ?
- * \param p_input the input
- * \param p_exception an initialized exception
- */
-vlc_bool_t  libvlc_input_has_vout       ( libvlc_input_t *, libvlc_exception_t *);
-float       libvlc_input_get_fps        ( libvlc_input_t *, libvlc_exception_t *);
-
-/**
- * Toggle fullscreen status on video output
- * \param p_input the input
- * \param p_exception an initialized exception
- */
-void libvlc_toggle_fullscreen( libvlc_input_t *, libvlc_exception_t * );
-
-/**
- * Enable or disable fullscreen on a video output
- * \param p_input the input
- * \param b_fullscreen boolean for fullscreen status
- * \param p_exception an initialized exception
- */
-void libvlc_set_fullscreen( libvlc_input_t *, int, libvlc_exception_t * );
-
-/**
- * Get current fullscreen status
- * \param p_input the input
- * \param p_exception an initialized exception
- * \return the fullscreen status (boolean)
- */
-int libvlc_get_fullscreen( libvlc_input_t *, libvlc_exception_t * );
-
-/**
- * Get current video height
- * \param p_input the input
- * \param p_exception an initialized exception
- * \return the video height
- */
-int libvlc_video_get_height( libvlc_input_t *, libvlc_exception_t * );
-
-/**
- * Get current video width
- * \param p_input the input
- * \param p_exception an initialized exception
- * \return the video width
- */
-int libvlc_video_get_width( libvlc_input_t *, libvlc_exception_t * );
-
-/**
- * Get current video aspect ratio
- * \param p_input the input
- * \param p_exception an initialized exception
- * \return the video aspect ratio
- */
-char *libvlc_video_get_aspect_ratio( libvlc_input_t *, libvlc_exception_t * );
-
-/**
- * Set new video aspect ratio
- * \param p_input the input
- * \param psz_aspect new video aspect-ratio
- * \param p_exception an initialized exception
- */
-void libvlc_video_set_aspect_ratio( libvlc_input_t *, char *, libvlc_exception_t * );
-
-/**
- * Take a snapshot of the current video window
- * \param p_input the input
- * \param psz_filepath the path where to save the screenshot to
- * \param p_exception an initialized exception
- */
-void libvlc_video_take_snapshot( libvlc_input_t *, char *, libvlc_exception_t * );
-
-int libvlc_video_destroy( libvlc_input_t *, libvlc_exception_t *);
-
-/**
- * Resize the video output window
- * \param p_instance libvlc instance
- * \param width new width for video output window
- * \param height new height for video output window
- * \param p_exception an initialized exception
- * \return the mute status (boolean)
- */
-void libvlc_video_resize( libvlc_input_t *, int, int, libvlc_exception_t *);
-
-/**
-* Downcast to this general type as placeholder for a platform specific one, such as:
-*  Drawable on X11,
-*  CGrafPort on MacOSX,
-*  HWND on win32
-*/
-typedef int libvlc_drawable_t;
-
-/**
- * Get current mute status
- * \param p_instance libvlc instance
- * \param drawable the new parent window (Drawable on X11, CGrafPort on MacOSX, HWND on Win32)
- * \param p_exception an initialized exception
- * \return the mute status (boolean)
- */
-int libvlc_video_reparent( libvlc_input_t *, libvlc_drawable_t, libvlc_exception_t * );
-
-/**
- * Embedding support: Set/change the default parent drawable for video outputs
- * \param p_instance libvlc instance
- * \param drawable the new parent window (Drawable on X11, CGrafPort on MacOSX, HWND on Win32)
- * \param p_exception an initialized exception
- */
-void libvlc_video_set_parent( libvlc_instance_t *, libvlc_drawable_t, libvlc_exception_t * );
-
-/**
- * Embedding support: Set/change the default size for video outputs
- * \param p_instance libvlc instance
- * \param width new width for video drawable
- * \param height new height for video drawable
- * \param p_exception an initialized exception
- */
-void libvlc_video_set_size( libvlc_instance_t *, int, int, libvlc_exception_t * );
-
-/**
-* Embedding support: rectangle for viewport
-*/
-typedef struct
-{
-    int top, left;
-    int bottom, right;
-}
-libvlc_rectangle_t;
-
-/**
- * Embedding support: Set the video output viewport for a windowless video output (MacOS X only)
- * \param p_instance libvlc instance
- * \param view coordinates within video drawable
- * \param clip coordinates within video drawable
- * \param p_exception an initialized exception
- */
-void libvlc_video_set_viewport( libvlc_instance_t *, const libvlc_rectangle_t *, const libvlc_rectangle_t *, libvlc_exception_t * );
-
-
-/** @} */
-
-/**
- * defgroup libvlc_vlm VLM
- * \ingroup libvlc
- * LibVLC VLM handling
- * @{
- */
-
-/** defgroup libvlc_audio Audio
- * \ingroup libvlc
- * LibVLC Audio handling
- * @{
- */
-
-/**
- * Toggle mute status
- * \param p_instance libvlc instance
- * \param p_exception an initialized exception
- * \return void
- */
-void libvlc_audio_toggle_mute( libvlc_instance_t *, libvlc_exception_t * );
-
-/**
- * Get current mute status
- * \param p_instance libvlc instance
- * \param p_exception an initialized exception
- * \return the mute status (boolean)
- */
-vlc_bool_t libvlc_audio_get_mute( libvlc_instance_t *, libvlc_exception_t * );
-
-/**
- * Set mute status
- * \param p_instance libvlc instance
- * \param status If status is VLC_TRUE then mute, otherwise unmute
- * \param p_exception an initialized exception
- * \return void
- */
-void libvlc_audio_set_mute( libvlc_instance_t *, vlc_bool_t , libvlc_exception_t * );
-
-/**
- * Get current audio level
- * \param p_instance libvlc instance
- * \param p_exception an initialized exception
- * \return the audio level (int)
- */
-int libvlc_audio_get_volume( libvlc_instance_t *, libvlc_exception_t * );
-
-/**
- * Set current audio level
- * \param p_instance libvlc instance
- * \param i_volume the volume (int)
- * \param p_exception an initialized exception
- * \return void
- */
-void libvlc_audio_set_volume( libvlc_instance_t *, int , libvlc_exception_t *);
-
-/** @} */
-
-
-/**
- * Add a broadcast, with one input
- * \param p_instance the instance
- * \param psz_name the name of the new broadcast
- * \param psz_input the input MRL
- * \param psz_output the output MRL (the parameter to the "sout" variable)
- * \param i_options number of additional options
- * \param ppsz_options additional options
- * \param b_enabled boolean for enabling the new broadcast
- * \param b_loop Should this broadcast be played in loop ?
- * \param p_exception an initialized exception
- */
-void libvlc_vlm_add_broadcast( libvlc_instance_t *, char *, char *, char* ,
-                               int, char **, int, int, libvlc_exception_t * );
-
-/**
- * Delete a media (vod or broadcast)
- * \param p_instance the instance
- * \param psz_name the media to delete
- * \param p_exception an initialized exception
- */
-void libvlc_vlm_del_media( libvlc_instance_t *, char *, libvlc_exception_t * );
-
-/**
- * Enable or disable a media (vod or broadcast)
- * \param p_instance the instance
- * \param psz_name the media to work on
- * \param b_enabled the new status
- * \param p_exception an initialized exception
- */
-void libvlc_vlm_set_enabled( libvlc_instance_t *, char *, int,
-                             libvlc_exception_t *);
-
-/**
- * Set the output for a media
- * \param p_instance the instance
- * \param psz_name the media to work on
- * \param psz_output the output MRL (the parameter to the "sout" variable)
- * \param p_exception an initialized exception
- */
-void libvlc_vlm_set_output( libvlc_instance_t *, char *, char*,
-                            libvlc_exception_t *);
-
-/**
- * Set a media's input MRL. This will delete all existing inputs and
- * add the specified one.
- * \param p_instance the instance
- * \param psz_name the media to work on
- * \param psz_input the input MRL
- * \param p_exception an initialized exception
- */
-void libvlc_vlm_set_input( libvlc_instance_t *, char *, char*,
-                           libvlc_exception_t *);
-
-/**
- * Set output for a media
- * \param p_instance the instance
- * \param psz_name the media to work on
- * \param b_loop the new status
- * \param p_exception an initialized exception
- */
-void libvlc_vlm_set_loop( libvlc_instance_t *, char *, int,
-                          libvlc_exception_t *);
-
-/**
- * Edit the parameters of a media. This will delete all existing inputs and
- * add the specified one.
- * \param p_instance the instance
- * \param psz_name the name of the new broadcast
- * \param psz_input the input MRL
- * \param psz_output the output MRL (the parameter to the "sout" variable)
- * \param i_options number of additional options
- * \param ppsz_options additional options
- * \param b_enabled boolean for enabling the new broadcast
- * \param b_loop Should this broadcast be played in loop ?
- * \param p_exception an initialized exception
- */
-void libvlc_vlm_change_media( libvlc_instance_t *, char *, char *, char* ,
-                              int, char **, int, int, libvlc_exception_t * );
-
-/**
- * Plays the named broadcast.
- * \param p_instance the instance
- * \param psz_name the name of the broadcast
- * \param p_exception an initialized exception
- */
-void libvlc_vlm_play_media ( libvlc_instance_t *, char *, libvlc_exception_t * );
-
-/**
- * Stops the named broadcast.
- * \param p_instance the instance
- * \param psz_name the name of the broadcast
- * \param p_exception an initialized exception
- */
-void libvlc_vlm_stop_media ( libvlc_instance_t *, char *, libvlc_exception_t * );
-
-/**
- * Pauses the named broadcast.
- * \param p_instance the instance
- * \param psz_name the name of the broadcast
- * \param p_exception an initialized exception
- */
-void libvlc_vlm_pause_media( libvlc_instance_t *, char *, libvlc_exception_t * );
-
-/** @} */
-/** @} */
-
-/*****************************************************************************
- * Message log handling
- *****************************************************************************/
-
-/** defgroup libvlc_log Log
- * \ingroup libvlc
- * LibVLC Message Logging
- * @{
- */
-
-/** This structure is opaque. It represents a libvlc log instance */
-typedef struct libvlc_log_t libvlc_log_t;
-
-/** This structure is opaque. It represents a libvlc log iterator */
-typedef struct libvlc_log_iterator_t libvlc_log_iterator_t;
-
-typedef struct libvlc_log_message_t
-{
-    unsigned    sizeof_msg;   /* sizeof() of message structure, must be filled in by user */
-    int         i_severity;   /* 0=INFO, 1=ERR, 2=WARN, 3=DBG */
-    const char *psz_type;     /* module type */
-    const char *psz_name;     /* module name */
-    const char *psz_header;   /* optional header */
-    const char *psz_message;  /* message */
-} libvlc_log_message_t;
-
-/**
- * Returns the VLC messaging verbosity level
- * \param p_instance libvlc instance
- * \param exception an initialized exception pointer
- */
-unsigned libvlc_get_log_verbosity( const libvlc_instance_t *p_instance, libvlc_exception_t *p_e );
-
-/**
- * Set the VLC messaging verbosity level
- * \param p_log libvlc log instance
- * \param exception an initialized exception pointer
- */
-void libvlc_set_log_verbosity( libvlc_instance_t *p_instance, unsigned level, libvlc_exception_t *p_e );
-
-/**
- * Open an instance to VLC message log 
- * \param p_instance libvlc instance
- * \param exception an initialized exception pointer
- */
-libvlc_log_t *libvlc_log_open( const libvlc_instance_t *, libvlc_exception_t *);
-
-/**
- * Close an instance of VLC message log 
- * \param p_log libvlc log instance
- * \param exception an initialized exception pointer
- */
-void libvlc_log_close( libvlc_log_t *, libvlc_exception_t *);
-
-/**
- * Returns the number of messages in log
- * \param p_log libvlc log instance
- * \param exception an initialized exception pointer
- */
-unsigned libvlc_log_count( const libvlc_log_t *, libvlc_exception_t *);
-
-/**
- * Clear all messages in log
- *  the log should be cleared on a regular basis to avoid clogging
- * \param p_log libvlc log instance
- * \param exception an initialized exception pointer
- */
-void libvlc_log_clear( libvlc_log_t *, libvlc_exception_t *);
-
-/**
- * Allocate and returns a new iterator to messages in log
- * \param p_log libvlc log instance
- * \param exception an initialized exception pointer
- */
-libvlc_log_iterator_t *libvlc_log_get_iterator( const libvlc_log_t *, libvlc_exception_t *);
-
-/**
- * Releases a previoulsy allocated iterator
- * \param p_log libvlc log iterator 
- * \param exception an initialized exception pointer
- */
-void libvlc_log_iterator_free( libvlc_log_iterator_t *p_iter, libvlc_exception_t *p_e );
-
-/**
- * Returns whether log iterator has more messages 
- * \param p_log libvlc log iterator
- * \param exception an initialized exception pointer
- */
-int libvlc_log_iterator_has_next( const libvlc_log_iterator_t *p_iter, libvlc_exception_t *p_e );
-
-/**
- * Returns next log message
- *   the content of message must not be freed
- * \param p_log libvlc log iterator
- * \param exception an initialized exception pointer
- */
-libvlc_log_message_t *libvlc_log_iterator_next( libvlc_log_iterator_t *p_iter,
-                                                struct libvlc_log_message_t *buffer,
-                                                libvlc_exception_t *p_e );
-
-/** @} */
-
-# ifdef __cplusplus
-}
-# endif
-
-#endif /* <vlc/libvlc.h> */
+/*****************************************************************************
+ * libvlc.h:  libvlc_* new external API
+ *****************************************************************************
+ * Copyright (C) 1998-2005 the VideoLAN team
+ * $Id: vlc.h 13701 2005-12-12 17:58:56Z zorglub $
+ *
+ * Authors: Clément Stenac <zorglub@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \defgroup libvlc Libvlc
+ * This is libvlc, the base library of the VLC program.
+ *
+ * @{
+ */
+
+
+#ifndef _LIBVLC_H
+#define _LIBVLC_H 1
+
+#include <vlc/vlc.h>
+
+/* BEGIN SONGBIRD EDIT */
+#include <vlc_meta.h>
+/* END SONGBIRD EDIT */
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/*****************************************************************************
+ * Exception handling
+ *****************************************************************************/
+/** defgroup libvlc_exception Exceptions
+ * \ingroup libvlc
+ * LibVLC Exceptions handling
+ * @{
+ */
+
+struct libvlc_exception_t
+{
+    int b_raised;
+    char *psz_message;
+};
+typedef struct libvlc_exception_t libvlc_exception_t;
+
+/**
+ * Initialize an exception structure. This can be called several times to reuse
+ * an exception structure.
+ * \param p_exception the exception to initialize
+ */
+void libvlc_exception_init( libvlc_exception_t *p_exception );
+
+/**
+ * Has an exception been raised ?
+ * \param p_exception the exception to query
+ * \return 0 if no exception raised, 1 else
+ */
+int libvlc_exception_raised( libvlc_exception_t *p_exception );
+
+/**
+ * Raise an exception
+ * \param p_exception the exception to raise
+ * \param psz_message the exception message
+ */
+void libvlc_exception_raise( libvlc_exception_t *p_exception, char *psz_format, ... );
+
+/**
+ * Clear an exception object so it can be reused.
+ * The exception object must be initialized
+ * \param p_exception the exception to clear
+ */
+void libvlc_exception_clear( libvlc_exception_t * );
+
+/**
+ * Get exception message
+ * \param p_exception the exception to query
+ * \return the exception message or NULL if not applicable (exception not raised
+ * for example)
+ */
+char* libvlc_exception_get_message( libvlc_exception_t *p_exception );
+
+/**@} */
+
+/*****************************************************************************
+ * Core handling
+ *****************************************************************************/
+
+/** defgroup libvlc_core Core
+ * \ingroup libvlc
+ * LibVLC Core
+ * @{
+ */
+
+/** This structure is opaque. It represents a libvlc instance */
+typedef struct libvlc_instance_t libvlc_instance_t;
+
+/**
+ * Create an initialized libvlc instance
+ * \param argc the number of arguments
+ * \param argv command-line-type arguments
+ * \param exception an initialized exception pointer
+ */
+libvlc_instance_t * libvlc_new( int , char **, libvlc_exception_t *);
+
+/**
+ * Returns a libvlc instance identifier for legacy APIs. Use of this
+ * function is discouraged, you should convert your program to use the
+ * new API.
+ * \param p_instance the instance
+ */
+int libvlc_get_vlc_id( libvlc_instance_t *p_instance );
+
+/**
+ * Destroy a libvlc instance
+ * \param p_instance the instance to destroy
+ */
+void libvlc_destroy( libvlc_instance_t *);
+
+/** @}*/
+
+/*****************************************************************************
+ * Playlist
+ *****************************************************************************/
+/** defgroup libvlc_playlist Playlist
+ * \ingroup libvlc
+ * LibVLC Playlist handling
+ * @{
+ */
+
+/**
+ * Start playing. You can give some additionnal playlist item options
+ * that will be added to the item before playing it.
+ * \param p_instance the instance
+ * \param i_id the item to play. If this is a negative number, the next
+ * item will be selected. Else, the item with the given ID will be played
+ * \param i_options the number of options to add to the item
+ * \param ppsz_options the options to add to the item
+ * \param p_exception an initialized exception
+ */
+void libvlc_playlist_play( libvlc_instance_t*, int, int, char **,
+                           libvlc_exception_t * );
+
+/**
+ * Pause a running playlist, resume if it was stopped
+ * \param p_instance the instance to pause
+ * \param p_exception an initialized exception
+ */
+void libvlc_playlist_pause( libvlc_instance_t *, libvlc_exception_t * );
+
+/**
+ * Checks if the playlist is running
+ * \param p_instance the instance
+ * \param p_exception an initialized exception
+ * \return 0 if the playlist is stopped or paused, 1 if it is running
+ */
+int libvlc_playlist_isplaying( libvlc_instance_t *, libvlc_exception_t * );
+
+/**
+ * Get the number of items in the playlist
+ * \param p_instance the instance
+ * \param p_exception an initialized exception
+ * \return the number of items
+ */
+int libvlc_playlist_items_count( libvlc_instance_t *, libvlc_exception_t * );
+
+/**
+ * Stop playing
+ * \param p_instance the instance to stop
+ * \param p_exception an initialized exception
+ */
+void libvlc_playlist_stop( libvlc_instance_t *, libvlc_exception_t * );
+
+/**
+ * Go to next playlist item (starts playback if it was stopped)
+ * \param p_instance the instance to use
+ * \param p_exception an initialized exception
+ */
+void libvlc_playlist_next( libvlc_instance_t *, libvlc_exception_t * );
+
+/**
+ * Go to previous playlist item (starts playback if it was stopped)
+ * \param p_instance the instance to use
+ * \param p_exception an initialized exception
+ */
+void libvlc_playlist_prev( libvlc_instance_t *, libvlc_exception_t * );
+
+/**
+ * Remove all playlist items
+ * \param p_instance the instance
+ * \param p_exception an initialized exception
+ */
+void libvlc_playlist_clear( libvlc_instance_t *, libvlc_exception_t * );
+
+/**
+ * Add an item at the end of the playlist
+ * If you need more advanced options, \see libvlc_playlist_add_extended
+ * \param p_instance the instance
+ * \param psz_uri the URI to open, using VLC format
+ * \param psz_name a name that you might want to give or NULL
+ * \return the identifier of the new item
+ */
+int libvlc_playlist_add( libvlc_instance_t *, const char *, const char *,
+                         libvlc_exception_t * );
+
+/**
+ * Add an item at the end of the playlist, with additional input options
+ * \param p_instance the instance
+ * \param psz_uri the URI to open, using VLC format
+ * \param psz_name a name that you might want to give or NULL
+ * \param i_options the number of options to add
+ * \param ppsz_options strings representing the options to add
+ * \param p_exception an initialized exception
+ * \return the identifier of the new item
+ */
+int libvlc_playlist_add_extended( libvlc_instance_t *, const char *,
+                                  const char *, int, const char **,
+                                  libvlc_exception_t * );
+
+/** 
+ * Delete the playlist item with the given ID.
+ * \param p_instance the instance
+ * \param i_id the id to remove
+ * \param p_exception an initialized exception
+ * \return
+ */
+int libvlc_playlist_delete_item( libvlc_instance_t *, int,
+                                 libvlc_exception_t * );
+
+typedef struct libvlc_input_t libvlc_input_t;
+
+/* Get the input that is currently being played by the playlist
+ * \param p_instance the instance to use
+ * \param p_exception an initialized excecption
+ * \return an input object
+ */
+libvlc_input_t *libvlc_playlist_get_input( libvlc_instance_t *,
+                                           libvlc_exception_t * );
+
+
+/* BEGIN SONGBIRD EDIT */
+
+/** 
+ * Get metadata for currently playing input.
+ * 
+ * \param p_instance the instance
+ * \param pp_meta a pointer to the metadata container.
+ * \param p_exception an initialized exception.
+ */
+void libvlc_playlist_get_metadata( libvlc_instance_t *, vlc_meta_t **, libvlc_exception_t * );
+
+/* END SONGBIRD EDIT */
+
+/** @}*/
+
+/*****************************************************************************
+ * Input
+ *****************************************************************************/
+/** defgroup libvlc_input Input
+ * \ingroup libvlc
+ * LibVLC Input handling
+ * @{
+ */
+
+/** Free an input object
+ * \param p_input the input to free
+ */
+void libvlc_input_free( libvlc_input_t * );
+
+/// \bug This might go away ... to be replaced by a broader system
+vlc_int64_t libvlc_input_get_length     ( libvlc_input_t *, libvlc_exception_t *);
+vlc_int64_t libvlc_input_get_time       ( libvlc_input_t *, libvlc_exception_t *);
+void        libvlc_input_set_time       ( libvlc_input_t *, vlc_int64_t, libvlc_exception_t *);
+float       libvlc_input_get_position   ( libvlc_input_t *, libvlc_exception_t *);
+void        libvlc_input_set_position   ( libvlc_input_t *, float, libvlc_exception_t *);
+vlc_bool_t  libvlc_input_will_play      ( libvlc_input_t *, libvlc_exception_t *);
+float       libvlc_input_get_rate       ( libvlc_input_t *, libvlc_exception_t *);
+void        libvlc_input_set_rate       ( libvlc_input_t *, float, libvlc_exception_t *);
+int         libvlc_input_get_state      ( libvlc_input_t *, libvlc_exception_t *);
+
+/** @} */
+
+/** defgroup libvlc_video Video
+ * \ingroup libvlc
+ * LibVLC Video handling
+ * @{
+ */
+
+/**
+ * Does this input have a video output ?
+ * \param p_input the input
+ * \param p_exception an initialized exception
+ */
+vlc_bool_t  libvlc_input_has_vout       ( libvlc_input_t *, libvlc_exception_t *);
+float       libvlc_input_get_fps        ( libvlc_input_t *, libvlc_exception_t *);
+
+/**
+ * Toggle fullscreen status on video output
+ * \param p_input the input
+ * \param p_exception an initialized exception
+ */
+void libvlc_toggle_fullscreen( libvlc_input_t *, libvlc_exception_t * );
+
+/**
+ * Enable or disable fullscreen on a video output
+ * \param p_input the input
+ * \param b_fullscreen boolean for fullscreen status
+ * \param p_exception an initialized exception
+ */
+void libvlc_set_fullscreen( libvlc_input_t *, int, libvlc_exception_t * );
+
+/**
+ * Get current fullscreen status
+ * \param p_input the input
+ * \param p_exception an initialized exception
+ * \return the fullscreen status (boolean)
+ */
+int libvlc_get_fullscreen( libvlc_input_t *, libvlc_exception_t * );
+
+/**
+ * Get current video height
+ * \param p_input the input
+ * \param p_exception an initialized exception
+ * \return the video height
+ */
+int libvlc_video_get_height( libvlc_input_t *, libvlc_exception_t * );
+
+/**
+ * Get current video width
+ * \param p_input the input
+ * \param p_exception an initialized exception
+ * \return the video width
+ */
+int libvlc_video_get_width( libvlc_input_t *, libvlc_exception_t * );
+
+/**
+ * Get current video aspect ratio
+ * \param p_input the input
+ * \param p_exception an initialized exception
+ * \return the video aspect ratio
+ */
+char *libvlc_video_get_aspect_ratio( libvlc_input_t *, libvlc_exception_t * );
+
+/**
+ * Set new video aspect ratio
+ * \param p_input the input
+ * \param psz_aspect new video aspect-ratio
+ * \param p_exception an initialized exception
+ */
+void libvlc_video_set_aspect_ratio( libvlc_input_t *, char *, libvlc_exception_t * );
+
+/**
+ * Take a snapshot of the current video window
+ * \param p_input the input
+ * \param psz_filepath the path where to save the screenshot to
+ * \param p_exception an initialized exception
+ */
+void libvlc_video_take_snapshot( libvlc_input_t *, char *, libvlc_exception_t * );
+
+int libvlc_video_destroy( libvlc_input_t *, libvlc_exception_t *);
+
+/**
+ * Resize the video output window
+ * \param p_instance libvlc instance
+ * \param width new width for video output window
+ * \param height new height for video output window
+ * \param p_exception an initialized exception
+ * \return the mute status (boolean)
+ */
+void libvlc_video_resize( libvlc_input_t *, int, int, libvlc_exception_t *);
+
+/**
+* Downcast to this general type as placeholder for a platform specific one, such as:
+*  Drawable on X11,
+*  CGrafPort on MacOSX,
+*  HWND on win32
+*/
+typedef int libvlc_drawable_t;
+
+/**
+ * Get current mute status
+ * \param p_instance libvlc instance
+ * \param drawable the new parent window (Drawable on X11, CGrafPort on MacOSX, HWND on Win32)
+ * \param p_exception an initialized exception
+ * \return the mute status (boolean)
+ */
+int libvlc_video_reparent( libvlc_input_t *, libvlc_drawable_t, libvlc_exception_t * );
+
+/**
+ * Embedding support: Set/change the default parent drawable for video outputs
+ * \param p_instance libvlc instance
+ * \param drawable the new parent window (Drawable on X11, CGrafPort on MacOSX, HWND on Win32)
+ * \param p_exception an initialized exception
+ */
+void libvlc_video_set_parent( libvlc_instance_t *, libvlc_drawable_t, libvlc_exception_t * );
+
+/**
+ * Embedding support: Set/change the default size for video outputs
+ * \param p_instance libvlc instance
+ * \param width new width for video drawable
+ * \param height new height for video drawable
+ * \param p_exception an initialized exception
+ */
+void libvlc_video_set_size( libvlc_instance_t *, int, int, libvlc_exception_t * );
+
+/**
+* Embedding support: rectangle for viewport
+*/
+typedef struct
+{
+    int top, left;
+    int bottom, right;
+}
+libvlc_rectangle_t;
+
+/**
+ * Embedding support: Set the video output viewport for a windowless video output (MacOS X only)
+ * \param p_instance libvlc instance
+ * \param view coordinates within video drawable
+ * \param clip coordinates within video drawable
+ * \param p_exception an initialized exception
+ */
+void libvlc_video_set_viewport( libvlc_instance_t *, const libvlc_rectangle_t *, const libvlc_rectangle_t *, libvlc_exception_t * );
+
+
+/** @} */
+
+/**
+ * defgroup libvlc_vlm VLM
+ * \ingroup libvlc
+ * LibVLC VLM handling
+ * @{
+ */
+
+/** defgroup libvlc_audio Audio
+ * \ingroup libvlc
+ * LibVLC Audio handling
+ * @{
+ */
+
+/**
+ * Toggle mute status
+ * \param p_instance libvlc instance
+ * \param p_exception an initialized exception
+ * \return void
+ */
+void libvlc_audio_toggle_mute( libvlc_instance_t *, libvlc_exception_t * );
+
+/**
+ * Get current mute status
+ * \param p_instance libvlc instance
+ * \param p_exception an initialized exception
+ * \return the mute status (boolean)
+ */
+vlc_bool_t libvlc_audio_get_mute( libvlc_instance_t *, libvlc_exception_t * );
+
+/**
+ * Set mute status
+ * \param p_instance libvlc instance
+ * \param status If status is VLC_TRUE then mute, otherwise unmute
+ * \param p_exception an initialized exception
+ * \return void
+ */
+void libvlc_audio_set_mute( libvlc_instance_t *, vlc_bool_t , libvlc_exception_t * );
+
+/**
+ * Get current audio level
+ * \param p_instance libvlc instance
+ * \param p_exception an initialized exception
+ * \return the audio level (int)
+ */
+int libvlc_audio_get_volume( libvlc_instance_t *, libvlc_exception_t * );
+
+/**
+ * Set current audio level
+ * \param p_instance libvlc instance
+ * \param i_volume the volume (int)
+ * \param p_exception an initialized exception
+ * \return void
+ */
+void libvlc_audio_set_volume( libvlc_instance_t *, int , libvlc_exception_t *);
+
+/** @} */
+
+
+/**
+ * Add a broadcast, with one input
+ * \param p_instance the instance
+ * \param psz_name the name of the new broadcast
+ * \param psz_input the input MRL
+ * \param psz_output the output MRL (the parameter to the "sout" variable)
+ * \param i_options number of additional options
+ * \param ppsz_options additional options
+ * \param b_enabled boolean for enabling the new broadcast
+ * \param b_loop Should this broadcast be played in loop ?
+ * \param p_exception an initialized exception
+ */
+void libvlc_vlm_add_broadcast( libvlc_instance_t *, char *, char *, char* ,
+                               int, char **, int, int, libvlc_exception_t * );
+
+/**
+ * Delete a media (vod or broadcast)
+ * \param p_instance the instance
+ * \param psz_name the media to delete
+ * \param p_exception an initialized exception
+ */
+void libvlc_vlm_del_media( libvlc_instance_t *, char *, libvlc_exception_t * );
+
+/**
+ * Enable or disable a media (vod or broadcast)
+ * \param p_instance the instance
+ * \param psz_name the media to work on
+ * \param b_enabled the new status
+ * \param p_exception an initialized exception
+ */
+void libvlc_vlm_set_enabled( libvlc_instance_t *, char *, int,
+                             libvlc_exception_t *);
+
+/**
+ * Set the output for a media
+ * \param p_instance the instance
+ * \param psz_name the media to work on
+ * \param psz_output the output MRL (the parameter to the "sout" variable)
+ * \param p_exception an initialized exception
+ */
+void libvlc_vlm_set_output( libvlc_instance_t *, char *, char*,
+                            libvlc_exception_t *);
+
+/**
+ * Set a media's input MRL. This will delete all existing inputs and
+ * add the specified one.
+ * \param p_instance the instance
+ * \param psz_name the media to work on
+ * \param psz_input the input MRL
+ * \param p_exception an initialized exception
+ */
+void libvlc_vlm_set_input( libvlc_instance_t *, char *, char*,
+                           libvlc_exception_t *);
+
+/**
+ * Set output for a media
+ * \param p_instance the instance
+ * \param psz_name the media to work on
+ * \param b_loop the new status
+ * \param p_exception an initialized exception
+ */
+void libvlc_vlm_set_loop( libvlc_instance_t *, char *, int,
+                          libvlc_exception_t *);
+
+/**
+ * Edit the parameters of a media. This will delete all existing inputs and
+ * add the specified one.
+ * \param p_instance the instance
+ * \param psz_name the name of the new broadcast
+ * \param psz_input the input MRL
+ * \param psz_output the output MRL (the parameter to the "sout" variable)
+ * \param i_options number of additional options
+ * \param ppsz_options additional options
+ * \param b_enabled boolean for enabling the new broadcast
+ * \param b_loop Should this broadcast be played in loop ?
+ * \param p_exception an initialized exception
+ */
+void libvlc_vlm_change_media( libvlc_instance_t *, char *, char *, char* ,
+                              int, char **, int, int, libvlc_exception_t * );
+
+/**
+ * Plays the named broadcast.
+ * \param p_instance the instance
+ * \param psz_name the name of the broadcast
+ * \param p_exception an initialized exception
+ */
+void libvlc_vlm_play_media ( libvlc_instance_t *, char *, libvlc_exception_t * );
+
+/**
+ * Stops the named broadcast.
+ * \param p_instance the instance
+ * \param psz_name the name of the broadcast
+ * \param p_exception an initialized exception
+ */
+void libvlc_vlm_stop_media ( libvlc_instance_t *, char *, libvlc_exception_t * );
+
+/**
+ * Pauses the named broadcast.
+ * \param p_instance the instance
+ * \param psz_name the name of the broadcast
+ * \param p_exception an initialized exception
+ */
+void libvlc_vlm_pause_media( libvlc_instance_t *, char *, libvlc_exception_t * );
+
+/** @} */
+/** @} */
+
+/*****************************************************************************
+ * Message log handling
+ *****************************************************************************/
+
+/** defgroup libvlc_log Log
+ * \ingroup libvlc
+ * LibVLC Message Logging
+ * @{
+ */
+
+/** This structure is opaque. It represents a libvlc log instance */
+typedef struct libvlc_log_t libvlc_log_t;
+
+/** This structure is opaque. It represents a libvlc log iterator */
+typedef struct libvlc_log_iterator_t libvlc_log_iterator_t;
+
+typedef struct libvlc_log_message_t
+{
+    unsigned    sizeof_msg;   /* sizeof() of message structure, must be filled in by user */
+    int         i_severity;   /* 0=INFO, 1=ERR, 2=WARN, 3=DBG */
+    const char *psz_type;     /* module type */
+    const char *psz_name;     /* module name */
+    const char *psz_header;   /* optional header */
+    const char *psz_message;  /* message */
+} libvlc_log_message_t;
+
+/**
+ * Returns the VLC messaging verbosity level
+ * \param p_instance libvlc instance
+ * \param exception an initialized exception pointer
+ */
+unsigned libvlc_get_log_verbosity( const libvlc_instance_t *p_instance, libvlc_exception_t *p_e );
+
+/**
+ * Set the VLC messaging verbosity level
+ * \param p_log libvlc log instance
+ * \param exception an initialized exception pointer
+ */
+void libvlc_set_log_verbosity( libvlc_instance_t *p_instance, unsigned level, libvlc_exception_t *p_e );
+
+/**
+ * Open an instance to VLC message log 
+ * \param p_instance libvlc instance
+ * \param exception an initialized exception pointer
+ */
+libvlc_log_t *libvlc_log_open( const libvlc_instance_t *, libvlc_exception_t *);
+
+/**
+ * Close an instance of VLC message log 
+ * \param p_log libvlc log instance
+ * \param exception an initialized exception pointer
+ */
+void libvlc_log_close( libvlc_log_t *, libvlc_exception_t *);
+
+/**
+ * Returns the number of messages in log
+ * \param p_log libvlc log instance
+ * \param exception an initialized exception pointer
+ */
+unsigned libvlc_log_count( const libvlc_log_t *, libvlc_exception_t *);
+
+/**
+ * Clear all messages in log
+ *  the log should be cleared on a regular basis to avoid clogging
+ * \param p_log libvlc log instance
+ * \param exception an initialized exception pointer
+ */
+void libvlc_log_clear( libvlc_log_t *, libvlc_exception_t *);
+
+/**
+ * Allocate and returns a new iterator to messages in log
+ * \param p_log libvlc log instance
+ * \param exception an initialized exception pointer
+ */
+libvlc_log_iterator_t *libvlc_log_get_iterator( const libvlc_log_t *, libvlc_exception_t *);
+
+/**
+ * Releases a previoulsy allocated iterator
+ * \param p_log libvlc log iterator 
+ * \param exception an initialized exception pointer
+ */
+void libvlc_log_iterator_free( libvlc_log_iterator_t *p_iter, libvlc_exception_t *p_e );
+
+/**
+ * Returns whether log iterator has more messages 
+ * \param p_log libvlc log iterator
+ * \param exception an initialized exception pointer
+ */
+int libvlc_log_iterator_has_next( const libvlc_log_iterator_t *p_iter, libvlc_exception_t *p_e );
+
+/**
+ * Returns next log message
+ *   the content of message must not be freed
+ * \param p_log libvlc log iterator
+ * \param exception an initialized exception pointer
+ */
+libvlc_log_message_t *libvlc_log_iterator_next( libvlc_log_iterator_t *p_iter,
+                                                struct libvlc_log_message_t *buffer,
+                                                libvlc_exception_t *p_e );
+
+/** @} */
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif /* <vlc/libvlc.h> */

Property changes on: include\vlc\libvlc.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc\mediacontrol.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc\mediacontrol_structures.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc\sout.h
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: include/vlc/vlc.h
===================================================================
--- include/vlc/vlc.h	(revision 159)
+++ include/vlc/vlc.h	(working copy)
@@ -1,583 +1,599 @@
-/*****************************************************************************
- * vlc.h: global header for libvlc (old-style)
- *****************************************************************************
- * Copyright (C) 1998-2004 the VideoLAN team
- * $Id: vlc.h 13960 2006-01-21 16:44:36Z zorglub $
- *
- * Authors: Vincent Seguin <seguin@via.ecp.fr>
- *          Samuel Hocevar <sam@zoy.org>
- *          Gildas Bazin <gbazin@netcourrier.com>
- *          Derk-Jan Hartman <hartman at videolan dot org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/**
- * \defgroup libvlc_old Libvlc Old
- * This is libvlc, the base library of the VLC program.
- * This is the legacy API. Please consider using the new libvlc API
- *
- * @{
- */
-
-
-#ifndef _VLC_VLC_H
-#define _VLC_VLC_H 1
-
-# ifdef __cplusplus
-extern "C" {
-# endif
-
-/*****************************************************************************
- * Our custom types
- *****************************************************************************/
-typedef int vlc_bool_t;
-typedef struct vlc_list_t vlc_list_t;
-typedef struct vlc_object_t vlc_object_t;
-
-#if (defined( WIN32 ) || defined( UNDER_CE )) && !defined( __MINGW32__ )
-typedef signed __int64 vlc_int64_t;
-# else
-typedef signed long long vlc_int64_t;
-#endif
-
-/**
- * \defgroup var_type Variable types
- * These are the different types a vlc variable can have.
- * @{
- */
-#define VLC_VAR_VOID      0x0010
-#define VLC_VAR_BOOL      0x0020
-#define VLC_VAR_INTEGER   0x0030
-#define VLC_VAR_HOTKEY    0x0031
-#define VLC_VAR_STRING    0x0040
-#define VLC_VAR_MODULE    0x0041
-#define VLC_VAR_FILE      0x0042
-#define VLC_VAR_DIRECTORY 0x0043
-#define VLC_VAR_VARIABLE  0x0044
-#define VLC_VAR_FLOAT     0x0050
-#define VLC_VAR_TIME      0x0060
-#define VLC_VAR_ADDRESS   0x0070
-#define VLC_VAR_MUTEX     0x0080
-#define VLC_VAR_LIST      0x0090
-/**@}*/
-
-/**
- * VLC value structure
- */
-typedef union
-{
-    int             i_int;
-    vlc_bool_t      b_bool;
-    float           f_float;
-    char *          psz_string;
-    void *          p_address;
-    vlc_object_t *  p_object;
-    vlc_list_t *    p_list;
-    vlc_int64_t     i_time;
-
-    struct { char *psz_name; int i_object_id; } var;
-
-   /* Make sure the structure is at least 64bits */
-    struct { char a, b, c, d, e, f, g, h; } padding;
-
-} vlc_value_t;
-
-/**
- * VLC list structure
- */
-struct vlc_list_t
-{
-    int             i_count;
-    vlc_value_t *   p_values;
-    int *           pi_types;
-
-};
-
-/*****************************************************************************
- * Error values
- *****************************************************************************/
-#define VLC_SUCCESS         -0                                   /* No error */
-#define VLC_ENOMEM          -1                          /* Not enough memory */
-#define VLC_ETHREAD         -2                               /* Thread error */
-#define VLC_ETIMEOUT        -3                                    /* Timeout */
-
-#define VLC_ENOMOD         -10                           /* Module not found */
-
-#define VLC_ENOOBJ         -20                           /* Object not found */
-#define VLC_EBADOBJ        -21                            /* Bad object type */
-
-#define VLC_ENOVAR         -30                         /* Variable not found */
-#define VLC_EBADVAR        -31                         /* Bad variable value */
-
-#define VLC_EEXIT         -255                             /* Program exited */
-#define VLC_EEXITSUCCESS  -999                /* Program exited successfully */
-#define VLC_EGENERIC      -666                              /* Generic error */
-
-/*****************************************************************************
- * Booleans
- *****************************************************************************/
-#define VLC_FALSE 0
-#define VLC_TRUE  1
-
-/*****************************************************************************
- * Playlist
- *****************************************************************************/
-
-/* Used by VLC_AddTarget() */
-#define PLAYLIST_INSERT          0x0001
-#define PLAYLIST_REPLACE         0x0002
-#define PLAYLIST_APPEND          0x0004
-#define PLAYLIST_GO              0x0008
-#define PLAYLIST_CHECK_INSERT    0x0010
-#define PLAYLIST_PREPARSE        0x0020
-
-#define PLAYLIST_END           -666
-
-/*****************************************************************************
- * Required internal headers
- *****************************************************************************/
-#if defined( __VLC__ )
-#   include "vlc_common.h"
-#endif
-
-/*****************************************************************************
- * Exported libvlc API
- *****************************************************************************/
-#if !defined( __VLC__ )
-/* Otherwise they are declared and exported in vlc_common.h */
-/**
- * Retrieve libvlc version
- *
- * \return a string containing the libvlc version
- */
-char const * VLC_Version ( void );
-
-/**
- * Retrieve libvlc compile time
- *
- * \return a string containing the libvlc compile time
- */
-char const * VLC_CompileTime ( void );
-
-/**
- * Retrieve the username of the libvlc builder
- *
- * \return a string containing the username of the libvlc builder
- */
-char const * VLC_CompileBy ( void );
-
-/**
- * Retrieve the host of the libvlc builder
- *
- * \return a string containing the host of the libvlc builder
- */
-char const * VLC_CompileHost ( void );
-
-/**
- * Retrieve the domain name of the host of the libvlc builder
- *
- * \return a string containing the domain name of the host of the libvlc builder
- */
-char const * VLC_CompileDomain ( void );
-
-/**
- * Retrieve libvlc compiler version
- *
- * \return a string containing the libvlc compiler version
- */
-char const * VLC_Compiler ( void );
-
-/**
- * Retrieve libvlc changeset
- *
- * \return a string containing the libvlc subversion changeset
- */
-char const * VLC_Changeset ( void );
-
-/**
- * Return an error string
- *
- * \param i_err an error code
- * \return an error string
- */
-char const * VLC_Error ( int i_err );
-
-#endif /* __VLC__ */
-
-/**
- * Initialize libvlc
- *
- * This function allocates a vlc_t structure and returns a negative value
- * in case of failure. Also, the thread system is initialized
- *
- * \return vlc object id or an error code
- */
-int     VLC_Create( void );
-
-/**
- * Initialize a vlc_t structure
- *
- * This function initializes a previously allocated vlc_t structure:
- *  - CPU detection
- *  - gettext initialization
- *  - message queue, module bank and playlist initialization
- *  - configuration and commandline parsing
- *
- *  \param i_object a vlc object id
- *  \param i_argc the number of arguments
- *  \param ppsz_argv an array of arguments
- *  \return VLC_SUCCESS on success
- */
-int     VLC_Init( int, int, char *[] );
-
-/**
- * Add an interface
- *
- * This function opens an interface plugin and runs it. If b_block is set
- * to 0, VLC_AddIntf will return immediately and let the interface run in a
- * separate thread. If b_block is set to 1, VLC_AddIntf will continue until
- * user requests to quit.
- *
- * \param i_object a vlc object id
- * \param psz_module a vlc module name of an interface
- * \param b_block make this interface blocking
- * \param b_play start playing when the interface is done loading
- * \return VLC_SUCCESS on success
- */
-int     VLC_AddIntf( int, char const *, vlc_bool_t, vlc_bool_t );
-
-/**
- * Ask vlc to die
- *
- * This function sets p_vlc->b_die to VLC_TRUE, but does not do any other
- * task. It is your duty to call VLC_CleanUp and VLC_Destroy afterwards.
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int     VLC_Die( int );
-
-/**
- * Clean up all the intf, playlist, vout and aout
- *
- * This function requests all intf, playlist, vout and aout objects to finish
- * and CleanUp. Only a blank VLC object should remain after this.
- *
- * \note This function was previously called VLC_Stop
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int     VLC_CleanUp( int );
-
-/**
- * Destroy all threads and the VLC object
- *
- * This function requests the running threads to finish, waits for their
- * termination, and destroys their structure.
- * Then it will de-init all VLC object initializations.
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int     VLC_Destroy( int );
-
-/**
- * Set a VLC variable
- *
- * This function sets a variable of VLC
- *
- * \note Was previously called VLC_Set
- *
- * \param i_object a vlc object id
- * \param psz_var a vlc variable name
- * \param value a vlc_value_t structure
- * \return VLC_SUCCESS on success
- */
-int     VLC_VariableSet( int, char const *, vlc_value_t );
-
-/**
- * Get a VLC variable
- *
- * This function gets the value of a variable of VLC
- * It stores it in the p_value argument
- *
- * \note Was previously called VLC_Get
- *
- * \param i_object a vlc object id
- * \param psz_var a vlc variable name
- * \param p_value a pointer to a vlc_value_t structure
- * \return VLC_SUCCESS on success
- */
-int     VLC_VariableGet( int, char const *, vlc_value_t * );
-
-/**
- * Get a VLC variable type
- *
- * This function gets the type of a variable of VLC
- * It stores it in the p_type argument
- *
- * \param i_object a vlc object id
- * \param psz_var a vlc variable name
- * \param pi_type a pointer to an integer
- * \return VLC_SUCCESS on success
- */
-int     VLC_VariableType( int, char const *, int * );
-
-/**
- * Add a target to the current playlist
- *
- * This funtion will add a target to the current playlist. If a playlist does
- * not exist, it will be created.
- *
- * \param i_object a vlc object id
- * \param psz_target the URI of the target to play
- * \param ppsz_options an array of strings with input options (ie. :input-repeat)
- * \param i_options the amount of options in the ppsz_options array
- * \param i_mode the insert mode to insert the target into the playlist (PLAYLIST_* defines)
- * \param i_pos the position at which to add the new target (PLAYLIST_END for end)
- * \return VLC_SUCCESS on success
- */
-int     VLC_AddTarget( int, char const *, const char **, int, int, int );
-
-/**
- * Start the playlist and play the currently selected playlist item
- *
- * If there is something in the playlist, and the playlist is not running,
- * then start the playlist and play the currently selected playlist item.
- * If an item is currently paused, then resume it.
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int     VLC_Play( int );
-
-/**
- * Pause the currently playing item. Resume it if already paused
- *
- * If an item is currently playing then pause it.
- * If the item is already paused, then resume playback.
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int     VLC_Pause( int );
-
-/**
- * Stop the playlist
- *
- * If an item is currently playing then stop it.
- * Set the playlist to a stopped state.
- *
- * \note This function is new. The old VLC_Stop is now called VLC_CleanUp
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int             VLC_Stop( int );
-
-/**
- * Tell if VLC is playing
- *
- * If an item is currently playing, it returns
- * VLC_TRUE, else VLC_FALSE
- *
- * \param i_object a vlc object id
- * \return VLC_TRUE or VLC_FALSE
- */
-vlc_bool_t      VLC_IsPlaying( int );
-
-/**
- * Get the current position in a input
- *
- * Return the current position as a float
- * This method should be used for time sliders etc
- * \note For some inputs, this will be unknown.
- *
- * \param i_object a vlc object id
- * \return a float in the range of 0.0 - 1.0
- */
-float           VLC_PositionGet( int );
-
-/**
- * Set the current position in a input
- *
- * Set the current position as a float
- * This method should be used for time sliders etc
- * \note For some inputs, this will be unknown.
- *
- * \param i_object a vlc object id
- * \param i_position a float in the range of 0.0 - 1.0
- * \return a float in the range of 0.0 - 1.0
- */
-float           VLC_PositionSet( int, float );
-
-/**
- * Get the current position in a input
- *
- * Return the current position in seconds from the start.
- * \note For some inputs, this will be unknown.
- *
- * \param i_object a vlc object id
- * \return the offset from 0:00 in seconds
- */
-int             VLC_TimeGet( int );
-
-/**
- * Seek to a position in the current input
- *
- * Seek i_seconds in the current input. If b_relative is set,
- * then the seek will be relative to the current position, otherwise
- * it will seek to i_seconds from the beginning of the input.
- * \note For some inputs, this will be unknown.
- *
- * \param i_object a vlc object id
- * \param i_seconds seconds from current position or from beginning of input
- * \param b_relative seek relative from current position
- * \return VLC_SUCCESS on success
- */
-int             VLC_TimeSet( int, int, vlc_bool_t );
-
-/**
- * Get the total length of a input
- *
- * Return the total length in seconds from the current input.
- * \note For some inputs, this will be unknown.
- *
- * \param i_object a vlc object id
- * \return the length in seconds
- */
-int             VLC_LengthGet( int );
-
-/**
- * Play the input faster than realtime
- *
- * 2x, 4x, 8x faster than realtime
- * \note For some inputs, this will be impossible.
- *
- * \param i_object a vlc object id
- * \return the current speedrate
- */
-float           VLC_SpeedFaster( int );
-
-/**
- * Play the input slower than realtime
- *
- * 1/2x, 1/4x, 1/8x slower than realtime
- * \note For some inputs, this will be impossible.
- *
- * \param i_object a vlc object id
- * \return the current speedrate
- */
-float           VLC_SpeedSlower( int );
-
-/**
- * Return the current playlist item
- *
- * \param i_object a vlc object id
- * \return the index of the playlistitem that is currently selected for play
- */
-int             VLC_PlaylistIndex( int );
-
-/**
- * Total amount of items in the playlist
- *
- * \param i_object a vlc object id
- * \return amount of playlist items
- */
-int             VLC_PlaylistNumberOfItems( int );
-
-/**
- * Next playlist item
- *
- * Skip to the next playlistitem and play it.
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int             VLC_PlaylistNext( int );
-
-/**
- * Previous playlist item
- *
- * Skip to the previous playlistitem and play it.
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int             VLC_PlaylistPrev( int );
-
-/**
- * Clear the contents of the playlist
- *
- * Completly empty the entire playlist.
- *
- * \note Was previously called VLC_ClearPlaylist
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int             VLC_PlaylistClear( int );
-
-/**
- * Change the volume
- *
- * \param i_object a vlc object id
- * \param i_volume something in a range from 0-200
- * \return the new volume (range 0-200 %)
- */
-int             VLC_VolumeSet( int, int );
-
-/**
- * Get the current volume
- *
- * Retrieve the current volume.
- *
- * \param i_object a vlc object id
- * \return the current volume (range 0-200 %)
- */
-int             VLC_VolumeGet( int );
-
-/**
- * Mute/Unmute the volume
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int            VLC_VolumeMute( int );
-
-/**
- * Toggle Fullscreen mode
- *
- * Switch between normal and fullscreen video
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int             VLC_FullScreen( int );
-
-
-# ifdef __cplusplus
-}
-# endif
-
-#define LICENSE_MSG \
-  _("This program comes with NO WARRANTY, to the extent permitted by " \
-    "law.\nYou may redistribute it under the terms of the GNU General " \
-    "Public License;\nsee the file named COPYING for details.\n" \
-    "Written by the VideoLAN team; see the AUTHORS file.\n")
-
-#endif /* <vlc/vlc.h> */
+/*****************************************************************************
+ * vlc.h: global header for libvlc (old-style)
+ *****************************************************************************
+ * Copyright (C) 1998-2004 the VideoLAN team
+ * $Id: vlc.h 13960 2006-01-21 16:44:36Z zorglub $
+ *
+ * Authors: Vincent Seguin <seguin@via.ecp.fr>
+ *          Samuel Hocevar <sam@zoy.org>
+ *          Gildas Bazin <gbazin@netcourrier.com>
+ *          Derk-Jan Hartman <hartman at videolan dot org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+ * \defgroup libvlc_old Libvlc Old
+ * This is libvlc, the base library of the VLC program.
+ * This is the legacy API. Please consider using the new libvlc API
+ *
+ * @{
+ */
+
+
+#ifndef _VLC_VLC_H
+#define _VLC_VLC_H 1
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/*****************************************************************************
+ * Our custom types
+ *****************************************************************************/
+typedef int vlc_bool_t;
+typedef struct vlc_list_t vlc_list_t;
+typedef struct vlc_object_t vlc_object_t;
+
+#if (defined( WIN32 ) || defined( UNDER_CE )) && !defined( __MINGW32__ )
+typedef signed __int64 vlc_int64_t;
+# else
+typedef signed long long vlc_int64_t;
+#endif
+
+/**
+ * \defgroup var_type Variable types
+ * These are the different types a vlc variable can have.
+ * @{
+ */
+#define VLC_VAR_VOID      0x0010
+#define VLC_VAR_BOOL      0x0020
+#define VLC_VAR_INTEGER   0x0030
+#define VLC_VAR_HOTKEY    0x0031
+#define VLC_VAR_STRING    0x0040
+#define VLC_VAR_MODULE    0x0041
+#define VLC_VAR_FILE      0x0042
+#define VLC_VAR_DIRECTORY 0x0043
+#define VLC_VAR_VARIABLE  0x0044
+#define VLC_VAR_FLOAT     0x0050
+#define VLC_VAR_TIME      0x0060
+#define VLC_VAR_ADDRESS   0x0070
+#define VLC_VAR_MUTEX     0x0080
+#define VLC_VAR_LIST      0x0090
+/**@}*/
+
+/**
+ * VLC value structure
+ */
+typedef union
+{
+    int             i_int;
+    vlc_bool_t      b_bool;
+    float           f_float;
+    char *          psz_string;
+    void *          p_address;
+    vlc_object_t *  p_object;
+    vlc_list_t *    p_list;
+    vlc_int64_t     i_time;
+
+    struct { char *psz_name; int i_object_id; } var;
+
+   /* Make sure the structure is at least 64bits */
+    struct { char a, b, c, d, e, f, g, h; } padding;
+
+} vlc_value_t;
+
+/**
+ * VLC list structure
+ */
+struct vlc_list_t
+{
+    int             i_count;
+    vlc_value_t *   p_values;
+    int *           pi_types;
+
+};
+
+/*****************************************************************************
+ * Error values
+ *****************************************************************************/
+#define VLC_SUCCESS         -0                                   /* No error */
+#define VLC_ENOMEM          -1                          /* Not enough memory */
+#define VLC_ETHREAD         -2                               /* Thread error */
+#define VLC_ETIMEOUT        -3                                    /* Timeout */
+
+#define VLC_ENOMOD         -10                           /* Module not found */
+
+#define VLC_ENOOBJ         -20                           /* Object not found */
+#define VLC_EBADOBJ        -21                            /* Bad object type */
+
+#define VLC_ENOVAR         -30                         /* Variable not found */
+#define VLC_EBADVAR        -31                         /* Bad variable value */
+
+#define VLC_EEXIT         -255                             /* Program exited */
+#define VLC_EEXITSUCCESS  -999                /* Program exited successfully */
+#define VLC_EGENERIC      -666                              /* Generic error */
+
+/*****************************************************************************
+ * Booleans
+ *****************************************************************************/
+#define VLC_FALSE 0
+#define VLC_TRUE  1
+
+/*****************************************************************************
+ * Playlist
+ *****************************************************************************/
+
+/* Used by VLC_AddTarget() */
+#define PLAYLIST_INSERT          0x0001
+#define PLAYLIST_REPLACE         0x0002
+#define PLAYLIST_APPEND          0x0004
+#define PLAYLIST_GO              0x0008
+#define PLAYLIST_CHECK_INSERT    0x0010
+#define PLAYLIST_PREPARSE        0x0020
+
+#define PLAYLIST_END           -666
+
+/*****************************************************************************
+ * Required internal headers
+ *****************************************************************************/
+#if defined( __VLC__ )
+#   include "vlc_common.h"
+#endif
+
+/* BEGIN SONGBIRD EDIT */
+#include "vlc_meta.h"
+/* END SONGBIRD EDIT */
+
+/*****************************************************************************
+ * Exported libvlc API
+ *****************************************************************************/
+#if !defined( __VLC__ )
+/* Otherwise they are declared and exported in vlc_common.h */
+/**
+ * Retrieve libvlc version
+ *
+ * \return a string containing the libvlc version
+ */
+char const * VLC_Version ( void );
+
+/**
+ * Retrieve libvlc compile time
+ *
+ * \return a string containing the libvlc compile time
+ */
+char const * VLC_CompileTime ( void );
+
+/**
+ * Retrieve the username of the libvlc builder
+ *
+ * \return a string containing the username of the libvlc builder
+ */
+char const * VLC_CompileBy ( void );
+
+/**
+ * Retrieve the host of the libvlc builder
+ *
+ * \return a string containing the host of the libvlc builder
+ */
+char const * VLC_CompileHost ( void );
+
+/**
+ * Retrieve the domain name of the host of the libvlc builder
+ *
+ * \return a string containing the domain name of the host of the libvlc builder
+ */
+char const * VLC_CompileDomain ( void );
+
+/**
+ * Retrieve libvlc compiler version
+ *
+ * \return a string containing the libvlc compiler version
+ */
+char const * VLC_Compiler ( void );
+
+/**
+ * Retrieve libvlc changeset
+ *
+ * \return a string containing the libvlc subversion changeset
+ */
+char const * VLC_Changeset ( void );
+
+/**
+ * Return an error string
+ *
+ * \param i_err an error code
+ * \return an error string
+ */
+char const * VLC_Error ( int i_err );
+
+#endif /* __VLC__ */
+
+/**
+ * Initialize libvlc
+ *
+ * This function allocates a vlc_t structure and returns a negative value
+ * in case of failure. Also, the thread system is initialized
+ *
+ * \return vlc object id or an error code
+ */
+int     VLC_Create( void );
+
+/**
+ * Initialize a vlc_t structure
+ *
+ * This function initializes a previously allocated vlc_t structure:
+ *  - CPU detection
+ *  - gettext initialization
+ *  - message queue, module bank and playlist initialization
+ *  - configuration and commandline parsing
+ *
+ *  \param i_object a vlc object id
+ *  \param i_argc the number of arguments
+ *  \param ppsz_argv an array of arguments
+ *  \return VLC_SUCCESS on success
+ */
+int     VLC_Init( int, int, char *[] );
+
+/**
+ * Add an interface
+ *
+ * This function opens an interface plugin and runs it. If b_block is set
+ * to 0, VLC_AddIntf will return immediately and let the interface run in a
+ * separate thread. If b_block is set to 1, VLC_AddIntf will continue until
+ * user requests to quit.
+ *
+ * \param i_object a vlc object id
+ * \param psz_module a vlc module name of an interface
+ * \param b_block make this interface blocking
+ * \param b_play start playing when the interface is done loading
+ * \return VLC_SUCCESS on success
+ */
+int     VLC_AddIntf( int, char const *, vlc_bool_t, vlc_bool_t );
+
+/**
+ * Ask vlc to die
+ *
+ * This function sets p_vlc->b_die to VLC_TRUE, but does not do any other
+ * task. It is your duty to call VLC_CleanUp and VLC_Destroy afterwards.
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int     VLC_Die( int );
+
+/**
+ * Clean up all the intf, playlist, vout and aout
+ *
+ * This function requests all intf, playlist, vout and aout objects to finish
+ * and CleanUp. Only a blank VLC object should remain after this.
+ *
+ * \note This function was previously called VLC_Stop
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int     VLC_CleanUp( int );
+
+/**
+ * Destroy all threads and the VLC object
+ *
+ * This function requests the running threads to finish, waits for their
+ * termination, and destroys their structure.
+ * Then it will de-init all VLC object initializations.
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int     VLC_Destroy( int );
+
+/**
+ * Set a VLC variable
+ *
+ * This function sets a variable of VLC
+ *
+ * \note Was previously called VLC_Set
+ *
+ * \param i_object a vlc object id
+ * \param psz_var a vlc variable name
+ * \param value a vlc_value_t structure
+ * \return VLC_SUCCESS on success
+ */
+int     VLC_VariableSet( int, char const *, vlc_value_t );
+
+/**
+ * Get a VLC variable
+ *
+ * This function gets the value of a variable of VLC
+ * It stores it in the p_value argument
+ *
+ * \note Was previously called VLC_Get
+ *
+ * \param i_object a vlc object id
+ * \param psz_var a vlc variable name
+ * \param p_value a pointer to a vlc_value_t structure
+ * \return VLC_SUCCESS on success
+ */
+int     VLC_VariableGet( int, char const *, vlc_value_t * );
+
+/**
+ * Get a VLC variable type
+ *
+ * This function gets the type of a variable of VLC
+ * It stores it in the p_type argument
+ *
+ * \param i_object a vlc object id
+ * \param psz_var a vlc variable name
+ * \param pi_type a pointer to an integer
+ * \return VLC_SUCCESS on success
+ */
+int     VLC_VariableType( int, char const *, int * );
+
+/**
+ * Add a target to the current playlist
+ *
+ * This funtion will add a target to the current playlist. If a playlist does
+ * not exist, it will be created.
+ *
+ * \param i_object a vlc object id
+ * \param psz_target the URI of the target to play
+ * \param ppsz_options an array of strings with input options (ie. :input-repeat)
+ * \param i_options the amount of options in the ppsz_options array
+ * \param i_mode the insert mode to insert the target into the playlist (PLAYLIST_* defines)
+ * \param i_pos the position at which to add the new target (PLAYLIST_END for end)
+ * \return VLC_SUCCESS on success
+ */
+int     VLC_AddTarget( int, char const *, const char **, int, int, int );
+
+/**
+ * Start the playlist and play the currently selected playlist item
+ *
+ * If there is something in the playlist, and the playlist is not running,
+ * then start the playlist and play the currently selected playlist item.
+ * If an item is currently paused, then resume it.
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int     VLC_Play( int );
+
+/**
+ * Pause the currently playing item. Resume it if already paused
+ *
+ * If an item is currently playing then pause it.
+ * If the item is already paused, then resume playback.
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int     VLC_Pause( int );
+
+/**
+ * Stop the playlist
+ *
+ * If an item is currently playing then stop it.
+ * Set the playlist to a stopped state.
+ *
+ * \note This function is new. The old VLC_Stop is now called VLC_CleanUp
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int             VLC_Stop( int );
+
+/**
+ * Tell if VLC is playing
+ *
+ * If an item is currently playing, it returns
+ * VLC_TRUE, else VLC_FALSE
+ *
+ * \param i_object a vlc object id
+ * \return VLC_TRUE or VLC_FALSE
+ */
+vlc_bool_t      VLC_IsPlaying( int );
+
+/**
+ * Get the current position in a input
+ *
+ * Return the current position as a float
+ * This method should be used for time sliders etc
+ * \note For some inputs, this will be unknown.
+ *
+ * \param i_object a vlc object id
+ * \return a float in the range of 0.0 - 1.0
+ */
+float           VLC_PositionGet( int );
+
+/**
+ * Set the current position in a input
+ *
+ * Set the current position as a float
+ * This method should be used for time sliders etc
+ * \note For some inputs, this will be unknown.
+ *
+ * \param i_object a vlc object id
+ * \param i_position a float in the range of 0.0 - 1.0
+ * \return a float in the range of 0.0 - 1.0
+ */
+float           VLC_PositionSet( int, float );
+
+/**
+ * Get the current position in a input
+ *
+ * Return the current position in seconds from the start.
+ * \note For some inputs, this will be unknown.
+ *
+ * \param i_object a vlc object id
+ * \return the offset from 0:00 in seconds
+ */
+int             VLC_TimeGet( int );
+
+/**
+ * Seek to a position in the current input
+ *
+ * Seek i_seconds in the current input. If b_relative is set,
+ * then the seek will be relative to the current position, otherwise
+ * it will seek to i_seconds from the beginning of the input.
+ * \note For some inputs, this will be unknown.
+ *
+ * \param i_object a vlc object id
+ * \param i_seconds seconds from current position or from beginning of input
+ * \param b_relative seek relative from current position
+ * \return VLC_SUCCESS on success
+ */
+int             VLC_TimeSet( int, int, vlc_bool_t );
+
+/**
+ * Get the total length of a input
+ *
+ * Return the total length in seconds from the current input.
+ * \note For some inputs, this will be unknown.
+ *
+ * \param i_object a vlc object id
+ * \return the length in seconds
+ */
+int             VLC_LengthGet( int );
+
+/**
+ * Play the input faster than realtime
+ *
+ * 2x, 4x, 8x faster than realtime
+ * \note For some inputs, this will be impossible.
+ *
+ * \param i_object a vlc object id
+ * \return the current speedrate
+ */
+float           VLC_SpeedFaster( int );
+
+/**
+ * Play the input slower than realtime
+ *
+ * 1/2x, 1/4x, 1/8x slower than realtime
+ * \note For some inputs, this will be impossible.
+ *
+ * \param i_object a vlc object id
+ * \return the current speedrate
+ */
+float           VLC_SpeedSlower( int );
+
+/**
+ * Return the current playlist item
+ *
+ * \param i_object a vlc object id
+ * \return the index of the playlistitem that is currently selected for play
+ */
+int             VLC_PlaylistIndex( int );
+
+/**
+ * Total amount of items in the playlist
+ *
+ * \param i_object a vlc object id
+ * \return amount of playlist items
+ */
+int             VLC_PlaylistNumberOfItems( int );
+
+/**
+ * Next playlist item
+ *
+ * Skip to the next playlistitem and play it.
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int             VLC_PlaylistNext( int );
+
+/**
+ * Previous playlist item
+ *
+ * Skip to the previous playlistitem and play it.
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int             VLC_PlaylistPrev( int );
+
+/**
+ * Clear the contents of the playlist
+ *
+ * Completly empty the entire playlist.
+ *
+ * \note Was previously called VLC_ClearPlaylist
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int             VLC_PlaylistClear( int );
+
+/**
+ * Change the volume
+ *
+ * \param i_object a vlc object id
+ * \param i_volume something in a range from 0-200
+ * \return the new volume (range 0-200 %)
+ */
+int             VLC_VolumeSet( int, int );
+
+/**
+ * Get the current volume
+ *
+ * Retrieve the current volume.
+ *
+ * \param i_object a vlc object id
+ * \return the current volume (range 0-200 %)
+ */
+int             VLC_VolumeGet( int );
+
+/**
+ * Mute/Unmute the volume
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int            VLC_VolumeMute( int );
+
+/**
+ * Toggle Fullscreen mode
+ *
+ * Switch between normal and fullscreen video
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int             VLC_FullScreen( int );
+
+/* BEGIN SONGBIRD EDIT */
+
+/**
+ * Get Playlist Item MetaData.
+ *
+ * \param i_object a vlc object id.
+ * \param i_item an item index.
+ * \return VLC_SUCCESS on success
+ */
+int             VLC_PlaylistGetItemMetadata( int, int, vlc_meta_t ** );
+
+/* END SONGBIRD EDIT */
+
+# ifdef __cplusplus
+}
+# endif
+
+#define LICENSE_MSG \
+  _("This program comes with NO WARRANTY, to the extent permitted by " \
+    "law.\nYou may redistribute it under the terms of the GNU General " \
+    "Public License;\nsee the file named COPYING for details.\n" \
+    "Written by the VideoLAN team; see the AUTHORS file.\n")
+
+#endif /* <vlc/vlc.h> */

Property changes on: include\vlc\vlc.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc\vout.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_access.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_acl.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_bits.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_block.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_block_helper.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_codec.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_common.h
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: include/vlc_config.h
===================================================================
--- include/vlc_config.h	(revision 159)
+++ include/vlc_config.h	(working copy)
@@ -1,223 +1,243 @@
-/*****************************************************************************
- * vlc_config.h: limits and configuration
- * Defines all compilation-time configuration constants and size limits
- *****************************************************************************
- * Copyright (C) 1999-2003 the VideoLAN team
- *
- * Authors: Vincent Seguin <seguin@via.ecp.fr>
- *          Samuel Hocevar <sam@via.ecp.fr>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/* Conventions regarding names of symbols and variables
- * ----------------------------------------------------
- *
- * - Symbols should begin with a prefix indicating in which module they are
- *   used, such as INTF_, VOUT_ or AOUT_.
- */
-
-/*****************************************************************************
- * General configuration
- *****************************************************************************/
-
-#define CLOCK_FREQ 1000000
-
-
-/* When creating or destroying threads in blocking mode, delay to poll thread
- * status */
-#define THREAD_SLEEP                    ((mtime_t)(0.010*CLOCK_FREQ))
-
-/* When a thread waits on a condition in debug mode, delay to wait before
- * outputting an error message (in second) */
-#define THREAD_COND_TIMEOUT             1
-
-/* The configuration file and directory */
-#ifdef SYS_BEOS
-#  define CONFIG_DIR                    "config/settings/VideoLAN Client"
-#elif __APPLE__
-#  define CONFIG_DIR                    "Library/Preferences/VLC"
-#elif defined( WIN32 ) || defined( UNDER_CE )
-#  define CONFIG_DIR                    "vlc"
-#else
-#  define CONFIG_DIR                    ".vlc"
-#endif
-#define CONFIG_FILE                     "vlcrc"
-#define PLUGINSCACHE_DIR                "cache"
-
-/*****************************************************************************
- * Interface configuration
- *****************************************************************************/
-
-/* Base delay in micro second for interface sleeps */
-#define INTF_IDLE_SLEEP                 ((mtime_t)(0.050*CLOCK_FREQ))
-
-/* Step for changing gamma, and minimum and maximum values */
-#define INTF_GAMMA_STEP                 .1
-#define INTF_GAMMA_LIMIT                3
-
-/*****************************************************************************
- * Input thread configuration
- *****************************************************************************/
-
-/* Used in ErrorThread */
-#define INPUT_IDLE_SLEEP                ((mtime_t)(0.100*CLOCK_FREQ))
-
-/* Time to wait in case of read error */
-#define INPUT_ERROR_SLEEP               ((mtime_t)(0.10*CLOCK_FREQ))
-
-/* Number of read() calls needed until we check the file size through
- * fstat() */
-#define INPUT_FSTAT_NB_READS            10
-
-/*
- * General limitations
- */
-
-/* Duration between the time we receive the data packet, and the time we will
- * mark it to be presented */
-#define DEFAULT_PTS_DELAY               (mtime_t)(.3*CLOCK_FREQ)
-
-/* DVD and VCD devices */
-#if !defined( WIN32 ) && !defined( UNDER_CE )
-#   define VCD_DEVICE "/dev/cdrom"
-#   define CDAUDIO_DEVICE "/dev/cdrom"
-#else
-#   define VCD_DEVICE "D:"
-#   define CDAUDIO_DEVICE "D:"
-#endif
-
-/*****************************************************************************
- * Audio configuration
- *****************************************************************************/
-
-/* Volume */
-#define AOUT_VOLUME_DEFAULT             256
-#define AOUT_VOLUME_STEP                32
-#define AOUT_VOLUME_MAX                 1024
-#define AOUT_VOLUME_MIN                 0
-
-/* Max number of pre-filters per input, and max number of post-filters */
-#define AOUT_MAX_FILTERS                10
-
-/* Max number of inputs */
-#define AOUT_MAX_INPUTS                 5
-
-/* Buffers which arrive in advance of more than AOUT_MAX_ADVANCE_TIME
- * will be considered as bogus and be trashed */
-#define AOUT_MAX_ADVANCE_TIME           (mtime_t)(DEFAULT_PTS_DELAY * 3)
-
-/* Buffers which arrive in advance of more than AOUT_MAX_PREPARE_TIME
- * will cause the calling thread to sleep */
-#define AOUT_MAX_PREPARE_TIME           (mtime_t)(.5*CLOCK_FREQ)
-
-/* Buffers which arrive after pts - AOUT_MIN_PREPARE_TIME will be trashed
- * to avoid too heavy resampling */
-#define AOUT_MIN_PREPARE_TIME           (mtime_t)(.04*CLOCK_FREQ)
-
-/* Max acceptable delay between the coded PTS and the actual presentation
- * time, without resampling */
-#define AOUT_PTS_TOLERANCE              (mtime_t)(.04*CLOCK_FREQ)
-
-/* Max acceptable resampling (in %) */
-#define AOUT_MAX_RESAMPLING             10
-
-/*****************************************************************************
- * Video configuration
- *****************************************************************************/
-
-/*
- * Default settings for video output threads
- */
-
-/* Multiplier value for aspect ratio calculation (2^7 * 3^3 * 5^3) */
-#define VOUT_ASPECT_FACTOR              432000
-
-/* Maximum width of a scaled source picture - this should be relatively high,
- * since higher stream values will result in no display at all. */
-#define VOUT_MAX_WIDTH                  4096
-
-/* Number of planes in a picture */
-#define VOUT_MAX_PLANES                 5
-
-/* Video heap size - remember that a decompressed picture is big
- * (~1 Mbyte) before using huge values */
-#ifdef OPTIMIZE_MEMORY
-#   define VOUT_MAX_PICTURES               5
-#else
-#   define VOUT_MAX_PICTURES               8
-#endif
-
-/* Minimum number of direct pictures the video output will accept without
- * creating additional pictures in system memory */
-#define VOUT_MIN_DIRECT_PICTURES        6
-
-/* Number of simultaneous subpictures */
-#define VOUT_MAX_SUBPICTURES            8
-
-/* Statistics are displayed every n loops (=~ pictures) */
-#define VOUT_STATS_NB_LOOPS             100
-
-/*
- * Time settings
- */
-
-/* Time during which the thread will sleep if it has nothing to
- * display (in micro-seconds) */
-#define VOUT_IDLE_SLEEP                 ((int)(0.020*CLOCK_FREQ))
-
-/* Maximum lap of time allowed between the beginning of rendering and
- * display. If, compared to the current date, the next image is too
- * late, the thread will perform an idle loop. This time should be
- * at least VOUT_IDLE_SLEEP plus the time required to render a few
- * images, to avoid trashing of decoded images */
-#define VOUT_DISPLAY_DELAY              ((int)(0.200*CLOCK_FREQ))
-
-/* Pictures which are VOUT_BOGUS_DELAY or more in advance probably have
- * a bogus PTS and won't be displayed */
-#define VOUT_BOGUS_DELAY                ((mtime_t)(DEFAULT_PTS_DELAY * 30))
-
-/* Delay (in microseconds) before an idle screen is displayed */
-#define VOUT_IDLE_DELAY                 (5*CLOCK_FREQ)
-
-/* Number of pictures required to computes the FPS rate */
-#define VOUT_FPS_SAMPLES                20
-
-/* Better be in advance when awakening than late... */
-#define VOUT_MWAIT_TOLERANCE            ((mtime_t)(0.020*CLOCK_FREQ))
-
-/* Time to sleep when waiting for a buffer (from vout or the video fifo).
- * It should be approximately the time needed to perform a complete picture
- * loop. Since it only happens when the video heap is full, it does not need
- * to be too low, even if it blocks the decoder. */
-#define VOUT_OUTMEM_SLEEP               ((mtime_t)(0.020*CLOCK_FREQ))
-
-/* The default video output window title */
-#define VOUT_TITLE                      "VLC"
-
-/*****************************************************************************
- * Messages and console interfaces configuration
- *****************************************************************************/
-
-/* Maximal size of a message to be stored in the mesage queue,
- * it is needed when vasprintf is not available */
-#define INTF_MAX_MSG_SIZE               512
-
-/* Maximal size of the message queue - in case of overflow, all messages in the
- * queue are printed, but not sent to the threads */
-#define VLC_MSG_QSIZE                   256
-
-/* Maximal depth of the object tree output by vlc_dumpstructure */
-#define MAX_DUMPSTRUCTURE_DEPTH         100
+/*****************************************************************************
+ * vlc_config.h: limits and configuration
+ * Defines all compilation-time configuration constants and size limits
+ *****************************************************************************
+ * Copyright (C) 1999-2003 the VideoLAN team
+ *
+ * Authors: Vincent Seguin <seguin@via.ecp.fr>
+ *          Samuel Hocevar <sam@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/* Conventions regarding names of symbols and variables
+ * ----------------------------------------------------
+ *
+ * - Symbols should begin with a prefix indicating in which module they are
+ *   used, such as INTF_, VOUT_ or AOUT_.
+ */
+
+/*****************************************************************************
+ * General configuration
+ *****************************************************************************/
+
+#define CLOCK_FREQ 1000000
+
+
+/* When creating or destroying threads in blocking mode, delay to poll thread
+ * status */
+#define THREAD_SLEEP                    ((mtime_t)(0.010*CLOCK_FREQ))
+
+/* When a thread waits on a condition in debug mode, delay to wait before
+ * outputting an error message (in second) */
+#define THREAD_COND_TIMEOUT             1
+
+/*BEGIN SONGBIRD EDIT*/
+
+/* Unmodified code block below */
+/*
+// The configuration file and directory 
+#ifdef SYS_BEOS
+#  define CONFIG_DIR                    "config/settings/VideoLAN Client"
+#elif __APPLE__
+#  define CONFIG_DIR                    "Library/Preferences/VLC"
+#elif defined( WIN32 ) || defined( UNDER_CE )
+#  define CONFIG_DIR                    "vlc"
+#else
+#  define CONFIG_DIR                    ".vlc"
+#endif
+#define CONFIG_FILE                     "vlcrc"
+#define PLUGINSCACHE_DIR                "cache"
+*/
+
+/* The configuration file and directory */
+#ifdef SYS_BEOS
+#  define CONFIG_DIR                    "config/settings/Songbird VLC"
+#elif __APPLE__
+#  define CONFIG_DIR                    "Library/Preferences/SongbirdVLC"
+#elif defined( WIN32 ) || defined( UNDER_CE )
+#  define CONFIG_DIR                    "SongbirdVLC"
+#else
+#  define CONFIG_DIR                    ".songbird_vlc"
+#endif
+#define CONFIG_FILE                     "songbirdvlcrc"
+#define PLUGINSCACHE_DIR                "cache"
+
+/*END SONGBIRD EDIT*/
+
+/*****************************************************************************
+ * Interface configuration
+ *****************************************************************************/
+
+/* Base delay in micro second for interface sleeps */
+#define INTF_IDLE_SLEEP                 ((mtime_t)(0.050*CLOCK_FREQ))
+
+/* Step for changing gamma, and minimum and maximum values */
+#define INTF_GAMMA_STEP                 .1
+#define INTF_GAMMA_LIMIT                3
+
+/*****************************************************************************
+ * Input thread configuration
+ *****************************************************************************/
+
+/* Used in ErrorThread */
+#define INPUT_IDLE_SLEEP                ((mtime_t)(0.100*CLOCK_FREQ))
+
+/* Time to wait in case of read error */
+#define INPUT_ERROR_SLEEP               ((mtime_t)(0.10*CLOCK_FREQ))
+
+/* Number of read() calls needed until we check the file size through
+ * fstat() */
+#define INPUT_FSTAT_NB_READS            10
+
+/*
+ * General limitations
+ */
+
+/* Duration between the time we receive the data packet, and the time we will
+ * mark it to be presented */
+#define DEFAULT_PTS_DELAY               (mtime_t)(.3*CLOCK_FREQ)
+
+/* DVD and VCD devices */
+#if !defined( WIN32 ) && !defined( UNDER_CE )
+#   define VCD_DEVICE "/dev/cdrom"
+#   define CDAUDIO_DEVICE "/dev/cdrom"
+#else
+#   define VCD_DEVICE "D:"
+#   define CDAUDIO_DEVICE "D:"
+#endif
+
+/*****************************************************************************
+ * Audio configuration
+ *****************************************************************************/
+
+/* Volume */
+#define AOUT_VOLUME_DEFAULT             256
+#define AOUT_VOLUME_STEP                32
+#define AOUT_VOLUME_MAX                 1024
+#define AOUT_VOLUME_MIN                 0
+
+/* Max number of pre-filters per input, and max number of post-filters */
+#define AOUT_MAX_FILTERS                10
+
+/* Max number of inputs */
+#define AOUT_MAX_INPUTS                 5
+
+/* Buffers which arrive in advance of more than AOUT_MAX_ADVANCE_TIME
+ * will be considered as bogus and be trashed */
+#define AOUT_MAX_ADVANCE_TIME           (mtime_t)(DEFAULT_PTS_DELAY * 3)
+
+/* Buffers which arrive in advance of more than AOUT_MAX_PREPARE_TIME
+ * will cause the calling thread to sleep */
+#define AOUT_MAX_PREPARE_TIME           (mtime_t)(.5*CLOCK_FREQ)
+
+/* Buffers which arrive after pts - AOUT_MIN_PREPARE_TIME will be trashed
+ * to avoid too heavy resampling */
+#define AOUT_MIN_PREPARE_TIME           (mtime_t)(.04*CLOCK_FREQ)
+
+/* Max acceptable delay between the coded PTS and the actual presentation
+ * time, without resampling */
+#define AOUT_PTS_TOLERANCE              (mtime_t)(.04*CLOCK_FREQ)
+
+/* Max acceptable resampling (in %) */
+#define AOUT_MAX_RESAMPLING             10
+
+/*****************************************************************************
+ * Video configuration
+ *****************************************************************************/
+
+/*
+ * Default settings for video output threads
+ */
+
+/* Multiplier value for aspect ratio calculation (2^7 * 3^3 * 5^3) */
+#define VOUT_ASPECT_FACTOR              432000
+
+/* Maximum width of a scaled source picture - this should be relatively high,
+ * since higher stream values will result in no display at all. */
+#define VOUT_MAX_WIDTH                  4096
+
+/* Number of planes in a picture */
+#define VOUT_MAX_PLANES                 5
+
+/* Video heap size - remember that a decompressed picture is big
+ * (~1 Mbyte) before using huge values */
+#ifdef OPTIMIZE_MEMORY
+#   define VOUT_MAX_PICTURES               5
+#else
+#   define VOUT_MAX_PICTURES               8
+#endif
+
+/* Minimum number of direct pictures the video output will accept without
+ * creating additional pictures in system memory */
+#define VOUT_MIN_DIRECT_PICTURES        6
+
+/* Number of simultaneous subpictures */
+#define VOUT_MAX_SUBPICTURES            8
+
+/* Statistics are displayed every n loops (=~ pictures) */
+#define VOUT_STATS_NB_LOOPS             100
+
+/*
+ * Time settings
+ */
+
+/* Time during which the thread will sleep if it has nothing to
+ * display (in micro-seconds) */
+#define VOUT_IDLE_SLEEP                 ((int)(0.020*CLOCK_FREQ))
+
+/* Maximum lap of time allowed between the beginning of rendering and
+ * display. If, compared to the current date, the next image is too
+ * late, the thread will perform an idle loop. This time should be
+ * at least VOUT_IDLE_SLEEP plus the time required to render a few
+ * images, to avoid trashing of decoded images */
+#define VOUT_DISPLAY_DELAY              ((int)(0.200*CLOCK_FREQ))
+
+/* Pictures which are VOUT_BOGUS_DELAY or more in advance probably have
+ * a bogus PTS and won't be displayed */
+#define VOUT_BOGUS_DELAY                ((mtime_t)(DEFAULT_PTS_DELAY * 30))
+
+/* Delay (in microseconds) before an idle screen is displayed */
+#define VOUT_IDLE_DELAY                 (5*CLOCK_FREQ)
+
+/* Number of pictures required to computes the FPS rate */
+#define VOUT_FPS_SAMPLES                20
+
+/* Better be in advance when awakening than late... */
+#define VOUT_MWAIT_TOLERANCE            ((mtime_t)(0.020*CLOCK_FREQ))
+
+/* Time to sleep when waiting for a buffer (from vout or the video fifo).
+ * It should be approximately the time needed to perform a complete picture
+ * loop. Since it only happens when the video heap is full, it does not need
+ * to be too low, even if it blocks the decoder. */
+#define VOUT_OUTMEM_SLEEP               ((mtime_t)(0.020*CLOCK_FREQ))
+
+/* The default video output window title */
+#define VOUT_TITLE                      "VLC"
+
+/*****************************************************************************
+ * Messages and console interfaces configuration
+ *****************************************************************************/
+
+/* Maximal size of a message to be stored in the mesage queue,
+ * it is needed when vasprintf is not available */
+#define INTF_MAX_MSG_SIZE               512
+
+/* Maximal size of the message queue - in case of overflow, all messages in the
+ * queue are printed, but not sent to the threads */
+#define VLC_MSG_QSIZE                   256
+
+/* Maximal depth of the object tree output by vlc_dumpstructure */
+#define MAX_DUMPSTRUCTURE_DEPTH         100

Property changes on: include\vlc_config.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_config_cat.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_cpu.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_demux.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_error.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_es.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_es_out.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_filter.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_httpd.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_image.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_input.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_interaction.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_interface.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_keys.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_md5.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_messages.h
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: include/vlc_meta.h
===================================================================
--- include/vlc_meta.h	(revision 159)
+++ include/vlc_meta.h	(working copy)
@@ -1,181 +1,186 @@
-/*****************************************************************************
- * vlc_meta.h: Stream meta-data
- *****************************************************************************
- * Copyright (C) 2004 the VideoLAN team
- * $Id: vlc_meta.h 14408 2006-02-19 16:16:56Z zorglub $
- *
- * Authors: Laurent Aimar <fenrir@via.ecp.fr>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-#ifndef _VLC_META_H
-#define _VLC_META_H 1
-
-/* VLC meta name */
-#define VLC_META_INFO_CAT           N_("Meta-information")
-#define VLC_META_TITLE              N_("Title")
-#define VLC_META_AUTHOR             N_("Author")
-#define VLC_META_ARTIST             N_("Artist")
-#define VLC_META_GENRE              N_("Genre")
-#define VLC_META_COPYRIGHT          N_("Copyright")
-#define VLC_META_COLLECTION         N_("Album/movie/show title")
-#define VLC_META_SEQ_NUM            N_("Track number/position in set")
-#define VLC_META_DESCRIPTION        N_("Description")
-#define VLC_META_RATING             N_("Rating")
-#define VLC_META_DATE               N_("Date")
-#define VLC_META_SETTING            N_("Setting")
-#define VLC_META_URL                N_("URL")
-#define VLC_META_LANGUAGE           N_("Language")
-#define VLC_META_NOW_PLAYING        N_("Now Playing")
-#define VLC_META_PUBLISHER          N_("Publisher")
-
-#define VLC_META_CDDB_ARTIST        N_("CDDB Artist")
-#define VLC_META_CDDB_CATEGORY      N_("CDDB Category")
-#define VLC_META_CDDB_DISCID        N_("CDDB Disc ID")
-#define VLC_META_CDDB_EXT_DATA      N_("CDDB Extended Data")
-#define VLC_META_CDDB_GENRE         N_("CDDB Genre")
-#define VLC_META_CDDB_YEAR          N_("CDDB Year")
-#define VLC_META_CDDB_TITLE         N_("CDDB Title")
-
-#define VLC_META_CDTEXT_ARRANGER    N_("CD-Text Arranger")
-#define VLC_META_CDTEXT_COMPOSER    N_("CD-Text Composer")
-#define VLC_META_CDTEXT_DISCID      N_("CD-Text Disc ID")
-#define VLC_META_CDTEXT_GENRE       N_("CD-Text Genre")
-#define VLC_META_CDTEXT_MESSAGE     N_("CD-Text Message")
-#define VLC_META_CDTEXT_SONGWRITER  N_("CD-Text Songwriter")
-#define VLC_META_CDTEXT_PERFORMER   N_("CD-Text Performer")
-#define VLC_META_CDTEXT_TITLE       N_("CD-Text Title")
-
-#define VLC_META_ISO_APPLICATION_ID N_("ISO-9660 Application ID")
-#define VLC_META_ISO_PREPARER       N_("ISO-9660 Preparer")
-#define VLC_META_ISO_PUBLISHER      N_("ISO-9660 Publisher")
-#define VLC_META_ISO_VOLUME         N_("ISO-9660 Volume")
-#define VLC_META_ISO_VOLUMESET      N_("ISO-9660 Volume Set")
-
-#define VLC_META_CODEC_NAME         N_("Codec Name")
-#define VLC_META_CODEC_DESCRIPTION  N_("Codec Description")
-
-struct vlc_meta_t
-{
-    /* meta name/value pairs */
-    int     i_meta;
-    char    **name;
-    char    **value;
-
-    /* track meta information */
-    int         i_track;
-    vlc_meta_t  **track;
-};
-
-static inline vlc_meta_t *vlc_meta_New( void )
-{
-    vlc_meta_t *m = (vlc_meta_t*)malloc( sizeof( vlc_meta_t ) );
-
-    m->i_meta = 0;
-    m->name   = NULL;
-    m->value  = NULL;
-
-    m->i_track= 0;
-    m->track  = NULL;
-
-    return m;
-}
-
-static inline void vlc_meta_Delete( vlc_meta_t *m )
-{
-    int i;
-    for( i = 0; i < m->i_meta; i++ )
-    {
-        free( m->name[i] );
-        free( m->value[i] );
-    }
-    if( m->name ) free( m->name );
-    if( m->value ) free( m->value );
-
-    for( i = 0; i < m->i_track; i++ )
-    {
-        vlc_meta_Delete( m->track[i] );
-    }
-    if( m->track ) free( m->track );
-    free( m );
-}
-
-static inline void vlc_meta_Add( vlc_meta_t *m,
-                                 const char *name, const char *value )
-{
-    m->name  = (char**)realloc( m->name, sizeof(char*) * ( m->i_meta + 1 ) );
-    m->name[m->i_meta] = strdup( name );
-
-    m->value = (char**)realloc( m->value, sizeof(char*) * ( m->i_meta + 1 ) );
-    m->value[m->i_meta] = strdup( value );
-
-    m->i_meta++;
-}
-
-static inline vlc_meta_t *vlc_meta_Duplicate( vlc_meta_t *src )
-{
-    vlc_meta_t *dst = vlc_meta_New();
-    int i;
-    for( i = 0; i < src->i_meta; i++ )
-    {
-        vlc_meta_Add( dst, src->name[i], src->value[i] );
-    }
-    for( i = 0; i < src->i_track; i++ )
-    {
-        vlc_meta_t *tk = vlc_meta_Duplicate( src->track[i] );
-
-        dst->track = (vlc_meta_t**)realloc( dst->track, sizeof( vlc_meta_t* ) * (dst->i_track+1) );
-        dst->track[dst->i_track++] = tk;
-    }
-    return dst;
-}
-
-static inline void vlc_meta_Merge( vlc_meta_t *dst, vlc_meta_t *src )
-{
-    int i, j;
-    for( i = 0; i < src->i_meta; i++ )
-    {
-        /* Check if dst contains the entry */
-        for( j = 0; j < dst->i_meta; j++ )
-        {
-            if( !strcmp( src->name[i], dst->name[j] ) ) break;
-        }
-        if( j < dst->i_meta )
-        {
-            if( dst->value[j] ) free( dst->value[j] );
-            dst->value[j] = strdup( src->value[i] );
-        }
-        else vlc_meta_Add( dst, src->name[i], src->value[i] );
-    }
-}
-
-static inline char *vlc_meta_GetValue( vlc_meta_t *m, const char *name )
-{
-    int i;
-
-    for( i = 0; i < m->i_meta; i++ )
-    {
-        if( !strcmp( m->name[i], name ) )
-        {
-            char *value = NULL;
-            if( m->value[i] ) value = strdup( m->value[i] );
-            return value;
-        }
-    }
-    return NULL;
-}
-
-#endif
+/*****************************************************************************
+ * vlc_meta.h: Stream meta-data
+ *****************************************************************************
+ * Copyright (C) 2004 the VideoLAN team
+ * $Id: vlc_meta.h 14408 2006-02-19 16:16:56Z zorglub $
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef _VLC_META_H
+#define _VLC_META_H 1
+
+/* VLC meta name */
+#define VLC_META_INFO_CAT           N_("Meta-information")
+#define VLC_META_TITLE              N_("Title")
+#define VLC_META_AUTHOR             N_("Author")
+#define VLC_META_ARTIST             N_("Artist")
+#define VLC_META_GENRE              N_("Genre")
+#define VLC_META_COPYRIGHT          N_("Copyright")
+#define VLC_META_COLLECTION         N_("Album/movie/show title")
+#define VLC_META_SEQ_NUM            N_("Track number/position in set")
+#define VLC_META_DESCRIPTION        N_("Description")
+#define VLC_META_RATING             N_("Rating")
+#define VLC_META_DATE               N_("Date")
+#define VLC_META_SETTING            N_("Setting")
+#define VLC_META_URL                N_("URL")
+#define VLC_META_LANGUAGE           N_("Language")
+#define VLC_META_NOW_PLAYING        N_("Now Playing")
+#define VLC_META_PUBLISHER          N_("Publisher")
+
+#define VLC_META_CDDB_ARTIST        N_("CDDB Artist")
+#define VLC_META_CDDB_CATEGORY      N_("CDDB Category")
+#define VLC_META_CDDB_DISCID        N_("CDDB Disc ID")
+#define VLC_META_CDDB_EXT_DATA      N_("CDDB Extended Data")
+#define VLC_META_CDDB_GENRE         N_("CDDB Genre")
+#define VLC_META_CDDB_YEAR          N_("CDDB Year")
+#define VLC_META_CDDB_TITLE         N_("CDDB Title")
+
+#define VLC_META_CDTEXT_ARRANGER    N_("CD-Text Arranger")
+#define VLC_META_CDTEXT_COMPOSER    N_("CD-Text Composer")
+#define VLC_META_CDTEXT_DISCID      N_("CD-Text Disc ID")
+#define VLC_META_CDTEXT_GENRE       N_("CD-Text Genre")
+#define VLC_META_CDTEXT_MESSAGE     N_("CD-Text Message")
+#define VLC_META_CDTEXT_SONGWRITER  N_("CD-Text Songwriter")
+#define VLC_META_CDTEXT_PERFORMER   N_("CD-Text Performer")
+#define VLC_META_CDTEXT_TITLE       N_("CD-Text Title")
+
+#define VLC_META_ISO_APPLICATION_ID N_("ISO-9660 Application ID")
+#define VLC_META_ISO_PREPARER       N_("ISO-9660 Preparer")
+#define VLC_META_ISO_PUBLISHER      N_("ISO-9660 Publisher")
+#define VLC_META_ISO_VOLUME         N_("ISO-9660 Volume")
+#define VLC_META_ISO_VOLUMESET      N_("ISO-9660 Volume Set")
+
+#define VLC_META_CODEC_NAME         N_("Codec Name")
+#define VLC_META_CODEC_DESCRIPTION  N_("Codec Description")
+
+/* BEGIN SONGBIRD CHANGES */
+#include <stdlib.h>
+#include <string.h>
+/* END SONGBIRD CHANGES */
+
+struct vlc_meta_t
+{
+    /* meta name/value pairs */
+    int     i_meta;
+    char    **name;
+    char    **value;
+
+    /* track meta information */
+    int         i_track;
+    vlc_meta_t  **track;
+};
+
+static inline vlc_meta_t *vlc_meta_New( void )
+{
+    vlc_meta_t *m = (vlc_meta_t*)malloc( sizeof( vlc_meta_t ) );
+
+    m->i_meta = 0;
+    m->name   = NULL;
+    m->value  = NULL;
+
+    m->i_track= 0;
+    m->track  = NULL;
+
+    return m;
+}
+
+static inline void vlc_meta_Delete( vlc_meta_t *m )
+{
+    int i;
+    for( i = 0; i < m->i_meta; i++ )
+    {
+        free( m->name[i] );
+        free( m->value[i] );
+    }
+    if( m->name ) free( m->name );
+    if( m->value ) free( m->value );
+
+    for( i = 0; i < m->i_track; i++ )
+    {
+        vlc_meta_Delete( m->track[i] );
+    }
+    if( m->track ) free( m->track );
+    free( m );
+}
+
+static inline void vlc_meta_Add( vlc_meta_t *m,
+                                 const char *name, const char *value )
+{
+    m->name  = (char**)realloc( m->name, sizeof(char*) * ( m->i_meta + 1 ) );
+    m->name[m->i_meta] = strdup( name );
+
+    m->value = (char**)realloc( m->value, sizeof(char*) * ( m->i_meta + 1 ) );
+    m->value[m->i_meta] = strdup( value );
+
+    m->i_meta++;
+}
+
+static inline vlc_meta_t *vlc_meta_Duplicate( vlc_meta_t *src )
+{
+    vlc_meta_t *dst = vlc_meta_New();
+    int i;
+    for( i = 0; i < src->i_meta; i++ )
+    {
+        vlc_meta_Add( dst, src->name[i], src->value[i] );
+    }
+    for( i = 0; i < src->i_track; i++ )
+    {
+        vlc_meta_t *tk = vlc_meta_Duplicate( src->track[i] );
+
+        dst->track = (vlc_meta_t**)realloc( dst->track, sizeof( vlc_meta_t* ) * (dst->i_track+1) );
+        dst->track[dst->i_track++] = tk;
+    }
+    return dst;
+}
+
+static inline void vlc_meta_Merge( vlc_meta_t *dst, vlc_meta_t *src )
+{
+    int i, j;
+    for( i = 0; i < src->i_meta; i++ )
+    {
+        /* Check if dst contains the entry */
+        for( j = 0; j < dst->i_meta; j++ )
+        {
+            if( !strcmp( src->name[i], dst->name[j] ) ) break;
+        }
+        if( j < dst->i_meta )
+        {
+            if( dst->value[j] ) free( dst->value[j] );
+            dst->value[j] = strdup( src->value[i] );
+        }
+        else vlc_meta_Add( dst, src->name[i], src->value[i] );
+    }
+}
+
+static inline char *vlc_meta_GetValue( vlc_meta_t *m, const char *name )
+{
+    int i;
+
+    for( i = 0; i < m->i_meta; i++ )
+    {
+        if( !strcmp( m->name[i], name ) )
+        {
+            char *value = NULL;
+            if( m->value[i] ) value = strdup( m->value[i] );
+            return value;
+        }
+    }
+    return NULL;
+}
+
+#endif

Property changes on: include\vlc_meta.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_objects.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_osd.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_playlist.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_spu.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_stream.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_strings.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_symbols.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_threads.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_threads_funcs.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_tls.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_update.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_url.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_video.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_vlm.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_vod.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vlc_xml.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\vout_synchro.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: include\win32_specific.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: INSTALL
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: INSTALL.win32
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: INSTALL.wince
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\control.gpe
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\control.h3600
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\control.opie
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\control.zaurus
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\patch
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\postinst.gpe
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\postinst.opie
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\postinst.zaurus
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\postrm.gpe
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\postrm.opie
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\postrm.zaurus
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\rules.gpe
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\rules.h3600
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\rules.opie
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\rules.zaurus
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\vlc.desktop
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\vlc.gpe
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\vlc.opie
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: ipkg\vlc.zaurus
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\afl.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\com.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\driver.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\driver.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\ext.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\ext.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\kludge.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\ldt_keeper.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\ldt_keeper.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\loader.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\module.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\pe_image.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\pe_resource.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\qtx\qtxsdk\components.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\registry.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\registry.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\resource.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\stubs.s
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\vfl.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\win32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\win32.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\avifmt.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\basetsd.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\debugtools.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\driver.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\heap.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\mmreg.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\module.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\msacm.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\msacmdrv.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\pe_image.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\poppack.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\pshpack1.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\pshpack2.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\vfw.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\winbase.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\windef.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\winerror.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\winestring.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\winnt.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\winreg.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wine\winuser.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wineacm.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wrapper.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: loader\wrapper.S
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\BIG.FAT.WARNING
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\checklist.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\colors.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\dialog.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\inputbox.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\lxdialog.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\Makefile
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\menubox.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\msgbox.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\textbox.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\util.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: lxdialog\yesno.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\ac_prog_java.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\ac_prog_java_cc.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\ac_prog_java_works.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\ac_prog_javac.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\ac_prog_javac_works.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\ac_prog_javah.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\codeset.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\gettext.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\glibc21.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\iconv.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\intdiv0.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\inttypes-pri.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\inttypes.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\inttypes_h.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\isc-posix.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\lcmessage.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\lib-ld.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\lib-link.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\lib-prefix.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\progtest.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\stdint_h.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\uintmax_t.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\ulonglong.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: m4\vlc.m4
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: MAINTAINERS
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: menuconfig
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\cdda.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\cdda\access.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\cdda\access.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\cdda\callback.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\cdda\callback.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\cdda\cdda.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\cdda\cdda.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\cdda\info.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\cdda\info.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\cdda\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dc1394.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\directory.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dshow\common.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dshow\crossbar.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dshow\dshow.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dshow\filter.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dshow\filter.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dshow\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dv.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dvb\access.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dvb\dvb.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dvb\en50221.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dvb\http.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dvb\linux_dvb.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dvb\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dvdnav.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\dvdread.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\fake.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\file.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\ftp.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\gnomevfs.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\http.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\mms\asf.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\mms\asf.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\mms\buffer.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\mms\buffer.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\mms\mms.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\mms\mms.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\mms\mmsh.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\mms\mmsh.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\mms\mmstu.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\mms\mmstu.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\mms\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\pvr\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\pvr\pvr.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\pvr\videodev2.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\rtsp\access.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\rtsp\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\rtsp\real.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\rtsp\real.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\rtsp\real_asmrp.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\rtsp\real_rmff.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\rtsp\real_rmff.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\rtsp\real_sdpplin.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\rtsp\real_sdpplin.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\rtsp\rtsp.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\rtsp\rtsp.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\screen\beos.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\screen\mac.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\screen\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\screen\screen.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\screen\screen.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\screen\win32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\screen\x11.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\smb.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\tcp.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\udp.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\v4l\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\v4l\v4l.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\v4l\videodev_mjpeg.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcd\cdrom.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcd\cdrom.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcd\cdrom_internals.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcd\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcd\vcd.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcdx\access.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcdx\demux.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcdx\info.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcdx\info.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcdx\intf.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcdx\intf.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcdx\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcdx\vcd.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcdx\vcd.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcdx\vcdplayer.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access\vcdx\vcdplayer.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_filter\dump.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_filter\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_filter\record.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_filter\timeshift.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_output\bonjour.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_output\bonjour.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_output\dummy.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_output\file.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_output\http.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_output\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_output\shout.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\access_output\udp.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\channel_mixer\dolby.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\channel_mixer\headphone.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\channel_mixer\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\channel_mixer\simple.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\channel_mixer\trivial.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\a52tofloat32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\a52tospdif.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\dtstofloat32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\dtstospdif.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\fixed32tofloat32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\fixed32tos16.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\float32tos16.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\float32tos8.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\float32tou16.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\float32tou8.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\mpgatofixed32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\s16tofixed32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\s16tofloat32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\s16tofloat32swab.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\s8tofloat32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\u8tofixed32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\converter\u8tofloat32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\equalizer.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\equalizer_presets.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\format.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\normvol.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\param_eq.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\resampler\bandlimited.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\resampler\bandlimited.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\resampler\linear.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\resampler\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\resampler\trivial.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_filter\resampler\ugly.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_mixer\float32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_mixer\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_mixer\spdif.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_mixer\trivial.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\alsa.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\arts.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\auhal.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\directx.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\esd.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\file.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\hd1000a.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\jack.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\oss.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\portaudio.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\sdl.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\audio_output\waveout.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\a52.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\adpcm.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\araw.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cinepak.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\browser_open.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\browser_open.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\cmml.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\HACKING
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\history.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\history.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\intf.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\xarray.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\xarray.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\xlist.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\xlist.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\xstrcat.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\xtag.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\xtag.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\xurl.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cmml\xurl.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\cvdsub.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\dirac.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\dmo\buffer.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\dmo\dmo.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\dmo\dmo.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\dmo\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\dts.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\dvbsub.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\faad.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\fake.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\ffmpeg\audio.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\ffmpeg\chroma.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\ffmpeg\demux.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\ffmpeg\encoder.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\ffmpeg\ffmpeg.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\ffmpeg\ffmpeg.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\ffmpeg\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\ffmpeg\mux.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\ffmpeg\postprocess.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\ffmpeg\video.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\ffmpeg\video_filter.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\flac.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\libmpeg2.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\lpcm.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\mash.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\mpeg_audio.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\png.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\quicktime.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\rawvideo.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\realaudio.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\sdl_image.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\speex.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\spudec\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\spudec\parse.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\spudec\spudec.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\spudec\spudec.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\subsdec.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\svcdsub.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\tarkin.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\telx.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\theora.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\twolame.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\vorbis.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\codec\x264.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\corba\corba.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\corba\MediaControl.idl
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\corba\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\corba\README
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\gestures.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\hotkeys.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\http\http.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\http\http.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\http\macro.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\http\macros.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\http\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\http\mvar.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\http\rpn.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\http\util.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\lirc.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\netsync.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\ntservice.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\rc.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\showintf.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\control\telnet.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\a52.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\aiff.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\asf\asf.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\asf\libasf.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\asf\libasf.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\asf\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\au.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\avi\avi.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\avi\libavi.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\avi\libavi.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\avi\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\demuxdump.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\dts.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\flac.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\live555.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\m3u.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mjpeg.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mkv.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mod.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: modules/demux/mp4/drms.c
===================================================================
--- modules/demux/mp4/drms.c	(revision 159)
+++ modules/demux/mp4/drms.c	(working copy)
@@ -1,2085 +1,2166 @@
-/*****************************************************************************
- * drms.c: DRMS
- *****************************************************************************
- * Copyright (C) 2004 the VideoLAN team
- * $Id: drms.c 16993 2006-10-08 14:17:51Z jpsaman $
- *
- * Authors: Jon Lech Johansen <jon-vl@nanocrew.net>
- *          Sam Hocevar <sam@zoy.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-#include <stdlib.h>                                      /* malloc(), free() */
-
-#ifdef WIN32
-#   include <io.h>
-#else
-#   include <stdio.h>
-#endif
-
-#ifdef __VLC__
-#   include <vlc/vlc.h>
-#   include <vlc_md5.h>
-#   include "libmp4.h"
-#   include "charset.h"
-#else
-#   include "drmsvl.h"
-#endif
-
-#ifdef HAVE_ERRNO_H
-#   include <errno.h>
-#endif
-
-#ifdef WIN32
-#   if !defined( UNDER_CE )
-#       include <direct.h>
-#   endif
-#   include <tchar.h>
-#   include <shlobj.h>
-#   include <windows.h>
-#endif
-
-#ifdef HAVE_SYS_STAT_H
-#   include <sys/stat.h>
-#endif
-#ifdef HAVE_SYS_TYPES_H
-#   include <sys/types.h>
-#endif
-
-/* In Solaris (and perhaps others) PATH_MAX is in limits.h. */
-#ifdef HAVE_LIMITS_H
-#   include <limits.h>
-#endif
-
-#ifdef __APPLE__
-#   include <mach/mach.h>
-#   include <IOKit/IOKitLib.h>
-#   include <CoreFoundation/CFNumber.h>
-#endif
-
-#ifdef HAVE_SYSFS_LIBSYSFS_H
-#   include <sysfs/libsysfs.h>
-#endif
-
-#include "drms.h"
-#include "drmstables.h"
-
-#if !defined( UNDER_CE )
-/*****************************************************************************
- * aes_s: AES keys structure
- *****************************************************************************
- * This structure stores a set of keys usable for encryption and decryption
- * with the AES/Rijndael algorithm.
- *****************************************************************************/
-struct aes_s
-{
-    uint32_t pp_enc_keys[ AES_KEY_COUNT + 1 ][ 4 ];
-    uint32_t pp_dec_keys[ AES_KEY_COUNT + 1 ][ 4 ];
-};
-
-#ifdef __VLC__
-# define Digest DigestMD5
-#else
-/*****************************************************************************
- * md5_s: MD5 message structure
- *****************************************************************************
- * This structure stores the static information needed to compute an MD5
- * hash. It has an extra data buffer to allow non-aligned writes.
- *****************************************************************************/
-struct md5_s
-{
-    uint64_t i_bits;      /* Total written bits */
-    uint32_t p_digest[4]; /* The MD5 digest */
-    uint32_t p_data[16];  /* Buffer to cache non-aligned writes */
-};
-#endif
-
-/*****************************************************************************
- * shuffle_s: shuffle structure
- *****************************************************************************
- * This structure stores the static information needed to shuffle data using
- * a custom algorithm.
- *****************************************************************************/
-struct shuffle_s
-{
-    uint32_t i_version;
-    uint32_t p_commands[ 20 ];
-    uint32_t p_bordel[ 16 ];
-};
-
-#define SWAP( a, b ) { (a) ^= (b); (b) ^= (a); (a) ^= (b); }
-
-/*****************************************************************************
- * drms_s: DRMS structure
- *****************************************************************************
- * This structure stores the static information needed to decrypt DRMS data.
- *****************************************************************************/
-struct drms_s
-{
-    uint32_t i_user;
-    uint32_t i_key;
-    uint8_t  p_iviv[ 16 ];
-    uint8_t *p_name;
-
-    uint32_t p_key[ 4 ];
-    struct aes_s aes;
-
-    char     psz_homedir[ PATH_MAX ];
-};
-
-/*****************************************************************************
- * Local prototypes
- *****************************************************************************/
-static void InitAES       ( struct aes_s *, uint32_t * );
-static void DecryptAES    ( struct aes_s *, uint32_t *, const uint32_t * );
-
-#ifndef __VLC__
-static void InitMD5       ( struct md5_s * );
-static void AddMD5        ( struct md5_s *, const uint8_t *, uint32_t );
-static void EndMD5        ( struct md5_s * );
-static void Digest        ( struct md5_s *, uint32_t * );
-#endif
-
-static void InitShuffle   ( struct shuffle_s *, uint32_t *, uint32_t );
-static void DoShuffle     ( struct shuffle_s *, uint32_t *, uint32_t );
-
-static uint32_t FirstPass ( uint32_t * );
-static void SecondPass    ( uint32_t *, uint32_t );
-static void ThirdPass     ( uint32_t * );
-static void FourthPass    ( uint32_t * );
-static void TinyShuffle1  ( uint32_t * );
-static void TinyShuffle2  ( uint32_t * );
-static void TinyShuffle3  ( uint32_t * );
-static void TinyShuffle4  ( uint32_t * );
-static void TinyShuffle5  ( uint32_t * );
-static void TinyShuffle6  ( uint32_t * );
-static void TinyShuffle7  ( uint32_t * );
-static void TinyShuffle8  ( uint32_t * );
-static void DoExtShuffle  ( uint32_t * );
-
-static int GetSystemKey   ( uint32_t *, vlc_bool_t );
-static int WriteUserKey   ( void *, uint32_t * );
-static int ReadUserKey    ( void *, uint32_t * );
-static int GetUserKey     ( void *, uint32_t * );
-
-static int GetSCIData     ( char *, uint32_t **, uint32_t * );
-static int HashSystemInfo ( uint32_t * );
-static int GetiPodID      ( int64_t * );
-
-#ifdef WORDS_BIGENDIAN
-/*****************************************************************************
- * Reverse: reverse byte order
- *****************************************************************************/
-static inline void Reverse( uint32_t *p_buffer, int n )
-{
-    int i;
-
-    for( i = 0; i < n; i++ )
-    {
-        p_buffer[ i ] = GetDWLE(&p_buffer[ i ]);
-    }
-}
-#    define REVERSE( p, n ) Reverse( p, n )
-#else
-#    define REVERSE( p, n )
-#endif
-
-/*****************************************************************************
- * BlockXOR: XOR two 128 bit blocks
- *****************************************************************************/
-static inline void BlockXOR( uint32_t *p_dest, uint32_t *p_s1, uint32_t *p_s2 )
-{
-    int i;
-
-    for( i = 0; i < 4; i++ )
-    {
-        p_dest[ i ] = p_s1[ i ] ^ p_s2[ i ];
-    }
-}
-
-/*****************************************************************************
- * drms_alloc: allocate a DRMS structure
- *****************************************************************************/
-void *drms_alloc( char *psz_homedir )
-{
-    struct drms_s *p_drms;
-
-    p_drms = malloc( sizeof(struct drms_s) );
-
-    if( p_drms == NULL )
-    {
-        return NULL;
-    }
-
-    memset( p_drms, 0, sizeof(struct drms_s) );
-
-    strncpy( p_drms->psz_homedir, psz_homedir, PATH_MAX );
-    p_drms->psz_homedir[ PATH_MAX - 1 ] = '\0';
-
-    return (void *)p_drms;
-}
-
-/*****************************************************************************
- * drms_free: free a previously allocated DRMS structure
- *****************************************************************************/
-void drms_free( void *_p_drms )
-{
-    struct drms_s *p_drms = (struct drms_s *)_p_drms;
-
-    if( p_drms->p_name != NULL )
-    {
-        free( (void *)p_drms->p_name );
-    }
-
-    free( p_drms );
-}
-
-/*****************************************************************************
- * drms_decrypt: unscramble a chunk of data
- *****************************************************************************/
-void drms_decrypt( void *_p_drms, uint32_t *p_buffer, uint32_t i_bytes )
-{
-    struct drms_s *p_drms = (struct drms_s *)_p_drms;
-    uint32_t p_key[ 4 ];
-    unsigned int i_blocks;
-
-    /* AES is a block cypher, round down the byte count */
-    i_blocks = i_bytes / 16;
-    i_bytes = i_blocks * 16;
-
-    /* Initialise the key */
-    memcpy( p_key, p_drms->p_key, 16 );
-
-    /* Unscramble */
-    while( i_blocks-- )
-    {
-        uint32_t p_tmp[ 4 ];
-
-        REVERSE( p_buffer, 4 );
-        DecryptAES( &p_drms->aes, p_tmp, p_buffer );
-        BlockXOR( p_tmp, p_key, p_tmp );
-
-        /* Use the previous scrambled data as the key for next block */
-        memcpy( p_key, p_buffer, 16 );
-
-        /* Copy unscrambled data back to the buffer */
-        memcpy( p_buffer, p_tmp, 16 );
-        REVERSE( p_buffer, 4 );
-
-        p_buffer += 4;
-    }
-}
-
-/*****************************************************************************
- * drms_init: initialise a DRMS structure
- *****************************************************************************
- * Return values:
- *  0: success
- * -1: unimplemented
- * -2: invalid argument
- * -3: could not get system key
- * -4: could not get SCI data
- * -5: no user key found in SCI data
- * -6: invalid user key
- *****************************************************************************/
-int drms_init( void *_p_drms, uint32_t i_type,
-               uint8_t *p_info, uint32_t i_len )
-{
-    struct drms_s *p_drms = (struct drms_s *)_p_drms;
-    int i_ret = 0;
-
-    switch( i_type )
-    {
-        case FOURCC_user:
-            if( i_len < sizeof(p_drms->i_user) )
-            {
-                i_ret = -2;
-                break;
-            }
-
-            p_drms->i_user = U32_AT( p_info );
-            break;
-
-        case FOURCC_key:
-            if( i_len < sizeof(p_drms->i_key) )
-            {
-                i_ret = -2;
-                break;
-            }
-
-            p_drms->i_key = U32_AT( p_info );
-            break;
-
-        case FOURCC_iviv:
-            if( i_len < sizeof(p_drms->p_key) )
-            {
-                i_ret = -2;
-                break;
-            }
-
-            memcpy( p_drms->p_iviv, p_info, 16 );
-            break;
-
-        case FOURCC_name:
-            p_drms->p_name = (uint8_t*) strdup( (char *)p_info );
-
-            if( p_drms->p_name == NULL )
-            {
-                i_ret = -2;
-            }
-            break;
-
-        case FOURCC_priv:
-        {
-            uint32_t p_priv[ 64 ];
-            struct md5_s md5;
-
-            if( i_len < 64 )
-            {
-                i_ret = -2;
-                break;
-            }
-
-            InitMD5( &md5 );
-            AddMD5( &md5, p_drms->p_name, strlen( (char *)p_drms->p_name ) );
-            AddMD5( &md5, p_drms->p_iviv, 16 );
-            EndMD5( &md5 );
-
-            if( p_drms->i_user == 0 && p_drms->i_key == 0 )
-            {
-                static char const p_secret[] = "tr1-th3n.y00_by3";
-                memcpy( p_drms->p_key, p_secret, 16 );
-                REVERSE( p_drms->p_key, 4 );
-            }
-            else
-            {
-                i_ret = GetUserKey( p_drms, p_drms->p_key );
-                if( i_ret )
-                {
-                    break;
-                }
-            }
-
-            InitAES( &p_drms->aes, p_drms->p_key );
-
-            memcpy( p_priv, p_info, 64 );
-            memcpy( p_drms->p_key, md5.p_digest, 16 );
-            drms_decrypt( p_drms, p_priv, 64 );
-            REVERSE( p_priv, 64 );
-
-            if( p_priv[ 0 ] != 0x6e757469 ) /* itun */
-            {
-                i_ret = -6;
-                break;
-            }
-
-            InitAES( &p_drms->aes, p_priv + 6 );
-            memcpy( p_drms->p_key, p_priv + 12, 16 );
-
-            free( (void *)p_drms->p_name );
-            p_drms->p_name = NULL;
-        }
-        break;
-    }
-
-    return i_ret;
-}
-
-/* The following functions are local */
-
-/*****************************************************************************
- * InitAES: initialise AES/Rijndael encryption/decryption tables
- *****************************************************************************
- * The Advanced Encryption Standard (AES) is described in RFC 3268
- *****************************************************************************/
-static void InitAES( struct aes_s *p_aes, uint32_t *p_key )
-{
-    unsigned int i, t;
-    uint32_t i_key, i_seed;
-
-    memset( p_aes->pp_enc_keys[1], 0, 16 );
-    memcpy( p_aes->pp_enc_keys[0], p_key, 16 );
-
-    /* Generate the key tables */
-    i_seed = p_aes->pp_enc_keys[ 0 ][ 3 ];
-
-    for( i_key = 0; i_key < AES_KEY_COUNT; i_key++ )
-    {
-        uint32_t j;
-
-        i_seed = AES_ROR( i_seed, 8 );
-
-        j = p_aes_table[ i_key ];
-
-        j ^= p_aes_encrypt[ (i_seed >> 24) & 0xff ]
-              ^ AES_ROR( p_aes_encrypt[ (i_seed >> 16) & 0xff ], 8 )
-              ^ AES_ROR( p_aes_encrypt[ (i_seed >> 8) & 0xff ], 16 )
-              ^ AES_ROR( p_aes_encrypt[ i_seed & 0xff ], 24 );
-
-        j ^= p_aes->pp_enc_keys[ i_key ][ 0 ];
-        p_aes->pp_enc_keys[ i_key + 1 ][ 0 ] = j;
-        j ^= p_aes->pp_enc_keys[ i_key ][ 1 ];
-        p_aes->pp_enc_keys[ i_key + 1 ][ 1 ] = j;
-        j ^= p_aes->pp_enc_keys[ i_key ][ 2 ];
-        p_aes->pp_enc_keys[ i_key + 1 ][ 2 ] = j;
-        j ^= p_aes->pp_enc_keys[ i_key ][ 3 ];
-        p_aes->pp_enc_keys[ i_key + 1 ][ 3 ] = j;
-
-        i_seed = j;
-    }
-
-    memcpy( p_aes->pp_dec_keys[ 0 ],
-            p_aes->pp_enc_keys[ 0 ], 16 );
-
-    for( i = 1; i < AES_KEY_COUNT; i++ )
-    {
-        for( t = 0; t < 4; t++ )
-        {
-            uint32_t j, k, l, m, n;
-
-            j = p_aes->pp_enc_keys[ i ][ t ];
-
-            k = (((j >> 7) & 0x01010101) * 27) ^ ((j & 0xff7f7f7f) << 1);
-            l = (((k >> 7) & 0x01010101) * 27) ^ ((k & 0xff7f7f7f) << 1);
-            m = (((l >> 7) & 0x01010101) * 27) ^ ((l & 0xff7f7f7f) << 1);
-
-            j ^= m;
-
-            n = AES_ROR( l ^ j, 16 ) ^ AES_ROR( k ^ j, 8 ) ^ AES_ROR( j, 24 );
-
-            p_aes->pp_dec_keys[ i ][ t ] = k ^ l ^ m ^ n;
-        }
-    }
-}
-
-/*****************************************************************************
- * DecryptAES: decrypt an AES/Rijndael 128 bit block
- *****************************************************************************/
-static void DecryptAES( struct aes_s *p_aes,
-                        uint32_t *p_dest, const uint32_t *p_src )
-{
-    uint32_t p_wtxt[ 4 ]; /* Working cyphertext */
-    uint32_t p_tmp[ 4 ];
-    unsigned int i_round, t;
-
-    for( t = 0; t < 4; t++ )
-    {
-        /* FIXME: are there any endianness issues here? */
-        p_wtxt[ t ] = p_src[ t ] ^ p_aes->pp_enc_keys[ AES_KEY_COUNT ][ t ];
-    }
-
-    /* Rounds 0 - 8 */
-    for( i_round = 0; i_round < (AES_KEY_COUNT - 1); i_round++ )
-    {
-        for( t = 0; t < 4; t++ )
-        {
-            p_tmp[ t ] = AES_XOR_ROR( p_aes_itable, p_wtxt );
-        }
-
-        for( t = 0; t < 4; t++ )
-        {
-            p_wtxt[ t ] = p_tmp[ t ]
-                    ^ p_aes->pp_dec_keys[ (AES_KEY_COUNT - 1) - i_round ][ t ];
-        }
-    }
-
-    /* Final round (9) */
-    for( t = 0; t < 4; t++ )
-    {
-        p_dest[ t ] = AES_XOR_ROR( p_aes_decrypt, p_wtxt );
-        p_dest[ t ] ^= p_aes->pp_dec_keys[ 0 ][ t ];
-    }
-}
-
-#ifndef __VLC__
-/*****************************************************************************
- * InitMD5: initialise an MD5 message
- *****************************************************************************
- * The MD5 message-digest algorithm is described in RFC 1321
- *****************************************************************************/
-static void InitMD5( struct md5_s *p_md5 )
-{
-    p_md5->p_digest[ 0 ] = 0x67452301;
-    p_md5->p_digest[ 1 ] = 0xefcdab89;
-    p_md5->p_digest[ 2 ] = 0x98badcfe;
-    p_md5->p_digest[ 3 ] = 0x10325476;
-
-    memset( p_md5->p_data, 0, 64 );
-    p_md5->i_bits = 0;
-}
-
-/*****************************************************************************
- * AddMD5: add i_len bytes to an MD5 message
- *****************************************************************************/
-static void AddMD5( struct md5_s *p_md5, const uint8_t *p_src, uint32_t i_len )
-{
-    unsigned int i_current; /* Current bytes in the spare buffer */
-    unsigned int i_offset = 0;
-
-    i_current = (p_md5->i_bits / 8) & 63;
-
-    p_md5->i_bits += 8 * i_len;
-
-    /* If we can complete our spare buffer to 64 bytes, do it and add the
-     * resulting buffer to the MD5 message */
-    if( i_len >= (64 - i_current) )
-    {
-        memcpy( ((uint8_t *)p_md5->p_data) + i_current, p_src,
-                (64 - i_current) );
-        Digest( p_md5, p_md5->p_data );
-
-        i_offset += (64 - i_current);
-        i_len -= (64 - i_current);
-        i_current = 0;
-    }
-
-    /* Add as many entire 64 bytes blocks as we can to the MD5 message */
-    while( i_len >= 64 )
-    {
-        uint32_t p_tmp[ 16 ];
-        memcpy( p_tmp, p_src + i_offset, 64 );
-        Digest( p_md5, p_tmp );
-        i_offset += 64;
-        i_len -= 64;
-    }
-
-    /* Copy our remaining data to the message's spare buffer */
-    memcpy( ((uint8_t *)p_md5->p_data) + i_current, p_src + i_offset, i_len );
-}
-
-/*****************************************************************************
- * EndMD5: finish an MD5 message
- *****************************************************************************
- * This function adds adequate padding to the end of the message, and appends
- * the bit count so that we end at a block boundary.
- *****************************************************************************/
-static void EndMD5( struct md5_s *p_md5 )
-{
-    unsigned int i_current;
-
-    i_current = (p_md5->i_bits / 8) & 63;
-
-    /* Append 0x80 to our buffer. No boundary check because the temporary
-     * buffer cannot be full, otherwise AddMD5 would have emptied it. */
-    ((uint8_t *)p_md5->p_data)[ i_current++ ] = 0x80;
-
-    /* If less than 8 bytes are available at the end of the block, complete
-     * this 64 bytes block with zeros and add it to the message. We'll add
-     * our length at the end of the next block. */
-    if( i_current > 56 )
-    {
-        memset( ((uint8_t *)p_md5->p_data) + i_current, 0, (64 - i_current) );
-        Digest( p_md5, p_md5->p_data );
-        i_current = 0;
-    }
-
-    /* Fill the unused space in our last block with zeroes and put the
-     * message length at the end. */
-    memset( ((uint8_t *)p_md5->p_data) + i_current, 0, (56 - i_current) );
-    p_md5->p_data[ 14 ] = p_md5->i_bits & 0xffffffff;
-    p_md5->p_data[ 15 ] = (p_md5->i_bits >> 32);
-    REVERSE( &p_md5->p_data[ 14 ], 2 );
-
-    Digest( p_md5, p_md5->p_data );
-}
-
-#define F1( x, y, z ) ((z) ^ ((x) & ((y) ^ (z))))
-#define F2( x, y, z ) F1((z), (x), (y))
-#define F3( x, y, z ) ((x) ^ (y) ^ (z))
-#define F4( x, y, z ) ((y) ^ ((x) | ~(z)))
-
-#define MD5_DO( f, w, x, y, z, data, s ) \
-    ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
-
-/*****************************************************************************
- * Digest: update the MD5 digest with 64 bytes of data
- *****************************************************************************/
-static void Digest( struct md5_s *p_md5, uint32_t *p_input )
-{
-    uint32_t a, b, c, d;
-
-    REVERSE( p_input, 16 );
-
-    a = p_md5->p_digest[ 0 ];
-    b = p_md5->p_digest[ 1 ];
-    c = p_md5->p_digest[ 2 ];
-    d = p_md5->p_digest[ 3 ];
-
-    MD5_DO( F1, a, b, c, d, p_input[  0 ] + 0xd76aa478,  7 );
-    MD5_DO( F1, d, a, b, c, p_input[  1 ] + 0xe8c7b756, 12 );
-    MD5_DO( F1, c, d, a, b, p_input[  2 ] + 0x242070db, 17 );
-    MD5_DO( F1, b, c, d, a, p_input[  3 ] + 0xc1bdceee, 22 );
-    MD5_DO( F1, a, b, c, d, p_input[  4 ] + 0xf57c0faf,  7 );
-    MD5_DO( F1, d, a, b, c, p_input[  5 ] + 0x4787c62a, 12 );
-    MD5_DO( F1, c, d, a, b, p_input[  6 ] + 0xa8304613, 17 );
-    MD5_DO( F1, b, c, d, a, p_input[  7 ] + 0xfd469501, 22 );
-    MD5_DO( F1, a, b, c, d, p_input[  8 ] + 0x698098d8,  7 );
-    MD5_DO( F1, d, a, b, c, p_input[  9 ] + 0x8b44f7af, 12 );
-    MD5_DO( F1, c, d, a, b, p_input[ 10 ] + 0xffff5bb1, 17 );
-    MD5_DO( F1, b, c, d, a, p_input[ 11 ] + 0x895cd7be, 22 );
-    MD5_DO( F1, a, b, c, d, p_input[ 12 ] + 0x6b901122,  7 );
-    MD5_DO( F1, d, a, b, c, p_input[ 13 ] + 0xfd987193, 12 );
-    MD5_DO( F1, c, d, a, b, p_input[ 14 ] + 0xa679438e, 17 );
-    MD5_DO( F1, b, c, d, a, p_input[ 15 ] + 0x49b40821, 22 );
-
-    MD5_DO( F2, a, b, c, d, p_input[  1 ] + 0xf61e2562,  5 );
-    MD5_DO( F2, d, a, b, c, p_input[  6 ] + 0xc040b340,  9 );
-    MD5_DO( F2, c, d, a, b, p_input[ 11 ] + 0x265e5a51, 14 );
-    MD5_DO( F2, b, c, d, a, p_input[  0 ] + 0xe9b6c7aa, 20 );
-    MD5_DO( F2, a, b, c, d, p_input[  5 ] + 0xd62f105d,  5 );
-    MD5_DO( F2, d, a, b, c, p_input[ 10 ] + 0x02441453,  9 );
-    MD5_DO( F2, c, d, a, b, p_input[ 15 ] + 0xd8a1e681, 14 );
-    MD5_DO( F2, b, c, d, a, p_input[  4 ] + 0xe7d3fbc8, 20 );
-    MD5_DO( F2, a, b, c, d, p_input[  9 ] + 0x21e1cde6,  5 );
-    MD5_DO( F2, d, a, b, c, p_input[ 14 ] + 0xc33707d6,  9 );
-    MD5_DO( F2, c, d, a, b, p_input[  3 ] + 0xf4d50d87, 14 );
-    MD5_DO( F2, b, c, d, a, p_input[  8 ] + 0x455a14ed, 20 );
-    MD5_DO( F2, a, b, c, d, p_input[ 13 ] + 0xa9e3e905,  5 );
-    MD5_DO( F2, d, a, b, c, p_input[  2 ] + 0xfcefa3f8,  9 );
-    MD5_DO( F2, c, d, a, b, p_input[  7 ] + 0x676f02d9, 14 );
-    MD5_DO( F2, b, c, d, a, p_input[ 12 ] + 0x8d2a4c8a, 20 );
-
-    MD5_DO( F3, a, b, c, d, p_input[  5 ] + 0xfffa3942,  4 );
-    MD5_DO( F3, d, a, b, c, p_input[  8 ] + 0x8771f681, 11 );
-    MD5_DO( F3, c, d, a, b, p_input[ 11 ] + 0x6d9d6122, 16 );
-    MD5_DO( F3, b, c, d, a, p_input[ 14 ] + 0xfde5380c, 23 );
-    MD5_DO( F3, a, b, c, d, p_input[  1 ] + 0xa4beea44,  4 );
-    MD5_DO( F3, d, a, b, c, p_input[  4 ] + 0x4bdecfa9, 11 );
-    MD5_DO( F3, c, d, a, b, p_input[  7 ] + 0xf6bb4b60, 16 );
-    MD5_DO( F3, b, c, d, a, p_input[ 10 ] + 0xbebfbc70, 23 );
-    MD5_DO( F3, a, b, c, d, p_input[ 13 ] + 0x289b7ec6,  4 );
-    MD5_DO( F3, d, a, b, c, p_input[  0 ] + 0xeaa127fa, 11 );
-    MD5_DO( F3, c, d, a, b, p_input[  3 ] + 0xd4ef3085, 16 );
-    MD5_DO( F3, b, c, d, a, p_input[  6 ] + 0x04881d05, 23 );
-    MD5_DO( F3, a, b, c, d, p_input[  9 ] + 0xd9d4d039,  4 );
-    MD5_DO( F3, d, a, b, c, p_input[ 12 ] + 0xe6db99e5, 11 );
-    MD5_DO( F3, c, d, a, b, p_input[ 15 ] + 0x1fa27cf8, 16 );
-    MD5_DO( F3, b, c, d, a, p_input[  2 ] + 0xc4ac5665, 23 );
-
-    MD5_DO( F4, a, b, c, d, p_input[  0 ] + 0xf4292244,  6 );
-    MD5_DO( F4, d, a, b, c, p_input[  7 ] + 0x432aff97, 10 );
-    MD5_DO( F4, c, d, a, b, p_input[ 14 ] + 0xab9423a7, 15 );
-    MD5_DO( F4, b, c, d, a, p_input[  5 ] + 0xfc93a039, 21 );
-    MD5_DO( F4, a, b, c, d, p_input[ 12 ] + 0x655b59c3,  6 );
-    MD5_DO( F4, d, a, b, c, p_input[  3 ] + 0x8f0ccc92, 10 );
-    MD5_DO( F4, c, d, a, b, p_input[ 10 ] + 0xffeff47d, 15 );
-    MD5_DO( F4, b, c, d, a, p_input[  1 ] + 0x85845dd1, 21 );
-    MD5_DO( F4, a, b, c, d, p_input[  8 ] + 0x6fa87e4f,  6 );
-    MD5_DO( F4, d, a, b, c, p_input[ 15 ] + 0xfe2ce6e0, 10 );
-    MD5_DO( F4, c, d, a, b, p_input[  6 ] + 0xa3014314, 15 );
-    MD5_DO( F4, b, c, d, a, p_input[ 13 ] + 0x4e0811a1, 21 );
-    MD5_DO( F4, a, b, c, d, p_input[  4 ] + 0xf7537e82,  6 );
-    MD5_DO( F4, d, a, b, c, p_input[ 11 ] + 0xbd3af235, 10 );
-    MD5_DO( F4, c, d, a, b, p_input[  2 ] + 0x2ad7d2bb, 15 );
-    MD5_DO( F4, b, c, d, a, p_input[  9 ] + 0xeb86d391, 21 );
-
-    p_md5->p_digest[ 0 ] += a;
-    p_md5->p_digest[ 1 ] += b;
-    p_md5->p_digest[ 2 ] += c;
-    p_md5->p_digest[ 3 ] += d;
-}
-#endif
-
-/*****************************************************************************
- * InitShuffle: initialise a shuffle structure
- *****************************************************************************
- * This function initialises tables in the p_shuffle structure that will be
- * used later by DoShuffle. The only external parameter is p_sys_key.
- *****************************************************************************/
-static void InitShuffle( struct shuffle_s *p_shuffle, uint32_t *p_sys_key,
-                         uint32_t i_version )
-{
-    char p_secret1[] = "Tv!*";
-    static char const p_secret2[] = "____v8rhvsaAvOKM____FfUH%798=[;."
-                                    "____f8677680a634____ba87fnOIf)(*";
-    unsigned int i;
-
-    p_shuffle->i_version = i_version;
-
-    /* Fill p_commands using the key and a secret seed */
-    for( i = 0; i < 20; i++ )
-    {
-        struct md5_s md5;
-        int32_t i_hash;
-
-        InitMD5( &md5 );
-        AddMD5( &md5, (const uint8_t *)p_sys_key, 16 );
-        AddMD5( &md5, (const uint8_t *)p_secret1, 4 );
-        EndMD5( &md5 );
-
-        p_secret1[ 3 ]++;
-
-        REVERSE( md5.p_digest, 1 );
-        i_hash = ((int32_t)U32_AT(md5.p_digest)) % 1024;
-
-        p_shuffle->p_commands[ i ] = i_hash < 0 ? i_hash * -1 : i_hash;
-    }
-
-    /* Fill p_bordel with completely meaningless initial values. */
-    memcpy( p_shuffle->p_bordel, p_secret2, 64 );
-    for( i = 0; i < 4; i++ )
-    {
-        p_shuffle->p_bordel[ 4 * i ] = U32_AT(p_sys_key + i);
-        REVERSE( p_shuffle->p_bordel + 4 * i + 1, 3 );
-    }
-}
-
-/*****************************************************************************
- * DoShuffle: shuffle buffer
- *****************************************************************************
- * This is so ugly and uses so many MD5 checksums that it is most certainly
- * one-way, though why it needs to be so complicated is beyond me.
- *****************************************************************************/
-static void DoShuffle( struct shuffle_s *p_shuffle,
-                       uint32_t *p_buffer, uint32_t i_size )
-{
-    struct md5_s md5;
-    uint32_t p_big_bordel[ 16 ];
-    uint32_t *p_bordel = p_shuffle->p_bordel;
-    unsigned int i;
-
-    static uint32_t i_secret = 0;
-
-    static uint32_t p_secret3[] =
-    {
-        0xAAAAAAAA, 0x01757700, 0x00554580, 0x01724500, 0x00424580,
-        0x01427700, 0x00000080, 0xC1D59D01, 0x80144981, 0x815C8901,
-        0x80544981, 0x81D45D01, 0x00000080, 0x81A3BB03, 0x00A2AA82,
-        0x01A3BB03, 0x0022A282, 0x813BA202, 0x00000080, 0x6D575737,
-        0x4A5275A5, 0x6D525725, 0x4A5254A5, 0x6B725437, 0x00000080,
-        0xD5DDB938, 0x5455A092, 0x5D95A013, 0x4415A192, 0xC5DD393A,
-        0x00000080, 0x55555555
-    };
-
-    static char p_secret4[] =
-        "pbclevtug (p) Nccyr Pbzchgre, Vap.  Nyy Evtugf Erfreirq.";
-
-    if( i_secret == 0 )
-    {
-        REVERSE( p_secret3, sizeof(p_secret3)/sizeof(p_secret3[ 0 ]) );
-        for( ; p_secret4[ i_secret ] != '\0'; i_secret++ )
-        {
-#define ROT13(c) (((c)>='A'&&(c)<='Z')?(((c)-'A'+13)%26)+'A':\
-                  ((c)>='a'&&(c)<='z')?(((c)-'a'+13)%26)+'a':c)
-            p_secret4[ i_secret ] = ROT13(p_secret4[ i_secret ]);
-        }
-        i_secret++; /* include zero terminator */
-    }
-
-    /* Using the MD5 hash of a memory block is probably not one-way enough
-     * for the iTunes people. This function randomises p_bordel depending on
-     * the values in p_commands to make things even more messy in p_bordel. */
-    for( i = 0; i < 20; i++ )
-    {
-        uint8_t i_command, i_index;
-
-        if( !p_shuffle->p_commands[ i ] )
-        {
-            continue;
-        }
-
-        i_command = (p_shuffle->p_commands[ i ] & 0x300) >> 8;
-        i_index = p_shuffle->p_commands[ i ] & 0xff;
-
-        switch( i_command )
-        {
-        case 0x3:
-            p_bordel[ i_index & 0xf ] = p_bordel[ i_index >> 4 ]
-                                      + p_bordel[ ((i_index + 0x10) >> 4) & 0xf ];
-            break;
-        case 0x2:
-            p_bordel[ i_index >> 4 ] ^= p_shuffle_xor[ 0xff - i_index ];
-            break;
-        case 0x1:
-            p_bordel[ i_index >> 4 ] -= p_shuffle_sub[ 0xff - i_index ];
-            break;
-        default:
-            p_bordel[ i_index >> 4 ] += p_shuffle_add[ 0xff - i_index ];
-            break;
-        }
-    }
-
-    if( p_shuffle->i_version == 0x01000300 )
-    {
-        DoExtShuffle( p_bordel );
-    }
-
-    /* Convert our newly randomised p_bordel to big endianness and take
-     * its MD5 hash. */
-    InitMD5( &md5 );
-    for( i = 0; i < 16; i++ )
-    {
-        p_big_bordel[ i ] = U32_AT(p_bordel + i);
-    }
-    AddMD5( &md5, (const uint8_t *)p_big_bordel, 64 );
-    if( p_shuffle->i_version == 0x01000300 )
-    {
-        AddMD5( &md5, (const uint8_t *)p_secret3, sizeof(p_secret3) );
-        AddMD5( &md5, (const uint8_t *)p_secret4, i_secret );
-    }
-    EndMD5( &md5 );
-
-    /* XOR our buffer with the computed checksum */
-    for( i = 0; i < i_size; i++ )
-    {
-        p_buffer[ i ] ^= md5.p_digest[ i ];
-    }
-}
-
-/*****************************************************************************
- * DoExtShuffle: extended shuffle
- *****************************************************************************
- * This is even uglier.
- *****************************************************************************/
-static void DoExtShuffle( uint32_t * p_bordel )
-{
-    uint32_t i_ret;
-
-    i_ret = FirstPass( p_bordel );
-
-    SecondPass( p_bordel, i_ret );
-
-    ThirdPass( p_bordel );
-
-    FourthPass( p_bordel );
-}
-
-static uint32_t FirstPass( uint32_t * p_bordel )
-{
-    uint32_t i, i_cmd, i_ret = 5;
-
-    TinyShuffle1( p_bordel );
-
-    for( ; ; )
-    {
-        for( ; ; )
-        {
-            p_bordel[ 1 ] += 0x10000000;
-            p_bordel[ 3 ] += 0x12777;
-
-            if( (p_bordel[ 10 ] & 1) && i_ret )
-            {
-                i_ret--;
-                p_bordel[ 1 ] -= p_bordel[ 2 ];
-                p_bordel[ 11 ] += p_bordel[ 12 ];
-                break;
-            }
-
-            if( (p_bordel[ 1 ] + p_bordel[ 2 ]) >= 0x7D0 )
-            {
-                switch( ((p_bordel[ 3 ] ^ 0x567F) >> 2) & 7 )
-                {
-                    case 0:
-                        for( i = 0; i < 3; i++ )
-                        {
-                            if( p_bordel[ i + 10 ] > 0x4E20 )
-                            {
-                                p_bordel[ i + 1 ] += p_bordel[ i + 2 ];
-                            }
-                        }
-                        break;
-                    case 4:
-                        p_bordel[ 1 ] -= p_bordel[ 2 ];
-                        /* no break */
-                    case 3:
-                        p_bordel[ 11 ] += p_bordel[ 12 ];
-                        break;
-                    case 6:
-                        p_bordel[ 3 ] ^= p_bordel[ 4 ];
-                        /* no break */
-                    case 8:
-                        p_bordel[ 13 ] &= p_bordel[ 14 ];
-                        /* no break */
-                    case 1:
-                        p_bordel[ 0 ] |= p_bordel[ 1 ];
-                        if( i_ret )
-                        {
-                            return i_ret;
-                        }
-                        break;
-                }
-
-                break;
-            }
-        }
-
-        for( i = 0, i_cmd = 0; i < 16; i++ )
-        {
-            if( p_bordel[ i ] < p_bordel[ i_cmd ] )
-            {
-                i_cmd = i;
-            }
-        }
-
-        if( i_ret && i_cmd != 5 )
-        {
-            i_ret--;
-        }
-        else
-        {
-            if( i_cmd == 5 )
-            {
-                p_bordel[ 8 ] &= p_bordel[ 6 ] >> 1;
-                p_bordel[ 3 ] <<= 1;
-            }
-
-            for( i = 0; i < 3; i++ )
-            {
-                p_bordel[ 11 ] += 1;
-                if( p_bordel[ 11 ] & 5 )
-                {
-                    p_bordel[ 8 ] += p_bordel[ 9 ];
-                }
-                else if( i_ret )
-                {
-                    i_ret--;
-                    i_cmd = 3;
-                    goto break2;
-                }
-            }
-
-            i_cmd = (p_bordel[ 15 ] + 0x93) >> 3;
-            if( p_bordel[ 15 ] & 0x100 )
-            {
-                i_cmd ^= 0xDEAD;
-            }
-        }
-
-        switch( i_cmd & 3 )
-        {
-            case 0:
-                while( p_bordel[ 11 ] & 1 )
-                {
-                    p_bordel[ 11 ] >>= 1;
-                    p_bordel[ 12 ] += 1;
-                }
-                /* no break */
-            case 2:
-                p_bordel[ 14 ] -= 0x19FE;
-                break;
-            case 3:
-                if( i_ret )
-                {
-                    i_ret--;
-                    p_bordel[ 5 ] += 5;
-                    continue;
-                }
-                break;
-        }
-
-        i_cmd = ((p_bordel[ 3 ] + p_bordel[ 4 ] + 10) >> 1) - p_bordel[ 4 ];
-        break;
-    }
-break2:
-
-    switch( i_cmd & 3 )
-    {
-        case 0:
-            p_bordel[ 14 ] >>= 1;
-            break;
-        case 1:
-            p_bordel[ 5 ] <<= 2;
-            break;
-        case 2:
-            p_bordel[ 12 ] |= 5;
-            break;
-        case 3:
-            p_bordel[ 15 ] &= 0x55;
-            if( i_ret )
-            {
-                p_bordel[ 2 ] &= 0xB62FC;
-                return i_ret;
-            }
-            break;
-    }
-
-    TinyShuffle2( p_bordel );
-
-    return i_ret;
-}
-
-static void SecondPass( uint32_t * p_bordel, uint32_t i_tmp )
-{
-    uint32_t i, i_cmd, i_jc = 5;
-
-    TinyShuffle3( p_bordel );
-
-    for( i = 0, i_cmd = 0; i < 16; i++ )
-    {
-        if( p_bordel[ i ] > p_bordel[ i_cmd ] )
-        {
-            i_cmd = i;
-        }
-    }
-
-    switch( i_cmd )
-    {
-        case 0:
-            if( p_bordel[ 1 ] < p_bordel[ 8 ] )
-            {
-                p_bordel[ 5 ] += 1;
-            }
-            break;
-        case 4:
-            if( (p_bordel[ 9 ] & 0x7777) == 0x3333 )
-            {
-                p_bordel[ 5 ] -= 1;
-            }
-            else
-            {
-                i_jc--;
-                if( p_bordel[ 1 ] < p_bordel[ 8 ] )
-                {
-                    p_bordel[ 5 ] += 1;
-                }
-                break;
-            }
-            /* no break */
-        case 7:
-            p_bordel[ 2 ] -= 1;
-            p_bordel[ 1 ] -= p_bordel[ 5 ];
-            for( i = 0; i < 3; i++ )
-            {
-                switch( p_bordel[ 1 ] & 3 )
-                {
-                    case 0:
-                        p_bordel[ 1 ] += 1;
-                        /* no break */
-                    case 1:
-                        p_bordel[ 3 ] -= 8;
-                        break;
-                    case 2:
-                        p_bordel[ 13 ] &= 0xFEFEFEF7;
-                        break;
-                    case 3:
-                        p_bordel[ 8 ] |= 0x80080011;
-                        break;
-                }
-            }
-            return;
-        case 10:
-            p_bordel[ 4 ] -= 1;
-            p_bordel[ 5 ] += 1;
-            p_bordel[ 6 ] -= 1;
-            p_bordel[ 7 ] += 1;
-            break;
-        default:
-            p_bordel[ 15 ] ^= 0x18547EFF;
-            break;
-    }
-
-    for( i = 3; i--; )
-    {
-        switch( ( p_bordel[ 12 ] + p_bordel[ 13 ] + p_bordel[ 6 ] ) % 5 )
-        {
-            case 0:
-                p_bordel[ 12 ] -= 1;
-                /* no break */
-            case 1:
-                p_bordel[ 12 ] -= 1;
-                p_bordel[ 13 ] += 1;
-                break;
-            case 2:
-                p_bordel[ 13 ] += 4;
-                /* no break */
-            case 3:
-                p_bordel[ 12 ] -= 1;
-                break;
-            case 4:
-                i_jc--;
-                p_bordel[ 5 ] += 1;
-                p_bordel[ 6 ] -= 1;
-                p_bordel[ 7 ] += 1;
-                i = 3; /* Restart the whole loop */
-                break;
-        }
-    }
-
-    TinyShuffle4( p_bordel );
-
-    for( ; ; )
-    {
-        TinyShuffle5( p_bordel );
-
-        switch( ( p_bordel[ 2 ] * 2 + 15 ) % 5 )
-        {
-            case 0:
-                if( ( p_bordel[ 3 ] + i_tmp ) <=
-                    ( p_bordel[ 1 ] + p_bordel[ 15 ] ) )
-                {
-                    p_bordel[ 3 ] += 1;
-                }
-                break;
-            case 4:
-                p_bordel[ 10 ] -= 0x13;
-                break;
-            case 3:
-                p_bordel[ 5 ] >>= 2;
-                break;
-        }
-
-        if( !( p_bordel[ 2 ] & 1 ) || i_jc == 0 )
-        {
-            break;
-        }
-
-        i_jc--;
-        p_bordel[ 2 ] += 0x13;
-        p_bordel[ 12 ] += 1;
-    }
-
-    p_bordel[ 2 ] &= 0x10076000;
-}
-
-static void ThirdPass( uint32_t * p_bordel )
-{
-    uint32_t i_cmd;
-
-    i_cmd = ((p_bordel[ 7 ] + p_bordel[ 14 ] + 10) >> 1) - p_bordel[ 14 ];
-    i_cmd = i_cmd % 10;
-
-    switch( i_cmd )
-    {
-        case 0:
-            p_bordel[ 1 ] <<= 1;
-            p_bordel[ 2 ] <<= 2;
-            p_bordel[ 3 ] <<= 3;
-            break;
-        case 6:
-            p_bordel[ i_cmd + 3 ] &= 0x5EDE36B;
-            p_bordel[ 5 ] += p_bordel[ 8 ];
-            p_bordel[ 4 ] += p_bordel[ 7 ];
-            p_bordel[ 3 ] += p_bordel[ 6 ];
-            p_bordel[ 2 ] += p_bordel[ 5 ];
-            /* no break */
-        case 2:
-            p_bordel[ 1 ] += p_bordel[ 4 ];
-            p_bordel[ 0 ] += p_bordel[ 3 ];
-            TinyShuffle6( p_bordel );
-            return; /* jc = 4 */
-        case 3:
-            if( (p_bordel[ 11 ] & p_bordel[ 2 ]) > 0x211B )
-            {
-                p_bordel[ 6 ] += 1;
-            }
-            break;
-        case 4:
-            p_bordel[ 7 ] += 1;
-            /* no break */
-        case 5:
-            p_bordel[ 9 ] ^= p_bordel[ 2 ];
-            break;
-        case 7:
-            p_bordel[ 2 ] ^= (p_bordel[ 1 ] & p_bordel[ 13 ]);
-            break;
-        case 8:
-            p_bordel[ 0 ] -= p_bordel[ 11 ] & p_bordel[ 15 ];
-            return; /* jc = 4 */
-        case 9:
-            p_bordel[ 6 ] >>= (p_bordel[ 14 ] & 3);
-            break;
-    }
-
-    SWAP( p_bordel[ 0 ], p_bordel[ 10 ] );
-
-    TinyShuffle6( p_bordel );
-
-    return; /* jc = 5 */
-}
-
-static void FourthPass( uint32_t * p_bordel )
-{
-    uint32_t i, j;
-
-    TinyShuffle7( p_bordel );
-
-    switch( p_bordel[ 5 ] % 5)
-    {
-        case 0:
-            p_bordel[ 0 ] += 1;
-            break;
-        case 2:
-            p_bordel[ 11 ] ^= (p_bordel[ 3 ] + p_bordel[ 6 ] + p_bordel[ 8 ]);
-            break;
-        case 3:
-            for( i = 4; i < 15 && (p_bordel[ i ] & 5) == 0; i++ )
-            {
-                SWAP( p_bordel[ i ], p_bordel[ 15 - i ] );
-            }
-            break;
-        case 4:
-            p_bordel[ 12 ] -= 1;
-            p_bordel[ 13 ] += 1;
-            p_bordel[ 2 ] -= 0x64;
-            p_bordel[ 3 ] += 0x64;
-            TinyShuffle8( p_bordel );
-            return;
-    }
-
-    for( i = 0, j = 0; i < 16; i++ )
-    {
-        if( p_bordel[ i ] > p_bordel[ j ] )
-        {
-            j = i;
-        }
-    }
-
-    switch( p_bordel[ j ] % 100 )
-    {
-        case 0:
-            SWAP( p_bordel[ 0 ], p_bordel[ j ] );
-            break;
-        case 8:
-            p_bordel[ 1 ] >>= 1;
-            p_bordel[ 2 ] <<= 1;
-            p_bordel[ 14 ] >>= 3;
-            p_bordel[ 15 ] <<= 4;
-            break;
-        case 57:
-            p_bordel[ j ] += p_bordel[ 13 ];
-            break;
-        case 76:
-            p_bordel[ 1 ] += 0x20E;
-            p_bordel[ 5 ] += 0x223D;
-            p_bordel[ 13 ] -= 0x576;
-            p_bordel[ 15 ] += 0x576;
-            return;
-        case 91:
-            p_bordel[ 2 ] -= 0x64;
-            p_bordel[ 3 ] += 0x64;
-            p_bordel[ 12 ] -= 1;
-            p_bordel[ 13 ] += 1;
-            break;
-        case 99:
-            p_bordel[ 0 ] += 1;
-            p_bordel[ j ] += p_bordel[ 13 ];
-            break;
-    }
-
-    TinyShuffle8( p_bordel );
-}
-
-/*****************************************************************************
- * TinyShuffle[12345678]: tiny shuffle subroutines
- *****************************************************************************
- * These standalone functions are little helpers for the shuffling process.
- *****************************************************************************/
-static void TinyShuffle1( uint32_t * p_bordel )
-{
-    uint32_t i_cmd = (p_bordel[ 5 ] + 10) >> 2;
-
-    if( p_bordel[ 5 ] > 0x7D0 )
-    {
-        i_cmd -= 0x305;
-    }
-
-    switch( i_cmd & 3 )
-    {
-        case 0:
-            p_bordel[ 5 ] += 5;
-            break;
-        case 1:
-            p_bordel[ 4 ] -= 1;
-            break;
-        case 2:
-            if( p_bordel[ 4 ] & 5 )
-            {
-                p_bordel[ 1 ] ^= 0x4D;
-            }
-            /* no break */
-        case 3:
-            p_bordel[ 12 ] += 5;
-            break;
-    }
-}
-
-static void TinyShuffle2( uint32_t * p_bordel )
-{
-    uint32_t i, j;
-
-    for( i = 0, j = 0; i < 16; i++ )
-    {
-        if( (p_bordel[ i ] & 0x777) > (p_bordel[ j ] & 0x777) )
-        {
-            j = i;
-        }
-    }
-
-    if( j > 5 )
-    {
-        for( ; j < 15; j++ )
-        {
-            p_bordel[ j ] += p_bordel[ j + 1 ];
-        }
-    }
-    else
-    {
-        p_bordel[ 2 ] &= 0xB62FC;
-    }
-}
-
-static void TinyShuffle3( uint32_t * p_bordel )
-{
-    uint32_t i_cmd = p_bordel[ 6 ] + 0x194B;
-
-    if( p_bordel[ 6 ] > 0x2710 )
-    {
-        i_cmd >>= 1;
-    }
-
-    switch( i_cmd & 3 )
-    {
-        case 1:
-            p_bordel[ 3 ] += 0x19FE;
-            break;
-        case 2:
-            p_bordel[ 7 ] -= p_bordel[ 3 ] >> 2;
-            /* no break */
-        case 0:
-            p_bordel[ 5 ] ^= 0x248A;
-            break;
-    }
-}
-
-static void TinyShuffle4( uint32_t * p_bordel )
-{
-    uint32_t i, j;
-
-    for( i = 0, j = 0; i < 16; i++ )
-    {
-        if( p_bordel[ i ] < p_bordel[ j ] )
-        {
-            j = i;
-        }
-    }
-
-    if( (p_bordel[ j ] % (j + 1)) > 10 )
-    {
-        p_bordel[ 1 ] -= 1;
-        p_bordel[ 2 ] += 0x13;
-        p_bordel[ 12 ] += 1;
-    }
-}
-
-static void TinyShuffle5( uint32_t * p_bordel )
-{
-    uint32_t i;
-
-    p_bordel[ 2 ] &= 0x7F3F;
-
-    for( i = 0; i < 5; i++ )
-    {
-        switch( ( p_bordel[ 2 ] + 10 + i ) % 5 )
-        {
-            case 0:
-                p_bordel[ 12 ] &= p_bordel[ 2 ];
-                /* no break */
-            case 1:
-                p_bordel[ 3 ] ^= p_bordel[ 15 ];
-                break;
-            case 2:
-                p_bordel[ 15 ] += 0x576;
-                /* no break */
-            case 3:
-                p_bordel[ 7 ] -= 0x2D;
-                /* no break */
-            case 4:
-                p_bordel[ 1 ] <<= 1;
-                break;
-        }
-    }
-}
-
-static void TinyShuffle6( uint32_t * p_bordel )
-{
-    uint32_t i, j;
-
-    for( i = 0; i < 8; i++ )
-    {
-        j = p_bordel[ 3 ] & 0x7514 ? 5 : 7;
-        SWAP( p_bordel[ i ], p_bordel[ i + j ] );
-    }
-}
-
-static void TinyShuffle7( uint32_t * p_bordel )
-{
-    uint32_t i;
-
-    i = (((p_bordel[ 9 ] + p_bordel[ 15 ] + 12) >> 2) - p_bordel[ 4 ]) & 7;
-
-    while( i-- )
-    {
-        SWAP( p_bordel[ i ], p_bordel[ i + 3 ] );
-    }
-
-    SWAP( p_bordel[ 1 ], p_bordel[ 10 ] );
-}
-
-static void TinyShuffle8( uint32_t * p_bordel )
-{
-    uint32_t i;
-
-    i = (p_bordel[ 0 ] & p_bordel[ 6 ]) & 0xF;
-
-    switch( p_bordel[ i ] % 1000 )
-    {
-        case 7:
-            if( (p_bordel[ i ] & 0x777) > (p_bordel[ 7 ] & 0x5555) )
-            {
-                p_bordel[ i ] ^= p_bordel[ 5 ] & p_bordel[ 3 ];
-            }
-            break;
-        case 19:
-            p_bordel[ 15 ] &= 0x5555;
-            break;
-        case 93:
-            p_bordel[ i ] ^= p_bordel[ 15 ];
-            break;
-        case 100:
-            SWAP( p_bordel[ 0 ], p_bordel[ 3 ] );
-            SWAP( p_bordel[ 1 ], p_bordel[ 6 ] );
-            SWAP( p_bordel[ 3 ], p_bordel[ 6 ] );
-            SWAP( p_bordel[ 4 ], p_bordel[ 9 ] );
-            SWAP( p_bordel[ 5 ], p_bordel[ 8 ] );
-            SWAP( p_bordel[ 6 ], p_bordel[ 7 ] );
-            SWAP( p_bordel[ 13 ], p_bordel[ 14 ] );
-            break;
-        case 329:
-            p_bordel[ i ] += p_bordel[ 1 ] ^ 0x80080011;
-            p_bordel[ i ] += p_bordel[ 2 ] ^ 0xBEEFDEAD;
-            p_bordel[ i ] += p_bordel[ 3 ] ^ 0x8765F444;
-            p_bordel[ i ] += p_bordel[ 4 ] ^ 0x78145326;
-            break;
-        case 567:
-            p_bordel[ 12 ] -= p_bordel[ i ];
-            p_bordel[ 13 ] += p_bordel[ i ];
-            break;
-        case 612:
-            p_bordel[ i ] += p_bordel[ 1 ];
-            p_bordel[ i ] -= p_bordel[ 7 ];
-            p_bordel[ i ] -= p_bordel[ 8 ];
-            p_bordel[ i ] += p_bordel[ 9 ];
-            p_bordel[ i ] += p_bordel[ 13 ];
-            break;
-        case 754:
-            i = __MIN( i, 12 );
-            p_bordel[ i + 1 ] >>= 1;
-            p_bordel[ i + 2 ] <<= 4;
-            p_bordel[ i + 3 ] >>= 3;
-            break;
-        case 777:
-            p_bordel[ 1 ] += 0x20E;
-            p_bordel[ 5 ] += 0x223D;
-            p_bordel[ 13 ] -= 0x576;
-            p_bordel[ 15 ] += 0x576;
-            break;
-        case 981:
-            if( (p_bordel[ i ] ^ 0x8765F441) < 0x2710 )
-            {
-                SWAP( p_bordel[ 0 ], p_bordel[ 1 ] );
-            }
-            else
-            {
-                SWAP( p_bordel[ 1 ], p_bordel[ 11 ] );
-            }
-            break;
-    }
-}
-
-/*****************************************************************************
- * GetSystemKey: get the system key
- *****************************************************************************
- * Compute the system key from various system information, see HashSystemInfo.
- *****************************************************************************/
-static int GetSystemKey( uint32_t *p_sys_key, vlc_bool_t b_ipod )
-{
-    static char const p_secret5[ 8 ] = "YuaFlafu";
-    static char const p_secret6[ 8 ] = "zPif98ga";
-    struct md5_s md5;
-    int64_t i_ipod_id;
-    uint32_t p_system_hash[ 4 ];
-
-    /* Compute the MD5 hash of our system info */
-    if( ( !b_ipod && HashSystemInfo( p_system_hash ) ) ||
-        (  b_ipod && GetiPodID( &i_ipod_id ) ) )
-    {
-        return -1;
-    }
-
-    /* Combine our system info hash with additional secret data. The resulting
-     * MD5 hash will be our system key. */
-    InitMD5( &md5 );
-    AddMD5( &md5, (const uint8_t*)p_secret5, 8 );
-
-    if( !b_ipod )
-    {
-        AddMD5( &md5, (const uint8_t *)p_system_hash, 6 );
-        AddMD5( &md5, (const uint8_t *)p_system_hash, 6 );
-        AddMD5( &md5, (const uint8_t *)p_system_hash, 6 );
-        AddMD5( &md5, (const uint8_t*)p_secret6, 8 );
-    }
-    else
-    {
-        i_ipod_id = U64_AT(&i_ipod_id);
-        AddMD5( &md5, (const uint8_t *)&i_ipod_id, sizeof(i_ipod_id) );
-        AddMD5( &md5, (const uint8_t *)&i_ipod_id, sizeof(i_ipod_id) );
-        AddMD5( &md5, (const uint8_t *)&i_ipod_id, sizeof(i_ipod_id) );
-    }
-
-    EndMD5( &md5 );
-
-    memcpy( p_sys_key, md5.p_digest, 16 );
-
-    return 0;
-}
-
-#ifdef WIN32
-#   define DRMS_DIRNAME "drms"
-#else
-#   define DRMS_DIRNAME ".drms"
-#endif
-
-/*****************************************************************************
- * WriteUserKey: write the user key to hard disk
- *****************************************************************************
- * Write the user key to the hard disk so that it can be reused later or used
- * on operating systems other than Win32.
- *****************************************************************************/
-static int WriteUserKey( void *_p_drms, uint32_t *p_user_key )
-{
-    struct drms_s *p_drms = (struct drms_s *)_p_drms;
-    FILE *file;
-    int i_ret = -1;
-    char psz_path[ PATH_MAX ];
-
-    snprintf( psz_path, PATH_MAX - 1,
-              "%s/" DRMS_DIRNAME, p_drms->psz_homedir );
-
-#if defined( HAVE_ERRNO_H )
-#   if defined( WIN32 )
-    if( !mkdir( psz_path ) || errno == EEXIST )
-#   else
-    if( !mkdir( psz_path, 0755 ) || errno == EEXIST )
-#   endif
-#else
-    if( !mkdir( psz_path ) )
-#endif
-    {
-        snprintf( psz_path, PATH_MAX - 1, "%s/" DRMS_DIRNAME "/%08X.%03d",
-                  p_drms->psz_homedir, p_drms->i_user, p_drms->i_key );
-
-        file = utf8_fopen( psz_path, "wb" );
-        if( file != NULL )
-        {
-            i_ret = fwrite( p_user_key, sizeof(uint32_t),
-                            4, file ) == 4 ? 0 : -1;
-            fclose( file );
-        }
-    }
-
-    return i_ret;
-}
-
-/*****************************************************************************
- * ReadUserKey: read the user key from hard disk
- *****************************************************************************
- * Retrieve the user key from the hard disk if available.
- *****************************************************************************/
-static int ReadUserKey( void *_p_drms, uint32_t *p_user_key )
-{
-    struct drms_s *p_drms = (struct drms_s *)_p_drms;
-    FILE *file;
-    int i_ret = -1;
-    char psz_path[ PATH_MAX ];
-
-    snprintf( psz_path, PATH_MAX - 1,
-              "%s/" DRMS_DIRNAME "/%08X.%03d", p_drms->psz_homedir,
-              p_drms->i_user, p_drms->i_key );
-
-    file = utf8_fopen( psz_path, "rb" );
-    if( file != NULL )
-    {
-        i_ret = fread( p_user_key, sizeof(uint32_t),
-                       4, file ) == 4 ? 0 : -1;
-        fclose( file );
-    }
-
-    return i_ret;
-}
-
-/*****************************************************************************
- * GetUserKey: get the user key
- *****************************************************************************
- * Retrieve the user key from the hard disk if available, otherwise generate
- * it from the system key. If the key could be successfully generated, write
- * it to the hard disk for future use.
- *****************************************************************************/
-static int GetUserKey( void *_p_drms, uint32_t *p_user_key )
-{
-    static char const p_secret7[] = "mUfnpognadfgf873";
-    struct drms_s *p_drms = (struct drms_s *)_p_drms;
-    struct aes_s aes;
-    struct shuffle_s shuffle;
-    uint32_t i, y;
-    uint32_t *p_sci_data = NULL;
-    uint32_t i_user, i_key;
-    uint32_t p_sys_key[ 4 ];
-    uint32_t i_sci_size = 0, i_blocks, i_remaining;
-    uint32_t *p_sci0, *p_sci1, *p_buffer;
-    uint32_t p_sci_key[ 4 ];
-    char *psz_ipod;
-    int i_ret = -5;
-
-    if( ReadUserKey( p_drms, p_user_key ) == 0 )
-    {
-        REVERSE( p_user_key, 4 );
-        return 0;
-    }
-
-    psz_ipod = getenv( "IPOD" );
-
-    if( GetSystemKey( p_sys_key, psz_ipod ? VLC_TRUE : VLC_FALSE ) )
-    {
-        return -3;
-    }
-
-    if( GetSCIData( psz_ipod, &p_sci_data, &i_sci_size ) )
-    {
-        return -4;
-    }
-
-    /* Phase 1: unscramble the SCI data using the system key and shuffle
-     *          it using DoShuffle(). */
-
-    /* Skip the first 4 bytes (some sort of header). Decrypt the rest. */
-    i_blocks = (i_sci_size - 4) / 16;
-    i_remaining = (i_sci_size - 4) - (i_blocks * 16);
-    p_buffer = p_sci_data + 1;
-
-    /* Decrypt and shuffle our data at the same time */
-    InitAES( &aes, p_sys_key );
-    REVERSE( p_sys_key, 4 );
-    REVERSE( p_sci_data, 1 );
-    InitShuffle( &shuffle, p_sys_key, p_sci_data[ 0 ] );
-
-    memcpy( p_sci_key, p_secret7, 16 );
-    REVERSE( p_sci_key, 4 );
-
-    while( i_blocks-- )
-    {
-        uint32_t p_tmp[ 4 ];
-
-        REVERSE( p_buffer, 4 );
-        DecryptAES( &aes, p_tmp, p_buffer );
-        BlockXOR( p_tmp, p_sci_key, p_tmp );
-
-        /* Use the previous scrambled data as the key for next block */
-        memcpy( p_sci_key, p_buffer, 16 );
-
-        /* Shuffle the decrypted data using a custom routine */
-        DoShuffle( &shuffle, p_tmp, 4 );
-
-        /* Copy this block back to p_buffer */
-        memcpy( p_buffer, p_tmp, 16 );
-
-        p_buffer += 4;
-    }
-
-    if( i_remaining >= 4 )
-    {
-        REVERSE( p_buffer, i_remaining / 4 );
-        DoShuffle( &shuffle, p_buffer, i_remaining / 4 );
-    }
-
-    /* Phase 2: look for the user key in the generated data. I must admit I
-     *          do not understand what is going on here, because it almost
-     *          looks like we are browsing data that makes sense, even though
-     *          the DoShuffle() part made it completely meaningless. */
-
-    y = 0;
-    REVERSE( p_sci_data + 5, 1 );
-    i = U32_AT( p_sci_data + 5 );
-    i_sci_size -= 22 * sizeof(uint32_t);
-    p_sci1 = p_sci_data + 22;
-    p_sci0 = NULL;
-
-    while( i_sci_size >= 20 && i > 0 )
-    {
-        if( p_sci0 == NULL )
-        {
-            i_sci_size -= 18 * sizeof(uint32_t);
-            if( i_sci_size < 20 )
-            {
-                break;
-            }
-
-            p_sci0 = p_sci1;
-            REVERSE( p_sci1 + 17, 1 );
-            y = U32_AT( p_sci1 + 17 );
-            p_sci1 += 18;
-        }
-
-        if( !y )
-        {
-            i--;
-            p_sci0 = NULL;
-            continue;
-        }
-
-        i_user = U32_AT( p_sci0 );
-        i_key = U32_AT( p_sci1 );
-        REVERSE( &i_user, 1 );
-        REVERSE( &i_key, 1 );
-        if( i_user == p_drms->i_user && ( ( i_key == p_drms->i_key ) ||
-            ( !p_drms->i_key && ( p_sci1 == (p_sci0 + 18) ) ) ) )
-        {
-            memcpy( p_user_key, p_sci1 + 1, 16 );
-            REVERSE( p_sci1 + 1, 4 );
-            WriteUserKey( p_drms, p_sci1 + 1 );
-            i_ret = 0;
-            break;
-        }
-
-        y--;
-        p_sci1 += 5;
-        i_sci_size -= 5 * sizeof(uint32_t);
-    }
-
-    free( p_sci_data );
-
-    return i_ret;
-}
-
-/*****************************************************************************
- * GetSCIData: get SCI data from "SC Info.sidb"
- *****************************************************************************
- * Read SCI data from "\Apple Computer\iTunes\SC Info\SC Info.sidb"
- *****************************************************************************/
-static int GetSCIData( char *psz_ipod, uint32_t **pp_sci,
-                       uint32_t *pi_sci_size )
-{
-    FILE *file;
-    char *psz_path = NULL;
-    char p_tmp[ 4 * PATH_MAX ];
-    int i_ret = -1;
-
-    if( psz_ipod == NULL )
-    {
-#ifdef WIN32
-        char *p_filename = "\\Apple Computer\\iTunes\\SC Info\\SC Info.sidb";
-        typedef HRESULT (WINAPI *SHGETFOLDERPATH)( HWND, int, HANDLE, DWORD,
-                                                   LPSTR );
-        HINSTANCE shfolder_dll = NULL;
-        SHGETFOLDERPATH dSHGetFolderPath = NULL;
-
-        if( ( shfolder_dll = LoadLibrary( _T("SHFolder.dll") ) ) != NULL )
-        {
-            dSHGetFolderPath =
-                (SHGETFOLDERPATH)GetProcAddress( shfolder_dll,
-                                                 _T("SHGetFolderPathA") );
-        }
-
-        if( dSHGetFolderPath != NULL &&
-            SUCCEEDED( dSHGetFolderPath( NULL, CSIDL_COMMON_APPDATA,
-                                         NULL, 0, p_tmp ) ) )
-        {
-            strncat( p_tmp, p_filename, min( strlen( p_filename ),
-                     (sizeof(p_tmp) - 1) - strlen( p_tmp ) ) );
-
-            psz_path = FromLocale( p_tmp );
-            strncpy( p_tmp, psz_path, sizeof( p_tmp ) - 1 );
-            p_tmp[sizeof( p_tmp ) - 1] = '\0';
-            LocaleFree( psz_path );
-            psz_path = p_tmp;
-        }
-
-        if( shfolder_dll != NULL )
-        {
-            FreeLibrary( shfolder_dll );
-        }
-#endif
-    }
-    else
-    {
-#define ISCINFO "iSCInfo"
-        if( strstr( psz_ipod, ISCINFO ) == NULL )
-        {
-            snprintf( p_tmp, sizeof(p_tmp) - 1,
-                      "%s/iPod_Control/iTunes/" ISCINFO "2", psz_ipod );
-            psz_path = p_tmp;
-        }
-        else
-        {
-            psz_path = psz_ipod;
-        }
-    }
-
-    if( psz_path == NULL )
-    {
-        return -1;
-    }
-
-    file = utf8_fopen( psz_path, "rb" );
-    if( file != NULL )
-    {
-        struct stat st;
-
-        if( !fstat( fileno( file ), &st ) && st.st_size >= 4 )
-        {
-            *pp_sci = malloc( st.st_size );
-            if( *pp_sci != NULL )
-            {
-                if( fread( *pp_sci, 1, st.st_size,
-                           file ) == (size_t)st.st_size )
-                {
-                    *pi_sci_size = st.st_size;
-                    i_ret = 0;
-                }
-                else
-                {
-                    free( (void *)*pp_sci );
-                    *pp_sci = NULL;
-                }
-            }
-        }
-
-        fclose( file );
-    }
-
-    return i_ret;
-}
-
-/*****************************************************************************
- * HashSystemInfo: hash system information
- *****************************************************************************
- * This function computes the MD5 hash of the C: hard drive serial number,
- * BIOS version, CPU type and Windows version.
- *****************************************************************************/
-static int HashSystemInfo( uint32_t *p_system_hash )
-{
-    struct md5_s md5;
-    int i_ret = 0;
-
-#ifdef WIN32
-    HKEY i_key;
-    unsigned int i;
-    DWORD i_size;
-    DWORD i_serial;
-    LPBYTE p_reg_buf;
-
-    static LPCTSTR p_reg_keys[ 3 ][ 2 ] =
-    {
-        {
-            _T("HARDWARE\\DESCRIPTION\\System"),
-            _T("SystemBiosVersion")
-        },
-
-        {
-            _T("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0"),
-            _T("ProcessorNameString")
-        },
-
-        {
-            _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"),
-            _T("ProductId")
-        }
-    };
-
-    InitMD5( &md5 );
-
-    AddMD5( &md5, "cache-control", 13 );
-    AddMD5( &md5, "Ethernet", 8 );
-
-    GetVolumeInformation( _T("C:\\"), NULL, 0, &i_serial,
-                          NULL, NULL, NULL, 0 );
-    AddMD5( &md5, (const uint8_t *)&i_serial, 4 );
-
-    for( i = 0; i < sizeof(p_reg_keys) / sizeof(p_reg_keys[ 0 ]); i++ )
-    {
-        if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, p_reg_keys[ i ][ 0 ],
-                          0, KEY_READ, &i_key ) != ERROR_SUCCESS )
-        {
-            continue;
-        }
-
-        if( RegQueryValueEx( i_key, p_reg_keys[ i ][ 1 ],
-                             NULL, NULL, NULL, &i_size ) != ERROR_SUCCESS )
-        {
-            RegCloseKey( i_key );
-            continue;
-        }
-
-        p_reg_buf = malloc( i_size );
-
-        if( p_reg_buf != NULL )
-        {
-            if( RegQueryValueEx( i_key, p_reg_keys[ i ][ 1 ],
-                                 NULL, NULL, p_reg_buf,
-                                 &i_size ) == ERROR_SUCCESS )
-            {
-                AddMD5( &md5, (const uint8_t *)p_reg_buf, i_size );
-            }
-
-            free( p_reg_buf );
-        }
-
-        RegCloseKey( i_key );
-    }
-
-#else
-    InitMD5( &md5 );
-    i_ret = -1;
-#endif
-
-    EndMD5( &md5 );
-    memcpy( p_system_hash, md5.p_digest, 16 );
-
-    return i_ret;
-}
-
-/*****************************************************************************
- * GetiPodID: Get iPod ID
- *****************************************************************************
- * This function gets the iPod ID.
- *****************************************************************************/
-static int GetiPodID( int64_t *p_ipod_id )
-{
-    int i_ret = -1;
-
-#define PROD_NAME   "iPod"
-#define VENDOR_NAME "Apple Computer, Inc."
-
-    char *psz_ipod_id = getenv( "IPODID" );
-    if( psz_ipod_id != NULL )
-    {
-        *p_ipod_id = strtoll( psz_ipod_id, NULL, 16 );
-        return 0;
-    }
-
-#ifdef __APPLE__
-    CFTypeRef value;
-    mach_port_t port;
-    io_object_t device;
-    io_iterator_t iterator;
-    CFMutableDictionaryRef match_dic;
-    CFMutableDictionaryRef smatch_dic;
-
-    if( IOMasterPort( MACH_PORT_NULL, &port ) == KERN_SUCCESS )
-    {
-        smatch_dic = IOServiceMatching( "IOFireWireUnit" );
-        match_dic = CFDictionaryCreateMutable( kCFAllocatorDefault, 0,
-                                           &kCFTypeDictionaryKeyCallBacks,
-                                           &kCFTypeDictionaryValueCallBacks );
-
-        if( smatch_dic != NULL && match_dic != NULL )
-        {
-            CFDictionarySetValue( smatch_dic,
-                                  CFSTR("FireWire Vendor Name"),
-                                  CFSTR(VENDOR_NAME) );
-            CFDictionarySetValue( smatch_dic,
-                                  CFSTR("FireWire Product Name"),
-                                  CFSTR(PROD_NAME) );
-
-            CFDictionarySetValue( match_dic,
-                                  CFSTR(kIOPropertyMatchKey),
-                                  smatch_dic );
-
-            if( IOServiceGetMatchingServices( port, match_dic,
-                                              &iterator ) == KERN_SUCCESS )
-            {
-                while( ( device = IOIteratorNext( iterator ) ) != NULL )
-                {
-                    value = IORegistryEntryCreateCFProperty( device,
-                        CFSTR("GUID"), kCFAllocatorDefault, kNilOptions );
-
-                    if( value != NULL )
-                    {
-                        if( CFGetTypeID( value ) == CFNumberGetTypeID() )
-                        {
-                            int64_t i_ipod_id;
-                            CFNumberGetValue( (CFNumberRef)value,
-                                              kCFNumberLongLongType,
-                                              &i_ipod_id );
-                            *p_ipod_id = i_ipod_id;
-                            i_ret = 0;
-                        }
-
-                        CFRelease( value );
-                    }
-
-                    IOObjectRelease( device );
-
-                    if( !i_ret ) break;
-                }
-
-                IOObjectRelease( iterator );
-            }
-        }
-
-        mach_port_deallocate( mach_task_self(), port );
-    }
-
-#elif HAVE_SYSFS_LIBSYSFS_H
-    struct sysfs_bus *bus = NULL;
-    struct dlist *devlist = NULL;
-    struct dlist *attributes = NULL;
-    struct sysfs_device *curdev = NULL;
-    struct sysfs_attribute *curattr = NULL;
-
-    bus = sysfs_open_bus( "ieee1394" );
-    if( bus != NULL )
-    {
-        devlist = sysfs_get_bus_devices( bus );
-        if( devlist != NULL )
-        {
-            dlist_for_each_data( devlist, curdev, struct sysfs_device )
-            {
-                attributes = sysfs_get_device_attributes( curdev );
-                if( attributes != NULL )
-                {
-                    dlist_for_each_data( attributes, curattr,
-                                         struct sysfs_attribute )
-                    {
-                        if( ( strcmp( curattr->name, "model_name" ) == 0 ) &&
-                            ( strncmp( curattr->value, PROD_NAME,
-                                       sizeof(PROD_NAME) ) == 0 ) )
-                        {
-                            *p_ipod_id = strtoll( curdev->name, NULL, 16 );
-                            i_ret = 0;
-                            break;
-                        }
-                    }
-               }
-
-                if( !i_ret ) break;
-            }
-        }
-
-        sysfs_close_bus( bus );
-    }
-#endif
-
-    return i_ret;
-}
-
-#else /* !defined( UNDER_CE ) */
-
-void *drms_alloc( char *psz_homedir ){ return 0; }
-void drms_free( void *a ){}
-void drms_decrypt( void *a, uint32_t *b, uint32_t c  ){}
-int drms_init( void *a, uint32_t b, uint8_t *c, uint32_t d ){ return -1; }
-
-#endif /* defined( UNDER_CE ) */
+/*****************************************************************************
+ * drms.c: DRMS
+ *****************************************************************************
+ * Copyright (C) 2004 the VideoLAN team
+ * $Id: drms.c 16993 2006-10-08 14:17:51Z jpsaman $
+ *
+ * Authors: Jon Lech Johansen <jon-vl@nanocrew.net>
+ *          Sam Hocevar <sam@zoy.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <stdlib.h>                                      /* malloc(), free() */
+
+/* BEGIN SONGBIRD EDIT */
+
+#define DISABLE_DRMS_PLAYBACK
+
+/* END SONGBIRD EDIT */
+
+#ifdef WIN32
+#   include <io.h>
+#else
+#   include <stdio.h>
+#endif
+
+#ifdef __VLC__
+#   include <vlc/vlc.h>
+#   include <vlc_md5.h>
+#   include "libmp4.h"
+#   include "charset.h"
+#else
+#   include "drmsvl.h"
+#endif
+
+#ifdef HAVE_ERRNO_H
+#   include <errno.h>
+#endif
+
+#ifdef WIN32
+#   if !defined( UNDER_CE )
+#       include <direct.h>
+#   endif
+#   include <tchar.h>
+#   include <shlobj.h>
+#   include <windows.h>
+#endif
+
+#ifdef HAVE_SYS_STAT_H
+#   include <sys/stat.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#   include <sys/types.h>
+#endif
+
+/* In Solaris (and perhaps others) PATH_MAX is in limits.h. */
+#ifdef HAVE_LIMITS_H
+#   include <limits.h>
+#endif
+
+#ifdef __APPLE__
+#   include <mach/mach.h>
+#   include <IOKit/IOKitLib.h>
+#   include <CoreFoundation/CFNumber.h>
+#endif
+
+#ifdef HAVE_SYSFS_LIBSYSFS_H
+#   include <sysfs/libsysfs.h>
+#endif
+
+#include "drms.h"
+#include "drmstables.h"
+
+#if !defined( UNDER_CE )
+/*****************************************************************************
+ * aes_s: AES keys structure
+ *****************************************************************************
+ * This structure stores a set of keys usable for encryption and decryption
+ * with the AES/Rijndael algorithm.
+ *****************************************************************************/
+struct aes_s
+{
+    uint32_t pp_enc_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+    uint32_t pp_dec_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+};
+
+#ifdef __VLC__
+# define Digest DigestMD5
+#else
+/*****************************************************************************
+ * md5_s: MD5 message structure
+ *****************************************************************************
+ * This structure stores the static information needed to compute an MD5
+ * hash. It has an extra data buffer to allow non-aligned writes.
+ *****************************************************************************/
+struct md5_s
+{
+    uint64_t i_bits;      /* Total written bits */
+    uint32_t p_digest[4]; /* The MD5 digest */
+    uint32_t p_data[16];  /* Buffer to cache non-aligned writes */
+};
+#endif
+
+/*****************************************************************************
+ * shuffle_s: shuffle structure
+ *****************************************************************************
+ * This structure stores the static information needed to shuffle data using
+ * a custom algorithm.
+ *****************************************************************************/
+struct shuffle_s
+{
+    uint32_t i_version;
+    uint32_t p_commands[ 20 ];
+    uint32_t p_bordel[ 16 ];
+};
+
+#define SWAP( a, b ) { (a) ^= (b); (b) ^= (a); (a) ^= (b); }
+
+/*****************************************************************************
+ * drms_s: DRMS structure
+ *****************************************************************************
+ * This structure stores the static information needed to decrypt DRMS data.
+ *****************************************************************************/
+struct drms_s
+{
+    uint32_t i_user;
+    uint32_t i_key;
+    uint8_t  p_iviv[ 16 ];
+    uint8_t *p_name;
+
+    uint32_t p_key[ 4 ];
+    struct aes_s aes;
+
+    char     psz_homedir[ PATH_MAX ];
+};
+
+/*****************************************************************************
+ * Local prototypes
+ *****************************************************************************/
+static void InitAES       ( struct aes_s *, uint32_t * );
+static void DecryptAES    ( struct aes_s *, uint32_t *, const uint32_t * );
+
+#ifndef __VLC__
+static void InitMD5       ( struct md5_s * );
+static void AddMD5        ( struct md5_s *, const uint8_t *, uint32_t );
+static void EndMD5        ( struct md5_s * );
+static void Digest        ( struct md5_s *, uint32_t * );
+#endif
+
+static void InitShuffle   ( struct shuffle_s *, uint32_t *, uint32_t );
+static void DoShuffle     ( struct shuffle_s *, uint32_t *, uint32_t );
+
+static uint32_t FirstPass ( uint32_t * );
+static void SecondPass    ( uint32_t *, uint32_t );
+static void ThirdPass     ( uint32_t * );
+static void FourthPass    ( uint32_t * );
+static void TinyShuffle1  ( uint32_t * );
+static void TinyShuffle2  ( uint32_t * );
+static void TinyShuffle3  ( uint32_t * );
+static void TinyShuffle4  ( uint32_t * );
+static void TinyShuffle5  ( uint32_t * );
+static void TinyShuffle6  ( uint32_t * );
+static void TinyShuffle7  ( uint32_t * );
+static void TinyShuffle8  ( uint32_t * );
+static void DoExtShuffle  ( uint32_t * );
+
+static int GetSystemKey   ( uint32_t *, vlc_bool_t );
+static int WriteUserKey   ( void *, uint32_t * );
+static int ReadUserKey    ( void *, uint32_t * );
+static int GetUserKey     ( void *, uint32_t * );
+
+static int GetSCIData     ( char *, uint32_t **, uint32_t * );
+static int HashSystemInfo ( uint32_t * );
+static int GetiPodID      ( int64_t * );
+
+#ifdef WORDS_BIGENDIAN
+/*****************************************************************************
+ * Reverse: reverse byte order
+ *****************************************************************************/
+static inline void Reverse( uint32_t *p_buffer, int n )
+{
+    int i;
+
+    for( i = 0; i < n; i++ )
+    {
+        p_buffer[ i ] = GetDWLE(&p_buffer[ i ]);
+    }
+}
+#    define REVERSE( p, n ) Reverse( p, n )
+#else
+#    define REVERSE( p, n )
+#endif
+
+/*****************************************************************************
+ * BlockXOR: XOR two 128 bit blocks
+ *****************************************************************************/
+static inline void BlockXOR( uint32_t *p_dest, uint32_t *p_s1, uint32_t *p_s2 )
+{
+    int i;
+
+    for( i = 0; i < 4; i++ )
+    {
+        p_dest[ i ] = p_s1[ i ] ^ p_s2[ i ];
+    }
+}
+
+/*****************************************************************************
+ * drms_alloc: allocate a DRMS structure
+ *****************************************************************************/
+void *drms_alloc( char *psz_homedir )
+{
+    struct drms_s *p_drms;
+
+    p_drms = malloc( sizeof(struct drms_s) );
+
+    if( p_drms == NULL )
+    {
+        return NULL;
+    }
+
+    memset( p_drms, 0, sizeof(struct drms_s) );
+
+    strncpy( p_drms->psz_homedir, psz_homedir, PATH_MAX );
+    p_drms->psz_homedir[ PATH_MAX - 1 ] = '\0';
+
+    return (void *)p_drms;
+}
+
+/*****************************************************************************
+ * drms_free: free a previously allocated DRMS structure
+ *****************************************************************************/
+void drms_free( void *_p_drms )
+{
+    struct drms_s *p_drms = (struct drms_s *)_p_drms;
+
+    if( p_drms->p_name != NULL )
+    {
+        free( (void *)p_drms->p_name );
+    }
+
+    free( p_drms );
+}
+
+/*****************************************************************************
+ * drms_decrypt: unscramble a chunk of data
+ *****************************************************************************/
+void drms_decrypt( void *_p_drms, uint32_t *p_buffer, uint32_t i_bytes )
+{
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return;
+#else  
+  
+    struct drms_s *p_drms = (struct drms_s *)_p_drms;
+    uint32_t p_key[ 4 ];
+    unsigned int i_blocks;
+
+    /* AES is a block cypher, round down the byte count */
+    i_blocks = i_bytes / 16;
+    i_bytes = i_blocks * 16;
+
+    /* Initialise the key */
+    memcpy( p_key, p_drms->p_key, 16 );
+
+    /* Unscramble */
+    while( i_blocks-- )
+    {
+        uint32_t p_tmp[ 4 ];
+
+        REVERSE( p_buffer, 4 );
+        DecryptAES( &p_drms->aes, p_tmp, p_buffer );
+        BlockXOR( p_tmp, p_key, p_tmp );
+
+        /* Use the previous scrambled data as the key for next block */
+        memcpy( p_key, p_buffer, 16 );
+
+        /* Copy unscrambled data back to the buffer */
+        memcpy( p_buffer, p_tmp, 16 );
+        REVERSE( p_buffer, 4 );
+
+        p_buffer += 4;
+    }
+    
+#endif
+/* END SONGBIRD EDIT */    
+}
+
+/*****************************************************************************
+ * drms_init: initialise a DRMS structure
+ *****************************************************************************
+ * Return values:
+ *  0: success
+ * -1: unimplemented
+ * -2: invalid argument
+ * -3: could not get system key
+ * -4: could not get SCI data
+ * -5: no user key found in SCI data
+ * -6: invalid user key
+ *****************************************************************************/
+int drms_init( void *_p_drms, uint32_t i_type,
+               uint8_t *p_info, uint32_t i_len )
+{
+  
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+
+    struct drms_s *p_drms = (struct drms_s *)_p_drms;
+    int i_ret = 0;
+
+    switch( i_type )
+    {
+        case FOURCC_user:
+            if( i_len < sizeof(p_drms->i_user) )
+            {
+                i_ret = -2;
+                break;
+            }
+
+            p_drms->i_user = U32_AT( p_info );
+            break;
+
+        case FOURCC_key:
+            if( i_len < sizeof(p_drms->i_key) )
+            {
+                i_ret = -2;
+                break;
+            }
+
+            p_drms->i_key = U32_AT( p_info );
+            break;
+
+        case FOURCC_iviv:
+            if( i_len < sizeof(p_drms->p_key) )
+            {
+                i_ret = -2;
+                break;
+            }
+
+            memcpy( p_drms->p_iviv, p_info, 16 );
+            break;
+
+        case FOURCC_name:
+            p_drms->p_name = (uint8_t*) strdup( (char *)p_info );
+
+            if( p_drms->p_name == NULL )
+            {
+                i_ret = -2;
+            }
+            break;
+
+        case FOURCC_priv:
+        {
+            uint32_t p_priv[ 64 ];
+            struct md5_s md5;
+
+            if( i_len < 64 )
+            {
+                i_ret = -2;
+                break;
+            }
+
+            InitMD5( &md5 );
+            AddMD5( &md5, p_drms->p_name, strlen( (char *)p_drms->p_name ) );
+            AddMD5( &md5, p_drms->p_iviv, 16 );
+            EndMD5( &md5 );
+
+            if( p_drms->i_user == 0 && p_drms->i_key == 0 )
+            {
+                static char const p_secret[] = "tr1-th3n.y00_by3";
+                memcpy( p_drms->p_key, p_secret, 16 );
+                REVERSE( p_drms->p_key, 4 );
+            }
+            else
+            {
+                i_ret = GetUserKey( p_drms, p_drms->p_key );
+                if( i_ret )
+                {
+                    break;
+                }
+            }
+
+            InitAES( &p_drms->aes, p_drms->p_key );
+
+            memcpy( p_priv, p_info, 64 );
+            memcpy( p_drms->p_key, md5.p_digest, 16 );
+            drms_decrypt( p_drms, p_priv, 64 );
+            REVERSE( p_priv, 64 );
+
+            if( p_priv[ 0 ] != 0x6e757469 ) /* itun */
+            {
+                i_ret = -6;
+                break;
+            }
+
+            InitAES( &p_drms->aes, p_priv + 6 );
+            memcpy( p_drms->p_key, p_priv + 12, 16 );
+
+            free( (void *)p_drms->p_name );
+            p_drms->p_name = NULL;
+        }
+        break;
+    }
+
+    return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */    
+}
+
+/* The following functions are local */
+
+/*****************************************************************************
+ * InitAES: initialise AES/Rijndael encryption/decryption tables
+ *****************************************************************************
+ * The Advanced Encryption Standard (AES) is described in RFC 3268
+ *****************************************************************************/
+static void InitAES( struct aes_s *p_aes, uint32_t *p_key )
+{
+    unsigned int i, t;
+    uint32_t i_key, i_seed;
+
+    memset( p_aes->pp_enc_keys[1], 0, 16 );
+    memcpy( p_aes->pp_enc_keys[0], p_key, 16 );
+
+    /* Generate the key tables */
+    i_seed = p_aes->pp_enc_keys[ 0 ][ 3 ];
+
+    for( i_key = 0; i_key < AES_KEY_COUNT; i_key++ )
+    {
+        uint32_t j;
+
+        i_seed = AES_ROR( i_seed, 8 );
+
+        j = p_aes_table[ i_key ];
+
+        j ^= p_aes_encrypt[ (i_seed >> 24) & 0xff ]
+              ^ AES_ROR( p_aes_encrypt[ (i_seed >> 16) & 0xff ], 8 )
+              ^ AES_ROR( p_aes_encrypt[ (i_seed >> 8) & 0xff ], 16 )
+              ^ AES_ROR( p_aes_encrypt[ i_seed & 0xff ], 24 );
+
+        j ^= p_aes->pp_enc_keys[ i_key ][ 0 ];
+        p_aes->pp_enc_keys[ i_key + 1 ][ 0 ] = j;
+        j ^= p_aes->pp_enc_keys[ i_key ][ 1 ];
+        p_aes->pp_enc_keys[ i_key + 1 ][ 1 ] = j;
+        j ^= p_aes->pp_enc_keys[ i_key ][ 2 ];
+        p_aes->pp_enc_keys[ i_key + 1 ][ 2 ] = j;
+        j ^= p_aes->pp_enc_keys[ i_key ][ 3 ];
+        p_aes->pp_enc_keys[ i_key + 1 ][ 3 ] = j;
+
+        i_seed = j;
+    }
+
+    memcpy( p_aes->pp_dec_keys[ 0 ],
+            p_aes->pp_enc_keys[ 0 ], 16 );
+
+    for( i = 1; i < AES_KEY_COUNT; i++ )
+    {
+        for( t = 0; t < 4; t++ )
+        {
+            uint32_t j, k, l, m, n;
+
+            j = p_aes->pp_enc_keys[ i ][ t ];
+
+            k = (((j >> 7) & 0x01010101) * 27) ^ ((j & 0xff7f7f7f) << 1);
+            l = (((k >> 7) & 0x01010101) * 27) ^ ((k & 0xff7f7f7f) << 1);
+            m = (((l >> 7) & 0x01010101) * 27) ^ ((l & 0xff7f7f7f) << 1);
+
+            j ^= m;
+
+            n = AES_ROR( l ^ j, 16 ) ^ AES_ROR( k ^ j, 8 ) ^ AES_ROR( j, 24 );
+
+            p_aes->pp_dec_keys[ i ][ t ] = k ^ l ^ m ^ n;
+        }
+    }
+}
+
+/*****************************************************************************
+ * DecryptAES: decrypt an AES/Rijndael 128 bit block
+ *****************************************************************************/
+static void DecryptAES( struct aes_s *p_aes,
+                        uint32_t *p_dest, const uint32_t *p_src )
+{
+    uint32_t p_wtxt[ 4 ]; /* Working cyphertext */
+    uint32_t p_tmp[ 4 ];
+    unsigned int i_round, t;
+
+    for( t = 0; t < 4; t++ )
+    {
+        /* FIXME: are there any endianness issues here? */
+        p_wtxt[ t ] = p_src[ t ] ^ p_aes->pp_enc_keys[ AES_KEY_COUNT ][ t ];
+    }
+
+    /* Rounds 0 - 8 */
+    for( i_round = 0; i_round < (AES_KEY_COUNT - 1); i_round++ )
+    {
+        for( t = 0; t < 4; t++ )
+        {
+            p_tmp[ t ] = AES_XOR_ROR( p_aes_itable, p_wtxt );
+        }
+
+        for( t = 0; t < 4; t++ )
+        {
+            p_wtxt[ t ] = p_tmp[ t ]
+                    ^ p_aes->pp_dec_keys[ (AES_KEY_COUNT - 1) - i_round ][ t ];
+        }
+    }
+
+    /* Final round (9) */
+    for( t = 0; t < 4; t++ )
+    {
+        p_dest[ t ] = AES_XOR_ROR( p_aes_decrypt, p_wtxt );
+        p_dest[ t ] ^= p_aes->pp_dec_keys[ 0 ][ t ];
+    }
+}
+
+#ifndef __VLC__
+/*****************************************************************************
+ * InitMD5: initialise an MD5 message
+ *****************************************************************************
+ * The MD5 message-digest algorithm is described in RFC 1321
+ *****************************************************************************/
+static void InitMD5( struct md5_s *p_md5 )
+{
+    p_md5->p_digest[ 0 ] = 0x67452301;
+    p_md5->p_digest[ 1 ] = 0xefcdab89;
+    p_md5->p_digest[ 2 ] = 0x98badcfe;
+    p_md5->p_digest[ 3 ] = 0x10325476;
+
+    memset( p_md5->p_data, 0, 64 );
+    p_md5->i_bits = 0;
+}
+
+/*****************************************************************************
+ * AddMD5: add i_len bytes to an MD5 message
+ *****************************************************************************/
+static void AddMD5( struct md5_s *p_md5, const uint8_t *p_src, uint32_t i_len )
+{
+    unsigned int i_current; /* Current bytes in the spare buffer */
+    unsigned int i_offset = 0;
+
+    i_current = (p_md5->i_bits / 8) & 63;
+
+    p_md5->i_bits += 8 * i_len;
+
+    /* If we can complete our spare buffer to 64 bytes, do it and add the
+     * resulting buffer to the MD5 message */
+    if( i_len >= (64 - i_current) )
+    {
+        memcpy( ((uint8_t *)p_md5->p_data) + i_current, p_src,
+                (64 - i_current) );
+        Digest( p_md5, p_md5->p_data );
+
+        i_offset += (64 - i_current);
+        i_len -= (64 - i_current);
+        i_current = 0;
+    }
+
+    /* Add as many entire 64 bytes blocks as we can to the MD5 message */
+    while( i_len >= 64 )
+    {
+        uint32_t p_tmp[ 16 ];
+        memcpy( p_tmp, p_src + i_offset, 64 );
+        Digest( p_md5, p_tmp );
+        i_offset += 64;
+        i_len -= 64;
+    }
+
+    /* Copy our remaining data to the message's spare buffer */
+    memcpy( ((uint8_t *)p_md5->p_data) + i_current, p_src + i_offset, i_len );
+}
+
+/*****************************************************************************
+ * EndMD5: finish an MD5 message
+ *****************************************************************************
+ * This function adds adequate padding to the end of the message, and appends
+ * the bit count so that we end at a block boundary.
+ *****************************************************************************/
+static void EndMD5( struct md5_s *p_md5 )
+{
+    unsigned int i_current;
+
+    i_current = (p_md5->i_bits / 8) & 63;
+
+    /* Append 0x80 to our buffer. No boundary check because the temporary
+     * buffer cannot be full, otherwise AddMD5 would have emptied it. */
+    ((uint8_t *)p_md5->p_data)[ i_current++ ] = 0x80;
+
+    /* If less than 8 bytes are available at the end of the block, complete
+     * this 64 bytes block with zeros and add it to the message. We'll add
+     * our length at the end of the next block. */
+    if( i_current > 56 )
+    {
+        memset( ((uint8_t *)p_md5->p_data) + i_current, 0, (64 - i_current) );
+        Digest( p_md5, p_md5->p_data );
+        i_current = 0;
+    }
+
+    /* Fill the unused space in our last block with zeroes and put the
+     * message length at the end. */
+    memset( ((uint8_t *)p_md5->p_data) + i_current, 0, (56 - i_current) );
+    p_md5->p_data[ 14 ] = p_md5->i_bits & 0xffffffff;
+    p_md5->p_data[ 15 ] = (p_md5->i_bits >> 32);
+    REVERSE( &p_md5->p_data[ 14 ], 2 );
+
+    Digest( p_md5, p_md5->p_data );
+}
+
+#define F1( x, y, z ) ((z) ^ ((x) & ((y) ^ (z))))
+#define F2( x, y, z ) F1((z), (x), (y))
+#define F3( x, y, z ) ((x) ^ (y) ^ (z))
+#define F4( x, y, z ) ((y) ^ ((x) | ~(z)))
+
+#define MD5_DO( f, w, x, y, z, data, s ) \
+    ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
+
+/*****************************************************************************
+ * Digest: update the MD5 digest with 64 bytes of data
+ *****************************************************************************/
+static void Digest( struct md5_s *p_md5, uint32_t *p_input )
+{
+    uint32_t a, b, c, d;
+
+    REVERSE( p_input, 16 );
+
+    a = p_md5->p_digest[ 0 ];
+    b = p_md5->p_digest[ 1 ];
+    c = p_md5->p_digest[ 2 ];
+    d = p_md5->p_digest[ 3 ];
+
+    MD5_DO( F1, a, b, c, d, p_input[  0 ] + 0xd76aa478,  7 );
+    MD5_DO( F1, d, a, b, c, p_input[  1 ] + 0xe8c7b756, 12 );
+    MD5_DO( F1, c, d, a, b, p_input[  2 ] + 0x242070db, 17 );
+    MD5_DO( F1, b, c, d, a, p_input[  3 ] + 0xc1bdceee, 22 );
+    MD5_DO( F1, a, b, c, d, p_input[  4 ] + 0xf57c0faf,  7 );
+    MD5_DO( F1, d, a, b, c, p_input[  5 ] + 0x4787c62a, 12 );
+    MD5_DO( F1, c, d, a, b, p_input[  6 ] + 0xa8304613, 17 );
+    MD5_DO( F1, b, c, d, a, p_input[  7 ] + 0xfd469501, 22 );
+    MD5_DO( F1, a, b, c, d, p_input[  8 ] + 0x698098d8,  7 );
+    MD5_DO( F1, d, a, b, c, p_input[  9 ] + 0x8b44f7af, 12 );
+    MD5_DO( F1, c, d, a, b, p_input[ 10 ] + 0xffff5bb1, 17 );
+    MD5_DO( F1, b, c, d, a, p_input[ 11 ] + 0x895cd7be, 22 );
+    MD5_DO( F1, a, b, c, d, p_input[ 12 ] + 0x6b901122,  7 );
+    MD5_DO( F1, d, a, b, c, p_input[ 13 ] + 0xfd987193, 12 );
+    MD5_DO( F1, c, d, a, b, p_input[ 14 ] + 0xa679438e, 17 );
+    MD5_DO( F1, b, c, d, a, p_input[ 15 ] + 0x49b40821, 22 );
+
+    MD5_DO( F2, a, b, c, d, p_input[  1 ] + 0xf61e2562,  5 );
+    MD5_DO( F2, d, a, b, c, p_input[  6 ] + 0xc040b340,  9 );
+    MD5_DO( F2, c, d, a, b, p_input[ 11 ] + 0x265e5a51, 14 );
+    MD5_DO( F2, b, c, d, a, p_input[  0 ] + 0xe9b6c7aa, 20 );
+    MD5_DO( F2, a, b, c, d, p_input[  5 ] + 0xd62f105d,  5 );
+    MD5_DO( F2, d, a, b, c, p_input[ 10 ] + 0x02441453,  9 );
+    MD5_DO( F2, c, d, a, b, p_input[ 15 ] + 0xd8a1e681, 14 );
+    MD5_DO( F2, b, c, d, a, p_input[  4 ] + 0xe7d3fbc8, 20 );
+    MD5_DO( F2, a, b, c, d, p_input[  9 ] + 0x21e1cde6,  5 );
+    MD5_DO( F2, d, a, b, c, p_input[ 14 ] + 0xc33707d6,  9 );
+    MD5_DO( F2, c, d, a, b, p_input[  3 ] + 0xf4d50d87, 14 );
+    MD5_DO( F2, b, c, d, a, p_input[  8 ] + 0x455a14ed, 20 );
+    MD5_DO( F2, a, b, c, d, p_input[ 13 ] + 0xa9e3e905,  5 );
+    MD5_DO( F2, d, a, b, c, p_input[  2 ] + 0xfcefa3f8,  9 );
+    MD5_DO( F2, c, d, a, b, p_input[  7 ] + 0x676f02d9, 14 );
+    MD5_DO( F2, b, c, d, a, p_input[ 12 ] + 0x8d2a4c8a, 20 );
+
+    MD5_DO( F3, a, b, c, d, p_input[  5 ] + 0xfffa3942,  4 );
+    MD5_DO( F3, d, a, b, c, p_input[  8 ] + 0x8771f681, 11 );
+    MD5_DO( F3, c, d, a, b, p_input[ 11 ] + 0x6d9d6122, 16 );
+    MD5_DO( F3, b, c, d, a, p_input[ 14 ] + 0xfde5380c, 23 );
+    MD5_DO( F3, a, b, c, d, p_input[  1 ] + 0xa4beea44,  4 );
+    MD5_DO( F3, d, a, b, c, p_input[  4 ] + 0x4bdecfa9, 11 );
+    MD5_DO( F3, c, d, a, b, p_input[  7 ] + 0xf6bb4b60, 16 );
+    MD5_DO( F3, b, c, d, a, p_input[ 10 ] + 0xbebfbc70, 23 );
+    MD5_DO( F3, a, b, c, d, p_input[ 13 ] + 0x289b7ec6,  4 );
+    MD5_DO( F3, d, a, b, c, p_input[  0 ] + 0xeaa127fa, 11 );
+    MD5_DO( F3, c, d, a, b, p_input[  3 ] + 0xd4ef3085, 16 );
+    MD5_DO( F3, b, c, d, a, p_input[  6 ] + 0x04881d05, 23 );
+    MD5_DO( F3, a, b, c, d, p_input[  9 ] + 0xd9d4d039,  4 );
+    MD5_DO( F3, d, a, b, c, p_input[ 12 ] + 0xe6db99e5, 11 );
+    MD5_DO( F3, c, d, a, b, p_input[ 15 ] + 0x1fa27cf8, 16 );
+    MD5_DO( F3, b, c, d, a, p_input[  2 ] + 0xc4ac5665, 23 );
+
+    MD5_DO( F4, a, b, c, d, p_input[  0 ] + 0xf4292244,  6 );
+    MD5_DO( F4, d, a, b, c, p_input[  7 ] + 0x432aff97, 10 );
+    MD5_DO( F4, c, d, a, b, p_input[ 14 ] + 0xab9423a7, 15 );
+    MD5_DO( F4, b, c, d, a, p_input[  5 ] + 0xfc93a039, 21 );
+    MD5_DO( F4, a, b, c, d, p_input[ 12 ] + 0x655b59c3,  6 );
+    MD5_DO( F4, d, a, b, c, p_input[  3 ] + 0x8f0ccc92, 10 );
+    MD5_DO( F4, c, d, a, b, p_input[ 10 ] + 0xffeff47d, 15 );
+    MD5_DO( F4, b, c, d, a, p_input[  1 ] + 0x85845dd1, 21 );
+    MD5_DO( F4, a, b, c, d, p_input[  8 ] + 0x6fa87e4f,  6 );
+    MD5_DO( F4, d, a, b, c, p_input[ 15 ] + 0xfe2ce6e0, 10 );
+    MD5_DO( F4, c, d, a, b, p_input[  6 ] + 0xa3014314, 15 );
+    MD5_DO( F4, b, c, d, a, p_input[ 13 ] + 0x4e0811a1, 21 );
+    MD5_DO( F4, a, b, c, d, p_input[  4 ] + 0xf7537e82,  6 );
+    MD5_DO( F4, d, a, b, c, p_input[ 11 ] + 0xbd3af235, 10 );
+    MD5_DO( F4, c, d, a, b, p_input[  2 ] + 0x2ad7d2bb, 15 );
+    MD5_DO( F4, b, c, d, a, p_input[  9 ] + 0xeb86d391, 21 );
+
+    p_md5->p_digest[ 0 ] += a;
+    p_md5->p_digest[ 1 ] += b;
+    p_md5->p_digest[ 2 ] += c;
+    p_md5->p_digest[ 3 ] += d;
+}
+#endif
+
+/*****************************************************************************
+ * InitShuffle: initialise a shuffle structure
+ *****************************************************************************
+ * This function initialises tables in the p_shuffle structure that will be
+ * used later by DoShuffle. The only external parameter is p_sys_key.
+ *****************************************************************************/
+static void InitShuffle( struct shuffle_s *p_shuffle, uint32_t *p_sys_key,
+                         uint32_t i_version )
+{
+    char p_secret1[] = "Tv!*";
+    static char const p_secret2[] = "____v8rhvsaAvOKM____FfUH%798=[;."
+                                    "____f8677680a634____ba87fnOIf)(*";
+    unsigned int i;
+
+    p_shuffle->i_version = i_version;
+
+    /* Fill p_commands using the key and a secret seed */
+    for( i = 0; i < 20; i++ )
+    {
+        struct md5_s md5;
+        int32_t i_hash;
+
+        InitMD5( &md5 );
+        AddMD5( &md5, (const uint8_t *)p_sys_key, 16 );
+        AddMD5( &md5, (const uint8_t *)p_secret1, 4 );
+        EndMD5( &md5 );
+
+        p_secret1[ 3 ]++;
+
+        REVERSE( md5.p_digest, 1 );
+        i_hash = ((int32_t)U32_AT(md5.p_digest)) % 1024;
+
+        p_shuffle->p_commands[ i ] = i_hash < 0 ? i_hash * -1 : i_hash;
+    }
+
+    /* Fill p_bordel with completely meaningless initial values. */
+    memcpy( p_shuffle->p_bordel, p_secret2, 64 );
+    for( i = 0; i < 4; i++ )
+    {
+        p_shuffle->p_bordel[ 4 * i ] = U32_AT(p_sys_key + i);
+        REVERSE( p_shuffle->p_bordel + 4 * i + 1, 3 );
+    }
+}
+
+/*****************************************************************************
+ * DoShuffle: shuffle buffer
+ *****************************************************************************
+ * This is so ugly and uses so many MD5 checksums that it is most certainly
+ * one-way, though why it needs to be so complicated is beyond me.
+ *****************************************************************************/
+static void DoShuffle( struct shuffle_s *p_shuffle,
+                       uint32_t *p_buffer, uint32_t i_size )
+{
+    struct md5_s md5;
+    uint32_t p_big_bordel[ 16 ];
+    uint32_t *p_bordel = p_shuffle->p_bordel;
+    unsigned int i;
+
+    static uint32_t i_secret = 0;
+
+    static uint32_t p_secret3[] =
+    {
+        0xAAAAAAAA, 0x01757700, 0x00554580, 0x01724500, 0x00424580,
+        0x01427700, 0x00000080, 0xC1D59D01, 0x80144981, 0x815C8901,
+        0x80544981, 0x81D45D01, 0x00000080, 0x81A3BB03, 0x00A2AA82,
+        0x01A3BB03, 0x0022A282, 0x813BA202, 0x00000080, 0x6D575737,
+        0x4A5275A5, 0x6D525725, 0x4A5254A5, 0x6B725437, 0x00000080,
+        0xD5DDB938, 0x5455A092, 0x5D95A013, 0x4415A192, 0xC5DD393A,
+        0x00000080, 0x55555555
+    };
+
+    static char p_secret4[] =
+        "pbclevtug (p) Nccyr Pbzchgre, Vap.  Nyy Evtugf Erfreirq.";
+
+    if( i_secret == 0 )
+    {
+        REVERSE( p_secret3, sizeof(p_secret3)/sizeof(p_secret3[ 0 ]) );
+        for( ; p_secret4[ i_secret ] != '\0'; i_secret++ )
+        {
+#define ROT13(c) (((c)>='A'&&(c)<='Z')?(((c)-'A'+13)%26)+'A':\
+                  ((c)>='a'&&(c)<='z')?(((c)-'a'+13)%26)+'a':c)
+            p_secret4[ i_secret ] = ROT13(p_secret4[ i_secret ]);
+        }
+        i_secret++; /* include zero terminator */
+    }
+
+    /* Using the MD5 hash of a memory block is probably not one-way enough
+     * for the iTunes people. This function randomises p_bordel depending on
+     * the values in p_commands to make things even more messy in p_bordel. */
+    for( i = 0; i < 20; i++ )
+    {
+        uint8_t i_command, i_index;
+
+        if( !p_shuffle->p_commands[ i ] )
+        {
+            continue;
+        }
+
+        i_command = (p_shuffle->p_commands[ i ] & 0x300) >> 8;
+        i_index = p_shuffle->p_commands[ i ] & 0xff;
+
+        switch( i_command )
+        {
+        case 0x3:
+            p_bordel[ i_index & 0xf ] = p_bordel[ i_index >> 4 ]
+                                      + p_bordel[ ((i_index + 0x10) >> 4) & 0xf ];
+            break;
+        case 0x2:
+            p_bordel[ i_index >> 4 ] ^= p_shuffle_xor[ 0xff - i_index ];
+            break;
+        case 0x1:
+            p_bordel[ i_index >> 4 ] -= p_shuffle_sub[ 0xff - i_index ];
+            break;
+        default:
+            p_bordel[ i_index >> 4 ] += p_shuffle_add[ 0xff - i_index ];
+            break;
+        }
+    }
+
+    if( p_shuffle->i_version == 0x01000300 )
+    {
+        DoExtShuffle( p_bordel );
+    }
+
+    /* Convert our newly randomised p_bordel to big endianness and take
+     * its MD5 hash. */
+    InitMD5( &md5 );
+    for( i = 0; i < 16; i++ )
+    {
+        p_big_bordel[ i ] = U32_AT(p_bordel + i);
+    }
+    AddMD5( &md5, (const uint8_t *)p_big_bordel, 64 );
+    if( p_shuffle->i_version == 0x01000300 )
+    {
+        AddMD5( &md5, (const uint8_t *)p_secret3, sizeof(p_secret3) );
+        AddMD5( &md5, (const uint8_t *)p_secret4, i_secret );
+    }
+    EndMD5( &md5 );
+
+    /* XOR our buffer with the computed checksum */
+    for( i = 0; i < i_size; i++ )
+    {
+        p_buffer[ i ] ^= md5.p_digest[ i ];
+    }
+}
+
+/*****************************************************************************
+ * DoExtShuffle: extended shuffle
+ *****************************************************************************
+ * This is even uglier.
+ *****************************************************************************/
+static void DoExtShuffle( uint32_t * p_bordel )
+{
+    uint32_t i_ret;
+
+    i_ret = FirstPass( p_bordel );
+
+    SecondPass( p_bordel, i_ret );
+
+    ThirdPass( p_bordel );
+
+    FourthPass( p_bordel );
+}
+
+static uint32_t FirstPass( uint32_t * p_bordel )
+{
+    uint32_t i, i_cmd, i_ret = 5;
+
+    TinyShuffle1( p_bordel );
+
+    for( ; ; )
+    {
+        for( ; ; )
+        {
+            p_bordel[ 1 ] += 0x10000000;
+            p_bordel[ 3 ] += 0x12777;
+
+            if( (p_bordel[ 10 ] & 1) && i_ret )
+            {
+                i_ret--;
+                p_bordel[ 1 ] -= p_bordel[ 2 ];
+                p_bordel[ 11 ] += p_bordel[ 12 ];
+                break;
+            }
+
+            if( (p_bordel[ 1 ] + p_bordel[ 2 ]) >= 0x7D0 )
+            {
+                switch( ((p_bordel[ 3 ] ^ 0x567F) >> 2) & 7 )
+                {
+                    case 0:
+                        for( i = 0; i < 3; i++ )
+                        {
+                            if( p_bordel[ i + 10 ] > 0x4E20 )
+                            {
+                                p_bordel[ i + 1 ] += p_bordel[ i + 2 ];
+                            }
+                        }
+                        break;
+                    case 4:
+                        p_bordel[ 1 ] -= p_bordel[ 2 ];
+                        /* no break */
+                    case 3:
+                        p_bordel[ 11 ] += p_bordel[ 12 ];
+                        break;
+                    case 6:
+                        p_bordel[ 3 ] ^= p_bordel[ 4 ];
+                        /* no break */
+                    case 8:
+                        p_bordel[ 13 ] &= p_bordel[ 14 ];
+                        /* no break */
+                    case 1:
+                        p_bordel[ 0 ] |= p_bordel[ 1 ];
+                        if( i_ret )
+                        {
+                            return i_ret;
+                        }
+                        break;
+                }
+
+                break;
+            }
+        }
+
+        for( i = 0, i_cmd = 0; i < 16; i++ )
+        {
+            if( p_bordel[ i ] < p_bordel[ i_cmd ] )
+            {
+                i_cmd = i;
+            }
+        }
+
+        if( i_ret && i_cmd != 5 )
+        {
+            i_ret--;
+        }
+        else
+        {
+            if( i_cmd == 5 )
+            {
+                p_bordel[ 8 ] &= p_bordel[ 6 ] >> 1;
+                p_bordel[ 3 ] <<= 1;
+            }
+
+            for( i = 0; i < 3; i++ )
+            {
+                p_bordel[ 11 ] += 1;
+                if( p_bordel[ 11 ] & 5 )
+                {
+                    p_bordel[ 8 ] += p_bordel[ 9 ];
+                }
+                else if( i_ret )
+                {
+                    i_ret--;
+                    i_cmd = 3;
+                    goto break2;
+                }
+            }
+
+            i_cmd = (p_bordel[ 15 ] + 0x93) >> 3;
+            if( p_bordel[ 15 ] & 0x100 )
+            {
+                i_cmd ^= 0xDEAD;
+            }
+        }
+
+        switch( i_cmd & 3 )
+        {
+            case 0:
+                while( p_bordel[ 11 ] & 1 )
+                {
+                    p_bordel[ 11 ] >>= 1;
+                    p_bordel[ 12 ] += 1;
+                }
+                /* no break */
+            case 2:
+                p_bordel[ 14 ] -= 0x19FE;
+                break;
+            case 3:
+                if( i_ret )
+                {
+                    i_ret--;
+                    p_bordel[ 5 ] += 5;
+                    continue;
+                }
+                break;
+        }
+
+        i_cmd = ((p_bordel[ 3 ] + p_bordel[ 4 ] + 10) >> 1) - p_bordel[ 4 ];
+        break;
+    }
+break2:
+
+    switch( i_cmd & 3 )
+    {
+        case 0:
+            p_bordel[ 14 ] >>= 1;
+            break;
+        case 1:
+            p_bordel[ 5 ] <<= 2;
+            break;
+        case 2:
+            p_bordel[ 12 ] |= 5;
+            break;
+        case 3:
+            p_bordel[ 15 ] &= 0x55;
+            if( i_ret )
+            {
+                p_bordel[ 2 ] &= 0xB62FC;
+                return i_ret;
+            }
+            break;
+    }
+
+    TinyShuffle2( p_bordel );
+
+    return i_ret;
+}
+
+static void SecondPass( uint32_t * p_bordel, uint32_t i_tmp )
+{
+    uint32_t i, i_cmd, i_jc = 5;
+
+    TinyShuffle3( p_bordel );
+
+    for( i = 0, i_cmd = 0; i < 16; i++ )
+    {
+        if( p_bordel[ i ] > p_bordel[ i_cmd ] )
+        {
+            i_cmd = i;
+        }
+    }
+
+    switch( i_cmd )
+    {
+        case 0:
+            if( p_bordel[ 1 ] < p_bordel[ 8 ] )
+            {
+                p_bordel[ 5 ] += 1;
+            }
+            break;
+        case 4:
+            if( (p_bordel[ 9 ] & 0x7777) == 0x3333 )
+            {
+                p_bordel[ 5 ] -= 1;
+            }
+            else
+            {
+                i_jc--;
+                if( p_bordel[ 1 ] < p_bordel[ 8 ] )
+                {
+                    p_bordel[ 5 ] += 1;
+                }
+                break;
+            }
+            /* no break */
+        case 7:
+            p_bordel[ 2 ] -= 1;
+            p_bordel[ 1 ] -= p_bordel[ 5 ];
+            for( i = 0; i < 3; i++ )
+            {
+                switch( p_bordel[ 1 ] & 3 )
+                {
+                    case 0:
+                        p_bordel[ 1 ] += 1;
+                        /* no break */
+                    case 1:
+                        p_bordel[ 3 ] -= 8;
+                        break;
+                    case 2:
+                        p_bordel[ 13 ] &= 0xFEFEFEF7;
+                        break;
+                    case 3:
+                        p_bordel[ 8 ] |= 0x80080011;
+                        break;
+                }
+            }
+            return;
+        case 10:
+            p_bordel[ 4 ] -= 1;
+            p_bordel[ 5 ] += 1;
+            p_bordel[ 6 ] -= 1;
+            p_bordel[ 7 ] += 1;
+            break;
+        default:
+            p_bordel[ 15 ] ^= 0x18547EFF;
+            break;
+    }
+
+    for( i = 3; i--; )
+    {
+        switch( ( p_bordel[ 12 ] + p_bordel[ 13 ] + p_bordel[ 6 ] ) % 5 )
+        {
+            case 0:
+                p_bordel[ 12 ] -= 1;
+                /* no break */
+            case 1:
+                p_bordel[ 12 ] -= 1;
+                p_bordel[ 13 ] += 1;
+                break;
+            case 2:
+                p_bordel[ 13 ] += 4;
+                /* no break */
+            case 3:
+                p_bordel[ 12 ] -= 1;
+                break;
+            case 4:
+                i_jc--;
+                p_bordel[ 5 ] += 1;
+                p_bordel[ 6 ] -= 1;
+                p_bordel[ 7 ] += 1;
+                i = 3; /* Restart the whole loop */
+                break;
+        }
+    }
+
+    TinyShuffle4( p_bordel );
+
+    for( ; ; )
+    {
+        TinyShuffle5( p_bordel );
+
+        switch( ( p_bordel[ 2 ] * 2 + 15 ) % 5 )
+        {
+            case 0:
+                if( ( p_bordel[ 3 ] + i_tmp ) <=
+                    ( p_bordel[ 1 ] + p_bordel[ 15 ] ) )
+                {
+                    p_bordel[ 3 ] += 1;
+                }
+                break;
+            case 4:
+                p_bordel[ 10 ] -= 0x13;
+                break;
+            case 3:
+                p_bordel[ 5 ] >>= 2;
+                break;
+        }
+
+        if( !( p_bordel[ 2 ] & 1 ) || i_jc == 0 )
+        {
+            break;
+        }
+
+        i_jc--;
+        p_bordel[ 2 ] += 0x13;
+        p_bordel[ 12 ] += 1;
+    }
+
+    p_bordel[ 2 ] &= 0x10076000;
+}
+
+static void ThirdPass( uint32_t * p_bordel )
+{
+    uint32_t i_cmd;
+
+    i_cmd = ((p_bordel[ 7 ] + p_bordel[ 14 ] + 10) >> 1) - p_bordel[ 14 ];
+    i_cmd = i_cmd % 10;
+
+    switch( i_cmd )
+    {
+        case 0:
+            p_bordel[ 1 ] <<= 1;
+            p_bordel[ 2 ] <<= 2;
+            p_bordel[ 3 ] <<= 3;
+            break;
+        case 6:
+            p_bordel[ i_cmd + 3 ] &= 0x5EDE36B;
+            p_bordel[ 5 ] += p_bordel[ 8 ];
+            p_bordel[ 4 ] += p_bordel[ 7 ];
+            p_bordel[ 3 ] += p_bordel[ 6 ];
+            p_bordel[ 2 ] += p_bordel[ 5 ];
+            /* no break */
+        case 2:
+            p_bordel[ 1 ] += p_bordel[ 4 ];
+            p_bordel[ 0 ] += p_bordel[ 3 ];
+            TinyShuffle6( p_bordel );
+            return; /* jc = 4 */
+        case 3:
+            if( (p_bordel[ 11 ] & p_bordel[ 2 ]) > 0x211B )
+            {
+                p_bordel[ 6 ] += 1;
+            }
+            break;
+        case 4:
+            p_bordel[ 7 ] += 1;
+            /* no break */
+        case 5:
+            p_bordel[ 9 ] ^= p_bordel[ 2 ];
+            break;
+        case 7:
+            p_bordel[ 2 ] ^= (p_bordel[ 1 ] & p_bordel[ 13 ]);
+            break;
+        case 8:
+            p_bordel[ 0 ] -= p_bordel[ 11 ] & p_bordel[ 15 ];
+            return; /* jc = 4 */
+        case 9:
+            p_bordel[ 6 ] >>= (p_bordel[ 14 ] & 3);
+            break;
+    }
+
+    SWAP( p_bordel[ 0 ], p_bordel[ 10 ] );
+
+    TinyShuffle6( p_bordel );
+
+    return; /* jc = 5 */
+}
+
+static void FourthPass( uint32_t * p_bordel )
+{
+    uint32_t i, j;
+
+    TinyShuffle7( p_bordel );
+
+    switch( p_bordel[ 5 ] % 5)
+    {
+        case 0:
+            p_bordel[ 0 ] += 1;
+            break;
+        case 2:
+            p_bordel[ 11 ] ^= (p_bordel[ 3 ] + p_bordel[ 6 ] + p_bordel[ 8 ]);
+            break;
+        case 3:
+            for( i = 4; i < 15 && (p_bordel[ i ] & 5) == 0; i++ )
+            {
+                SWAP( p_bordel[ i ], p_bordel[ 15 - i ] );
+            }
+            break;
+        case 4:
+            p_bordel[ 12 ] -= 1;
+            p_bordel[ 13 ] += 1;
+            p_bordel[ 2 ] -= 0x64;
+            p_bordel[ 3 ] += 0x64;
+            TinyShuffle8( p_bordel );
+            return;
+    }
+
+    for( i = 0, j = 0; i < 16; i++ )
+    {
+        if( p_bordel[ i ] > p_bordel[ j ] )
+        {
+            j = i;
+        }
+    }
+
+    switch( p_bordel[ j ] % 100 )
+    {
+        case 0:
+            SWAP( p_bordel[ 0 ], p_bordel[ j ] );
+            break;
+        case 8:
+            p_bordel[ 1 ] >>= 1;
+            p_bordel[ 2 ] <<= 1;
+            p_bordel[ 14 ] >>= 3;
+            p_bordel[ 15 ] <<= 4;
+            break;
+        case 57:
+            p_bordel[ j ] += p_bordel[ 13 ];
+            break;
+        case 76:
+            p_bordel[ 1 ] += 0x20E;
+            p_bordel[ 5 ] += 0x223D;
+            p_bordel[ 13 ] -= 0x576;
+            p_bordel[ 15 ] += 0x576;
+            return;
+        case 91:
+            p_bordel[ 2 ] -= 0x64;
+            p_bordel[ 3 ] += 0x64;
+            p_bordel[ 12 ] -= 1;
+            p_bordel[ 13 ] += 1;
+            break;
+        case 99:
+            p_bordel[ 0 ] += 1;
+            p_bordel[ j ] += p_bordel[ 13 ];
+            break;
+    }
+
+    TinyShuffle8( p_bordel );
+}
+
+/*****************************************************************************
+ * TinyShuffle[12345678]: tiny shuffle subroutines
+ *****************************************************************************
+ * These standalone functions are little helpers for the shuffling process.
+ *****************************************************************************/
+static void TinyShuffle1( uint32_t * p_bordel )
+{
+    uint32_t i_cmd = (p_bordel[ 5 ] + 10) >> 2;
+
+    if( p_bordel[ 5 ] > 0x7D0 )
+    {
+        i_cmd -= 0x305;
+    }
+
+    switch( i_cmd & 3 )
+    {
+        case 0:
+            p_bordel[ 5 ] += 5;
+            break;
+        case 1:
+            p_bordel[ 4 ] -= 1;
+            break;
+        case 2:
+            if( p_bordel[ 4 ] & 5 )
+            {
+                p_bordel[ 1 ] ^= 0x4D;
+            }
+            /* no break */
+        case 3:
+            p_bordel[ 12 ] += 5;
+            break;
+    }
+}
+
+static void TinyShuffle2( uint32_t * p_bordel )
+{
+    uint32_t i, j;
+
+    for( i = 0, j = 0; i < 16; i++ )
+    {
+        if( (p_bordel[ i ] & 0x777) > (p_bordel[ j ] & 0x777) )
+        {
+            j = i;
+        }
+    }
+
+    if( j > 5 )
+    {
+        for( ; j < 15; j++ )
+        {
+            p_bordel[ j ] += p_bordel[ j + 1 ];
+        }
+    }
+    else
+    {
+        p_bordel[ 2 ] &= 0xB62FC;
+    }
+}
+
+static void TinyShuffle3( uint32_t * p_bordel )
+{
+    uint32_t i_cmd = p_bordel[ 6 ] + 0x194B;
+
+    if( p_bordel[ 6 ] > 0x2710 )
+    {
+        i_cmd >>= 1;
+    }
+
+    switch( i_cmd & 3 )
+    {
+        case 1:
+            p_bordel[ 3 ] += 0x19FE;
+            break;
+        case 2:
+            p_bordel[ 7 ] -= p_bordel[ 3 ] >> 2;
+            /* no break */
+        case 0:
+            p_bordel[ 5 ] ^= 0x248A;
+            break;
+    }
+}
+
+static void TinyShuffle4( uint32_t * p_bordel )
+{
+    uint32_t i, j;
+
+    for( i = 0, j = 0; i < 16; i++ )
+    {
+        if( p_bordel[ i ] < p_bordel[ j ] )
+        {
+            j = i;
+        }
+    }
+
+    if( (p_bordel[ j ] % (j + 1)) > 10 )
+    {
+        p_bordel[ 1 ] -= 1;
+        p_bordel[ 2 ] += 0x13;
+        p_bordel[ 12 ] += 1;
+    }
+}
+
+static void TinyShuffle5( uint32_t * p_bordel )
+{
+    uint32_t i;
+
+    p_bordel[ 2 ] &= 0x7F3F;
+
+    for( i = 0; i < 5; i++ )
+    {
+        switch( ( p_bordel[ 2 ] + 10 + i ) % 5 )
+        {
+            case 0:
+                p_bordel[ 12 ] &= p_bordel[ 2 ];
+                /* no break */
+            case 1:
+                p_bordel[ 3 ] ^= p_bordel[ 15 ];
+                break;
+            case 2:
+                p_bordel[ 15 ] += 0x576;
+                /* no break */
+            case 3:
+                p_bordel[ 7 ] -= 0x2D;
+                /* no break */
+            case 4:
+                p_bordel[ 1 ] <<= 1;
+                break;
+        }
+    }
+}
+
+static void TinyShuffle6( uint32_t * p_bordel )
+{
+    uint32_t i, j;
+
+    for( i = 0; i < 8; i++ )
+    {
+        j = p_bordel[ 3 ] & 0x7514 ? 5 : 7;
+        SWAP( p_bordel[ i ], p_bordel[ i + j ] );
+    }
+}
+
+static void TinyShuffle7( uint32_t * p_bordel )
+{
+    uint32_t i;
+
+    i = (((p_bordel[ 9 ] + p_bordel[ 15 ] + 12) >> 2) - p_bordel[ 4 ]) & 7;
+
+    while( i-- )
+    {
+        SWAP( p_bordel[ i ], p_bordel[ i + 3 ] );
+    }
+
+    SWAP( p_bordel[ 1 ], p_bordel[ 10 ] );
+}
+
+static void TinyShuffle8( uint32_t * p_bordel )
+{
+    uint32_t i;
+
+    i = (p_bordel[ 0 ] & p_bordel[ 6 ]) & 0xF;
+
+    switch( p_bordel[ i ] % 1000 )
+    {
+        case 7:
+            if( (p_bordel[ i ] & 0x777) > (p_bordel[ 7 ] & 0x5555) )
+            {
+                p_bordel[ i ] ^= p_bordel[ 5 ] & p_bordel[ 3 ];
+            }
+            break;
+        case 19:
+            p_bordel[ 15 ] &= 0x5555;
+            break;
+        case 93:
+            p_bordel[ i ] ^= p_bordel[ 15 ];
+            break;
+        case 100:
+            SWAP( p_bordel[ 0 ], p_bordel[ 3 ] );
+            SWAP( p_bordel[ 1 ], p_bordel[ 6 ] );
+            SWAP( p_bordel[ 3 ], p_bordel[ 6 ] );
+            SWAP( p_bordel[ 4 ], p_bordel[ 9 ] );
+            SWAP( p_bordel[ 5 ], p_bordel[ 8 ] );
+            SWAP( p_bordel[ 6 ], p_bordel[ 7 ] );
+            SWAP( p_bordel[ 13 ], p_bordel[ 14 ] );
+            break;
+        case 329:
+            p_bordel[ i ] += p_bordel[ 1 ] ^ 0x80080011;
+            p_bordel[ i ] += p_bordel[ 2 ] ^ 0xBEEFDEAD;
+            p_bordel[ i ] += p_bordel[ 3 ] ^ 0x8765F444;
+            p_bordel[ i ] += p_bordel[ 4 ] ^ 0x78145326;
+            break;
+        case 567:
+            p_bordel[ 12 ] -= p_bordel[ i ];
+            p_bordel[ 13 ] += p_bordel[ i ];
+            break;
+        case 612:
+            p_bordel[ i ] += p_bordel[ 1 ];
+            p_bordel[ i ] -= p_bordel[ 7 ];
+            p_bordel[ i ] -= p_bordel[ 8 ];
+            p_bordel[ i ] += p_bordel[ 9 ];
+            p_bordel[ i ] += p_bordel[ 13 ];
+            break;
+        case 754:
+            i = __MIN( i, 12 );
+            p_bordel[ i + 1 ] >>= 1;
+            p_bordel[ i + 2 ] <<= 4;
+            p_bordel[ i + 3 ] >>= 3;
+            break;
+        case 777:
+            p_bordel[ 1 ] += 0x20E;
+            p_bordel[ 5 ] += 0x223D;
+            p_bordel[ 13 ] -= 0x576;
+            p_bordel[ 15 ] += 0x576;
+            break;
+        case 981:
+            if( (p_bordel[ i ] ^ 0x8765F441) < 0x2710 )
+            {
+                SWAP( p_bordel[ 0 ], p_bordel[ 1 ] );
+            }
+            else
+            {
+                SWAP( p_bordel[ 1 ], p_bordel[ 11 ] );
+            }
+            break;
+    }
+}
+
+/*****************************************************************************
+ * GetSystemKey: get the system key
+ *****************************************************************************
+ * Compute the system key from various system information, see HashSystemInfo.
+ *****************************************************************************/
+static int GetSystemKey( uint32_t *p_sys_key, vlc_bool_t b_ipod )
+{
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+
+    static char const p_secret5[ 8 ] = "YuaFlafu";
+    static char const p_secret6[ 8 ] = "zPif98ga";
+    struct md5_s md5;
+    int64_t i_ipod_id;
+    uint32_t p_system_hash[ 4 ];
+
+    /* Compute the MD5 hash of our system info */
+    if( ( !b_ipod && HashSystemInfo( p_system_hash ) ) ||
+        (  b_ipod && GetiPodID( &i_ipod_id ) ) )
+    {
+        return -1;
+    }
+
+    /* Combine our system info hash with additional secret data. The resulting
+     * MD5 hash will be our system key. */
+    InitMD5( &md5 );
+    AddMD5( &md5, (const uint8_t*)p_secret5, 8 );
+
+    if( !b_ipod )
+    {
+        AddMD5( &md5, (const uint8_t *)p_system_hash, 6 );
+        AddMD5( &md5, (const uint8_t *)p_system_hash, 6 );
+        AddMD5( &md5, (const uint8_t *)p_system_hash, 6 );
+        AddMD5( &md5, (const uint8_t*)p_secret6, 8 );
+    }
+    else
+    {
+        i_ipod_id = U64_AT(&i_ipod_id);
+        AddMD5( &md5, (const uint8_t *)&i_ipod_id, sizeof(i_ipod_id) );
+        AddMD5( &md5, (const uint8_t *)&i_ipod_id, sizeof(i_ipod_id) );
+        AddMD5( &md5, (const uint8_t *)&i_ipod_id, sizeof(i_ipod_id) );
+    }
+
+    EndMD5( &md5 );
+
+    memcpy( p_sys_key, md5.p_digest, 16 );
+
+    return 0;
+    
+#endif
+/* END SONGBIRD EDIT */    
+}
+
+#ifdef WIN32
+#   define DRMS_DIRNAME "drms"
+#else
+#   define DRMS_DIRNAME ".drms"
+#endif
+
+/*****************************************************************************
+ * WriteUserKey: write the user key to hard disk
+ *****************************************************************************
+ * Write the user key to the hard disk so that it can be reused later or used
+ * on operating systems other than Win32.
+ *****************************************************************************/
+static int WriteUserKey( void *_p_drms, uint32_t *p_user_key )
+{
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+/* BEGIN SONGBIRD EDIT */
+
+    struct drms_s *p_drms = (struct drms_s *)_p_drms;
+    FILE *file;
+    int i_ret = -1;
+    char psz_path[ PATH_MAX ];
+
+    snprintf( psz_path, PATH_MAX - 1,
+              "%s/" DRMS_DIRNAME, p_drms->psz_homedir );
+
+#if defined( HAVE_ERRNO_H )
+#   if defined( WIN32 )
+    if( !mkdir( psz_path ) || errno == EEXIST )
+#   else
+    if( !mkdir( psz_path, 0755 ) || errno == EEXIST )
+#   endif
+#else
+    if( !mkdir( psz_path ) )
+#endif
+    {
+        snprintf( psz_path, PATH_MAX - 1, "%s/" DRMS_DIRNAME "/%08X.%03d",
+                  p_drms->psz_homedir, p_drms->i_user, p_drms->i_key );
+
+        file = utf8_fopen( psz_path, "wb" );
+        if( file != NULL )
+        {
+            i_ret = fwrite( p_user_key, sizeof(uint32_t),
+                            4, file ) == 4 ? 0 : -1;
+            fclose( file );
+        }
+    }
+
+    return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */
+}
+
+/*****************************************************************************
+ * ReadUserKey: read the user key from hard disk
+ *****************************************************************************
+ * Retrieve the user key from the hard disk if available.
+ *****************************************************************************/
+static int ReadUserKey( void *_p_drms, uint32_t *p_user_key )
+{
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+/* BEGIN SONGBIRD EDIT */
+
+    struct drms_s *p_drms = (struct drms_s *)_p_drms;
+    FILE *file;
+    int i_ret = -1;
+    char psz_path[ PATH_MAX ];
+
+    snprintf( psz_path, PATH_MAX - 1,
+              "%s/" DRMS_DIRNAME "/%08X.%03d", p_drms->psz_homedir,
+              p_drms->i_user, p_drms->i_key );
+
+    file = utf8_fopen( psz_path, "rb" );
+    if( file != NULL )
+    {
+        i_ret = fread( p_user_key, sizeof(uint32_t),
+                       4, file ) == 4 ? 0 : -1;
+        fclose( file );
+    }
+
+    return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */
+}
+
+/*****************************************************************************
+ * GetUserKey: get the user key
+ *****************************************************************************
+ * Retrieve the user key from the hard disk if available, otherwise generate
+ * it from the system key. If the key could be successfully generated, write
+ * it to the hard disk for future use.
+ *****************************************************************************/
+static int GetUserKey( void *_p_drms, uint32_t *p_user_key )
+{
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+
+    static char const p_secret7[] = "mUfnpognadfgf873";
+    struct drms_s *p_drms = (struct drms_s *)_p_drms;
+    struct aes_s aes;
+    struct shuffle_s shuffle;
+    uint32_t i, y;
+    uint32_t *p_sci_data = NULL;
+    uint32_t i_user, i_key;
+    uint32_t p_sys_key[ 4 ];
+    uint32_t i_sci_size = 0, i_blocks, i_remaining;
+    uint32_t *p_sci0, *p_sci1, *p_buffer;
+    uint32_t p_sci_key[ 4 ];
+    char *psz_ipod;
+    int i_ret = -5;
+
+    if( ReadUserKey( p_drms, p_user_key ) == 0 )
+    {
+        REVERSE( p_user_key, 4 );
+        return 0;
+    }
+
+    psz_ipod = getenv( "IPOD" );
+
+    if( GetSystemKey( p_sys_key, psz_ipod ? VLC_TRUE : VLC_FALSE ) )
+    {
+        return -3;
+    }
+
+    if( GetSCIData( psz_ipod, &p_sci_data, &i_sci_size ) )
+    {
+        return -4;
+    }
+
+    /* Phase 1: unscramble the SCI data using the system key and shuffle
+     *          it using DoShuffle(). */
+
+    /* Skip the first 4 bytes (some sort of header). Decrypt the rest. */
+    i_blocks = (i_sci_size - 4) / 16;
+    i_remaining = (i_sci_size - 4) - (i_blocks * 16);
+    p_buffer = p_sci_data + 1;
+
+    /* Decrypt and shuffle our data at the same time */
+    InitAES( &aes, p_sys_key );
+    REVERSE( p_sys_key, 4 );
+    REVERSE( p_sci_data, 1 );
+    InitShuffle( &shuffle, p_sys_key, p_sci_data[ 0 ] );
+
+    memcpy( p_sci_key, p_secret7, 16 );
+    REVERSE( p_sci_key, 4 );
+
+    while( i_blocks-- )
+    {
+        uint32_t p_tmp[ 4 ];
+
+        REVERSE( p_buffer, 4 );
+        DecryptAES( &aes, p_tmp, p_buffer );
+        BlockXOR( p_tmp, p_sci_key, p_tmp );
+
+        /* Use the previous scrambled data as the key for next block */
+        memcpy( p_sci_key, p_buffer, 16 );
+
+        /* Shuffle the decrypted data using a custom routine */
+        DoShuffle( &shuffle, p_tmp, 4 );
+
+        /* Copy this block back to p_buffer */
+        memcpy( p_buffer, p_tmp, 16 );
+
+        p_buffer += 4;
+    }
+
+    if( i_remaining >= 4 )
+    {
+        REVERSE( p_buffer, i_remaining / 4 );
+        DoShuffle( &shuffle, p_buffer, i_remaining / 4 );
+    }
+
+    /* Phase 2: look for the user key in the generated data. I must admit I
+     *          do not understand what is going on here, because it almost
+     *          looks like we are browsing data that makes sense, even though
+     *          the DoShuffle() part made it completely meaningless. */
+
+    y = 0;
+    REVERSE( p_sci_data + 5, 1 );
+    i = U32_AT( p_sci_data + 5 );
+    i_sci_size -= 22 * sizeof(uint32_t);
+    p_sci1 = p_sci_data + 22;
+    p_sci0 = NULL;
+
+    while( i_sci_size >= 20 && i > 0 )
+    {
+        if( p_sci0 == NULL )
+        {
+            i_sci_size -= 18 * sizeof(uint32_t);
+            if( i_sci_size < 20 )
+            {
+                break;
+            }
+
+            p_sci0 = p_sci1;
+            REVERSE( p_sci1 + 17, 1 );
+            y = U32_AT( p_sci1 + 17 );
+            p_sci1 += 18;
+        }
+
+        if( !y )
+        {
+            i--;
+            p_sci0 = NULL;
+            continue;
+        }
+
+        i_user = U32_AT( p_sci0 );
+        i_key = U32_AT( p_sci1 );
+        REVERSE( &i_user, 1 );
+        REVERSE( &i_key, 1 );
+        if( i_user == p_drms->i_user && ( ( i_key == p_drms->i_key ) ||
+            ( !p_drms->i_key && ( p_sci1 == (p_sci0 + 18) ) ) ) )
+        {
+            memcpy( p_user_key, p_sci1 + 1, 16 );
+            REVERSE( p_sci1 + 1, 4 );
+            WriteUserKey( p_drms, p_sci1 + 1 );
+            i_ret = 0;
+            break;
+        }
+
+        y--;
+        p_sci1 += 5;
+        i_sci_size -= 5 * sizeof(uint32_t);
+    }
+
+    free( p_sci_data );
+
+    return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */
+
+}
+
+/*****************************************************************************
+ * GetSCIData: get SCI data from "SC Info.sidb"
+ *****************************************************************************
+ * Read SCI data from "\Apple Computer\iTunes\SC Info\SC Info.sidb"
+ *****************************************************************************/
+static int GetSCIData( char *psz_ipod, uint32_t **pp_sci,
+                       uint32_t *pi_sci_size )
+{
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+
+    FILE *file;
+    char *psz_path = NULL;
+    char p_tmp[ 4 * PATH_MAX ];
+    int i_ret = -1;
+
+    if( psz_ipod == NULL )
+    {
+#ifdef WIN32
+        char *p_filename = "\\Apple Computer\\iTunes\\SC Info\\SC Info.sidb";
+        typedef HRESULT (WINAPI *SHGETFOLDERPATH)( HWND, int, HANDLE, DWORD,
+                                                   LPSTR );
+        HINSTANCE shfolder_dll = NULL;
+        SHGETFOLDERPATH dSHGetFolderPath = NULL;
+
+        if( ( shfolder_dll = LoadLibrary( _T("SHFolder.dll") ) ) != NULL )
+        {
+            dSHGetFolderPath =
+                (SHGETFOLDERPATH)GetProcAddress( shfolder_dll,
+                                                 _T("SHGetFolderPathA") );
+        }
+
+        if( dSHGetFolderPath != NULL &&
+            SUCCEEDED( dSHGetFolderPath( NULL, CSIDL_COMMON_APPDATA,
+                                         NULL, 0, p_tmp ) ) )
+        {
+            strncat( p_tmp, p_filename, min( strlen( p_filename ),
+                     (sizeof(p_tmp) - 1) - strlen( p_tmp ) ) );
+
+            psz_path = FromLocale( p_tmp );
+            strncpy( p_tmp, psz_path, sizeof( p_tmp ) - 1 );
+            p_tmp[sizeof( p_tmp ) - 1] = '\0';
+            LocaleFree( psz_path );
+            psz_path = p_tmp;
+        }
+
+        if( shfolder_dll != NULL )
+        {
+            FreeLibrary( shfolder_dll );
+        }
+#endif
+    }
+    else
+    {
+#define ISCINFO "iSCInfo"
+        if( strstr( psz_ipod, ISCINFO ) == NULL )
+        {
+            snprintf( p_tmp, sizeof(p_tmp) - 1,
+                      "%s/iPod_Control/iTunes/" ISCINFO "2", psz_ipod );
+            psz_path = p_tmp;
+        }
+        else
+        {
+            psz_path = psz_ipod;
+        }
+    }
+
+    if( psz_path == NULL )
+    {
+        return -1;
+    }
+
+    file = utf8_fopen( psz_path, "rb" );
+    if( file != NULL )
+    {
+        struct stat st;
+
+        if( !fstat( fileno( file ), &st ) && st.st_size >= 4 )
+        {
+            *pp_sci = malloc( st.st_size );
+            if( *pp_sci != NULL )
+            {
+                if( fread( *pp_sci, 1, st.st_size,
+                           file ) == (size_t)st.st_size )
+                {
+                    *pi_sci_size = st.st_size;
+                    i_ret = 0;
+                }
+                else
+                {
+                    free( (void *)*pp_sci );
+                    *pp_sci = NULL;
+                }
+            }
+        }
+
+        fclose( file );
+    }
+
+    return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */
+
+}
+
+/*****************************************************************************
+ * HashSystemInfo: hash system information
+ *****************************************************************************
+ * This function computes the MD5 hash of the C: hard drive serial number,
+ * BIOS version, CPU type and Windows version.
+ *****************************************************************************/
+static int HashSystemInfo( uint32_t *p_system_hash )
+{
+    struct md5_s md5;
+    int i_ret = 0;
+
+#ifdef WIN32
+    HKEY i_key;
+    unsigned int i;
+    DWORD i_size;
+    DWORD i_serial;
+    LPBYTE p_reg_buf;
+
+    static LPCTSTR p_reg_keys[ 3 ][ 2 ] =
+    {
+        {
+            _T("HARDWARE\\DESCRIPTION\\System"),
+            _T("SystemBiosVersion")
+        },
+
+        {
+            _T("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0"),
+            _T("ProcessorNameString")
+        },
+
+        {
+            _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"),
+            _T("ProductId")
+        }
+    };
+
+    InitMD5( &md5 );
+
+    AddMD5( &md5, "cache-control", 13 );
+    AddMD5( &md5, "Ethernet", 8 );
+
+    GetVolumeInformation( _T("C:\\"), NULL, 0, &i_serial,
+                          NULL, NULL, NULL, 0 );
+    AddMD5( &md5, (const uint8_t *)&i_serial, 4 );
+
+    for( i = 0; i < sizeof(p_reg_keys) / sizeof(p_reg_keys[ 0 ]); i++ )
+    {
+        if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, p_reg_keys[ i ][ 0 ],
+                          0, KEY_READ, &i_key ) != ERROR_SUCCESS )
+        {
+            continue;
+        }
+
+        if( RegQueryValueEx( i_key, p_reg_keys[ i ][ 1 ],
+                             NULL, NULL, NULL, &i_size ) != ERROR_SUCCESS )
+        {
+            RegCloseKey( i_key );
+            continue;
+        }
+
+        p_reg_buf = malloc( i_size );
+
+        if( p_reg_buf != NULL )
+        {
+            if( RegQueryValueEx( i_key, p_reg_keys[ i ][ 1 ],
+                                 NULL, NULL, p_reg_buf,
+                                 &i_size ) == ERROR_SUCCESS )
+            {
+                AddMD5( &md5, (const uint8_t *)p_reg_buf, i_size );
+            }
+
+            free( p_reg_buf );
+        }
+
+        RegCloseKey( i_key );
+    }
+
+#else
+    InitMD5( &md5 );
+    i_ret = -1;
+#endif
+
+    EndMD5( &md5 );
+    memcpy( p_system_hash, md5.p_digest, 16 );
+
+    return i_ret;
+}
+
+/*****************************************************************************
+ * GetiPodID: Get iPod ID
+ *****************************************************************************
+ * This function gets the iPod ID.
+ *****************************************************************************/
+static int GetiPodID( int64_t *p_ipod_id )
+{
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+
+    int i_ret = -1;
+
+#define PROD_NAME   "iPod"
+#define VENDOR_NAME "Apple Computer, Inc."
+
+    char *psz_ipod_id = getenv( "IPODID" );
+    if( psz_ipod_id != NULL )
+    {
+        *p_ipod_id = strtoll( psz_ipod_id, NULL, 16 );
+        return 0;
+    }
+
+#ifdef __APPLE__
+    CFTypeRef value;
+    mach_port_t port;
+    io_object_t device;
+    io_iterator_t iterator;
+    CFMutableDictionaryRef match_dic;
+    CFMutableDictionaryRef smatch_dic;
+
+    if( IOMasterPort( MACH_PORT_NULL, &port ) == KERN_SUCCESS )
+    {
+        smatch_dic = IOServiceMatching( "IOFireWireUnit" );
+        match_dic = CFDictionaryCreateMutable( kCFAllocatorDefault, 0,
+                                           &kCFTypeDictionaryKeyCallBacks,
+                                           &kCFTypeDictionaryValueCallBacks );
+
+        if( smatch_dic != NULL && match_dic != NULL )
+        {
+            CFDictionarySetValue( smatch_dic,
+                                  CFSTR("FireWire Vendor Name"),
+                                  CFSTR(VENDOR_NAME) );
+            CFDictionarySetValue( smatch_dic,
+                                  CFSTR("FireWire Product Name"),
+                                  CFSTR(PROD_NAME) );
+
+            CFDictionarySetValue( match_dic,
+                                  CFSTR(kIOPropertyMatchKey),
+                                  smatch_dic );
+
+            if( IOServiceGetMatchingServices( port, match_dic,
+                                              &iterator ) == KERN_SUCCESS )
+            {
+                while( ( device = IOIteratorNext( iterator ) ) != NULL )
+                {
+                    value = IORegistryEntryCreateCFProperty( device,
+                        CFSTR("GUID"), kCFAllocatorDefault, kNilOptions );
+
+                    if( value != NULL )
+                    {
+                        if( CFGetTypeID( value ) == CFNumberGetTypeID() )
+                        {
+                            int64_t i_ipod_id;
+                            CFNumberGetValue( (CFNumberRef)value,
+                                              kCFNumberLongLongType,
+                                              &i_ipod_id );
+                            *p_ipod_id = i_ipod_id;
+                            i_ret = 0;
+                        }
+
+                        CFRelease( value );
+                    }
+
+                    IOObjectRelease( device );
+
+                    if( !i_ret ) break;
+                }
+
+                IOObjectRelease( iterator );
+            }
+        }
+
+        mach_port_deallocate( mach_task_self(), port );
+    }
+
+#elif HAVE_SYSFS_LIBSYSFS_H
+    struct sysfs_bus *bus = NULL;
+    struct dlist *devlist = NULL;
+    struct dlist *attributes = NULL;
+    struct sysfs_device *curdev = NULL;
+    struct sysfs_attribute *curattr = NULL;
+
+    bus = sysfs_open_bus( "ieee1394" );
+    if( bus != NULL )
+    {
+        devlist = sysfs_get_bus_devices( bus );
+        if( devlist != NULL )
+        {
+            dlist_for_each_data( devlist, curdev, struct sysfs_device )
+            {
+                attributes = sysfs_get_device_attributes( curdev );
+                if( attributes != NULL )
+                {
+                    dlist_for_each_data( attributes, curattr,
+                                         struct sysfs_attribute )
+                    {
+                        if( ( strcmp( curattr->name, "model_name" ) == 0 ) &&
+                            ( strncmp( curattr->value, PROD_NAME,
+                                       sizeof(PROD_NAME) ) == 0 ) )
+                        {
+                            *p_ipod_id = strtoll( curdev->name, NULL, 16 );
+                            i_ret = 0;
+                            break;
+                        }
+                    }
+               }
+
+                if( !i_ret ) break;
+            }
+        }
+
+        sysfs_close_bus( bus );
+    }
+#endif
+
+    return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */    
+}
+
+#else /* !defined( UNDER_CE ) */
+
+void *drms_alloc( char *psz_homedir ){ return 0; }
+void drms_free( void *a ){}
+void drms_decrypt( void *a, uint32_t *b, uint32_t c  ){}
+int drms_init( void *a, uint32_t b, uint8_t *c, uint32_t d ){ return -1; }
+
+#endif /* defined( UNDER_CE ) */

Property changes on: modules\demux\mp4\drms.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mp4\drms.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mp4\drmstables.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mp4\libmp4.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mp4\libmp4.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mp4\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mp4\mp4.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mpc.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mpeg\h264.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mpeg\m4a.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mpeg\m4v.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mpeg\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mpeg\mpga.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\mpeg\mpgv.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\nsc.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\nsv.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\nuv.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\ogg.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\b4s.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\dvb.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\m3u.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\old.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\playlist.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\playlist.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\pls.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\podcast.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\shoutcast.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\xspf.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\playlist\xspf.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\ps.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\ps.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\pva.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\rawdv.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\real.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\sgimb.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\subtitle.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\ts.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\tta.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\ty.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\util\id3genres.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\util\id3tag.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\util\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\vobsub.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\voc.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\wav.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\demux\xa.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\AudioOutput.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\BeOS.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\Bitmaps.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\DrawingTidbits.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\DrawingTidbits.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\Interface.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\InterfaceWindow.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\InterfaceWindow.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\ListViews.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\ListViews.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\MediaControlView.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\MediaControlView.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\MessagesWindow.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\MessagesWindow.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\MsgVals.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\PlayListWindow.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\PlayListWindow.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\PreferencesWindow.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\PreferencesWindow.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\TransportButton.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\TransportButton.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\VideoOutput.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\beos\VideoWindow.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\about.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\about.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\AppleRemote.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\AppleRemote.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\applescript.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\applescript.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\bookmarks.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\bookmarks.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\controls.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\controls.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\embeddedwindow.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\embeddedwindow.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\equalizer.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\equalizer.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\extended.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\extended.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\fspanel.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\fspanel.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\interaction.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\interaction.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\intf.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\intf.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\macosx.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\misc.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\misc.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\open.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\open.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\output.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\output.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\playlist.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\playlist.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\playlistinfo.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\playlistinfo.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\prefs.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\prefs.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\prefs_widgets.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\prefs_widgets.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\update.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\update.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\vout.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\vout.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\voutgl.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\voutqt.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\wizard.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\macosx\wizard.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\ncurses.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\opie\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\opie\opie.ui
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\pda\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\pda\pda.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\pda\pda.glade
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\pda\pda.gladep
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\pda\pda.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\pda\pda_callbacks.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\pda\pda_callbacks.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\pda\pda_interface.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\pda\pda_interface.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\pda\pda_support.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\pda\pda_support.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\qnx\aout.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\qnx\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\qnx\qnx.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\qnx\vout.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\async_queue.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\async_queue.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_add_item.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_add_item.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_audio.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_audio.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_change_skin.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_change_skin.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_dialogs.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_dummy.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_dvd.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_dvd.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_fullscreen.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_fullscreen.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_generic.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_input.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_input.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_layout.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_layout.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_minimize.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_minimize.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_muxer.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_muxer.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_on_top.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_on_top.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_playlist.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_playlist.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_playtree.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_playtree.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_quit.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_quit.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_resize.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_resize.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_show_window.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_snapshot.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_snapshot.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_vars.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\commands\cmd_vars.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_button.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_button.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_checkbox.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_checkbox.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_flat.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_generic.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_generic.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_image.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_image.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_list.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_list.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_move.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_move.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_radialslider.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_radialslider.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_resize.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_resize.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_slider.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_slider.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_text.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_text.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_tree.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_tree.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_video.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\controls\ctrl_video.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_enter.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_focus.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_generic.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_input.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_input.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_key.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_key.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_leave.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_menu.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_motion.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_mouse.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_mouse.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_refresh.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_scroll.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_scroll.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_special.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\events\evt_special.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_dragdrop.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_dragdrop.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_factory.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_factory.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_graphics.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_graphics.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_loop.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_loop.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_popup.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_popup.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_timer.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_timer.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_tooltip.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_tooltip.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_window.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\macosx\macosx_window.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\builder.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\builder.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\builder_data.def
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\builder_data.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\expr_evaluator.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\expr_evaluator.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\gen_builder.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\interpreter.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\interpreter.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\skin_parser.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\skin_parser.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\xmlparser.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\parser\xmlparser.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\anchor.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\anchor.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\anim_bitmap.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\anim_bitmap.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\bitmap_font.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\bitmap_font.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\dialogs.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\dialogs.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\file_bitmap.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\file_bitmap.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\ft2_bitmap.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\ft2_bitmap.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\ft2_font.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\ft2_font.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\generic_bitmap.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\generic_bitmap.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\generic_font.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\generic_layout.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\generic_layout.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\generic_window.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\generic_window.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\ini_file.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\ini_file.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\logger.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\logger.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\os_factory.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\os_factory.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\os_graphics.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\os_loop.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\os_popup.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\os_timer.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\os_tooltip.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\os_window.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\popup.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\popup.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\scaled_bitmap.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\scaled_bitmap.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\skin_common.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\skin_main.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\theme.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\theme.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\theme_loader.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\theme_loader.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\theme_repository.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\theme_repository.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\tooltip.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\tooltip.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\top_window.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\top_window.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\var_manager.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\var_manager.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\vlcproc.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\vlcproc.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\vout_window.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\vout_window.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\window_manager.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\src\window_manager.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\unzip\crypt.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\unzip\ioapi.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\unzip\ioapi.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\unzip\unzip.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\unzip\unzip.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\bezier.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\bezier.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\fsm.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\fsm.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\observer.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\pointer.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\position.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\position.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\ustring.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\ustring.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\var_bool.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\var_bool.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\var_list.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\var_list.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\var_percent.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\var_percent.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\var_text.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\var_text.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\var_tree.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\var_tree.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\utils\variable.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\vars\equalizer.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\vars\equalizer.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\vars\playlist.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\vars\playlist.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\vars\playtree.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\vars\playtree.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\vars\time.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\vars\time.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\vars\volume.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\vars\volume.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_dragdrop.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_dragdrop.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_factory.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_factory.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_graphics.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_graphics.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_loop.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_loop.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_popup.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_popup.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_timer.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_timer.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_tooltip.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_tooltip.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_window.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\win32\win32_window.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_display.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_display.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_dragdrop.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_dragdrop.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_factory.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_factory.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_graphics.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_graphics.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_loop.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_loop.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_popup.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_popup.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_timer.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_timer.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_tooltip.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_tooltip.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_window.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\skins2\x11\x11_window.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\dialogs.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\fileinfo.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\interface.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\iteminfo.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\menus.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\messages.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\open.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\playlist.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\preferences.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\preferences_widgets.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\preferences_widgets.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\subtitles.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\timer.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\video.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\wince.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\wince.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wince\wince_rc.rc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\advanced.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\audio.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\codec.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\edit.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\eject.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\fast.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\intf.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\loop.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\next.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\pause.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\play.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\playlist.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\playlist_small.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\prev.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\repeat.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\shuffle.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\slow.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\speaker.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\speaker_mute.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\stop.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\trash.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\type_afile.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\type_card.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\type_cdda.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\type_directory.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\type_disc.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\type_net.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\type_node.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\type_playlist.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\type_unknown.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\type_vfile.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\update_ascii.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\update_binary.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\update_document.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\update_info.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\update_source.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\bitmaps\video.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\bookmarks.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\bookmarks.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\fileinfo.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\fileinfo.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\infopanels.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\infopanels.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\interaction.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\interaction.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\iteminfo.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\iteminfo.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\messages.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\messages.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\open.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\open.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\playlist.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\playlist.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\preferences.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\preferences.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\preferences_widgets.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\preferences_widgets.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\streamout.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\streamout.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\subtitles.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\subtitles.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\updatevlc.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\updatevlc.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\vlm\vlm_panel.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\vlm\vlm_panel.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\vlm\vlm_slider_manager.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\vlm\vlm_slider_manager.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\vlm\vlm_stream.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\vlm\vlm_stream.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\vlm\vlm_streampanel.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\vlm\vlm_streampanel.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\vlm\vlm_wrapper.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\vlm\vlm_wrapper.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\wizard.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\dialogs\wizard.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\extrapanel.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\extrapanel.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\input_manager.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\input_manager.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\interface.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\interface.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\menus.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\playlist_manager.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\playlist_manager.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\streamdata.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\streamdata.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\timer.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\timer.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\video.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\video.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\wxwidgets.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\gui\wxwidgets\wxwidgets.hpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\LIST
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\list.sh
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\dummy\aout.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\dummy\decoder.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\dummy\dummy.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\dummy\dummy.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\dummy\encoder.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\dummy\input.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\dummy\interface.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\dummy\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\dummy\renderer.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\dummy\vout.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\freetype.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\gnutls.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\growl.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\gtk_main.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\logger.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\memcpy\fastmemcpy.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\memcpy\memcpy.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\memcpy\memcpyaltivec.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\memcpy\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\msn.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\network\ipv4.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\network\ipv6.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\network\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\notify.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\playlist\export.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\playlist\m3u.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\playlist\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\playlist\old.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\playlist\xspf.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\playlist\xspf.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\qte_main.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\rtsp.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\screensaver.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\svg.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\testsuite\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\testsuite\playlist.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\testsuite\test1.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\testsuite\test2.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\testsuite\test3.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\testsuite\test4.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\win32text.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\xml\libxml.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\xml\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\misc\xml\xtag.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\asf.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\avi.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\dummy.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\mp4.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\mpeg\bits.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\mpeg\csa.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\mpeg\csa.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\mpeg\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\mpeg\pes.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\mpeg\pes.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\mpeg\ps.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\mpeg\ts.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\mpjpeg.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\ogg.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\rtp\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\rtp\rtcp.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\rtp\rtcp.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\rtp\rtp.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\mux\wav.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\packetizer\copy.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\packetizer\h264.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\packetizer\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\packetizer\mpeg4audio.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\packetizer\mpeg4video.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\packetizer\mpegvideo.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\services_discovery\bonjour.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\services_discovery\daap.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\services_discovery\hal.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\services_discovery\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\services_discovery\podcast.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\services_discovery\sap.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\services_discovery\shout.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\services_discovery\upnp_cc.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\services_discovery\upnp_intel.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\bridge.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\description.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\display.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\dummy.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\duplicate.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\es.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\gather.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\mosaic_bridge.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\rtp.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\standard.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\switcher.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\transcode.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\transrate\block.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\transrate\frame.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\transrate\getvlc.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\transrate\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\transrate\putvlc.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\transrate\transrate.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\stream_out\transrate\transrate.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\i420_rgb.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\i420_rgb.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\i420_rgb16.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\i420_rgb8.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\i420_rgb_c.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\i420_rgb_mmx.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\i420_ymga.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\i420_yuy2.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\i420_yuy2.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\i422_yuy2.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\i422_yuy2.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_chroma\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\adjust.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\blend.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\clone.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\crop.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\deinterlace.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\distort.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\filter_common.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\invert.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\logo.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\magnify.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\marq.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\mosaic.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\mosaic.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\motionblur.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\motiondetect.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\osdmenu.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\rss.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\rv32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\scale.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\common.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\filter.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\rgb2rgb.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\rgb2rgb.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\rgb2rgb_template.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\swscale.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\swscale.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\swscale_altivec_template.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\swscale_internal.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\swscale_template.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\yuv2rgb.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\yuv2rgb_altivec.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\yuv2rgb_mlib.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\swscale\yuv2rgb_template.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\time.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\transform.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_filter\wall.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\aa.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\caca.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\directfb.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\directx\direct3d.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\directx\directx.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\directx\events.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\directx\glwin32.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\directx\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\directx\vout.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\fb.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\ggi.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\glide.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\hd1000v.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\image.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\mga.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\opengl.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\qte\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\qte\qte.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\qte\qte.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\sdl.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\snapshot.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\svgalib.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\wingdi.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\x11\glx.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\x11\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\x11\x11.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\x11\xcommon.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\x11\xcommon.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\video_output\x11\xvideo.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\beat_detect.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\beat_detect.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\builtin_funcs.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\builtin_funcs.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\common.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\compare.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\custom_shape.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\custom_shape.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\custom_shape_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\custom_wave.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\custom_wave.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\custom_wave_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\engine_vars.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\engine_vars.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\eval.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\eval.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\expr_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\fatal.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\fftsg.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\func.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\func.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\func_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\idle_preset.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\init_cond.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\init_cond.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\init_cond_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\interface_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\main.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\main.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\param.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\param.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\param_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\parser.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\parser.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\PCM.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\PCM.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\per_frame_eqn.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\per_frame_eqn.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\per_frame_eqn_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\per_pixel_eqn.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\per_pixel_eqn.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\per_pixel_eqn_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\per_point_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\plugin.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\plugin.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\preset.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\preset.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\preset_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\splaytree.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\splaytree.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\splaytree_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\tree_types.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\tree_types.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\video_init.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\galaktos\video_init.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\goom.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\visual\effects.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\visual\fft.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\visual\fft.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\visual\Modules.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\visual\visual.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\visual\visual.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: modules\visualization\xosd.c
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: mozilla/control/npolibvlc.cpp
===================================================================
--- mozilla/control/npolibvlc.cpp	(revision 159)
+++ mozilla/control/npolibvlc.cpp	(working copy)
@@ -1,1947 +1,2414 @@
-/*****************************************************************************
- * npolibvlc.cpp: official Javascript APIs
- *****************************************************************************
- * Copyright (C) 2002-2006 the VideoLAN team
- *
- * Authors: Damien Fouilleul <Damien.Fouilleul@laposte.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-#include "config.h"
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-
-/* Mozilla stuff */
-#ifdef HAVE_MOZILLA_CONFIG_H
-#   include <mozilla-config.h>
-#endif
-
-#include "npolibvlc.h"
-#include "vlcplugin.h"
-
-/*
-** implementation of libvlc root object
-*/
-
-LibvlcRootNPObject::~LibvlcRootNPObject()
-{
-    /*
-    ** when plugin is destroyed, firefox takes upon itself to destroy all 'live' script objects
-    ** and ignores refcounting. Therefore we cannot safely assume  that refcounting will control
-    ** lifespan of objects. Hence they are only lazily created on request, so that firefox can
-    ** take ownership, and are not released when plugin is being destroyed.
-    */
-    if( isValid() )
-    {
-        if( audioObj    ) NPN_ReleaseObject(audioObj);
-        if( inputObj    ) NPN_ReleaseObject(inputObj);
-        if( logObj      ) NPN_ReleaseObject(logObj);
-        if( playlistObj ) NPN_ReleaseObject(playlistObj);
-        if( videoObj    ) NPN_ReleaseObject(videoObj);
-    }
-}
-
-const NPUTF8 * const LibvlcRootNPObject::propertyNames[] = 
-{
-    "audio",
-    "input",
-    "log",
-    "playlist",
-    "video",
-    "VersionInfo",
-};
-
-const int LibvlcRootNPObject::propertyCount = sizeof(LibvlcRootNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcRootNPObjectPropertyIds
-{
-    ID_root_audio = 0,
-    ID_root_input,
-    ID_root_log,
-    ID_root_playlist,
-    ID_root_video,
-    ID_root_VersionInfo,
-};
-
-RuntimeNPObject::InvokeResult LibvlcRootNPObject::getProperty(int index, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        switch( index )
-        {
-            case ID_root_audio:
-                // create child object in lazyman fashion to avoid ownership problem with firefox
-                if( ! audioObj )
-                    audioObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcAudioNPObject>::getClass());
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(audioObj), result);
-                return INVOKERESULT_NO_ERROR;
-            case ID_root_input:
-                // create child object in lazyman fashion to avoid ownership problem with firefox
-                if( ! inputObj )
-                    inputObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcInputNPObject>::getClass());
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(inputObj), result);
-                return INVOKERESULT_NO_ERROR;
-            case ID_root_log:
-                // create child object in lazyman fashion to avoid ownership problem with firefox
-                if( ! logObj )
-                    logObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcLogNPObject>::getClass());
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(logObj), result);
-                return INVOKERESULT_NO_ERROR;
-            case ID_root_playlist:
-                // create child object in lazyman fashion to avoid ownership problem with firefox
-                if( ! playlistObj )
-                    playlistObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcPlaylistNPObject>::getClass());
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(playlistObj), result);
-                return INVOKERESULT_NO_ERROR;
-            case ID_root_video:
-                // create child object in lazyman fashion to avoid ownership problem with firefox
-                if( ! videoObj )
-                    videoObj = NPN_CreateObject(_instance,RuntimeNPClass<LibvlcVideoNPObject>::getClass());
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(videoObj), result);
-                return INVOKERESULT_NO_ERROR;
-            case ID_root_VersionInfo:
-            {
-                int len = strlen(VLC_Version());
-                NPUTF8 *retval =(NPUTF8*)NPN_MemAlloc(len);
-                if( retval )
-                {
-                    memcpy(retval, VLC_Version(), len);
-                    STRINGN_TO_NPVARIANT(retval, len, result);
-                }
-                else
-                {
-                    NULL_TO_NPVARIANT(result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcRootNPObject::methodNames[] =
-{
-    "versionInfo",
-};
-
-const int LibvlcRootNPObject::methodCount = sizeof(LibvlcRootNPObject::methodNames)/sizeof(NPUTF8 *);
-
-enum LibvlcRootNPObjectMethodIds
-{
-    ID_root_versionInfo,
-};
-
-RuntimeNPObject::InvokeResult LibvlcRootNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_root_versionInfo:
-                if( argCount == 0 )
-                {
-                    int len = strlen(VLC_Version());
-                    NPUTF8 *retval =(NPUTF8*)NPN_MemAlloc(len);
-                    if( retval )
-                    {
-                        memcpy(retval, VLC_Version(), len);
-                        STRINGN_TO_NPVARIANT(retval, len, result);
-                    }
-                    else
-                    {
-                        NULL_TO_NPVARIANT(result);
-                    }
-                    return INVOKERESULT_NO_ERROR;
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-/*
-** implementation of libvlc audio object
-*/
-
-const NPUTF8 * const LibvlcAudioNPObject::propertyNames[] = 
-{
-    "mute",
-    "volume",
-};
-
-const int LibvlcAudioNPObject::propertyCount = sizeof(LibvlcAudioNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcAudioNPObjectPropertyIds
-{
-    ID_audio_mute,
-    ID_audio_volume
-};
-
-RuntimeNPObject::InvokeResult LibvlcAudioNPObject::getProperty(int index, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_audio_mute:
-            {
-                vlc_bool_t muted = libvlc_audio_get_mute(p_plugin->getVLC(), &ex);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                BOOLEAN_TO_NPVARIANT(muted, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_audio_volume:
-            {
-                int volume = libvlc_audio_get_volume(p_plugin->getVLC(), &ex);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                INT32_TO_NPVARIANT(volume, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-RuntimeNPObject::InvokeResult LibvlcAudioNPObject::setProperty(int index, const NPVariant &value)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_audio_mute:
-                if( NPVARIANT_IS_BOOLEAN(value) )
-                {
-                    libvlc_audio_set_mute(p_plugin->getVLC(),
-                                          NPVARIANT_TO_BOOLEAN(value), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    return INVOKERESULT_NO_ERROR;
-                }
-                return INVOKERESULT_INVALID_VALUE;
-            case ID_audio_volume:
-                if( isNumberValue(value) )
-                {
-                    libvlc_audio_set_volume(p_plugin->getVLC(),
-                                            numberValue(value), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    return INVOKERESULT_NO_ERROR;
-                }
-                return INVOKERESULT_INVALID_VALUE;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcAudioNPObject::methodNames[] =
-{
-    "toggleMute",
-};
-
-const int LibvlcAudioNPObject::methodCount = sizeof(LibvlcAudioNPObject::methodNames)/sizeof(NPUTF8 *);
-
-enum LibvlcAudioNPObjectMethodIds
-{
-    ID_audio_togglemute,
-};
-
-RuntimeNPObject::InvokeResult LibvlcAudioNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_audio_togglemute:
-                if( argCount == 0 )
-                {
-                    libvlc_audio_toggle_mute(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-/*
-** implementation of libvlc input object
-*/
-
-const NPUTF8 * const LibvlcInputNPObject::propertyNames[] = 
-{
-    "length",
-    "position",
-    "time",
-    "state",
-    "rate",
-    "fps",
-    "hasVout",
-};
-
-const int LibvlcInputNPObject::propertyCount = sizeof(LibvlcInputNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcInputNPObjectPropertyIds
-{
-    ID_input_length,
-    ID_input_position,
-    ID_input_time,
-    ID_input_state,
-    ID_input_rate,
-    ID_input_fps,
-    ID_input_hasvout,
-};
-
-RuntimeNPObject::InvokeResult LibvlcInputNPObject::getProperty(int index, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
-        if( libvlc_exception_raised(&ex) )
-        {
-            if( index != ID_input_state )
-            {
-                NPN_SetException(this, libvlc_exception_get_message(&ex));
-                libvlc_exception_clear(&ex);
-                return INVOKERESULT_GENERIC_ERROR;
-            }
-            else
-            {
-                /* for input state, return CLOSED rather than an exception */
-                INT32_TO_NPVARIANT(0, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-        }
-
-        switch( index )
-        {
-            case ID_input_length:
-            {
-                double val = (double)libvlc_input_get_length(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                DOUBLE_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_input_position:
-            {
-                double val = libvlc_input_get_position(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                DOUBLE_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_input_time:
-            {
-                double val = (double)libvlc_input_get_time(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                DOUBLE_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_input_state:
-            {
-                int val = libvlc_input_get_state(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                INT32_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_input_rate:
-            {
-                float val = libvlc_input_get_rate(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                DOUBLE_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_input_fps:
-            {
-                double val = libvlc_input_get_fps(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                DOUBLE_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_input_hasvout:
-            {
-                vlc_bool_t val = libvlc_input_has_vout(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                BOOLEAN_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-        libvlc_input_free(p_input);
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-RuntimeNPObject::InvokeResult LibvlcInputNPObject::setProperty(int index, const NPVariant &value)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
-        if( libvlc_exception_raised(&ex) )
-        {
-            NPN_SetException(this, libvlc_exception_get_message(&ex));
-            libvlc_exception_clear(&ex);
-            return INVOKERESULT_GENERIC_ERROR;
-        }
-
-        switch( index )
-        {
-            case ID_input_position:
-            {
-                if( ! NPVARIANT_IS_DOUBLE(value) )
-                {
-                    libvlc_input_free(p_input);
-                    return INVOKERESULT_INVALID_VALUE;
-                }
-
-                float val = (float)NPVARIANT_TO_DOUBLE(value);
-                libvlc_input_set_position(p_input, val, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_input_time:
-            {
-                vlc_int64_t val;
-                if( NPVARIANT_IS_INT32(value) )
-                    val = (vlc_int64_t)NPVARIANT_TO_INT32(value);
-                else if( NPVARIANT_IS_DOUBLE(value) )
-                    val = (vlc_int64_t)NPVARIANT_TO_DOUBLE(value);
-                else
-                {
-                    libvlc_input_free(p_input);
-                    return INVOKERESULT_INVALID_VALUE;
-                }
-
-                libvlc_input_set_time(p_input, val, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_input_rate:
-            {
-                float val;
-                if( NPVARIANT_IS_INT32(value) )
-                    val = (float)NPVARIANT_TO_INT32(value);
-                else if( NPVARIANT_IS_DOUBLE(value) )
-                    val = (float)NPVARIANT_TO_DOUBLE(value);
-                else
-                {
-                    libvlc_input_free(p_input);
-                    return INVOKERESULT_INVALID_VALUE;
-                }
-
-                libvlc_input_set_rate(p_input, val, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-        libvlc_input_free(p_input);
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcInputNPObject::methodNames[] =
-{
-    /* no methods */
-};
-
-const int LibvlcInputNPObject::methodCount = sizeof(LibvlcInputNPObject::methodNames)/sizeof(NPUTF8 *);
-
-/*
-** implementation of libvlc message object
-*/
-
-const NPUTF8 * const LibvlcMessageNPObject::propertyNames[] = 
-{
-    "severity",
-    "type",
-    "name",
-    "header",
-    "message",
-};
-
-const int LibvlcMessageNPObject::propertyCount = sizeof(LibvlcMessageNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcMessageNPObjectPropertyIds
-{
-    ID_message_severity,
-    ID_message_type,
-    ID_message_name,
-    ID_message_header,
-    ID_message_message,
-};
-
-RuntimeNPObject::InvokeResult LibvlcMessageNPObject::getProperty(int index, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        switch( index )
-        {
-            case ID_message_severity:
-            {
-                INT32_TO_NPVARIANT(_msg.i_severity, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_message_type:
-            {
-                if( _msg.psz_type )
-                {
-                    int len = strlen(_msg.psz_type);
-                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
-                    if( retval )
-                    {
-                        memcpy(retval, _msg.psz_type, len);
-                        STRINGN_TO_NPVARIANT(retval, len, result);
-                    }
-                }
-                else
-                {
-                    NULL_TO_NPVARIANT(result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_message_name:
-            {
-                if( _msg.psz_name )
-                {
-                    int len = strlen(_msg.psz_name);
-                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
-                    if( retval )
-                    {
-                        memcpy(retval, _msg.psz_name, len);
-                        STRINGN_TO_NPVARIANT(retval, len, result);
-                    }
-                }
-                else
-                {
-                    NULL_TO_NPVARIANT(result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_message_header:
-            {
-                if( _msg.psz_header )
-                {
-                    int len = strlen(_msg.psz_header);
-                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
-                    if( retval )
-                    {
-                        memcpy(retval, _msg.psz_header, len);
-                        STRINGN_TO_NPVARIANT(retval, len, result);
-                    }
-                }
-                else
-                {
-                    NULL_TO_NPVARIANT(result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_message_message:
-            {
-                if( _msg.psz_message )
-                {
-                    int len = strlen(_msg.psz_message);
-                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
-                    if( retval )
-                    {
-                        memcpy(retval, _msg.psz_message, len);
-                        STRINGN_TO_NPVARIANT(retval, len, result);
-                    }
-                }
-                else
-                {
-                    NULL_TO_NPVARIANT(result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcMessageNPObject::methodNames[] =
-{
-    /* no methods */
-};
-
-const int LibvlcMessageNPObject::methodCount = sizeof(LibvlcMessageNPObject::methodNames)/sizeof(NPUTF8 *);
-
-/*
-** implementation of libvlc message iterator object
-*/
-
-LibvlcMessageIteratorNPObject::LibvlcMessageIteratorNPObject(NPP instance, const NPClass *aClass) :
-    RuntimeNPObject(instance, aClass),
-    _p_iter(NULL)
-{
-    /* is plugin still running */
-    if( instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(instance->pdata);
-        libvlc_log_t *p_log = p_plugin->getLog();
-        if( p_log )
-        {
-            _p_iter = libvlc_log_get_iterator(p_log, NULL);
-        }
-    }
-};
-
-LibvlcMessageIteratorNPObject::~LibvlcMessageIteratorNPObject()
-{
-    if( _p_iter )
-        libvlc_log_iterator_free(_p_iter, NULL);
-}
-
-const NPUTF8 * const LibvlcMessageIteratorNPObject::propertyNames[] = 
-{
-    "hasNext",
-};
-
-const int LibvlcMessageIteratorNPObject::propertyCount = sizeof(LibvlcMessageIteratorNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcMessageIteratorNPObjectPropertyIds
-{
-    ID_messageiterator_hasNext,
-};
-
-RuntimeNPObject::InvokeResult LibvlcMessageIteratorNPObject::getProperty(int index, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        switch( index )
-        {
-            case ID_messageiterator_hasNext:
-            {
-                if( _p_iter && p_plugin->getLog() )
-                {
-                    libvlc_exception_t ex;
-                    libvlc_exception_init(&ex);
-
-                    BOOLEAN_TO_NPVARIANT(libvlc_log_iterator_has_next(_p_iter, &ex), result);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                }
-                else
-                {
-                    BOOLEAN_TO_NPVARIANT(0, result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcMessageIteratorNPObject::methodNames[] =
-{
-    "next",
-};
-
-const int LibvlcMessageIteratorNPObject::methodCount = sizeof(LibvlcMessageIteratorNPObject::methodNames)/sizeof(NPUTF8 *);
-
-enum LibvlcMessageIteratorNPObjectMethodIds
-{
-    ID_messageiterator_next,
-};
-
-RuntimeNPObject::InvokeResult LibvlcMessageIteratorNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_messageiterator_next:
-                if( argCount == 0 )
-                {
-                    if( _p_iter && p_plugin->getLog() )
-                    {
-                        struct libvlc_log_message_t buffer;
-
-                        buffer.sizeof_msg = sizeof(buffer);
-
-                        libvlc_log_iterator_next(_p_iter, &buffer, &ex);
-                        if( libvlc_exception_raised(&ex) )
-                        {
-                            NPN_SetException(this, libvlc_exception_get_message(&ex));
-                            libvlc_exception_clear(&ex);
-                            return INVOKERESULT_GENERIC_ERROR;
-                        }
-                        else
-                        {
-                            LibvlcMessageNPObject* message =
-                                static_cast<LibvlcMessageNPObject*>(NPN_CreateObject(_instance, RuntimeNPClass<LibvlcMessageNPObject>::getClass()));
-                            if( message )
-                            {
-                                message->setMessage(buffer);
-                                OBJECT_TO_NPVARIANT(message, result);
-                                return INVOKERESULT_NO_ERROR;
-                            }
-                            return INVOKERESULT_OUT_OF_MEMORY;
-                        }
-                    }
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
- 
-/*
-** implementation of libvlc message object
-*/
-
-const NPUTF8 * const LibvlcMessagesNPObject::propertyNames[] = 
-{
-    "count",
-};
-
-const int LibvlcMessagesNPObject::propertyCount = sizeof(LibvlcMessagesNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcMessagesNPObjectPropertyIds
-{
-    ID_messages_count,
-};
-
-RuntimeNPObject::InvokeResult LibvlcMessagesNPObject::getProperty(int index, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        switch( index )
-        {
-            case ID_messages_count:
-            {
-                libvlc_log_t *p_log = p_plugin->getLog();
-                if( p_log )
-                {
-                    libvlc_exception_t ex;
-                    libvlc_exception_init(&ex);
-
-                    INT32_TO_NPVARIANT(libvlc_log_count(p_log, &ex), result);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                }
-                else
-                {
-                    INT32_TO_NPVARIANT(0, result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcMessagesNPObject::methodNames[] =
-{
-    "clear",
-    "iterator",
-};
-
-const int LibvlcMessagesNPObject::methodCount = sizeof(LibvlcMessagesNPObject::methodNames)/sizeof(NPUTF8 *);
-
-enum LibvlcMessagesNPObjectMethodIds
-{
-    ID_messages_clear,
-    ID_messages_iterator,
-};
-
-RuntimeNPObject::InvokeResult LibvlcMessagesNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_messages_clear:
-                if( argCount == 0 )
-                {
-                    libvlc_log_t *p_log = p_plugin->getLog();
-                    if( p_log )
-                    {
-                        libvlc_log_clear(p_log, &ex);
-                        if( libvlc_exception_raised(&ex) )
-                        {
-                            NPN_SetException(this, libvlc_exception_get_message(&ex));
-                            libvlc_exception_clear(&ex);
-                            return INVOKERESULT_GENERIC_ERROR;
-                        }
-                    }
-                    return INVOKERESULT_NO_ERROR;
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-
-            case ID_messages_iterator:
-                if( argCount == 0 )
-                {
-                    LibvlcMessageIteratorNPObject* iter =
-                        static_cast<LibvlcMessageIteratorNPObject*>(NPN_CreateObject(_instance, RuntimeNPClass<LibvlcMessageIteratorNPObject>::getClass()));
-                    if( iter )
-                    {
-                        OBJECT_TO_NPVARIANT(iter, result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                    return INVOKERESULT_OUT_OF_MEMORY;
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
- 
-/*
-** implementation of libvlc message object
-*/
-
-
-LibvlcLogNPObject::~LibvlcLogNPObject()
-{
-    if( isValid() )
-    {
-        if( messagesObj ) NPN_ReleaseObject(messagesObj);
-    }
-};
-
-const NPUTF8 * const LibvlcLogNPObject::propertyNames[] = 
-{
-    "messages",
-    "verbosity",
-};
-
-const int LibvlcLogNPObject::propertyCount = sizeof(LibvlcLogNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcLogNPObjectPropertyIds
-{
-    ID_log_messages,
-    ID_log_verbosity,
-};
-
-RuntimeNPObject::InvokeResult LibvlcLogNPObject::getProperty(int index, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_log_messages:
-            {
-                // create child object in lazyman fashion to avoid ownership problem with firefox
-                if( ! messagesObj )
-                    messagesObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcMessagesNPObject>::getClass());
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(messagesObj), result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_log_verbosity:
-            {
-                if( p_plugin->getLog() )
-                {
-                    INT32_TO_NPVARIANT(libvlc_get_log_verbosity(p_plugin->getVLC(),
-                                                                    &ex), result);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                }
-                else
-                {
-                    /* log is not enabled, return -1 */
-                    DOUBLE_TO_NPVARIANT(-1.0, result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-RuntimeNPObject::InvokeResult LibvlcLogNPObject::setProperty(int index, const NPVariant &value)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_log_verbosity:
-                if( isNumberValue(value) )
-                {
-                    libvlc_instance_t* p_libvlc = p_plugin->getVLC();
-                    libvlc_log_t *p_log = p_plugin->getLog();
-                    int verbosity = numberValue(value);
-                    if( verbosity >= 0 )
-                    {
-                        if( ! p_log )
-                        {
-                            p_log = libvlc_log_open(p_libvlc, &ex);
-                            if( libvlc_exception_raised(&ex) )
-                            {
-                                NPN_SetException(this, libvlc_exception_get_message(&ex));
-                                libvlc_exception_clear(&ex);
-                                return INVOKERESULT_GENERIC_ERROR;
-                            }
-                            p_plugin->setLog(p_log);
-                        }
-                        libvlc_set_log_verbosity(p_libvlc, (unsigned)verbosity, &ex);
-                        if( libvlc_exception_raised(&ex) )
-                        {
-                            NPN_SetException(this, libvlc_exception_get_message(&ex));
-                            libvlc_exception_clear(&ex);
-                            return INVOKERESULT_GENERIC_ERROR;
-                        }
-                    }
-                    else if( p_log )
-                    {
-                        /* close log  when verbosity is set to -1 */
-                        p_plugin->setLog(NULL);
-                        libvlc_log_close(p_log, &ex);
-                        if( libvlc_exception_raised(&ex) )
-                        {
-                            NPN_SetException(this, libvlc_exception_get_message(&ex));
-                            libvlc_exception_clear(&ex);
-                            return INVOKERESULT_GENERIC_ERROR;
-                        }
-                    }
-                    return INVOKERESULT_NO_ERROR;
-                }
-                return INVOKERESULT_INVALID_VALUE;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcLogNPObject::methodNames[] =
-{
-    /* no methods */
-};
-
-const int LibvlcLogNPObject::methodCount = sizeof(LibvlcLogNPObject::methodNames)/sizeof(NPUTF8 *);
-
-/*
-** implementation of libvlc playlist items object
-*/
-
-const NPUTF8 * const LibvlcPlaylistItemsNPObject::propertyNames[] = 
-{
-    "count",
-};
-
-const int LibvlcPlaylistItemsNPObject::propertyCount = sizeof(LibvlcPlaylistItemsNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcPlaylistItemsNPObjectPropertyIds
-{
-    ID_playlistitems_count,
-};
-
-RuntimeNPObject::InvokeResult LibvlcPlaylistItemsNPObject::getProperty(int index, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_playlistitems_count:
-            {
-                int val = libvlc_playlist_items_count(p_plugin->getVLC(), &ex);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                INT32_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcPlaylistItemsNPObject::methodNames[] =
-{
-    "clear",
-    "remove",
-};
-
-const int LibvlcPlaylistItemsNPObject::methodCount = sizeof(LibvlcPlaylistItemsNPObject::methodNames)/sizeof(NPUTF8 *);
-
-enum LibvlcPlaylistItemsNPObjectMethodIds
-{
-    ID_playlistitems_clear,
-    ID_playlistitems_remove,
-};
-
-RuntimeNPObject::InvokeResult LibvlcPlaylistItemsNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_playlistitems_clear:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_clear(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_playlistitems_remove:
-                if( (argCount == 1) && isNumberValue(args[0]) )
-                {
-                    libvlc_playlist_delete_item(p_plugin->getVLC(), numberValue(args[0]), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-/*
-** implementation of libvlc playlist object
-*/
-
-
-LibvlcPlaylistNPObject::~LibvlcPlaylistNPObject()
-{
-    if( isValid() )
-    {
-        if( playlistItemsObj ) NPN_ReleaseObject(playlistItemsObj);
-    }
-};
-
-const NPUTF8 * const LibvlcPlaylistNPObject::propertyNames[] = 
-{
-    "itemCount", /* deprecated */
-    "isPlaying",
-    "items",
-};
-
-const int LibvlcPlaylistNPObject::propertyCount = sizeof(LibvlcPlaylistNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcPlaylistNPObjectPropertyIds
-{
-    ID_playlist_itemcount,
-    ID_playlist_isplaying,
-    ID_playlist_items,
-};
-
-RuntimeNPObject::InvokeResult LibvlcPlaylistNPObject::getProperty(int index, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_playlist_itemcount: /* deprecated */
-            {
-                int val = libvlc_playlist_items_count(p_plugin->getVLC(), &ex);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                INT32_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_playlist_isplaying:
-            {
-                int val = libvlc_playlist_isplaying(p_plugin->getVLC(), &ex);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                BOOLEAN_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_playlist_items:
-            {
-                // create child object in lazyman fashion to avoid ownership problem with firefox
-                if( ! playlistItemsObj )
-                    playlistItemsObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcPlaylistItemsNPObject>::getClass());
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(playlistItemsObj), result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcPlaylistNPObject::methodNames[] =
-{
-    "add",
-    "play",
-    "playItem",
-    "togglePause",
-    "stop",
-    "next",
-    "prev",
-    "clear", /* deprecated */
-    "removeItem", /* deprecated */
-};
-
-const int LibvlcPlaylistNPObject::methodCount = sizeof(LibvlcPlaylistNPObject::methodNames)/sizeof(NPUTF8 *);
-
-enum LibvlcPlaylistNPObjectMethodIds
-{
-    ID_playlist_add,
-    ID_playlist_play,
-    ID_playlist_playItem,
-    ID_playlist_togglepause,
-    ID_playlist_stop,
-    ID_playlist_next,
-    ID_playlist_prev,
-    ID_playlist_clear,
-    ID_playlist_removeitem
-};
-
-RuntimeNPObject::InvokeResult LibvlcPlaylistNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_playlist_add:
-            {
-                if( (argCount < 1) || (argCount > 3) )
-                    return INVOKERESULT_NO_SUCH_METHOD;
-
-                char *url = NULL;
-
-                // grab URL
-                if( NPVARIANT_IS_STRING(args[0]) )
-                {
-                    char *s = stringValue(NPVARIANT_TO_STRING(args[0]));
-                    if( s )
-                    {
-                        url = p_plugin->getAbsoluteURL(s);
-                        if( url )
-                            delete s;
-                        else
-                            // problem with combining url, use argument
-                            url = s;
-                    }
-                    else
-                        return INVOKERESULT_OUT_OF_MEMORY;
-                }
-                else
-                    return INVOKERESULT_NO_SUCH_METHOD;
-
-                char *name = NULL;
-
-                // grab name if available
-                if( argCount > 1 )
-                {
-                    if( NPVARIANT_IS_NULL(args[1]) )
-                    {
-                        // do nothing
-                    }
-                    else if( NPVARIANT_IS_STRING(args[1]) )
-                    {
-                        name = stringValue(NPVARIANT_TO_STRING(args[0]));
-                    }
-                    else
-                    {
-                        delete url;
-                        return INVOKERESULT_INVALID_VALUE;
-                    }
-                }
-
-                int i_options = 0;
-                char** ppsz_options = NULL;
-
-                // grab options if available
-                if( argCount > 2 )
-                {
-                    if( NPVARIANT_IS_NULL(args[2]) )
-                    {
-                        // do nothing
-                    }
-                    else if( NPVARIANT_IS_STRING(args[2]) )
-                    {
-                        parseOptions(NPVARIANT_TO_STRING(args[2]), &i_options, &ppsz_options);
-
-                    }
-                    else if( NPVARIANT_IS_OBJECT(args[2]) )
-                    {
-                        parseOptions(NPVARIANT_TO_OBJECT(args[2]), &i_options, &ppsz_options);
-                    }
-                    else
-                    {
-                        delete url;
-                        delete name;
-                        return INVOKERESULT_INVALID_VALUE;
-                    }
-                }
-
-                int item = libvlc_playlist_add_extended(p_plugin->getVLC(),
-                                                        url,
-                                                        name,
-                                                        i_options,
-                                                        const_cast<const char **>(ppsz_options),
-                                                        &ex);
-                delete url;
-                delete name;
-                for( int i=0; i< i_options; ++i )
-                {
-                    delete ppsz_options[i];
-                }
-                delete ppsz_options;
-
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                else
-                {
-                    INT32_TO_NPVARIANT(item, result);
-                    return INVOKERESULT_NO_ERROR;
-                }
-            }
-            case ID_playlist_play:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_play(p_plugin->getVLC(), -1, 0, NULL, &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_playlist_playItem:
-                if( (argCount == 1) && isNumberValue(args[0]) )
-                {
-                    libvlc_playlist_play(p_plugin->getVLC(), numberValue(args[0]), 0, NULL, &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_playlist_togglepause:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_pause(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_playlist_stop:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_stop(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_playlist_next:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_next(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_playlist_prev:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_prev(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_playlist_clear: /* deprecated */
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_clear(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_playlist_removeitem: /* deprecated */
-                if( (argCount == 1) && isNumberValue(args[0]) )
-                {
-                    libvlc_playlist_delete_item(p_plugin->getVLC(), numberValue(args[0]), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-void LibvlcPlaylistNPObject::parseOptions(const NPString &nps, int *i_options, char*** ppsz_options)
-{
-    if( nps.utf8length )
-    {
-        char *s = stringValue(nps);
-        char *val = s;
-        if( val )
-        {
-            long capacity = 16;
-            char **options = (char **)malloc(capacity*sizeof(char *));
-            if( options )
-            {
-                int nOptions = 0;
-
-                char *end = val + nps.utf8length;
-                while( val < end )
-                {
-                    // skip leading blanks
-                    while( (val < end)
-                        && ((*val == ' ' ) || (*val == '\t')) )
-                        ++val;
-
-                    char *start = val;
-                    // skip till we get a blank character
-                    while( (val < end)
-                        && (*val != ' ' )
-                        && (*val != '\t') )
-                    {
-                        char c = *(val++);
-                        if( ('\'' == c) || ('"' == c) )
-                        {
-                            // skip till end of string
-                            while( (val < end) && (*(val++) != c ) );
-                        }
-                    }
-
-                    if( val > start )
-                    {
-                        if( nOptions == capacity )
-                        {
-                            capacity += 16;
-                            char **moreOptions = (char **)realloc(options, capacity*sizeof(char*)); 
-                            if( ! moreOptions )
-                            {
-                                /* failed to allocate more memory */
-                                delete s;
-                                /* return what we got so far */
-                                *i_options = nOptions;
-                                *ppsz_options = options;
-                                return;
-                            }
-                            options = moreOptions;
-                        }
-                        *(val++) = '\0';
-                        options[nOptions++] = strdup(start);
-                    }
-                    else
-                        // must be end of string
-                        break;
-                }
-                *i_options = nOptions;
-                *ppsz_options = options;
-            }
-            delete s;
-        }
-    }
-}
-
-void LibvlcPlaylistNPObject::parseOptions(NPObject *obj, int *i_options, char*** ppsz_options)
-{
-    /* WARNING: Safari does not implement NPN_HasProperty/NPN_HasMethod */
-
-    NPVariant value;
-
-    /* we are expecting to have a Javascript Array object */
-    NPIdentifier propId = NPN_GetStringIdentifier("length");
-    if( NPN_GetProperty(_instance, obj, propId, &value) )
-    {
-        int count = numberValue(value);
-        NPN_ReleaseVariantValue(&value);
-
-        if( count )
-        {
-            long capacity = 16;
-            char **options = (char **)malloc(capacity*sizeof(char *));
-            if( options )
-            {
-                int nOptions = 0;
-
-                while( nOptions < count )
-                {
-                    propId = NPN_GetIntIdentifier(nOptions);
-                    if( ! NPN_GetProperty(_instance, obj, propId, &value) )
-                        /* return what we got so far */
-                        break;
-
-                    if( ! NPVARIANT_IS_STRING(value) )
-                    {
-                        /* return what we got so far */
-                        NPN_ReleaseVariantValue(&value);
-                        break;
-                    }
-
-                    if( nOptions == capacity )
-                    {
-                        capacity += 16;
-                        char **moreOptions = (char **)realloc(options, capacity*sizeof(char*)); 
-                        if( ! moreOptions )
-                        {
-                            /* failed to allocate more memory */
-                            NPN_ReleaseVariantValue(&value);
-                            /* return what we got so far */
-                            *i_options = nOptions;
-                            *ppsz_options = options;
-                            break;
-                        }
-                        options = moreOptions;
-                    }
-
-                    options[nOptions++] = stringValue(value);
-                }
-                *i_options = nOptions;
-                *ppsz_options = options;
-            }
-        }
-    }
-}
-
-/*
-** implementation of libvlc video object
-*/
-
-const NPUTF8 * const LibvlcVideoNPObject::propertyNames[] = 
-{
-    "fullscreen",
-    "height",
-    "width",
-    "aspectRatio"
-};
-
-enum LibvlcVideoNPObjectPropertyIds
-{
-    ID_video_fullscreen,
-    ID_video_height,
-    ID_video_width,
-    ID_video_aspectratio
-};
-
-const int LibvlcVideoNPObject::propertyCount = sizeof(LibvlcVideoNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-RuntimeNPObject::InvokeResult LibvlcVideoNPObject::getProperty(int index, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
-        if( libvlc_exception_raised(&ex) )
-        {
-            NPN_SetException(this, libvlc_exception_get_message(&ex));
-            libvlc_exception_clear(&ex);
-            return INVOKERESULT_GENERIC_ERROR;
-        }
-
-        switch( index )
-        {
-            case ID_video_fullscreen:
-            {
-                int val = libvlc_get_fullscreen(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                BOOLEAN_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_video_height:
-            {
-                int val = libvlc_video_get_height(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                INT32_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_video_width:
-            {
-                int val = libvlc_video_get_width(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                INT32_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_video_aspectratio:
-            {
-                NPUTF8 *psz_aspect = libvlc_video_get_aspect_ratio(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                if( !psz_aspect )
-                    return INVOKERESULT_GENERIC_ERROR;
-
-                STRINGZ_TO_NPVARIANT(psz_aspect, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-        }
-        libvlc_input_free(p_input);
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-RuntimeNPObject::InvokeResult LibvlcVideoNPObject::setProperty(int index, const NPVariant &value)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
-        if( libvlc_exception_raised(&ex) )
-        {
-            NPN_SetException(this, libvlc_exception_get_message(&ex));
-            libvlc_exception_clear(&ex);
-            return INVOKERESULT_GENERIC_ERROR;
-        }
-
-        switch( index )
-        {
-            case ID_video_fullscreen:
-            {
-                if( ! NPVARIANT_IS_BOOLEAN(value) )
-                {
-                    libvlc_input_free(p_input);
-                    return INVOKERESULT_INVALID_VALUE;
-                }
-
-                int val = NPVARIANT_TO_BOOLEAN(value);
-                libvlc_set_fullscreen(p_input, val, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_video_aspectratio:
-            {
-                char *psz_aspect = NULL;
-
-                if( ! NPVARIANT_IS_STRING(value) )
-                {
-                    libvlc_input_free(p_input);
-                    return INVOKERESULT_INVALID_VALUE;
-                }
-
-                psz_aspect = stringValue(NPVARIANT_TO_STRING(value));
-                if( !psz_aspect )
-                {
-                    libvlc_input_free(p_input);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-
-                libvlc_video_set_aspect_ratio(p_input, psz_aspect, &ex);
-                delete psz_aspect;
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-        }
-        libvlc_input_free(p_input);
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcVideoNPObject::methodNames[] =
-{
-    "toggleFullscreen",
-};
-
-enum LibvlcVideoNPObjectMethodIds
-{
-    ID_video_togglefullscreen,
-};
-
-const int LibvlcVideoNPObject::methodCount = sizeof(LibvlcVideoNPObject::methodNames)/sizeof(NPUTF8 *);
-
-RuntimeNPObject::InvokeResult LibvlcVideoNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    /* is plugin still running */
-    if( _instance->pdata )
-    {
-        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
-        if( libvlc_exception_raised(&ex) )
-        {
-            NPN_SetException(this, libvlc_exception_get_message(&ex));
-            libvlc_exception_clear(&ex);
-            return INVOKERESULT_GENERIC_ERROR;
-        }
-
-        switch( index )
-        {
-            case ID_video_togglefullscreen:
-                if( argCount == 0 )
-                {
-                    libvlc_toggle_fullscreen(p_input, &ex);
-                    libvlc_input_free(p_input);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                else
-                {
-                    /* cannot get input, probably not playing */
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                    }
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            default:
-                return INVOKERESULT_NO_SUCH_METHOD;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
+/*****************************************************************************
+ * npolibvlc.cpp: official Javascript APIs
+ *****************************************************************************
+ * Copyright (C) 2002-2006 the VideoLAN team
+ *
+ * Authors: Damien Fouilleul <Damien.Fouilleul@laposte.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include "config.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+/* Mozilla stuff */
+#ifdef HAVE_MOZILLA_CONFIG_H
+#   include <mozilla-config.h>
+#endif
+
+#include "npolibvlc.h"
+#include "vlcplugin.h"
+
+//#define DEBUG_METADATA_OBJECT
+
+#define JS_EVAL_BUFFER_SIZE 16384
+namespace VLCUtils 
+{
+
+void GetMetadata(libvlc_instance_t *instance, vlc_meta_t **metadata, libvlc_exception_t* ex)
+{
+  if(!instance)
+    return;
+  
+  libvlc_playlist_get_metadata(instance, metadata, ex);
+ 
+  return;
+}
+
+char *GetMetadataString( libvlc_instance_t *instance, const char *category, const char *key, libvlc_exception_t* ex)
+{
+  char *metadataStr = NULL;
+  vlc_meta_t *metadata = NULL;
+
+  if(!instance ||
+     !category ||
+     !key)
+    return metadataStr;
+
+  GetMetadata(instance, &metadata, ex);
+  if( libvlc_exception_raised(ex) ) 
+    return metadataStr;
+
+  metadataStr = GetMetadataString(metadata, category, key);
+  vlc_meta_Delete(metadata);
+
+  return metadataStr;
+}
+
+char *GetMetadataString(vlc_meta_t *metadata, const char *category, const char *key)
+{
+  char *metadataStr = NULL;
+  
+  if(!metadata ||
+     !category ||
+     !key)
+    return metadataStr;
+
+  for(int i = 0; i < metadata->i_track; i++)
+  {
+    if(!strcmp(category, metadata->track[i]->value[0]))
+    {
+      for( int j = 0; j < metadata->track[i]->track[0]->i_meta; j++ )
+      {
+        if( !strcmp( metadata->track[i]->track[0]->name[j], key ) )
+        {
+#if defined(DEBUG_METADATA_OBJECT)
+          printf("\nGetMetadataString found %s:%s => %s\n", category, key, metadata->track[i]->track[0]->value[j]);
+#endif
+          if( metadata->track[i]->track[0]->value[j] ) 
+            metadataStr = strdup( metadata->track[i]->track[0]->value[j] );
+            
+          break;
+        }
+      }
+    }
+  }
+  
+  return metadataStr;
+}
+
+int GetMetadataCategoryCount(libvlc_instance_t *instance,  libvlc_exception_t* ex)
+{
+  int count = 0;
+  vlc_meta_t *metadata = NULL;
+
+  if(!instance)
+    return count;
+
+  GetMetadata(instance, &metadata, ex);
+  if( libvlc_exception_raised(ex) ) 
+    return count;
+
+  count = metadata->i_track;
+  
+  vlc_meta_Delete(metadata);
+  
+  return count;
+}
+
+int GetMetadataCategoryCount(vlc_meta_t *metadata)
+{
+  return metadata->i_track;
+}
+
+char *GetMetadataCategoryString(libvlc_instance_t *instance, int index, libvlc_exception_t* ex)
+{
+  char *category = NULL;
+  vlc_meta_t *metadata = NULL;
+
+  if(!instance ||
+     index < 0)
+    return category;
+
+  GetMetadata(instance, &metadata, ex);
+  if( libvlc_exception_raised(ex) ) 
+    return category;
+
+  category = GetMetadataCategoryString(metadata, index);
+  
+  vlc_meta_Delete(metadata);
+  
+  return category;
+}
+
+char *GetMetadataCategoryString(vlc_meta_t *metadata, int index)
+{
+  if(!metadata || 
+     index >= metadata->i_track) 
+    return NULL;
+    
+  return strdup(metadata->track[index]->value[0]);
+}
+
+int GetMetadataKeyCount(libvlc_instance_t * instance, const char *category, libvlc_exception_t* ex)
+{
+  int count = 0;
+  
+  if(!instance ||
+     !category)
+    return count;
+    
+  vlc_meta_t *metadata = NULL;
+  GetMetadata(instance, &metadata, ex);
+  if( libvlc_exception_raised(ex) ) 
+    return count;
+
+  count = GetMetadataKeyCount(metadata, category);
+
+  vlc_meta_Delete(metadata);
+   
+  return count;
+}
+
+int GetMetadataKeyCount(vlc_meta_t *metadata, const char *category)
+{
+  int count = 0;
+  
+  if(!metadata ||
+     !category)
+    return count;
+    
+  for(int i = 0; i < metadata->i_track; i++)
+  {
+    if(!strcmp(category, metadata->track[i]->value[0]))
+    {
+      count = metadata->track[i]->track[0]->i_meta;
+      break;
+    }
+  }
+
+  return count;
+}
+
+char *GetMetadataKeyString(libvlc_instance_t *instance, const char *category, int index, libvlc_exception_t* ex)
+{
+  char *key = NULL;
+  
+  if(!instance ||
+     !category ||
+     index < 0)
+    return key;
+    
+  vlc_meta_t *metadata = NULL;
+  GetMetadata(instance, &metadata, ex);
+  if( libvlc_exception_raised(ex) ) 
+    return key;
+
+  key = GetMetadataKeyString(metadata, category, index);
+    
+  return key;
+}
+
+char *GetMetadataKeyString(vlc_meta_t *metadata, const char *category, int index)
+{
+  char *key = NULL;
+  
+  if(!metadata ||
+     !category ||
+     index < 0)
+    return key;
+    
+  for(int i = 0; i < metadata->i_track; i++)
+  {
+    if(!strcmp(category, metadata->track[i]->value[0]) &&
+       index < metadata->track[i]->track[0]->i_meta)
+    {
+      key = strdup(metadata->track[i]->track[0]->name[index]);
+      break;
+    }
+  }
+ 
+  return key;
+}
+
+} //namespace VLCUtils
+
+/*
+** implementation of libvlc root object
+*/
+
+LibvlcRootNPObject::~LibvlcRootNPObject()
+{
+    /*
+    ** when plugin is destroyed, firefox takes upon itself to destroy all 'live' script objects
+    ** and ignores refcounting. Therefore we cannot safely assume  that refcounting will control
+    ** lifespan of objects. Hence they are only lazily created on request, so that firefox can
+    ** take ownership, and are not released when plugin is being destroyed.
+    */
+    if( isValid() )
+    {
+        if( audioObj    ) NPN_ReleaseObject(audioObj);
+        if( inputObj    ) NPN_ReleaseObject(inputObj);
+        if( logObj      ) NPN_ReleaseObject(logObj);
+        if( playlistObj ) NPN_ReleaseObject(playlistObj);
+        if( videoObj    ) NPN_ReleaseObject(videoObj);
+        if( metadataObj ) NPN_ReleaseObject(metadataObj);
+    }
+}
+
+const NPUTF8 * const LibvlcRootNPObject::propertyNames[] = 
+{
+    "audio",
+    "input",
+    "log",
+    "playlist",
+    "video",
+    "metadata",
+    "VersionInfo",
+};
+
+const int LibvlcRootNPObject::propertyCount = sizeof(LibvlcRootNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcRootNPObjectPropertyIds
+{
+    ID_root_audio = 0,
+    ID_root_input,
+    ID_root_log,
+    ID_root_playlist,
+    ID_root_video,
+    ID_root_metadata,
+    ID_root_VersionInfo,
+};
+
+RuntimeNPObject::InvokeResult LibvlcRootNPObject::getProperty(int index, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        switch( index )
+        {
+            case ID_root_audio:
+                // create child object in lazyman fashion to avoid ownership problem with firefox
+                if( ! audioObj )
+                    audioObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcAudioNPObject>::getClass());
+                OBJECT_TO_NPVARIANT(NPN_RetainObject(audioObj), result);
+                return INVOKERESULT_NO_ERROR;
+            case ID_root_input:
+                // create child object in lazyman fashion to avoid ownership problem with firefox
+                if( ! inputObj )
+                    inputObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcInputNPObject>::getClass());
+                OBJECT_TO_NPVARIANT(NPN_RetainObject(inputObj), result);
+                return INVOKERESULT_NO_ERROR;
+            case ID_root_log:
+                // create child object in lazyman fashion to avoid ownership problem with firefox
+                if( ! logObj )
+                    logObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcLogNPObject>::getClass());
+                OBJECT_TO_NPVARIANT(NPN_RetainObject(logObj), result);
+                return INVOKERESULT_NO_ERROR;
+            case ID_root_playlist:
+                // create child object in lazyman fashion to avoid ownership problem with firefox
+                if( ! playlistObj )
+                    playlistObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcPlaylistNPObject>::getClass());
+                OBJECT_TO_NPVARIANT(NPN_RetainObject(playlistObj), result);
+                return INVOKERESULT_NO_ERROR;
+            case ID_root_video:
+                // create child object in lazyman fashion to avoid ownership problem with firefox
+                if( ! videoObj )
+                    videoObj = NPN_CreateObject(_instance,RuntimeNPClass<LibvlcVideoNPObject>::getClass());
+                OBJECT_TO_NPVARIANT(NPN_RetainObject(videoObj), result);
+                return INVOKERESULT_NO_ERROR;
+            case ID_root_metadata:
+                // create child object in lazyman fashion to avoid ownership problem with firefox
+                if( ! metadataObj )
+                    metadataObj = NPN_CreateObject(_instance,RuntimeNPClass<LibvlcMetadataNPObject>::getClass());
+                OBJECT_TO_NPVARIANT(NPN_RetainObject(metadataObj), result);
+                return INVOKERESULT_NO_ERROR;
+            case ID_root_VersionInfo:
+            {
+                int len = strlen(VLC_Version());
+                NPUTF8 *retval =(NPUTF8*)NPN_MemAlloc(len);
+                if( retval )
+                {
+                    memcpy(retval, VLC_Version(), len);
+                    STRINGN_TO_NPVARIANT(retval, len, result);
+                }
+                else
+                {
+                    NULL_TO_NPVARIANT(result);
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcRootNPObject::methodNames[] =
+{
+    "versionInfo",
+};
+
+const int LibvlcRootNPObject::methodCount = sizeof(LibvlcRootNPObject::methodNames)/sizeof(NPUTF8 *);
+
+enum LibvlcRootNPObjectMethodIds
+{
+    ID_root_versionInfo,
+};
+
+RuntimeNPObject::InvokeResult LibvlcRootNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_root_versionInfo:
+                if( argCount == 0 )
+                {
+                    int len = strlen(VLC_Version());
+                    NPUTF8 *retval =(NPUTF8*)NPN_MemAlloc(len);
+                    if( retval )
+                    {
+                        memcpy(retval, VLC_Version(), len);
+                        STRINGN_TO_NPVARIANT(retval, len, result);
+                    }
+                    else
+                    {
+                        NULL_TO_NPVARIANT(result);
+                    }
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+/*
+** implementation of libvlc audio object
+*/
+
+const NPUTF8 * const LibvlcAudioNPObject::propertyNames[] = 
+{
+    "mute",
+    "volume",
+};
+
+const int LibvlcAudioNPObject::propertyCount = sizeof(LibvlcAudioNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcAudioNPObjectPropertyIds
+{
+    ID_audio_mute,
+    ID_audio_volume
+};
+
+RuntimeNPObject::InvokeResult LibvlcAudioNPObject::getProperty(int index, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_audio_mute:
+            {
+                vlc_bool_t muted = libvlc_audio_get_mute(p_plugin->getVLC(), &ex);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                BOOLEAN_TO_NPVARIANT(muted, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_audio_volume:
+            {
+                int volume = libvlc_audio_get_volume(p_plugin->getVLC(), &ex);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                INT32_TO_NPVARIANT(volume, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+RuntimeNPObject::InvokeResult LibvlcAudioNPObject::setProperty(int index, const NPVariant &value)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_audio_mute:
+                if( NPVARIANT_IS_BOOLEAN(value) )
+                {
+                    libvlc_audio_set_mute(p_plugin->getVLC(),
+                                          NPVARIANT_TO_BOOLEAN(value), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_INVALID_VALUE;
+            case ID_audio_volume:
+                if( isNumberValue(value) )
+                {
+                    libvlc_audio_set_volume(p_plugin->getVLC(),
+                                            numberValue(value), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_INVALID_VALUE;
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcAudioNPObject::methodNames[] =
+{
+    "toggleMute",
+};
+
+const int LibvlcAudioNPObject::methodCount = sizeof(LibvlcAudioNPObject::methodNames)/sizeof(NPUTF8 *);
+
+enum LibvlcAudioNPObjectMethodIds
+{
+    ID_audio_togglemute,
+};
+
+RuntimeNPObject::InvokeResult LibvlcAudioNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_audio_togglemute:
+                if( argCount == 0 )
+                {
+                    libvlc_audio_toggle_mute(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+/*
+** implementation of libvlc input object
+*/
+
+const NPUTF8 * const LibvlcInputNPObject::propertyNames[] = 
+{
+    "length",
+    "position",
+    "time",
+    "state",
+    "rate",
+    "fps",
+    "hasVout",
+};
+
+const int LibvlcInputNPObject::propertyCount = sizeof(LibvlcInputNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcInputNPObjectPropertyIds
+{
+    ID_input_length,
+    ID_input_position,
+    ID_input_time,
+    ID_input_state,
+    ID_input_rate,
+    ID_input_fps,
+    ID_input_hasvout,
+};
+
+RuntimeNPObject::InvokeResult LibvlcInputNPObject::getProperty(int index, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
+        if( libvlc_exception_raised(&ex) )
+        {
+            if( index != ID_input_state )
+            {
+                NPN_SetException(this, libvlc_exception_get_message(&ex));
+                libvlc_exception_clear(&ex);
+                return INVOKERESULT_GENERIC_ERROR;
+            }
+            else
+            {
+                /* for input state, return CLOSED rather than an exception */
+                INT32_TO_NPVARIANT(0, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+
+        switch( index )
+        {
+            case ID_input_length:
+            {
+                double val = (double)libvlc_input_get_length(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                DOUBLE_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_input_position:
+            {
+                double val = libvlc_input_get_position(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                DOUBLE_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_input_time:
+            {
+                double val = (double)libvlc_input_get_time(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                DOUBLE_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_input_state:
+            {
+                int val = libvlc_input_get_state(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                INT32_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_input_rate:
+            {
+                float val = libvlc_input_get_rate(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                DOUBLE_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_input_fps:
+            {
+                double val = libvlc_input_get_fps(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                DOUBLE_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_input_hasvout:
+            {
+                vlc_bool_t val = libvlc_input_has_vout(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                BOOLEAN_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            default:
+                ;
+        }
+        libvlc_input_free(p_input);
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+RuntimeNPObject::InvokeResult LibvlcInputNPObject::setProperty(int index, const NPVariant &value)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
+        if( libvlc_exception_raised(&ex) )
+        {
+            NPN_SetException(this, libvlc_exception_get_message(&ex));
+            libvlc_exception_clear(&ex);
+            return INVOKERESULT_GENERIC_ERROR;
+        }
+
+        switch( index )
+        {
+            case ID_input_position:
+            {
+                if( ! NPVARIANT_IS_DOUBLE(value) )
+                {
+                    libvlc_input_free(p_input);
+                    return INVOKERESULT_INVALID_VALUE;
+                }
+
+                float val = (float)NPVARIANT_TO_DOUBLE(value);
+                libvlc_input_set_position(p_input, val, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_input_time:
+            {
+                vlc_int64_t val;
+                if( NPVARIANT_IS_INT32(value) )
+                    val = (vlc_int64_t)NPVARIANT_TO_INT32(value);
+                else if( NPVARIANT_IS_DOUBLE(value) )
+                    val = (vlc_int64_t)NPVARIANT_TO_DOUBLE(value);
+                else
+                {
+                    libvlc_input_free(p_input);
+                    return INVOKERESULT_INVALID_VALUE;
+                }
+
+                libvlc_input_set_time(p_input, val, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_input_rate:
+            {
+                float val;
+                if( NPVARIANT_IS_INT32(value) )
+                    val = (float)NPVARIANT_TO_INT32(value);
+                else if( NPVARIANT_IS_DOUBLE(value) )
+                    val = (float)NPVARIANT_TO_DOUBLE(value);
+                else
+                {
+                    libvlc_input_free(p_input);
+                    return INVOKERESULT_INVALID_VALUE;
+                }
+
+                libvlc_input_set_rate(p_input, val, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            default:
+                ;
+        }
+        libvlc_input_free(p_input);
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcInputNPObject::methodNames[] =
+{
+    /* no methods */
+};
+
+const int LibvlcInputNPObject::methodCount = sizeof(LibvlcInputNPObject::methodNames)/sizeof(NPUTF8 *);
+
+/*
+** implementation of libvlc message object
+*/
+
+const NPUTF8 * const LibvlcMessageNPObject::propertyNames[] = 
+{
+    "severity",
+    "type",
+    "name",
+    "header",
+    "message",
+};
+
+const int LibvlcMessageNPObject::propertyCount = sizeof(LibvlcMessageNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMessageNPObjectPropertyIds
+{
+    ID_message_severity,
+    ID_message_type,
+    ID_message_name,
+    ID_message_header,
+    ID_message_message,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMessageNPObject::getProperty(int index, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        switch( index )
+        {
+            case ID_message_severity:
+            {
+                INT32_TO_NPVARIANT(_msg.i_severity, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_message_type:
+            {
+                if( _msg.psz_type )
+                {
+                    int len = strlen(_msg.psz_type);
+                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
+                    if( retval )
+                    {
+                        memcpy(retval, _msg.psz_type, len);
+                        STRINGN_TO_NPVARIANT(retval, len, result);
+                    }
+                }
+                else
+                {
+                    NULL_TO_NPVARIANT(result);
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_message_name:
+            {
+                if( _msg.psz_name )
+                {
+                    int len = strlen(_msg.psz_name);
+                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
+                    if( retval )
+                    {
+                        memcpy(retval, _msg.psz_name, len);
+                        STRINGN_TO_NPVARIANT(retval, len, result);
+                    }
+                }
+                else
+                {
+                    NULL_TO_NPVARIANT(result);
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_message_header:
+            {
+                if( _msg.psz_header )
+                {
+                    int len = strlen(_msg.psz_header);
+                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
+                    if( retval )
+                    {
+                        memcpy(retval, _msg.psz_header, len);
+                        STRINGN_TO_NPVARIANT(retval, len, result);
+                    }
+                }
+                else
+                {
+                    NULL_TO_NPVARIANT(result);
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_message_message:
+            {
+                if( _msg.psz_message )
+                {
+                    int len = strlen(_msg.psz_message);
+                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
+                    if( retval )
+                    {
+                        memcpy(retval, _msg.psz_message, len);
+                        STRINGN_TO_NPVARIANT(retval, len, result);
+                    }
+                }
+                else
+                {
+                    NULL_TO_NPVARIANT(result);
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcMessageNPObject::methodNames[] =
+{
+    /* no methods */
+};
+
+const int LibvlcMessageNPObject::methodCount = sizeof(LibvlcMessageNPObject::methodNames)/sizeof(NPUTF8 *);
+
+/*
+** implementation of libvlc message iterator object
+*/
+
+LibvlcMessageIteratorNPObject::LibvlcMessageIteratorNPObject(NPP instance, const NPClass *aClass) :
+    RuntimeNPObject(instance, aClass),
+    _p_iter(NULL)
+{
+    /* is plugin still running */
+    if( instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(instance->pdata);
+        libvlc_log_t *p_log = p_plugin->getLog();
+        if( p_log )
+        {
+            _p_iter = libvlc_log_get_iterator(p_log, NULL);
+        }
+    }
+};
+
+LibvlcMessageIteratorNPObject::~LibvlcMessageIteratorNPObject()
+{
+    if( _p_iter )
+        libvlc_log_iterator_free(_p_iter, NULL);
+}
+
+const NPUTF8 * const LibvlcMessageIteratorNPObject::propertyNames[] = 
+{
+    "hasNext",
+};
+
+const int LibvlcMessageIteratorNPObject::propertyCount = sizeof(LibvlcMessageIteratorNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMessageIteratorNPObjectPropertyIds
+{
+    ID_messageiterator_hasNext,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMessageIteratorNPObject::getProperty(int index, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        switch( index )
+        {
+            case ID_messageiterator_hasNext:
+            {
+                if( _p_iter && p_plugin->getLog() )
+                {
+                    libvlc_exception_t ex;
+                    libvlc_exception_init(&ex);
+
+                    BOOLEAN_TO_NPVARIANT(libvlc_log_iterator_has_next(_p_iter, &ex), result);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                }
+                else
+                {
+                    BOOLEAN_TO_NPVARIANT(0, result);
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcMessageIteratorNPObject::methodNames[] =
+{
+    "next",
+};
+
+const int LibvlcMessageIteratorNPObject::methodCount = sizeof(LibvlcMessageIteratorNPObject::methodNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMessageIteratorNPObjectMethodIds
+{
+    ID_messageiterator_next,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMessageIteratorNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_messageiterator_next:
+                if( argCount == 0 )
+                {
+                    if( _p_iter && p_plugin->getLog() )
+                    {
+                        struct libvlc_log_message_t buffer;
+
+                        buffer.sizeof_msg = sizeof(buffer);
+
+                        libvlc_log_iterator_next(_p_iter, &buffer, &ex);
+                        if( libvlc_exception_raised(&ex) )
+                        {
+                            NPN_SetException(this, libvlc_exception_get_message(&ex));
+                            libvlc_exception_clear(&ex);
+                            return INVOKERESULT_GENERIC_ERROR;
+                        }
+                        else
+                        {
+                            LibvlcMessageNPObject* message =
+                                static_cast<LibvlcMessageNPObject*>(NPN_CreateObject(_instance, RuntimeNPClass<LibvlcMessageNPObject>::getClass()));
+                            if( message )
+                            {
+                                message->setMessage(buffer);
+                                OBJECT_TO_NPVARIANT(message, result);
+                                return INVOKERESULT_NO_ERROR;
+                            }
+                            return INVOKERESULT_OUT_OF_MEMORY;
+                        }
+                    }
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+ 
+/*
+** implementation of libvlc message object
+*/
+
+const NPUTF8 * const LibvlcMessagesNPObject::propertyNames[] = 
+{
+    "count",
+};
+
+const int LibvlcMessagesNPObject::propertyCount = sizeof(LibvlcMessagesNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMessagesNPObjectPropertyIds
+{
+    ID_messages_count,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMessagesNPObject::getProperty(int index, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        switch( index )
+        {
+            case ID_messages_count:
+            {
+                libvlc_log_t *p_log = p_plugin->getLog();
+                if( p_log )
+                {
+                    libvlc_exception_t ex;
+                    libvlc_exception_init(&ex);
+
+                    INT32_TO_NPVARIANT(libvlc_log_count(p_log, &ex), result);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                }
+                else
+                {
+                    INT32_TO_NPVARIANT(0, result);
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcMessagesNPObject::methodNames[] =
+{
+    "clear",
+    "iterator",
+};
+
+const int LibvlcMessagesNPObject::methodCount = sizeof(LibvlcMessagesNPObject::methodNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMessagesNPObjectMethodIds
+{
+    ID_messages_clear,
+    ID_messages_iterator,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMessagesNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_messages_clear:
+                if( argCount == 0 )
+                {
+                    libvlc_log_t *p_log = p_plugin->getLog();
+                    if( p_log )
+                    {
+                        libvlc_log_clear(p_log, &ex);
+                        if( libvlc_exception_raised(&ex) )
+                        {
+                            NPN_SetException(this, libvlc_exception_get_message(&ex));
+                            libvlc_exception_clear(&ex);
+                            return INVOKERESULT_GENERIC_ERROR;
+                        }
+                    }
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+
+            case ID_messages_iterator:
+                if( argCount == 0 )
+                {
+                    LibvlcMessageIteratorNPObject* iter =
+                        static_cast<LibvlcMessageIteratorNPObject*>(NPN_CreateObject(_instance, RuntimeNPClass<LibvlcMessageIteratorNPObject>::getClass()));
+                    if( iter )
+                    {
+                        OBJECT_TO_NPVARIANT(iter, result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                    return INVOKERESULT_OUT_OF_MEMORY;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+ 
+/*
+** implementation of libvlc message object
+*/
+
+
+LibvlcLogNPObject::~LibvlcLogNPObject()
+{
+    if( isValid() )
+    {
+        if( messagesObj ) NPN_ReleaseObject(messagesObj);
+    }
+};
+
+const NPUTF8 * const LibvlcLogNPObject::propertyNames[] = 
+{
+    "messages",
+    "verbosity",
+};
+
+const int LibvlcLogNPObject::propertyCount = sizeof(LibvlcLogNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcLogNPObjectPropertyIds
+{
+    ID_log_messages,
+    ID_log_verbosity,
+};
+
+RuntimeNPObject::InvokeResult LibvlcLogNPObject::getProperty(int index, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_log_messages:
+            {
+                // create child object in lazyman fashion to avoid ownership problem with firefox
+                if( ! messagesObj )
+                    messagesObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcMessagesNPObject>::getClass());
+                OBJECT_TO_NPVARIANT(NPN_RetainObject(messagesObj), result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_log_verbosity:
+            {
+                if( p_plugin->getLog() )
+                {
+                    INT32_TO_NPVARIANT(libvlc_get_log_verbosity(p_plugin->getVLC(),
+                                                                    &ex), result);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                }
+                else
+                {
+                    /* log is not enabled, return -1 */
+                    DOUBLE_TO_NPVARIANT(-1.0, result);
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+RuntimeNPObject::InvokeResult LibvlcLogNPObject::setProperty(int index, const NPVariant &value)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_log_verbosity:
+                if( isNumberValue(value) )
+                {
+                    libvlc_instance_t* p_libvlc = p_plugin->getVLC();
+                    libvlc_log_t *p_log = p_plugin->getLog();
+                    int verbosity = numberValue(value);
+                    if( verbosity >= 0 )
+                    {
+                        if( ! p_log )
+                        {
+                            p_log = libvlc_log_open(p_libvlc, &ex);
+                            if( libvlc_exception_raised(&ex) )
+                            {
+                                NPN_SetException(this, libvlc_exception_get_message(&ex));
+                                libvlc_exception_clear(&ex);
+                                return INVOKERESULT_GENERIC_ERROR;
+                            }
+                            p_plugin->setLog(p_log);
+                        }
+                        libvlc_set_log_verbosity(p_libvlc, (unsigned)verbosity, &ex);
+                        if( libvlc_exception_raised(&ex) )
+                        {
+                            NPN_SetException(this, libvlc_exception_get_message(&ex));
+                            libvlc_exception_clear(&ex);
+                            return INVOKERESULT_GENERIC_ERROR;
+                        }
+                    }
+                    else if( p_log )
+                    {
+                        /* close log  when verbosity is set to -1 */
+                        p_plugin->setLog(NULL);
+                        libvlc_log_close(p_log, &ex);
+                        if( libvlc_exception_raised(&ex) )
+                        {
+                            NPN_SetException(this, libvlc_exception_get_message(&ex));
+                            libvlc_exception_clear(&ex);
+                            return INVOKERESULT_GENERIC_ERROR;
+                        }
+                    }
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_INVALID_VALUE;
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcLogNPObject::methodNames[] =
+{
+    /* no methods */
+};
+
+const int LibvlcLogNPObject::methodCount = sizeof(LibvlcLogNPObject::methodNames)/sizeof(NPUTF8 *);
+
+/*
+** implementation of libvlc playlist items object
+*/
+
+const NPUTF8 * const LibvlcPlaylistItemsNPObject::propertyNames[] = 
+{
+    "count",
+};
+
+const int LibvlcPlaylistItemsNPObject::propertyCount = sizeof(LibvlcPlaylistItemsNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcPlaylistItemsNPObjectPropertyIds
+{
+    ID_playlistitems_count,
+};
+
+RuntimeNPObject::InvokeResult LibvlcPlaylistItemsNPObject::getProperty(int index, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_playlistitems_count:
+            {
+                int val = libvlc_playlist_items_count(p_plugin->getVLC(), &ex);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                INT32_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcPlaylistItemsNPObject::methodNames[] =
+{
+    "clear",
+    "remove",
+};
+
+const int LibvlcPlaylistItemsNPObject::methodCount = sizeof(LibvlcPlaylistItemsNPObject::methodNames)/sizeof(NPUTF8 *);
+
+enum LibvlcPlaylistItemsNPObjectMethodIds
+{
+    ID_playlistitems_clear,
+    ID_playlistitems_remove,
+};
+
+RuntimeNPObject::InvokeResult LibvlcPlaylistItemsNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_playlistitems_clear:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_clear(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_playlistitems_remove:
+                if( (argCount == 1) && isNumberValue(args[0]) )
+                {
+                    libvlc_playlist_delete_item(p_plugin->getVLC(), numberValue(args[0]), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+/*
+** implementation of libvlc playlist object
+*/
+
+
+LibvlcPlaylistNPObject::~LibvlcPlaylistNPObject()
+{
+    if( isValid() )
+    {
+        if( playlistItemsObj ) NPN_ReleaseObject(playlistItemsObj);
+    }
+};
+
+const NPUTF8 * const LibvlcPlaylistNPObject::propertyNames[] = 
+{
+    "itemCount", /* deprecated */
+    "isPlaying",
+    "items",
+};
+
+const int LibvlcPlaylistNPObject::propertyCount = sizeof(LibvlcPlaylistNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcPlaylistNPObjectPropertyIds
+{
+    ID_playlist_itemcount,
+    ID_playlist_isplaying,
+    ID_playlist_items,
+};
+
+RuntimeNPObject::InvokeResult LibvlcPlaylistNPObject::getProperty(int index, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_playlist_itemcount: /* deprecated */
+            {
+                int val = libvlc_playlist_items_count(p_plugin->getVLC(), &ex);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                INT32_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_playlist_isplaying:
+            {
+                int val = libvlc_playlist_isplaying(p_plugin->getVLC(), &ex);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                BOOLEAN_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_playlist_items:
+            {
+                // create child object in lazyman fashion to avoid ownership problem with firefox
+                if( ! playlistItemsObj )
+                    playlistItemsObj = NPN_CreateObject(_instance, RuntimeNPClass<LibvlcPlaylistItemsNPObject>::getClass());
+                OBJECT_TO_NPVARIANT(NPN_RetainObject(playlistItemsObj), result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcPlaylistNPObject::methodNames[] =
+{
+    "add",
+    "play",
+    "playItem",
+    "togglePause",
+    "stop",
+    "next",
+    "prev",
+    "clear", /* deprecated */
+    "removeItem", /* deprecated */
+};
+
+const int LibvlcPlaylistNPObject::methodCount = sizeof(LibvlcPlaylistNPObject::methodNames)/sizeof(NPUTF8 *);
+
+enum LibvlcPlaylistNPObjectMethodIds
+{
+    ID_playlist_add,
+    ID_playlist_play,
+    ID_playlist_playItem,
+    ID_playlist_togglepause,
+    ID_playlist_stop,
+    ID_playlist_next,
+    ID_playlist_prev,
+    ID_playlist_clear,
+    ID_playlist_removeitem
+};
+
+RuntimeNPObject::InvokeResult LibvlcPlaylistNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_playlist_add:
+            {
+                if( (argCount < 1) || (argCount > 3) )
+                    return INVOKERESULT_NO_SUCH_METHOD;
+
+                char *url = NULL;
+
+                // grab URL
+                if( NPVARIANT_IS_STRING(args[0]) )
+                {
+                    char *s = stringValue(NPVARIANT_TO_STRING(args[0]));
+                    if( s )
+                    {
+                        url = p_plugin->getAbsoluteURL(s);
+                        if( url )
+                            delete s;
+                        else
+                            // problem with combining url, use argument
+                            url = s;
+                    }
+                    else
+                        return INVOKERESULT_OUT_OF_MEMORY;
+                }
+                else
+                    return INVOKERESULT_NO_SUCH_METHOD;
+
+                char *name = NULL;
+
+                // grab name if available
+                if( argCount > 1 )
+                {
+                    if( NPVARIANT_IS_NULL(args[1]) )
+                    {
+                        // do nothing
+                    }
+                    else if( NPVARIANT_IS_STRING(args[1]) )
+                    {
+                        name = stringValue(NPVARIANT_TO_STRING(args[0]));
+                    }
+                    else
+                    {
+                        delete url;
+                        return INVOKERESULT_INVALID_VALUE;
+                    }
+                }
+
+                int i_options = 0;
+                char** ppsz_options = NULL;
+
+                // grab options if available
+                if( argCount > 2 )
+                {
+                    if( NPVARIANT_IS_NULL(args[2]) )
+                    {
+                        // do nothing
+                    }
+                    else if( NPVARIANT_IS_STRING(args[2]) )
+                    {
+                        parseOptions(NPVARIANT_TO_STRING(args[2]), &i_options, &ppsz_options);
+
+                    }
+                    else if( NPVARIANT_IS_OBJECT(args[2]) )
+                    {
+                        parseOptions(NPVARIANT_TO_OBJECT(args[2]), &i_options, &ppsz_options);
+                    }
+                    else
+                    {
+                        delete url;
+                        delete name;
+                        return INVOKERESULT_INVALID_VALUE;
+                    }
+                }
+
+                int item = libvlc_playlist_add_extended(p_plugin->getVLC(),
+                                                        url,
+                                                        name,
+                                                        i_options,
+                                                        const_cast<const char **>(ppsz_options),
+                                                        &ex);
+                delete url;
+                delete name;
+                for( int i=0; i< i_options; ++i )
+                {
+                    delete ppsz_options[i];
+                }
+                delete ppsz_options;
+
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                else
+                {
+                    INT32_TO_NPVARIANT(item, result);
+                    return INVOKERESULT_NO_ERROR;
+                }
+            }
+            case ID_playlist_play:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_play(p_plugin->getVLC(), -1, 0, NULL, &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_playlist_playItem:
+                if( (argCount == 1) && isNumberValue(args[0]) )
+                {
+                    libvlc_playlist_play(p_plugin->getVLC(), numberValue(args[0]), 0, NULL, &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_playlist_togglepause:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_pause(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_playlist_stop:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_stop(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_playlist_next:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_next(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_playlist_prev:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_prev(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_playlist_clear: /* deprecated */
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_clear(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_playlist_removeitem: /* deprecated */
+                if( (argCount == 1) && isNumberValue(args[0]) )
+                {
+                    libvlc_playlist_delete_item(p_plugin->getVLC(), numberValue(args[0]), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                ;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+void LibvlcPlaylistNPObject::parseOptions(const NPString &nps, int *i_options, char*** ppsz_options)
+{
+    if( nps.utf8length )
+    {
+        char *s = stringValue(nps);
+        char *val = s;
+        if( val )
+        {
+            long capacity = 16;
+            char **options = (char **)malloc(capacity*sizeof(char *));
+            if( options )
+            {
+                int nOptions = 0;
+
+                char *end = val + nps.utf8length;
+                while( val < end )
+                {
+                    // skip leading blanks
+                    while( (val < end)
+                        && ((*val == ' ' ) || (*val == '\t')) )
+                        ++val;
+
+                    char *start = val;
+                    // skip till we get a blank character
+                    while( (val < end)
+                        && (*val != ' ' )
+                        && (*val != '\t') )
+                    {
+                        char c = *(val++);
+                        if( ('\'' == c) || ('"' == c) )
+                        {
+                            // skip till end of string
+                            while( (val < end) && (*(val++) != c ) );
+                        }
+                    }
+
+                    if( val > start )
+                    {
+                        if( nOptions == capacity )
+                        {
+                            capacity += 16;
+                            char **moreOptions = (char **)realloc(options, capacity*sizeof(char*)); 
+                            if( ! moreOptions )
+                            {
+                                /* failed to allocate more memory */
+                                delete s;
+                                /* return what we got so far */
+                                *i_options = nOptions;
+                                *ppsz_options = options;
+                                return;
+                            }
+                            options = moreOptions;
+                        }
+                        *(val++) = '\0';
+                        options[nOptions++] = strdup(start);
+                    }
+                    else
+                        // must be end of string
+                        break;
+                }
+                *i_options = nOptions;
+                *ppsz_options = options;
+            }
+            delete s;
+        }
+    }
+}
+
+void LibvlcPlaylistNPObject::parseOptions(NPObject *obj, int *i_options, char*** ppsz_options)
+{
+    /* WARNING: Safari does not implement NPN_HasProperty/NPN_HasMethod */
+
+    NPVariant value;
+
+    /* we are expecting to have a Javascript Array object */
+    NPIdentifier propId = NPN_GetStringIdentifier("length");
+    if( NPN_GetProperty(_instance, obj, propId, &value) )
+    {
+        int count = numberValue(value);
+        NPN_ReleaseVariantValue(&value);
+
+        if( count )
+        {
+            long capacity = 16;
+            char **options = (char **)malloc(capacity*sizeof(char *));
+            if( options )
+            {
+                int nOptions = 0;
+
+                while( nOptions < count )
+                {
+                    propId = NPN_GetIntIdentifier(nOptions);
+                    if( ! NPN_GetProperty(_instance, obj, propId, &value) )
+                        /* return what we got so far */
+                        break;
+
+                    if( ! NPVARIANT_IS_STRING(value) )
+                    {
+                        /* return what we got so far */
+                        NPN_ReleaseVariantValue(&value);
+                        break;
+                    }
+
+                    if( nOptions == capacity )
+                    {
+                        capacity += 16;
+                        char **moreOptions = (char **)realloc(options, capacity*sizeof(char*)); 
+                        if( ! moreOptions )
+                        {
+                            /* failed to allocate more memory */
+                            NPN_ReleaseVariantValue(&value);
+                            /* return what we got so far */
+                            *i_options = nOptions;
+                            *ppsz_options = options;
+                            break;
+                        }
+                        options = moreOptions;
+                    }
+
+                    options[nOptions++] = stringValue(value);
+                }
+                *i_options = nOptions;
+                *ppsz_options = options;
+            }
+        }
+    }
+}
+
+/*
+** implementation of libvlc video object
+*/
+
+const NPUTF8 * const LibvlcVideoNPObject::propertyNames[] = 
+{
+    "fullscreen",
+    "height",
+    "width",
+    "aspectRatio"
+};
+
+enum LibvlcVideoNPObjectPropertyIds
+{
+    ID_video_fullscreen,
+    ID_video_height,
+    ID_video_width,
+    ID_video_aspectratio
+};
+
+const int LibvlcVideoNPObject::propertyCount = sizeof(LibvlcVideoNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+RuntimeNPObject::InvokeResult LibvlcVideoNPObject::getProperty(int index, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
+        if( libvlc_exception_raised(&ex) )
+        {
+            NPN_SetException(this, libvlc_exception_get_message(&ex));
+            libvlc_exception_clear(&ex);
+            return INVOKERESULT_GENERIC_ERROR;
+        }
+
+        switch( index )
+        {
+            case ID_video_fullscreen:
+            {
+                int val = libvlc_get_fullscreen(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                BOOLEAN_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_video_height:
+            {
+                int val = libvlc_video_get_height(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                INT32_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_video_width:
+            {
+                int val = libvlc_video_get_width(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                INT32_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_video_aspectratio:
+            {
+                NPUTF8 *psz_aspect = libvlc_video_get_aspect_ratio(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                if( !psz_aspect )
+                    return INVOKERESULT_GENERIC_ERROR;
+
+                STRINGZ_TO_NPVARIANT(psz_aspect, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+        libvlc_input_free(p_input);
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+RuntimeNPObject::InvokeResult LibvlcVideoNPObject::setProperty(int index, const NPVariant &value)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
+        if( libvlc_exception_raised(&ex) )
+        {
+            NPN_SetException(this, libvlc_exception_get_message(&ex));
+            libvlc_exception_clear(&ex);
+            return INVOKERESULT_GENERIC_ERROR;
+        }
+
+        switch( index )
+        {
+            case ID_video_fullscreen:
+            {
+                if( ! NPVARIANT_IS_BOOLEAN(value) )
+                {
+                    libvlc_input_free(p_input);
+                    return INVOKERESULT_INVALID_VALUE;
+                }
+
+                int val = NPVARIANT_TO_BOOLEAN(value);
+                libvlc_set_fullscreen(p_input, val, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_video_aspectratio:
+            {
+                char *psz_aspect = NULL;
+
+                if( ! NPVARIANT_IS_STRING(value) )
+                {
+                    libvlc_input_free(p_input);
+                    return INVOKERESULT_INVALID_VALUE;
+                }
+
+                psz_aspect = stringValue(NPVARIANT_TO_STRING(value));
+                if( !psz_aspect )
+                {
+                    libvlc_input_free(p_input);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+
+                libvlc_video_set_aspect_ratio(p_input, psz_aspect, &ex);
+                delete psz_aspect;
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+        libvlc_input_free(p_input);
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcVideoNPObject::methodNames[] =
+{
+    "toggleFullscreen",
+};
+
+enum LibvlcVideoNPObjectMethodIds
+{
+    ID_video_togglefullscreen,
+};
+
+const int LibvlcVideoNPObject::methodCount = sizeof(LibvlcVideoNPObject::methodNames)/sizeof(NPUTF8 *);
+
+RuntimeNPObject::InvokeResult LibvlcVideoNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    /* is plugin still running */
+    if( _instance->pdata )
+    {
+        VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(_instance->pdata);
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
+        if( libvlc_exception_raised(&ex) )
+        {
+            NPN_SetException(this, libvlc_exception_get_message(&ex));
+            libvlc_exception_clear(&ex);
+            return INVOKERESULT_GENERIC_ERROR;
+        }
+
+        switch( index )
+        {
+            case ID_video_togglefullscreen:
+                if( argCount == 0 )
+                {
+                    libvlc_toggle_fullscreen(p_input, &ex);
+                    libvlc_input_free(p_input);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                else
+                {
+                    /* cannot get input, probably not playing */
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                    }
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                return INVOKERESULT_NO_SUCH_METHOD;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+/*
+** implementation of libvlc metadata object
+*
+*  Current usage:
+*   ["meta-information", "general"] = vlc.metadata.categories 
+*   ["artist", "album"] = vlc.metadata.getCategoryKeys("meta-information") 
+*   "metadata" = vlc.metadata.get("meta-information","album")
+*/
+
+const NPUTF8 * const LibvlcMetadataNPObject::propertyNames[] = 
+{
+    "categories",
+};
+
+const int LibvlcMetadataNPObject::propertyCount = sizeof(LibvlcMetadataNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMetadataNPObjectPropertyIds
+{
+    ID_categories,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMetadataNPObject::getProperty(int index, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_categories:
+            {
+                NPP browser = p_plugin->getBrowser();
+                NPObject *plugin;
+
+                if( NPERR_NO_ERROR == NPN_GetValue(browser, NPNVWindowNPObject, &plugin) )
+                {
+                    char buffer[JS_EVAL_BUFFER_SIZE] = "['";
+
+                    vlc_meta_t *metadata = NULL;
+
+                    VLCUtils::GetMetadata(p_plugin->getVLC(), &metadata, &ex);
+                    if( libvlc_exception_raised(&ex) ) 
+                        return INVOKERESULT_GENERIC_ERROR;
+
+                    int count = VLCUtils::GetMetadataCategoryCount(metadata);
+
+#if defined(DEBUG_METADATA_OBJECT)
+                    printf("GetMetadataCategoryCount: %d\n", count);
+#endif
+                    
+                    for(int i = 0; i < count; i++)
+                    {
+                        char *category = VLCUtils::GetMetadataCategoryString(metadata, i);
+
+                        strncat(buffer, category, JS_EVAL_BUFFER_SIZE - 1);
+                        strncat(buffer, "'", JS_EVAL_BUFFER_SIZE - 1);
+                      
+                        if(i + 1 < count)
+                          strncat(buffer, ",'", JS_EVAL_BUFFER_SIZE - 1);
+                      
+                        free(category);
+                    }
+
+                    vlc_meta_Delete(metadata);
+                   
+                    strncat(buffer, "]", JS_EVAL_BUFFER_SIZE - 1);
+
+#if defined(DEBUG_METADATA_OBJECT)
+                    printf("vlc.metadata.categories = %s", buffer);
+#endif
+                    
+                    NPString script;
+                    script.utf8characters = buffer;
+                    script.utf8length = strlen(buffer);
+
+                    if( NPN_Evaluate(browser, plugin, &script, &result) )
+                    {
+                        if( !NPVARIANT_IS_OBJECT(result) )
+                        {
+                            NPN_ReleaseObject(plugin);
+                            return INVOKERESULT_GENERIC_ERROR;
+                        }
+                        // NPN_RetainObject(NPVARIANT_TO_OBJECT(result));
+                        // NPN_ReleaseVariantValue(&result);
+                    } else {
+                       NPN_ReleaseObject(plugin);
+                       return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    NPN_ReleaseObject(plugin);
+                }
+
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+RuntimeNPObject::InvokeResult LibvlcMetadataNPObject::setProperty(int index, const NPVariant &value)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+       // TODO Should anything be writeable? Nope.
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcMetadataNPObject::methodNames[] =
+{
+    "getCategoryKeys",
+    "get",
+};
+
+enum LibvlcMetadataNPObjectMethodIds
+{
+    ID_getcategorykeys,
+    ID_get,
+};
+
+const int LibvlcMetadataNPObject::methodCount = sizeof(LibvlcMetadataNPObject::methodNames)/sizeof(NPUTF8 *);
+
+RuntimeNPObject::InvokeResult LibvlcMetadataNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_getcategorykeys:
+                if( argCount == 1 )
+                {
+                    if( NPVARIANT_IS_STRING(args[0]) )
+                    {
+                        char *s = stringValue(NPVARIANT_TO_STRING(args[0]));
+#if defined(DEBUG_METADATA_OBJECT)
+                        printf("\nvlc.metadata.getCategoryKeys(%s)\n", s);
+#endif
+                       
+                        NPP browser = p_plugin->getBrowser();
+                        NPObject *plugin;
+
+                        if( NPERR_NO_ERROR == NPN_GetValue(browser, NPNVWindowNPObject, &plugin) )
+                        {
+                            char buffer[JS_EVAL_BUFFER_SIZE] = "['";
+                            vlc_meta_t *metadata = NULL;
+
+                            VLCUtils::GetMetadata(p_plugin->getVLC(), &metadata, &ex);
+                            if( libvlc_exception_raised(&ex) ) 
+                                return INVOKERESULT_GENERIC_ERROR;
+
+                            int count = VLCUtils::GetMetadataKeyCount(metadata, s);
+
+                            for(int i = 0; i < count; i++)
+                            {
+                                char *key = VLCUtils::GetMetadataKeyString(metadata, s, i);
+
+                                strncat(buffer, key, JS_EVAL_BUFFER_SIZE - 1);
+                                strncat(buffer, "'", JS_EVAL_BUFFER_SIZE - 1);
+                              
+                                if(i + 1 < count)
+                                    strncat(buffer, ",'", JS_EVAL_BUFFER_SIZE - 1);
+                              
+                                free(key);
+                            }
+
+                            vlc_meta_Delete(metadata);
+                            free(s);
+
+                            strncat(buffer, "]", JS_EVAL_BUFFER_SIZE - 1);
+                            
+#if defined(DEBUG_METADATA_OBJECT)
+                            printf("vlc.metadata.categoryKeys = %s\n", buffer);
+#endif
+                            
+                            NPString script;
+                            script.utf8characters = buffer;
+                            script.utf8length = strlen(buffer);
+
+                            if( NPN_Evaluate(browser, plugin, &script, &result) )
+                            {
+                                if( !NPVARIANT_IS_OBJECT(result) )
+                                {
+                                    NPN_ReleaseObject(plugin);
+                                    return INVOKERESULT_GENERIC_ERROR;
+                                }
+                                // NPN_RetainObject(NPVARIANT_TO_OBJECT(result));
+                                // NPN_ReleaseVariantValue(&result);
+                            } else {
+                               NPN_ReleaseObject(plugin);
+                               return INVOKERESULT_GENERIC_ERROR;
+                            }
+                            
+                            NPN_ReleaseObject(plugin);
+                        }
+
+                    }
+                    else
+                        return INVOKERESULT_NO_SUCH_METHOD;                    
+
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+
+            case ID_get:
+                if( argCount == 2 )
+                {
+                    if( NPVARIANT_IS_STRING(args[0]) && NPVARIANT_IS_STRING(args[1]))
+                    {
+                        char *category = stringValue(NPVARIANT_TO_STRING(args[0]));
+                        char *key = stringValue(NPVARIANT_TO_STRING(args[1]));
+                        NPUTF8 *metadata = NULL;
+                        
+                        metadata = VLCUtils::GetMetadataString(p_plugin->getVLC(), category, key, &ex);
+
+                        if (category) 
+                            free(category);
+
+                        if (key) 
+                            free(key);
+
+                        if( libvlc_exception_raised(&ex) ) 
+                            return INVOKERESULT_GENERIC_ERROR;
+
+#if defined(DEBUG_METADATA_OBJECT)
+                        printf("vlc.metadata.get = %s\n", metadata);
+#endif
+                        
+                        copyStringToNPVariant(metadata, result);
+
+                        free(metadata);
+                    }
+                    else
+                        return INVOKERESULT_NO_SUCH_METHOD;                    
+
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                return INVOKERESULT_NO_SUCH_METHOD;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+

Property changes on: mozilla\control\npolibvlc.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: mozilla/control/npolibvlc.h
===================================================================
--- mozilla/control/npolibvlc.h	(revision 159)
+++ mozilla/control/npolibvlc.h	(working copy)
@@ -1,269 +1,312 @@
-/*****************************************************************************
- * npolibvlc.h: official Javascript APIs
- *****************************************************************************
- * Copyright (C) 2002-2006 the VideoLAN team
- *
- * Authors: Damien Fouilleul <damien.fouilleul@laposte.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/*
-** defined runtime script objects
-*/
-#include <vlc/libvlc.h>
-
-#include "nporuntime.h"
-
-class LibvlcRootNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcRootNPObject>;
-
-    LibvlcRootNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass),
-	audioObj(NULL),
-	inputObj(NULL),
-	logObj(NULL),
-	playlistObj(NULL),
-	videoObj(NULL) {};
-
-    virtual ~LibvlcRootNPObject();
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-
-private:
-    NPObject *audioObj;
-    NPObject *inputObj;
-    NPObject *logObj;
-    NPObject *playlistObj;
-    NPObject *videoObj;
-};
-
-class LibvlcAudioNPObject: public RuntimeNPObject
-{
-protected:
-    LibvlcAudioNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-    virtual ~LibvlcAudioNPObject() {};
-
-    friend class RuntimeNPClass<LibvlcAudioNPObject>;
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-    InvokeResult setProperty(int index, const NPVariant &value);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-};
-
-class LibvlcInputNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcInputNPObject>;
-
-    LibvlcInputNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-
-    virtual ~LibvlcInputNPObject() {};
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-    InvokeResult setProperty(int index, const NPVariant &value);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-};
-
-class LibvlcMessageNPObject: public RuntimeNPObject
-{
-public:
-    void setMessage(struct libvlc_log_message_t &msg)
-    {
-        _msg = msg;
-    };
-
-protected:
-    friend class RuntimeNPClass<LibvlcMessageNPObject>;
-
-    LibvlcMessageNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-
-    virtual ~LibvlcMessageNPObject() {};
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-private:
-    struct libvlc_log_message_t _msg;
-};
-
-class LibvlcLogNPObject;
-
-class LibvlcMessageIteratorNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcMessageIteratorNPObject>;
-
-    LibvlcMessageIteratorNPObject(NPP instance, const NPClass *aClass);
-    virtual ~LibvlcMessageIteratorNPObject();
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-
-private:
-    libvlc_log_iterator_t*  _p_iter;
-};
-
-class LibvlcMessagesNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcMessagesNPObject>;
-
-    LibvlcMessagesNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-
-    virtual ~LibvlcMessagesNPObject() {};
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-};
-
-class LibvlcLogNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcLogNPObject>;
-
-    LibvlcLogNPObject(NPP instance, const NPClass *aClass) :
-	RuntimeNPObject(instance, aClass),
-	messagesObj(NULL) {};
-
-    virtual ~LibvlcLogNPObject();
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-    InvokeResult setProperty(int index, const NPVariant &value);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-private:
-    NPObject* messagesObj;
-};
-
-class LibvlcPlaylistItemsNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcPlaylistItemsNPObject>;
-
-    LibvlcPlaylistItemsNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-    virtual ~LibvlcPlaylistItemsNPObject() {};
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-};
-
-class LibvlcPlaylistNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcPlaylistNPObject>;
-
-    LibvlcPlaylistNPObject(NPP instance, const NPClass *aClass) :
-	RuntimeNPObject(instance, aClass),
-	playlistItemsObj(NULL) {};
-	
-    virtual ~LibvlcPlaylistNPObject();
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-
-    void parseOptions(const NPString &s, int *i_options, char*** ppsz_options);
-    void parseOptions(NPObject *obj, int *i_options, char*** ppsz_options);
-
-private:
-    NPObject*  playlistItemsObj;
-};
-
-class LibvlcVideoNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcVideoNPObject>;
-
-    LibvlcVideoNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-    virtual ~LibvlcVideoNPObject() {};
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-    InvokeResult setProperty(int index, const NPVariant &value);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-};
-
+/*****************************************************************************
+ * npolibvlc.h: official Javascript APIs
+ *****************************************************************************
+ * Copyright (C) 2002-2006 the VideoLAN team
+ *
+ * Authors: Damien Fouilleul <damien.fouilleul@laposte.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*
+** defined runtime script objects
+*/
+#include <vlc/libvlc.h>
+
+#include "nporuntime.h"
+
+namespace VLCUtils 
+{
+  void GetMetadata(libvlc_instance_t *instance, vlc_meta_t **, libvlc_exception_t* ex);
+  
+  char *GetMetadataString(libvlc_instance_t *instance, const char *category, const char *key, libvlc_exception_t* ex);
+  char *GetMetadataString(vlc_meta_t *metadata, const char *category, const char *key);
+  
+  int GetMetadataCategoryCount(libvlc_instance_t *instance, libvlc_exception_t* ex);
+  int GetMetadataCategoryCount(vlc_meta_t *metadata);
+  
+  char *GetMetadataCategoryString(libvlc_instance_t *instance, int index, libvlc_exception_t* ex);
+  char *GetMetadataCategoryString(vlc_meta_t *metadata, int index);
+  
+  int GetMetadataKeyCount(libvlc_instance_t * instance, const char *category, libvlc_exception_t* ex);
+  int GetMetadataKeyCount(vlc_meta_t *metadata, const char *category);
+  
+  char *GetMetadataKeyString(libvlc_instance_t *instance, const char *category, int index, libvlc_exception_t* ex);
+  char *GetMetadataKeyString(vlc_meta_t *metadata, const char *category, int index);
+}
+
+class LibvlcRootNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcRootNPObject>;
+
+    LibvlcRootNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass),
+	audioObj(NULL),
+	inputObj(NULL),
+	logObj(NULL),
+	playlistObj(NULL),
+	videoObj(NULL),
+	metadataObj(NULL) {};
+
+    virtual ~LibvlcRootNPObject();
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+
+private:
+    NPObject *audioObj;
+    NPObject *inputObj;
+    NPObject *logObj;
+    NPObject *playlistObj;
+    NPObject *videoObj;
+    NPObject *metadataObj;
+};
+
+class LibvlcAudioNPObject: public RuntimeNPObject
+{
+protected:
+    LibvlcAudioNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+    virtual ~LibvlcAudioNPObject() {};
+
+    friend class RuntimeNPClass<LibvlcAudioNPObject>;
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+    InvokeResult setProperty(int index, const NPVariant &value);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+};
+
+class LibvlcInputNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcInputNPObject>;
+
+    LibvlcInputNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+
+    virtual ~LibvlcInputNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+    InvokeResult setProperty(int index, const NPVariant &value);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+};
+
+class LibvlcMessageNPObject: public RuntimeNPObject
+{
+public:
+    void setMessage(struct libvlc_log_message_t &msg)
+    {
+        _msg = msg;
+    };
+
+protected:
+    friend class RuntimeNPClass<LibvlcMessageNPObject>;
+
+    LibvlcMessageNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+
+    virtual ~LibvlcMessageNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+private:
+    struct libvlc_log_message_t _msg;
+};
+
+class LibvlcLogNPObject;
+
+class LibvlcMessageIteratorNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcMessageIteratorNPObject>;
+
+    LibvlcMessageIteratorNPObject(NPP instance, const NPClass *aClass);
+    virtual ~LibvlcMessageIteratorNPObject();
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+
+private:
+    libvlc_log_iterator_t*  _p_iter;
+};
+
+class LibvlcMessagesNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcMessagesNPObject>;
+
+    LibvlcMessagesNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+
+    virtual ~LibvlcMessagesNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+};
+
+class LibvlcLogNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcLogNPObject>;
+
+    LibvlcLogNPObject(NPP instance, const NPClass *aClass) :
+	RuntimeNPObject(instance, aClass),
+	messagesObj(NULL) {};
+
+    virtual ~LibvlcLogNPObject();
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+    InvokeResult setProperty(int index, const NPVariant &value);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+private:
+    NPObject* messagesObj;
+};
+
+class LibvlcPlaylistItemsNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcPlaylistItemsNPObject>;
+
+    LibvlcPlaylistItemsNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+    virtual ~LibvlcPlaylistItemsNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+};
+
+class LibvlcPlaylistNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcPlaylistNPObject>;
+
+    LibvlcPlaylistNPObject(NPP instance, const NPClass *aClass) :
+	RuntimeNPObject(instance, aClass),
+	playlistItemsObj(NULL) {};
+	
+    virtual ~LibvlcPlaylistNPObject();
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+
+    void parseOptions(const NPString &s, int *i_options, char*** ppsz_options);
+    void parseOptions(NPObject *obj, int *i_options, char*** ppsz_options);
+
+private:
+    NPObject*  playlistItemsObj;
+};
+
+class LibvlcVideoNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcVideoNPObject>;
+
+    LibvlcVideoNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+    virtual ~LibvlcVideoNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+    InvokeResult setProperty(int index, const NPVariant &value);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+};
+
+class LibvlcMetadataNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcMetadataNPObject>;
+
+    LibvlcMetadataNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+
+    virtual ~LibvlcMetadataNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+    InvokeResult setProperty(int index, const NPVariant &value);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+};

Property changes on: mozilla\control\npolibvlc.h
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: mozilla/control/nporuntime.cpp
===================================================================
--- mozilla/control/nporuntime.cpp	(revision 159)
+++ mozilla/control/nporuntime.cpp	(working copy)
@@ -56,6 +56,28 @@
     return s;
 }
 
+void RuntimeNPObject::copyStringToNPVariant(const NPUTF8* val, NPVariant &result)
+{
+    NPUTF8* retval = NULL;
+    NPUTF8 *p = NULL;
+    NPUTF8 *defaultVal = "";
+
+    int len = 0;
+   
+    p = (val == NULL) ? defaultVal : (NPUTF8 *)val;
+    len = strlen(p);
+
+    retval = (NPUTF8*)NPN_MemAlloc((len + 1) * sizeof(NPUTF8));
+   
+    if(retval)
+    {
+        memset(retval, 0, len + 1);
+        memcpy(retval, p, len);
+        
+        STRINGN_TO_NPVARIANT(retval, len, result);
+    }
+}
+
 RuntimeNPObject::InvokeResult RuntimeNPObject::getProperty(int index, NPVariant &result)
 {
     /* default behaviour */

Property changes on: mozilla\control\nporuntime.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: mozilla/control/nporuntime.h
===================================================================
--- mozilla/control/nporuntime.h	(revision 159)
+++ mozilla/control/nporuntime.h	(working copy)
@@ -68,6 +68,9 @@
     static char* stringValue(const NPString &v);
     static char* stringValue(const NPVariant &v);
 
+    static void copyStringToNPVariant(const NPUTF8* val, NPVariant &result);
+    virtual void ReleaseChildren() { };
+
 protected:
     void *operator new(size_t n)
     {

Property changes on: mozilla\control\nporuntime.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: mozilla\control\npovlc.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: mozilla\control\npovlc.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: mozilla\install.js
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: mozilla/Makefile.am
===================================================================
--- mozilla/Makefile.am	(revision 159)
+++ mozilla/Makefile.am	(working copy)
@@ -90,7 +90,7 @@
 	awk -v libdylib="$$dylib" ' \
 	/@executable_path/ { \
 	    newpath=$$1 ; \
-	    sub("@executable_path","/Library/Internet Plug-Ins/VLC Plugin.plugin/Contents/MacOS",newpath) ; \
+	    sub("@executable_path","@executable_path/../Resources/plugins/VLC Plugin.plugin/Contents/MacOS",newpath) ; \
 	    print "install_name_tool -change \""$$1"\" \""newpath"\" \""libdylib"\"" ; \
 	}' | sh -x
 endef

Property changes on: mozilla\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: mozilla/npvlc_rc.rc
===================================================================
--- mozilla/npvlc_rc.rc	(revision 159)
+++ mozilla/npvlc_rc.rc	(working copy)
@@ -31,17 +31,17 @@
     BEGIN
         BLOCK "040904e4"
         BEGIN
-            VALUE "ProductName", "VLC Multimedia Plugin\0"
+            VALUE "ProductName", "Songbird VLC Plugin\0"
             VALUE "ProductVersion", STRINGIFY( VERSION )
             VALUE "OriginalFilename", "npvlc.dll\0"
             VALUE "FileVersion", STRINGIFY( VERSION )
-            VALUE "FileDescription", "Version " STRINGIFY( VERSION ) ", copyright 1996-2006 The VideoLAN Team<br><a href=""http://www.videolan.org/"">http://www.videolan.org/</a>\0"
+            VALUE "FileDescription", "Version " STRINGIFY( VERSION ) ", copyright 1996-2006 The VideoLAN Team<br><a href=""http://www.videolan.org/"">http://www.videolan.org/</a><br><a href=""http://www.songbirdnest.com/"">http://www.songbirdnest.com/</a>\0"
             VALUE "InternalName", "npvlc\0"
             VALUE "CompanyName", "VideoLAN Team\0"
             VALUE "LegalCopyright", "Copyright \251 1996-2006 The VideoLAN Team\0"
-            VALUE "MIMEType", "application/x-ogg|application/ogg|application/x-vlc-plugin|application/x-google-vlc-plugin\0"
-            VALUE "FileExtents", "ogg|ogg|vlc|\0"
-            VALUE "FileOpenName", "Ogg stream|Ogg stream|VLC plugin|Google VLC plugin\0"
+            VALUE "MIMEType", "application/x-songbird-vlc-plugin|application/x-vlc-plugin|application/x-google-vlc-plugin\0"
+            VALUE "FileExtents", "sbvlc\0"
+            VALUE "FileOpenName", "Songbird VLC plugin\0"
         END
     END
     BLOCK "VarFileInfo"

Property changes on: mozilla\npvlc_rc.rc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: mozilla\support\classinfo.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: mozilla\support\npmac.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: mozilla\support\npunix.c
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: mozilla/support/npwin.cpp
===================================================================
--- mozilla/support/npwin.cpp	(revision 159)
+++ mozilla/support/npwin.cpp	(working copy)
@@ -1,570 +1,571 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: NPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Netscape Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/NPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code.
- *
- * The Initial Developer of the Original Code is 
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or 
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the NPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the NPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "config.h"
-
-#ifdef HAVE_MOZILLA_CONFIG_H
-#   include <mozilla-config.h>
-#endif
-
-#include "nscore.h"
-#include "npapi.h"
-#include "npupp.h"
-
-//\\// DEFINE
-#define NP_EXPORT
-
-//\\// GLOBAL DATA
-NPNetscapeFuncs* g_pNavigatorFuncs = 0;
-JRIGlobalRef Private_GetJavaClass(void);
-
-//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
-////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
-// Private_GetJavaClass (global function)
-//
-//	Given a Java class reference (thru NPP_GetJavaClass) inform JRT
-//	of this class existence
-//
-JRIGlobalRef
-Private_GetJavaClass(void)
-{
-    jref clazz = NPP_GetJavaClass();
-    if (clazz) {
-		JRIEnv* env = NPN_GetJavaEnv();
-		return JRI_NewGlobalRef(env, clazz);
-    }
-    return NULL;
-}
-
-//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
-////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
-//						PLUGIN DLL entry points   
-//
-// These are the Windows specific DLL entry points. They must be exoprted
-//
-
-// we need these to be global since we have to fill one of its field
-// with a data (class) which requires knowlwdge of the navigator
-// jump-table. This jump table is known at Initialize time (NP_Initialize)
-// which is called after NP_GetEntryPoint
-static NPPluginFuncs* g_pluginFuncs;
-
-//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
-////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
-// NP_GetEntryPoints
-//
-//	fills in the func table used by Navigator to call entry points in
-//  plugin DLL.  Note that these entry points ensure that DS is loaded
-//  by using the NP_LOADDS macro, when compiling for Win16
-//
-#ifdef __MINGW32__
-extern "C" __declspec(dllexport) NPError WINAPI
-#else
-NPError WINAPI NP_EXPORT
-#endif
-NP_GetEntryPoints(NPPluginFuncs* pFuncs)
-{
-    // trap a NULL ptr 
-    if(pFuncs == NULL)
-        return NPERR_INVALID_FUNCTABLE_ERROR;
-
-    // if the plugin's function table is smaller than the plugin expects,
-    // then they are incompatible, and should return an error 
-
-    pFuncs->version       = (NP_VERSION_MAJOR << 8) | NP_VERSION_MINOR;
-    pFuncs->newp          = NPP_New;
-    pFuncs->destroy       = NPP_Destroy;
-    pFuncs->setwindow     = NPP_SetWindow;
-    pFuncs->newstream     = NPP_NewStream;
-    pFuncs->destroystream = NPP_DestroyStream;
-    pFuncs->asfile        = NPP_StreamAsFile;
-    pFuncs->writeready    = NPP_WriteReady;
-    pFuncs->write         = NPP_Write;
-    pFuncs->print         = NPP_Print;
-    pFuncs->event         = 0;       /// reserved 
-    pFuncs->getvalue	  = NPP_GetValue;
-    //pFuncs->setvalue	  = NPP_SetValue;
-
-	g_pluginFuncs		  = pFuncs;
-
-    return NPERR_NO_ERROR;
-}
-
-//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
-////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
-// NP_Initialize
-//
-//	called immediately after the plugin DLL is loaded
-//
-#ifdef __MINGW32__
-extern "C" __declspec(dllexport) NPError WINAPI
-#else
-NPError WINAPI NP_EXPORT 
-#endif
-NP_Initialize(NPNetscapeFuncs* pFuncs)
-{
-    // trap a NULL ptr 
-    if(pFuncs == NULL)
-        return NPERR_INVALID_FUNCTABLE_ERROR;
-
-    g_pNavigatorFuncs = pFuncs; // save it for future reference 
-
-    // if the plugin's major ver level is lower than the Navigator's,
-    // then they are incompatible, and should return an error 
-    if(HIBYTE(pFuncs->version) > NP_VERSION_MAJOR)
-        return NPERR_INCOMPATIBLE_VERSION_ERROR;
-
-	// We have to defer these assignments until g_pNavigatorFuncs is set
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-
-	if( navMinorVers >= NPVERS_HAS_NOTIFICATION ) {
-		g_pluginFuncs->urlnotify = NPP_URLNotify;
-	}
-	
-	if( navMinorVers >= NPVERS_HAS_LIVECONNECT ) {
-		g_pluginFuncs->javaClass = Private_GetJavaClass();
-	}
-
-	// NPP_Initialize is a standard (cross-platform) initialize function.
-    return NPP_Initialize();
-}
-
-//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
-////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
-// NP_Shutdown
-//
-//	called immediately before the plugin DLL is unloaded.
-//	This functio shuold check for some ref count on the dll to see if it is
-//	unloadable or it needs to stay in memory. 
-//
-#ifdef __MINGW32__
-extern "C" __declspec(dllexport) NPError WINAPI
-#else
-NPError WINAPI NP_EXPORT 
-#endif
-NP_Shutdown()
-{
-    NPP_Shutdown();
-    g_pNavigatorFuncs = NULL;
-    return NPERR_NO_ERROR;
-}
-
-//						END - PLUGIN DLL entry points   
-////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
-//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
-
-/*    NAVIGATOR Entry points    */
-
-/* These entry points expect to be called from within the plugin.  The
-   noteworthy assumption is that DS has already been set to point to the
-   plugin's DLL data segment.  Don't call these functions from outside
-   the plugin without ensuring DS is set to the DLLs data segment first,
-   typically using the NP_LOADDS macro
-*/
-
-/* returns the major/minor version numbers of the Plugin API for the plugin
-   and the Navigator
-*/
-void NPN_Version(int* plugin_major, int* plugin_minor, int* netscape_major, int* netscape_minor)
-{
-    *plugin_major   = NP_VERSION_MAJOR;
-    *plugin_minor   = NP_VERSION_MINOR;
-    *netscape_major = HIBYTE(g_pNavigatorFuncs->version);
-    *netscape_minor = LOBYTE(g_pNavigatorFuncs->version);
-}
-
-/* causes the specified URL to be fetched and streamed in
-*/
-NPError NPN_GetURLNotify(NPP instance, const char *url, const char *target, void* notifyData)
-
-{
-	int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-	NPError err;
-	if( navMinorVers >= NPVERS_HAS_NOTIFICATION ) {
-		err = g_pNavigatorFuncs->geturlnotify(instance, url, target, notifyData);
-	}
-	else {
-		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
-	}
-	return err;
-}
-
-
-NPError NPN_GetURL(NPP instance, const char *url, const char *target)
-{
-    return g_pNavigatorFuncs->geturl(instance, url, target);
-}
-
-NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file, void* notifyData)
-{
-	int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-	NPError err;
-	if( navMinorVers >= NPVERS_HAS_NOTIFICATION ) {
-		err = g_pNavigatorFuncs->posturlnotify(instance, url, window, len, buf, file, notifyData);
-	}
-	else {
-		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
-	}
-	return err;
-}
-
-
-NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file)
-{
-    return g_pNavigatorFuncs->posturl(instance, url, window, len, buf, file);
-}
-
-/* Requests that a number of bytes be provided on a stream.  Typically
-   this would be used if a stream was in "pull" mode.  An optional
-   position can be provided for streams which are seekable.
-*/
-NPError NPN_RequestRead(NPStream* stream, NPByteRange* rangeList)
-{
-    return g_pNavigatorFuncs->requestread(stream, rangeList);
-}
-
-/* Creates a new stream of data from the plug-in to be interpreted
-   by Netscape in the current window.
-*/
-NPError NPN_NewStream(NPP instance, NPMIMEType type, 
-								const char* target, NPStream** stream)
-{
-	int navMinorVersion = g_pNavigatorFuncs->version & 0xFF;
-	NPError err;
-
-	if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT ) {
-		err = g_pNavigatorFuncs->newstream(instance, type, target, stream);
-	}
-	else {
-		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
-	}
-	return err;
-}
-
-/* Provides len bytes of data.
-*/
-int32 NPN_Write(NPP instance, NPStream *stream,
-                int32 len, void *buffer)
-{
-	int navMinorVersion = g_pNavigatorFuncs->version & 0xFF;
-	int32 result;
-
-	if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT ) {
-		result = g_pNavigatorFuncs->write(instance, stream, len, buffer);
-	}
-	else {
-		result = -1;
-	}
-	return result;
-}
-
-/* Closes a stream object.  
-reason indicates why the stream was closed.
-*/
-NPError NPN_DestroyStream(NPP instance, NPStream* stream, NPError reason)
-{
-	int navMinorVersion = g_pNavigatorFuncs->version & 0xFF;
-	NPError err;
-
-	if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT ) {
-		err = g_pNavigatorFuncs->destroystream(instance, stream, reason);
-	}
-	else {
-		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
-	}
-	return err;
-}
-
-/* Provides a text status message in the Netscape client user interface
-*/
-void NPN_Status(NPP instance, const char *message)
-{
-    g_pNavigatorFuncs->status(instance, message);
-}
-
-/* returns the user agent string of Navigator, which contains version info
-*/
-const char* NPN_UserAgent(NPP instance)
-{
-    return g_pNavigatorFuncs->uagent(instance);
-}
-
-/* allocates memory from the Navigator's memory space.  Necessary so that
-   saved instance data may be freed by Navigator when exiting.
-*/
-
-
-void* NPN_MemAlloc(uint32 size)
-{
-    return g_pNavigatorFuncs->memalloc(size);
-}
-
-/* reciprocal of MemAlloc() above
-*/
-void NPN_MemFree(void* ptr)
-{
-    g_pNavigatorFuncs->memfree(ptr);
-}
-
-/* private function to Netscape.  do not use!
-*/
-void NPN_ReloadPlugins(NPBool reloadPages)
-{
-    g_pNavigatorFuncs->reloadplugins(reloadPages);
-}
-
-JRIEnv* NPN_GetJavaEnv(void)
-{
-	return g_pNavigatorFuncs->getJavaEnv();
-}
-
-jref NPN_GetJavaPeer(NPP instance)
-{
-	return g_pNavigatorFuncs->getJavaPeer(instance);
-}
-
-NPError NPN_GetValue(NPP instance, NPNVariable variable, void *result)
-{
-    return g_pNavigatorFuncs->getvalue(instance, variable, result);
-}
-
-NPError NPN_SetValue(NPP instance, NPPVariable variable, void *value)
-{
-    return g_pNavigatorFuncs->setvalue(instance, variable, value);
-}
-
-void NPN_InvalidateRect(NPP instance, NPRect *rect)
-{
-    g_pNavigatorFuncs->invalidaterect(instance, rect);
-}
-
-void NPN_InvalidateRegion(NPP instance, NPRegion region)
-{
-    g_pNavigatorFuncs->invalidateregion(instance, region);
-}
-
-void NPN_ForceRedraw(NPP instance)
-{
-    g_pNavigatorFuncs->forceredraw(instance);
-}
-
-NPIdentifier NPN_GetStringIdentifier(const NPUTF8 *name)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->getstringidentifier(name);
-    }
-    return NULL;
-}
-
-void NPN_GetStringIdentifiers(const NPUTF8 **names, int32_t nameCount, NPIdentifier *identifiers)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	g_pNavigatorFuncs->getstringidentifiers(names, nameCount, identifiers);
-    }
-}
-
-NPIdentifier NPN_GetIntIdentifier(int32_t intid)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->getintidentifier(intid);
-    }
-    return NULL;
-}
-
-bool NPN_IdentifierIsString(NPIdentifier identifier)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->identifierisstring(identifier);
-    }
-    return false;
-}
-
-NPUTF8 *NPN_UTF8FromIdentifier(NPIdentifier identifier)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->utf8fromidentifier(identifier);
-    }
-    return NULL;
-}
-
-int32_t NPN_IntFromIdentifier(NPIdentifier identifier)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->intfromidentifier(identifier);
-    }
-    return 0;
-}
-
-NPObject *NPN_CreateObject(NPP instance, NPClass *aClass)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->createobject(instance, aClass);
-    }
-    return NULL;
-}
-
-NPObject *NPN_RetainObject(NPObject *npobj)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->retainobject(npobj);
-    }
-    return NULL;
-}
-
-void NPN_ReleaseObject(NPObject *npobj)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	g_pNavigatorFuncs->releaseobject(npobj);
-    }
-}
-
-bool NPN_Invoke(NPP instance, NPObject *npobj, NPIdentifier methodName, const NPVariant *args, uint32_t argCount, NPVariant *result)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->invoke(instance, npobj, methodName, args, argCount, result);
-    }
-    return false;
-}
-
-bool NPN_InvokeDefault(NPP instance, NPObject *npobj, const NPVariant *args, uint32_t argCount, NPVariant *result)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->invokeDefault(instance, npobj, args, argCount, result);
-    }
-    return false;
-}
-
-bool NPN_Evaluate(NPP instance, NPObject *npobj, NPString *script, NPVariant *result)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->evaluate(instance, npobj, script, result);
-    }
-    return false;
-}
-
-bool NPN_GetProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName, NPVariant *result)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->getproperty(instance, npobj, propertyName, result);
-    }
-    return false;
-}
-
-bool NPN_SetProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName, const NPVariant *value)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->setproperty(instance, npobj, propertyName, value);
-    }
-    return false;
-}
-
-bool NPN_RemoveProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->removeproperty(instance, npobj, propertyName);
-    }
-    return false;
-}
-
-bool NPN_HasProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->hasproperty(instance, npobj, propertyName);
-    }
-    return false;
-}
-
-bool NPN_HasMethod(NPP instance, NPObject *npobj, NPIdentifier methodName)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	return g_pNavigatorFuncs->hasmethod(instance, npobj, methodName);
-    }
-    return false;
-}
-
-void NPN_ReleaseVariantValue(NPVariant *variant)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	g_pNavigatorFuncs->releasevariantvalue(variant);
-    }
-}
-
-void NPN_SetException(NPObject *npobj, const NPUTF8 *message)
-{
-    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
-    if( navMinorVers >= 14 )
-    {   
-	g_pNavigatorFuncs->setexception(npobj, message);
-    }
-}
-
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Netscape Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/NPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code.
+ *
+ * The Initial Developer of the Original Code is 
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or 
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the NPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the NPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "config.h"
+
+#ifdef HAVE_MOZILLA_CONFIG_H
+#   include <mozilla-config.h>
+#endif
+
+#include "nscore.h"
+#include "npapi.h"
+#include "npupp.h"
+
+//\\// DEFINE
+#define NP_EXPORT
+
+//\\// GLOBAL DATA
+NPNetscapeFuncs* g_pNavigatorFuncs = 0;
+JRIGlobalRef Private_GetJavaClass(void);
+
+//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
+////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
+// Private_GetJavaClass (global function)
+//
+//	Given a Java class reference (thru NPP_GetJavaClass) inform JRT
+//	of this class existence
+//
+JRIGlobalRef
+Private_GetJavaClass(void)
+{
+    jref clazz = NPP_GetJavaClass();
+    if (clazz) {
+		JRIEnv* env = NPN_GetJavaEnv();
+		return JRI_NewGlobalRef(env, clazz);
+    }
+    return NULL;
+}
+
+//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
+////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
+//						PLUGIN DLL entry points   
+//
+// These are the Windows specific DLL entry points. They must be exoprted
+//
+
+// we need these to be global since we have to fill one of its field
+// with a data (class) which requires knowlwdge of the navigator
+// jump-table. This jump table is known at Initialize time (NP_Initialize)
+// which is called after NP_GetEntryPoint
+static NPPluginFuncs* g_pluginFuncs;
+
+//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
+////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
+// NP_GetEntryPoints
+//
+//	fills in the func table used by Navigator to call entry points in
+//  plugin DLL.  Note that these entry points ensure that DS is loaded
+//  by using the NP_LOADDS macro, when compiling for Win16
+//
+#ifdef __MINGW32__
+extern "C" __declspec(dllexport) NPError WINAPI
+#else
+NPError WINAPI NP_EXPORT
+#endif
+NP_GetEntryPoints(NPPluginFuncs* pFuncs)
+{
+    // trap a NULL ptr 
+    if(pFuncs == NULL)
+        return NPERR_INVALID_FUNCTABLE_ERROR;
+
+    // if the plugin's function table is smaller than the plugin expects,
+    // then they are incompatible, and should return an error 
+
+    pFuncs->version       = (NP_VERSION_MAJOR << 8) | NP_VERSION_MINOR;
+    pFuncs->newp          = NPP_New;
+    pFuncs->destroy       = NPP_Destroy;
+    pFuncs->setwindow     = NPP_SetWindow;
+    pFuncs->newstream     = NPP_NewStream;
+    pFuncs->destroystream = NPP_DestroyStream;
+    pFuncs->asfile        = NPP_StreamAsFile;
+    pFuncs->writeready    = NPP_WriteReady;
+    pFuncs->write         = NPP_Write;
+    pFuncs->print         = NPP_Print;
+    pFuncs->event         = 0;       /// reserved 
+    pFuncs->getvalue	  = NPP_GetValue;
+    //pFuncs->setvalue	  = NPP_SetValue;
+
+	g_pluginFuncs		  = pFuncs;
+
+    return NPERR_NO_ERROR;
+}
+
+//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
+////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
+// NP_Initialize
+//
+//	called immediately after the plugin DLL is loaded
+//
+#ifdef __MINGW32__
+extern "C" __declspec(dllexport) NPError WINAPI
+#else
+NPError WINAPI NP_EXPORT 
+#endif
+NP_Initialize(NPNetscapeFuncs* pFuncs)
+{
+    // trap a NULL ptr 
+    if(pFuncs == NULL)
+        return NPERR_INVALID_FUNCTABLE_ERROR;
+
+    g_pNavigatorFuncs = pFuncs; // save it for future reference 
+
+    // if the plugin's major ver level is lower than the Navigator's,
+    // then they are incompatible, and should return an error 
+    if(HIBYTE(pFuncs->version) > NP_VERSION_MAJOR)
+        return NPERR_INCOMPATIBLE_VERSION_ERROR;
+
+	// We have to defer these assignments until g_pNavigatorFuncs is set
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+
+	if( navMinorVers >= NPVERS_HAS_NOTIFICATION ) {
+		g_pluginFuncs->urlnotify = NPP_URLNotify;
+	}
+	
+	if( navMinorVers >= NPVERS_HAS_LIVECONNECT ) {
+		g_pluginFuncs->javaClass = Private_GetJavaClass();
+	}
+
+	// NPP_Initialize is a standard (cross-platform) initialize function.
+    return NPP_Initialize();
+}
+
+//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
+////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
+// NP_Shutdown
+//
+//	called immediately before the plugin DLL is unloaded.
+//	This functio shuold check for some ref count on the dll to see if it is
+//	unloadable or it needs to stay in memory. 
+//
+#ifdef __MINGW32__
+extern "C" __declspec(dllexport) NPError WINAPI
+#else
+NPError WINAPI NP_EXPORT 
+#endif
+NP_Shutdown()
+{
+    NPP_Shutdown();
+    g_pNavigatorFuncs = NULL;
+    g_pluginFuncs = NULL;
+    return NPERR_NO_ERROR;
+}
+
+//						END - PLUGIN DLL entry points   
+////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
+//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
+
+/*    NAVIGATOR Entry points    */
+
+/* These entry points expect to be called from within the plugin.  The
+   noteworthy assumption is that DS has already been set to point to the
+   plugin's DLL data segment.  Don't call these functions from outside
+   the plugin without ensuring DS is set to the DLLs data segment first,
+   typically using the NP_LOADDS macro
+*/
+
+/* returns the major/minor version numbers of the Plugin API for the plugin
+   and the Navigator
+*/
+void NPN_Version(int* plugin_major, int* plugin_minor, int* netscape_major, int* netscape_minor)
+{
+    *plugin_major   = NP_VERSION_MAJOR;
+    *plugin_minor   = NP_VERSION_MINOR;
+    *netscape_major = HIBYTE(g_pNavigatorFuncs->version);
+    *netscape_minor = LOBYTE(g_pNavigatorFuncs->version);
+}
+
+/* causes the specified URL to be fetched and streamed in
+*/
+NPError NPN_GetURLNotify(NPP instance, const char *url, const char *target, void* notifyData)
+
+{
+	int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+	NPError err;
+	if( navMinorVers >= NPVERS_HAS_NOTIFICATION ) {
+		err = g_pNavigatorFuncs->geturlnotify(instance, url, target, notifyData);
+	}
+	else {
+		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
+	}
+	return err;
+}
+
+
+NPError NPN_GetURL(NPP instance, const char *url, const char *target)
+{
+    return g_pNavigatorFuncs->geturl(instance, url, target);
+}
+
+NPError NPN_PostURLNotify(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file, void* notifyData)
+{
+	int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+	NPError err;
+	if( navMinorVers >= NPVERS_HAS_NOTIFICATION ) {
+		err = g_pNavigatorFuncs->posturlnotify(instance, url, window, len, buf, file, notifyData);
+	}
+	else {
+		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
+	}
+	return err;
+}
+
+
+NPError NPN_PostURL(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file)
+{
+    return g_pNavigatorFuncs->posturl(instance, url, window, len, buf, file);
+}
+
+/* Requests that a number of bytes be provided on a stream.  Typically
+   this would be used if a stream was in "pull" mode.  An optional
+   position can be provided for streams which are seekable.
+*/
+NPError NPN_RequestRead(NPStream* stream, NPByteRange* rangeList)
+{
+    return g_pNavigatorFuncs->requestread(stream, rangeList);
+}
+
+/* Creates a new stream of data from the plug-in to be interpreted
+   by Netscape in the current window.
+*/
+NPError NPN_NewStream(NPP instance, NPMIMEType type, 
+								const char* target, NPStream** stream)
+{
+	int navMinorVersion = g_pNavigatorFuncs->version & 0xFF;
+	NPError err;
+
+	if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT ) {
+		err = g_pNavigatorFuncs->newstream(instance, type, target, stream);
+	}
+	else {
+		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
+	}
+	return err;
+}
+
+/* Provides len bytes of data.
+*/
+int32 NPN_Write(NPP instance, NPStream *stream,
+                int32 len, void *buffer)
+{
+	int navMinorVersion = g_pNavigatorFuncs->version & 0xFF;
+	int32 result;
+
+	if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT ) {
+		result = g_pNavigatorFuncs->write(instance, stream, len, buffer);
+	}
+	else {
+		result = -1;
+	}
+	return result;
+}
+
+/* Closes a stream object.  
+reason indicates why the stream was closed.
+*/
+NPError NPN_DestroyStream(NPP instance, NPStream* stream, NPError reason)
+{
+	int navMinorVersion = g_pNavigatorFuncs->version & 0xFF;
+	NPError err;
+
+	if( navMinorVersion >= NPVERS_HAS_STREAMOUTPUT ) {
+		err = g_pNavigatorFuncs->destroystream(instance, stream, reason);
+	}
+	else {
+		err = NPERR_INCOMPATIBLE_VERSION_ERROR;
+	}
+	return err;
+}
+
+/* Provides a text status message in the Netscape client user interface
+*/
+void NPN_Status(NPP instance, const char *message)
+{
+    g_pNavigatorFuncs->status(instance, message);
+}
+
+/* returns the user agent string of Navigator, which contains version info
+*/
+const char* NPN_UserAgent(NPP instance)
+{
+    return g_pNavigatorFuncs->uagent(instance);
+}
+
+/* allocates memory from the Navigator's memory space.  Necessary so that
+   saved instance data may be freed by Navigator when exiting.
+*/
+
+
+void* NPN_MemAlloc(uint32 size)
+{
+    return g_pNavigatorFuncs->memalloc(size);
+}
+
+/* reciprocal of MemAlloc() above
+*/
+void NPN_MemFree(void* ptr)
+{
+    g_pNavigatorFuncs->memfree(ptr);
+}
+
+/* private function to Netscape.  do not use!
+*/
+void NPN_ReloadPlugins(NPBool reloadPages)
+{
+    g_pNavigatorFuncs->reloadplugins(reloadPages);
+}
+
+JRIEnv* NPN_GetJavaEnv(void)
+{
+	return g_pNavigatorFuncs->getJavaEnv();
+}
+
+jref NPN_GetJavaPeer(NPP instance)
+{
+	return g_pNavigatorFuncs->getJavaPeer(instance);
+}
+
+NPError NPN_GetValue(NPP instance, NPNVariable variable, void *result)
+{
+    return g_pNavigatorFuncs->getvalue(instance, variable, result);
+}
+
+NPError NPN_SetValue(NPP instance, NPPVariable variable, void *value)
+{
+    return g_pNavigatorFuncs->setvalue(instance, variable, value);
+}
+
+void NPN_InvalidateRect(NPP instance, NPRect *rect)
+{
+    g_pNavigatorFuncs->invalidaterect(instance, rect);
+}
+
+void NPN_InvalidateRegion(NPP instance, NPRegion region)
+{
+    g_pNavigatorFuncs->invalidateregion(instance, region);
+}
+
+void NPN_ForceRedraw(NPP instance)
+{
+    g_pNavigatorFuncs->forceredraw(instance);
+}
+
+NPIdentifier NPN_GetStringIdentifier(const NPUTF8 *name)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->getstringidentifier(name);
+    }
+    return NULL;
+}
+
+void NPN_GetStringIdentifiers(const NPUTF8 **names, int32_t nameCount, NPIdentifier *identifiers)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	g_pNavigatorFuncs->getstringidentifiers(names, nameCount, identifiers);
+    }
+}
+
+NPIdentifier NPN_GetIntIdentifier(int32_t intid)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->getintidentifier(intid);
+    }
+    return NULL;
+}
+
+bool NPN_IdentifierIsString(NPIdentifier identifier)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->identifierisstring(identifier);
+    }
+    return false;
+}
+
+NPUTF8 *NPN_UTF8FromIdentifier(NPIdentifier identifier)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->utf8fromidentifier(identifier);
+    }
+    return NULL;
+}
+
+int32_t NPN_IntFromIdentifier(NPIdentifier identifier)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->intfromidentifier(identifier);
+    }
+    return 0;
+}
+
+NPObject *NPN_CreateObject(NPP instance, NPClass *aClass)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->createobject(instance, aClass);
+    }
+    return NULL;
+}
+
+NPObject *NPN_RetainObject(NPObject *npobj)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->retainobject(npobj);
+    }
+    return NULL;
+}
+
+void NPN_ReleaseObject(NPObject *npobj)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	g_pNavigatorFuncs->releaseobject(npobj);
+    }
+}
+
+bool NPN_Invoke(NPP instance, NPObject *npobj, NPIdentifier methodName, const NPVariant *args, uint32_t argCount, NPVariant *result)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->invoke(instance, npobj, methodName, args, argCount, result);
+    }
+    return false;
+}
+
+bool NPN_InvokeDefault(NPP instance, NPObject *npobj, const NPVariant *args, uint32_t argCount, NPVariant *result)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->invokeDefault(instance, npobj, args, argCount, result);
+    }
+    return false;
+}
+
+bool NPN_Evaluate(NPP instance, NPObject *npobj, NPString *script, NPVariant *result)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->evaluate(instance, npobj, script, result);
+    }
+    return false;
+}
+
+bool NPN_GetProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName, NPVariant *result)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->getproperty(instance, npobj, propertyName, result);
+    }
+    return false;
+}
+
+bool NPN_SetProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName, const NPVariant *value)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->setproperty(instance, npobj, propertyName, value);
+    }
+    return false;
+}
+
+bool NPN_RemoveProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->removeproperty(instance, npobj, propertyName);
+    }
+    return false;
+}
+
+bool NPN_HasProperty(NPP instance, NPObject *npobj, NPIdentifier propertyName)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->hasproperty(instance, npobj, propertyName);
+    }
+    return false;
+}
+
+bool NPN_HasMethod(NPP instance, NPObject *npobj, NPIdentifier methodName)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	return g_pNavigatorFuncs->hasmethod(instance, npobj, methodName);
+    }
+    return false;
+}
+
+void NPN_ReleaseVariantValue(NPVariant *variant)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	g_pNavigatorFuncs->releasevariantvalue(variant);
+    }
+}
+
+void NPN_SetException(NPObject *npobj, const NPUTF8 *message)
+{
+    int navMinorVers = g_pNavigatorFuncs->version & 0xFF;
+    if( navMinorVers >= 14 )
+    {   
+	g_pNavigatorFuncs->setexception(npobj, message);
+    }
+}
+

Property changes on: mozilla\support\npwin.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: mozilla\test.html
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: mozilla/vlc.r
===================================================================
--- mozilla/vlc.r	(revision 159)
+++ mozilla/vlc.r	(working copy)
@@ -13,9 +13,9 @@
 resource 'STR#' (126)
 {
     {
-        "Version 0.8.6, copyright 1996-2006 The VideoLAN Team"
-        "<BR><A HREF='http://www.videolan.org'>http://www.videolan.org</A>",
-        "VLC Multimedia Plugin"
+        "Songbird VLC Version 0.8.6c, Copyright 2007, The VideoLAN Team"
+        "<BR><A HREF='http://www.videolan.org'>http://www.videolan.org</A>, <A HREF='http://www.songbirdnest.com'>http://www.songbirdnest.com</A>",
+        "Songbird VLC Multimedia Plugin"
     };
 };
 
@@ -30,6 +30,8 @@
         "VLC plugin",
         /* Google VLC */
         "Google VLC plugin",
+        /* Songbird VLC */
+        "Songbird VLC Plugin",
     };
 };
 
@@ -44,6 +46,8 @@
         "application/x-vlc-plugin", "vlc",
         /* Google VLC */
         "video/x-google-vlc-plugin", "",
+        /* Songbird VLC */
+        "application/x-songbird-vlc-plugin", "",
     };
 };
 

Property changes on: mozilla\vlc.r
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: mozilla\vlcintf.idl
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: mozilla/vlcplugin.cpp
===================================================================
--- mozilla/vlcplugin.cpp	(revision 159)
+++ mozilla/vlcplugin.cpp	(working copy)
@@ -1,452 +1,484 @@
-/*****************************************************************************
- * vlcplugin.cpp: a VLC plugin for Mozilla
- *****************************************************************************
- * Copyright (C) 2002-2005 the VideoLAN team
- * $Id: vlcplugin.cpp 19481 2007-03-25 22:38:56Z damienf $
- *
- * Authors: Samuel Hocevar <sam@zoy.org>
- *          Damien Fouilleul <damienf.fouilleul@laposte.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/*****************************************************************************
- * Preamble
- *****************************************************************************/
-#include "config.h"
-
-#ifdef HAVE_MOZILLA_CONFIG_H
-#   include <mozilla-config.h>
-#endif
-
-#include "vlcplugin.h"
-#include "control/npovlc.h"
-#include "control/npolibvlc.h"
-
-#include <ctype.h>
-
-/*****************************************************************************
- * VlcPlugin constructor and destructor
- *****************************************************************************/
-VlcPlugin::VlcPlugin( NPP instance, uint16 mode ) :
-    i_npmode(mode),
-    b_stream(0),
-    b_autoplay(1),
-    psz_target(NULL),
-    libvlc_instance(NULL),
-    libvlc_log(NULL),
-    p_scriptClass(NULL),
-    p_browser(instance),
-    psz_baseURL(NULL)
-#if XP_WIN
-    ,pf_wndproc(NULL)
-#endif
-#if XP_UNIX
-    ,i_width((unsigned)-1)
-    ,i_height((unsigned)-1)
-#endif
-{
-    memset(&npwindow, 0, sizeof(NPWindow));
-}
-
-static bool boolValue(const char *value) {
-    return ( !strcmp(value, "1") || 
-             !strcasecmp(value, "true") ||
-             !strcasecmp(value, "yes") );
-}
-
-NPError VlcPlugin::init(int argc, char* const argn[], char* const argv[])
-{
-    /* prepare VLC command line */
-    char *ppsz_argv[32] = { "vlc" };
-    int ppsz_argc = 1;
-
-    /* locate VLC module path */
-#ifdef XP_MACOSX
-    ppsz_argv[ppsz_argc++] = "--plugin-path";
-    ppsz_argv[ppsz_argc++] = "/Library/Internet Plug-Ins/VLC Plugin.plugin/"
-                             "Contents/MacOS/modules";
-#elif defined(XP_WIN)
-    HKEY h_key;
-    DWORD i_type, i_data = MAX_PATH + 1;
-    char p_data[MAX_PATH + 1];
-    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\VideoLAN\\VLC",
-                      0, KEY_READ, &h_key ) == ERROR_SUCCESS )
-    {
-         if( RegQueryValueEx( h_key, "InstallDir", 0, &i_type,
-                              (LPBYTE)p_data, &i_data ) == ERROR_SUCCESS )
-         {
-             if( i_type == REG_SZ )
-             {
-                 strcat( p_data, "\\plugins" );
-                 ppsz_argv[ppsz_argc++] = "--plugin-path";
-                 ppsz_argv[ppsz_argc++] = p_data;
-             }
-         }
-         RegCloseKey( h_key );
-    }
-    ppsz_argv[ppsz_argc++] = "--no-one-instance";
-    if( IsDebuggerPresent() )
-    {
-        /*
-        ** VLC default threading mechanism is designed to be as compatible
-        ** with POSIX as possible. However when debugged on win32, threads
-        ** lose signals and eventually VLC get stuck during initialization.
-        ** threading support can be configured to be more debugging friendly
-        ** but it will be less compatible with POSIX.
-        ** This is done by initializing with the following options:
-        */
-        ppsz_argv[ppsz_argc++] = "--fast-mutex";
-        ppsz_argv[ppsz_argc++] = "--win9x-cv-method=1";
-    }
-
-
-#if 0
-    ppsz_argv[0] = "C:\\Cygwin\\home\\damienf\\vlc-trunk\\vlc";
-#endif
-
-#endif /* XP_MACOSX */
-
-    /* common settings */
-    ppsz_argv[ppsz_argc++] = "-vv";
-    ppsz_argv[ppsz_argc++] = "--no-stats";
-    ppsz_argv[ppsz_argc++] = "--intf";
-    ppsz_argv[ppsz_argc++] = "dummy";
-
-    const char *progid = NULL;
-
-    /* parse plugin arguments */
-    for( int i = 0; i < argc ; i++ )
-    {
-        fprintf(stderr, "argn=%s, argv=%s\n", argn[i], argv[i]);
-
-        if( !strcmp( argn[i], "target" )
-         || !strcmp( argn[i], "mrl")
-         || !strcmp( argn[i], "filename")
-         || !strcmp( argn[i], "src") )
-        {
-            psz_target = argv[i];
-        }
-        else if( !strcmp( argn[i], "autoplay")
-              || !strcmp( argn[i], "autostart") )
-        {
-            b_autoplay = boolValue(argv[i]);
-        }
-        else if( !strcmp( argn[i], "fullscreen" ) )
-        {
-            if( boolValue(argv[i]) )
-            {
-                ppsz_argv[ppsz_argc++] = "--fullscreen";
-            }
-            else
-            {
-                ppsz_argv[ppsz_argc++] = "--no-fullscreen";
-            }
-        }
-        else if( !strcmp( argn[i], "mute" ) )
-        {
-            if( boolValue(argv[i]) )
-            {
-                ppsz_argv[ppsz_argc++] = "--volume";
-                ppsz_argv[ppsz_argc++] = "0";
-            }
-        }
-        else if( !strcmp( argn[i], "loop")
-              || !strcmp( argn[i], "autoloop") )
-        {
-            if( boolValue(argv[i]) )
-            {
-                ppsz_argv[ppsz_argc++] = "--loop";
-            }
-            else {
-                ppsz_argv[ppsz_argc++] = "--no-loop";
-            }
-        }
-        else if( !strcmp( argn[i], "version")
-              || !strcmp( argn[i], "progid") )
-        {
-            progid = argv[i];
-        }
-    }
-
-    libvlc_instance = libvlc_new(ppsz_argc, ppsz_argv, NULL);
-    if( ! libvlc_instance )
-    {
-        return NPERR_GENERIC_ERROR;
-    }
-
-    /*
-    ** fetch plugin base URL, which is the URL of the page containing the plugin
-    ** this URL is used for making absolute URL from relative URL that may be
-    ** passed as an MRL argument
-    */
-    NPObject *plugin;
-
-    if( NPERR_NO_ERROR == NPN_GetValue(p_browser, NPNVWindowNPObject, &plugin) )
-    {
-        /*
-        ** is there a better way to get that info ?
-        */
-        static const char docLocHref[] = "document.location.href";
-        NPString script;
-        NPVariant result;
-
-        script.utf8characters = docLocHref;
-        script.utf8length = sizeof(docLocHref)-1;
-
-        if( NPN_Evaluate(p_browser, plugin, &script, &result) )
-        {
-            if( NPVARIANT_IS_STRING(result) )
-            {
-                NPString &location = NPVARIANT_TO_STRING(result);
-
-                psz_baseURL = new char[location.utf8length+1];
-                if( psz_baseURL )
-                {
-                    strncpy(psz_baseURL, location.utf8characters, location.utf8length);
-                    psz_baseURL[location.utf8length] = '\0';
-                }
-            }
-            NPN_ReleaseVariantValue(&result);
-        }
-        NPN_ReleaseObject(plugin);
-    }
-
-    if( psz_target )
-    {
-        // get absolute URL from src
-        char *psz_absurl = getAbsoluteURL(psz_target);
-        psz_target = psz_absurl ? psz_absurl : strdup(psz_target);
-    }
-
-    /* assign plugin script root class */
-    if( (NULL != progid) && (!strcmp(progid, "VideoLAN.VLCPlugin.2")) )
-    {
-        /* new APIs */
-        p_scriptClass = RuntimeNPClass<LibvlcRootNPObject>::getClass();
-    }
-    else
-    {
-        /* legacy APIs */
-        p_scriptClass = RuntimeNPClass<VlcNPObject>::getClass();
-    }
-
-    return NPERR_NO_ERROR;
-}
-
-#if 0
-#ifdef XP_WIN
-/* This is really ugly but there is a deadlock when stopping a stream
- * (in VLC_CleanUp()) because the video output is a child of the drawable but
- * is in a different thread. */
-static void HackStopVout( VlcPlugin* p_plugin )
-{
-    MSG msg;
-    HWND hwnd;
-    vlc_value_t value;
-
-    int i_vlc = libvlc_get_vlc_id(p_plugin->libvlc_instance);
-    VLC_VariableGet( i_vlc, "drawable", &value );
-
-    hwnd = FindWindowEx( (HWND)value.i_int, 0, 0, 0 );
-    if( !hwnd ) return;
-
-    PostMessage( hwnd, WM_CLOSE, 0, 0 );
-
-    do
-    {
-        while( PeekMessage( &msg, (HWND)value.i_int, 0, 0, PM_REMOVE ) )
-        {
-            TranslateMessage(&msg);
-            DispatchMessage(&msg);
-        }
-        if( FindWindowEx( (HWND)value.i_int, 0, 0, 0 ) ) Sleep( 10 );
-    }
-    while( (hwnd = FindWindowEx( (HWND)value.i_int, 0, 0, 0 )) );
-}
-#endif /* XP_WIN */
-#endif
-
-VlcPlugin::~VlcPlugin()
-{
-    delete psz_baseURL;
-    delete psz_target;
-    if( libvlc_log )
-        libvlc_log_close(libvlc_log, NULL);
-    if( libvlc_instance )
-        libvlc_destroy(libvlc_instance);
-}
-
-/*****************************************************************************
- * VlcPlugin methods
- *****************************************************************************/
-
-char *VlcPlugin::getAbsoluteURL(const char *url)
-{
-    if( NULL != url )
-    {
-        // check whether URL is already absolute
-        const char *end=strchr(url, ':');
-        if( (NULL != end) && (end != url) )
-        {
-            // validate protocol header
-            const char *start = url;
-            while( start != end ) {
-                char c = tolower(*start);
-                if( (c < 'a') || (c > 'z') )
-                    // not valid protocol header, assume relative URL
-                    goto relativeurl;
-                ++start;
-            }
-            /* we have a protocol header, therefore URL is absolute */
-            return strdup(url);
-        }
-
-relativeurl:
-
-        if( psz_baseURL )
-        {
-            size_t baseLen = strlen(psz_baseURL);
-            char *href = new char[baseLen+strlen(url)+1];
-            if( href )
-            {
-                /* prepend base URL */
-                strcpy(href, psz_baseURL);
-
-                /*
-                ** relative url could be empty,
-                ** in which case return base URL
-                */
-                if( '\0' == *url )
-                    return href;
-
-                /*
-                ** locate pathname part of base URL
-                */
-
-                /* skip over protocol part  */
-                char *pathstart = strchr(href, ':');
-                char *pathend;
-                if( pathstart )
-                {
-                    if( '/' == *(++pathstart) )
-                    {
-                        if( '/' == *(++pathstart) )
-                        {
-                            ++pathstart;
-                        }
-                    }
-                    /* skip over host part */
-                    pathstart = strchr(pathstart, '/');
-                    pathend = href+baseLen;
-                    if( ! pathstart )
-                    {
-                        // no path, add a / past end of url (over '\0')
-                        pathstart = pathend;
-                        *pathstart = '/';
-                    }
-                }
-                else
-                {
-                    /* baseURL is just a UNIX path */
-                    if( '/' != *href )
-                    {
-                        /* baseURL is not an absolute path */
-                        return NULL;
-                    }
-                    pathstart = href;
-                    pathend = href+baseLen;
-                }
-
-                /* relative URL made of an absolute path ? */
-                if( '/' == *url )
-                {
-                    /* replace path completely */
-                    strcpy(pathstart, url);
-                    return href;
-                }
-
-                /* find last path component and replace it */ 
-                while( '/' != *pathend)
-                    --pathend;
-
-                /*
-                ** if relative url path starts with one or more '../',
-                ** factor them out of href so that we return a
-                ** normalized URL
-                */
-                while( pathend != pathstart )
-                {
-                    const char *p = url;
-                    if( '.' != *p )
-                        break;
-                    ++p;
-                    if( '\0' == *p  )
-                    {
-                        /* relative url is just '.' */
-                        url = p;
-                        break;
-                    }
-                    if( '/' == *p  )
-                    {
-                        /* relative url starts with './' */
-                        url = ++p;
-                        continue;
-                    }
-                    if( '.' != *p ) 
-                        break;
-                    ++p;
-                    if( '\0' == *p )
-                    {
-                        /* relative url is '..' */
-                    }
-                    else
-                    {
-                        if( '/' != *p ) 
-                            break;
-                        /* relative url starts with '../' */
-                        ++p;
-                    }
-                    url = p;
-                    do
-                    {
-                        --pathend;
-                    }
-                    while( '/' != *pathend );
-                }
-                /* skip over '/' separator */
-                ++pathend;
-                /* concatenate remaining base URL and relative URL */
-                strcpy(pathend, url);
-            }
-            return href;
-        }
-    }
-    return NULL;
-}
-
-#if XP_UNIX
-int  VlcPlugin::setSize(unsigned width, unsigned height)
-{
-    int diff = (width != i_width) || (height != i_height);
-
-    i_width = width;
-    i_height = height;
-
-    /* return size */
-    return diff;
-}
-#endif
-
+/*****************************************************************************
+ * vlcplugin.cpp: a VLC plugin for Mozilla
+ *****************************************************************************
+ * Copyright (C) 2002-2005 the VideoLAN team
+ * $Id: vlcplugin.cpp 19481 2007-03-25 22:38:56Z damienf $
+ *
+ * Authors: Samuel Hocevar <sam@zoy.org>
+ *          Damien Fouilleul <damienf.fouilleul@laposte.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+#include "config.h"
+
+#ifdef HAVE_MOZILLA_CONFIG_H
+#   include <mozilla-config.h>
+#endif
+
+#include "vlcplugin.h"
+#include "control/npovlc.h"
+#include "control/npolibvlc.h"
+
+#include <ctype.h>
+
+/*****************************************************************************
+ * VlcPlugin constructor and destructor
+ *****************************************************************************/
+VlcPlugin::VlcPlugin( NPP instance, uint16 mode ) :
+    i_npmode(mode),
+    b_stream(0),
+    b_autoplay(1),
+    psz_target(NULL),
+    libvlc_instance(NULL),
+    libvlc_log(NULL),
+    p_scriptClass(NULL),
+    p_browser(instance),
+    psz_baseURL(NULL)
+#if XP_WIN
+    ,pf_wndproc(NULL)
+#endif
+#if XP_UNIX
+    ,i_width((unsigned)-1)
+    ,i_height((unsigned)-1)
+#endif
+{
+    memset(&npwindow, 0, sizeof(NPWindow));
+}
+
+static int boolValue(const char *value) {
+    return ( !strcmp(value, "1") || 
+             !strcasecmp(value, "true") ||
+             !strcasecmp(value, "yes") );
+}
+
+NPError VlcPlugin::init(int argc, char* const argn[], char* const argv[])
+{
+    /* prepare VLC command line */
+    char *ppsz_argv[32] = { "vlc" };
+    int ppsz_argc = 1;
+
+    /* locate VLC module path */
+#ifdef XP_MACOSX
+    ppsz_argv[ppsz_argc++] = "--plugin-path";
+
+    // Dig through the os x bundle API to figure out the module path
+    CFBundleRef appBundle = CFBundleGetMainBundle();
+    if (appBundle == NULL) { 
+      printf("\nVlcPlugin::init - Could not get bundle ref\n");
+      return NPERR_GENERIC_ERROR;
+    }
+    CFURLRef bundleURL = CFBundleCopyBundleURL(appBundle);
+    if (bundleURL == NULL) {
+      printf("\nVlcPlugin::init - Could not get bundle URL\n");
+      return NPERR_GENERIC_ERROR;
+    }
+    CFStringRef myString = CFURLCopyFileSystemPath(bundleURL, kCFURLPOSIXPathStyle);
+
+    // ppsz_argv needs a CString path, so convert down.
+    // What happens if the user runs the app from some unicode URL?
+    const CFIndex PATH_BUFFER = PATH_MAX + 1;
+    char bundlePath[PATH_BUFFER];
+    CFStringGetCString(myString, bundlePath, PATH_BUFFER, kCFStringEncodingASCII);
+    if (bundlePath == NULL) {
+        printf("\nVlcPlugin::init - Could not get path string\n");
+        CFRelease(bundleURL);
+        return NPERR_GENERIC_ERROR;
+    }
+
+    // Add the known plugin path to the bundle path
+    strcat(bundlePath, "/Contents/Resources/plugins/VLC Plugin.plugin/Contents/MacOS/modules" );
+    printf("\nVlcPlugin::init - Using path %s\n", bundlePath);
+    ppsz_argv[ppsz_argc++] = bundlePath;
+
+    CFRelease(bundleURL);
+
+    //ppsz_argv[ppsz_argc++] = "/Library/Internet Plug-Ins/VLC Plugin.plugin/"
+    //                         "Contents/MacOS/modules";
+#elif defined(XP_WIN)
+    HKEY h_key;
+    DWORD i_type, i_data = MAX_PATH + 1;
+    char p_data[MAX_PATH + 1];
+    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\VideoLAN\\VLC",
+                      0, KEY_READ, &h_key ) == ERROR_SUCCESS )
+    {
+         if( RegQueryValueEx( h_key, "InstallDir", 0, &i_type,
+                              (LPBYTE)p_data, &i_data ) == ERROR_SUCCESS )
+         {
+             if( i_type == REG_SZ )
+             {
+                 strcat( p_data, "\\plugins" );
+                 ppsz_argv[ppsz_argc++] = "--plugin-path";
+                 ppsz_argv[ppsz_argc++] = p_data;
+             }
+         }
+         RegCloseKey( h_key );
+    }
+    ppsz_argv[ppsz_argc++] = "--no-one-instance";
+    if( IsDebuggerPresent() )
+    {
+        /*
+        ** VLC default threading mechanism is designed to be as compatible
+        ** with POSIX as possible. However when debugged on win32, threads
+        ** lose signals and eventually VLC get stuck during initialization.
+        ** threading support can be configured to be more debugging friendly
+        ** but it will be less compatible with POSIX.
+        ** This is done by initializing with the following options:
+        */
+        ppsz_argv[ppsz_argc++] = "--fast-mutex";
+        ppsz_argv[ppsz_argc++] = "--win9x-cv-method=1";
+    }
+
+
+#if 0
+    ppsz_argv[0] = "C:\\Cygwin\\home\\damienf\\vlc-trunk\\vlc";
+#endif
+
+#endif /* XP_MACOSX */
+
+    /* common settings */
+    ppsz_argv[ppsz_argc++] = "-vv";
+    ppsz_argv[ppsz_argc++] = "--no-stats";
+    ppsz_argv[ppsz_argc++] = "--intf";
+    ppsz_argv[ppsz_argc++] = "dummy";
+
+    const char *version = NULL;
+
+    /* parse plugin arguments */
+    for( int i = 0; i < argc ; i++ )
+    {
+        fprintf(stderr, "argn=%s, argv=%s\n", argn[i], argv[i]);
+
+        if( !strcmp( argn[i], "target" )
+         || !strcmp( argn[i], "mrl")
+         || !strcmp( argn[i], "filename")
+         || !strcmp( argn[i], "src") )
+        {
+            psz_target = argv[i];
+        }
+        else if( !strcmp( argn[i], "autoplay")
+              || !strcmp( argn[i], "autostart") )
+        {
+            b_autoplay = boolValue(argv[i]);
+        }
+        else if( !strcmp( argn[i], "fullscreen" ) )
+        {
+            if( boolValue(argv[i]) )
+            {
+                ppsz_argv[ppsz_argc++] = "--fullscreen";
+            }
+            else
+            {
+                ppsz_argv[ppsz_argc++] = "--no-fullscreen";
+            }
+        }
+        else if( !strcmp( argn[i], "mute" ) )
+        {
+            if( boolValue(argv[i]) )
+            {
+                ppsz_argv[ppsz_argc++] = "--volume";
+                ppsz_argv[ppsz_argc++] = "0";
+            }
+        }
+        else if( !strcmp( argn[i], "loop")
+              || !strcmp( argn[i], "autoloop") )
+        {
+            if( boolValue(argv[i]) )
+            {
+                ppsz_argv[ppsz_argc++] = "--loop";
+            }
+            else {
+                ppsz_argv[ppsz_argc++] = "--no-loop";
+            }
+        }
+        else if( !strcmp( argn[i], "version") )
+        {
+            version = argv[i];
+        }
+    }
+
+    libvlc_instance = libvlc_new(ppsz_argc, ppsz_argv, NULL);
+    if( ! libvlc_instance )
+    {
+        return NPERR_GENERIC_ERROR;
+    }
+
+    /*
+    ** fetch plugin base URL, which is the URL of the page containing the plugin
+    ** this URL is used for making absolute URL from relative URL that may be
+    ** passed as an MRL argument
+    */
+    NPObject *plugin;
+
+    if( NPERR_NO_ERROR == NPN_GetValue(p_browser, NPNVWindowNPObject, &plugin) )
+    {
+        /*
+        ** is there a better way to get that info ?
+        */
+        static const char docLocHref[] = "document.location.href";
+        NPString script;
+        NPVariant result;
+
+        script.utf8characters = docLocHref;
+        script.utf8length = sizeof(docLocHref)-1;
+
+        if( NPN_Evaluate(p_browser, plugin, &script, &result) )
+        {
+            if( NPVARIANT_IS_STRING(result) )
+            {
+                NPString &location = NPVARIANT_TO_STRING(result);
+
+                psz_baseURL = new char[location.utf8length+1];
+                if( psz_baseURL )
+                {
+                    strncpy(psz_baseURL, location.utf8characters, location.utf8length);
+                    psz_baseURL[location.utf8length] = '\0';
+                }
+            }
+            NPN_ReleaseVariantValue(&result);
+        }
+        NPN_ReleaseObject(plugin);
+    }
+
+    if( psz_target )
+    {
+        // get absolute URL from src
+        char *psz_absurl = getAbsoluteURL(psz_target);
+        psz_target = psz_absurl ? psz_absurl : strdup(psz_target);
+    }
+
+    /* assign plugin script root class */
+    if( (NULL != version) && (!strcmp(version, "VideoLAN.VLCPlugin.2")) )
+    {
+        /* new APIs */
+        p_scriptClass = RuntimeNPClass<LibvlcRootNPObject>::getClass();
+    }
+    else
+    {
+        /* legacy APIs */
+        p_scriptClass = RuntimeNPClass<VlcNPObject>::getClass();
+    }
+
+    return NPERR_NO_ERROR;
+}
+
+#if 0
+#ifdef XP_WIN
+/* This is really ugly but there is a deadlock when stopping a stream
+ * (in VLC_CleanUp()) because the video output is a child of the drawable but
+ * is in a different thread. */
+static void HackStopVout( VlcPlugin* p_plugin )
+{
+    MSG msg;
+    HWND hwnd;
+    vlc_value_t value;
+
+    int i_vlc = libvlc_get_vlc_id(p_plugin->libvlc_instance);
+    VLC_VariableGet( i_vlc, "drawable", &value );
+
+    hwnd = FindWindowEx( (HWND)value.i_int, 0, 0, 0 );
+    if( !hwnd ) return;
+
+    PostMessage( hwnd, WM_CLOSE, 0, 0 );
+
+    do
+    {
+        while( PeekMessage( &msg, (HWND)value.i_int, 0, 0, PM_REMOVE ) )
+        {
+            TranslateMessage(&msg);
+            DispatchMessage(&msg);
+        }
+        if( FindWindowEx( (HWND)value.i_int, 0, 0, 0 ) ) Sleep( 10 );
+    }
+    while( (hwnd = FindWindowEx( (HWND)value.i_int, 0, 0, 0 )) );
+}
+#endif /* XP_WIN */
+#endif
+
+VlcPlugin::~VlcPlugin()
+{
+    delete psz_baseURL;
+    delete psz_target;
+    if( libvlc_log )
+        libvlc_log_close(libvlc_log, NULL);
+    if( libvlc_instance )
+        libvlc_destroy(libvlc_instance);
+}
+
+/*****************************************************************************
+ * VlcPlugin methods
+ *****************************************************************************/
+
+char *VlcPlugin::getAbsoluteURL(const char *url)
+{
+    if( NULL != url )
+    {
+        // check whether URL is already absolute
+        const char *end=strchr(url, ':');
+        if( (NULL != end) && (end != url) )
+        {
+            // validate protocol header
+            const char *start = url;
+            while( start != end ) {
+                char c = tolower(*start);
+                if( (c < 'a') || (c > 'z') )
+                    // not valid protocol header, assume relative URL
+                    goto relativeurl;
+                ++start;
+            }
+            /* we have a protocol header, therefore URL is absolute */
+            return strdup(url);
+        }
+
+relativeurl:
+
+        if( psz_baseURL )
+        {
+            size_t baseLen = strlen(psz_baseURL);
+            char *href = new char[baseLen+strlen(url)+1];
+            if( href )
+            {
+                /* prepend base URL */
+                strcpy(href, psz_baseURL);
+
+                /*
+                ** relative url could be empty,
+                ** in which case return base URL
+                */
+                if( '\0' == *url )
+                    return href;
+
+                /*
+                ** locate pathname part of base URL
+                */
+
+                /* skip over protocol part  */
+                char *pathstart = strchr(href, ':');
+                char *pathend;
+                if( pathstart )
+                {
+                    if( '/' == *(++pathstart) )
+                    {
+                        if( '/' == *(++pathstart) )
+                        {
+                            ++pathstart;
+                        }
+                    }
+                    /* skip over host part */
+                    pathstart = strchr(pathstart, '/');
+                    pathend = href+baseLen;
+                    if( ! pathstart )
+                    {
+                        // no path, add a / past end of url (over '\0')
+                        pathstart = pathend;
+                        *pathstart = '/';
+                    }
+                }
+                else
+                {
+                    /* baseURL is just a UNIX path */
+                    if( '/' != *href )
+                    {
+                        /* baseURL is not an absolute path */
+                        return NULL;
+                    }
+                    pathstart = href;
+                    pathend = href+baseLen;
+                }
+
+                /* relative URL made of an absolute path ? */
+                if( '/' == *url )
+                {
+                    /* replace path completely */
+                    strcpy(pathstart, url);
+                    return href;
+                }
+
+                /* find last path component and replace it */ 
+                while( '/' != *pathend)
+                    --pathend;
+
+                /*
+                ** if relative url path starts with one or more '../',
+                ** factor them out of href so that we return a
+                ** normalized URL
+                */
+                while( pathend != pathstart )
+                {
+                    const char *p = url;
+                    if( '.' != *p )
+                        break;
+                    ++p;
+                    if( '\0' == *p  )
+                    {
+                        /* relative url is just '.' */
+                        url = p;
+                        break;
+                    }
+                    if( '/' == *p  )
+                    {
+                        /* relative url starts with './' */
+                        url = ++p;
+                        continue;
+                    }
+                    if( '.' != *p ) 
+                        break;
+                    ++p;
+                    if( '\0' == *p )
+                    {
+                        /* relative url is '..' */
+                    }
+                    else
+                    {
+                        if( '/' != *p ) 
+                            break;
+                        /* relative url starts with '../' */
+                        ++p;
+                    }
+                    url = p;
+                    do
+                    {
+                        --pathend;
+                    }
+                    while( '/' != *pathend );
+                }
+                /* skip over '/' separator */
+                ++pathend;
+                /* concatenate remaining base URL and relative URL */
+                strcpy(pathend, url);
+            }
+            return href;
+        }
+    }
+    return NULL;
+}
+
+#if XP_UNIX
+int  VlcPlugin::setSize(unsigned width, unsigned height)
+{
+    int diff = (width != i_width) || (height != i_height);
+
+    i_width = width;
+    i_height = height;
+
+    /* return size */
+    return diff;
+}
+#endif
+
+

Property changes on: mozilla\vlcplugin.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: mozilla/vlcplugin.h
===================================================================
--- mozilla/vlcplugin.h	(revision 159)
+++ mozilla/vlcplugin.h	(working copy)
@@ -1,166 +1,137 @@
-/*****************************************************************************
- * vlcplugin.h: a VLC plugin for Mozilla
- *****************************************************************************
- * Copyright (C) 2002-2006 the VideoLAN team
- * $Id: vlcplugin.h 19481 2007-03-25 22:38:56Z damienf $
- *
- * Authors: Samuel Hocevar <sam@zoy.org>
-            Damien Fouilleul <damienf@videolan.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/*******************************************************************************
- * Instance state information about the plugin.
- ******************************************************************************/
-#ifndef __VLCPLUGIN_H__
-#define __VLCPLUGIN_H__
-
-#include <vlc/libvlc.h>
-#include <npapi.h>
-#include "control/nporuntime.h"
-
-#if !defined(XP_MACOSX) && !defined(XP_UNIX) && !defined(XP_WIN)
-#define XP_UNIX 1
-#elif defined(XP_MACOSX)
-#undef XP_UNIX
-#endif
-
-#ifdef XP_WIN
-    /* Windows stuff */
-#endif
-
-#ifdef XP_MACOSX
-    /* Mac OS X stuff */
-#   include <Quickdraw.h>
-#endif
-
-#ifdef XP_UNIX
-    /* X11 stuff */
-#   include <X11/Xlib.h>
-#   include <X11/Intrinsic.h>
-#   include <X11/StringDefs.h>
-#endif
-
-class VlcPlugin
-{
-public:
-             VlcPlugin( NPP, uint16 ); 
-    virtual ~VlcPlugin();
-
-    NPError             init(int argc, char* const argn[], char* const argv[]);
-    libvlc_instance_t*  getVLC() 
-                            { return libvlc_instance; };
-    NPP                 getBrowser()
-                            { return p_browser; };
-    char*               getAbsoluteURL(const char *url);
-    const NPWindow*     getWindow()
-                            { return &npwindow; };
-    void                setWindow(const NPWindow *window)
-                            { npwindow = *window; };
-
-    NPClass*            getScriptClass()
-                            { return p_scriptClass; };
-
-    void                setLog(libvlc_log_t *log)
-                            { libvlc_log = log; };
-    libvlc_log_t*       getLog()
-                            { return libvlc_log; };
-#if XP_WIN
-    WNDPROC             getWindowProc()
-                            { return pf_wndproc; };
-    void                setWindowProc(WNDPROC wndproc)
-                            { pf_wndproc = wndproc; };
-#endif
-
-#if XP_UNIX
-    int                 setSize(unsigned width, unsigned height);
-#endif
-
-    uint16    i_npmode; /* either NP_EMBED or NP_FULL */
-
-    /* plugin properties */
-    int      b_stream;
-    int      b_autoplay;
-    char *   psz_target;
-
-private:
-    /* VLC reference */
-    libvlc_instance_t   *libvlc_instance;
-    libvlc_log_t        *libvlc_log;
-    NPClass             *p_scriptClass;
-
-    /* browser reference */
-    NPP     p_browser;
-    char*   psz_baseURL;
-
-    /* display settings */
-    NPWindow  npwindow;
-#if XP_WIN
-    WNDPROC   pf_wndproc;
-#endif
-#if XP_UNIX
-    unsigned int     i_width, i_height;
-#endif
-};
-
-/*******************************************************************************
- * Plugin properties.
- ******************************************************************************/
-#define PLUGIN_NAME         "VLC Multimedia Plugin"
-#define PLUGIN_DESCRIPTION \
-    "Version %s, copyright 1996-2007 The VideoLAN Team" \
-    "<br><a href=\"http://www.videolan.org/\">http://www.videolan.org/</a>"
-
-#define PLUGIN_MIMETYPES \
-    /* MPEG-1 and MPEG-2 */ \
-    "audio/mpeg:mp2,mp3,mpga,mpega:MPEG audio;" \
-    "audio/x-mpeg:mp2,mp3,mpga,mpega:MPEG audio;" \
-    "video/mpeg:mpg,mpeg,mpe:MPEG video;" \
-    "video/x-mpeg:mpg,mpeg,mpe:MPEG video;" \
-    "video/mpeg-system:mpg,mpeg,mpe,vob:MPEG video;" \
-    "video/x-mpeg-system:mpg,mpeg,mpe,vob:MPEG video;" \
-    /* MPEG-4 */ \
-    "video/mpeg4:mp4,mpg4:MPEG-4 video;" \
-    "audio/mpeg4:mp4,mpg4:MPEG-4 audio;" \
-    "application/mpeg4-iod:mp4,mpg4:MPEG-4 video;" \
-    "application/mpeg4-muxcodetable:mp4,mpg4:MPEG-4 video;" \
-    /* AVI */ \
-    "video/x-msvideo:avi:AVI video;" \
-    /* QuickTime */ \
-    "video/quicktime:mov,qt:QuickTime video;" \
-    /* OGG */ \
-    "application/x-ogg:ogg:Ogg stream;" \
-    "application/ogg:ogg:Ogg stream;" \
-    /* VLC */ \
-    "application/x-vlc-plugin:vlc:VLC plugin;" \
-    /* Windows Media */ \
-    "video/x-ms-asf-plugin:asf,asx:Windows Media Video;" \
-    "video/x-ms-asf:asf,asx:Windows Media Video;" \
-    "application/x-mplayer2::Windows Media;" \
-    "video/x-ms-wmv:wmv:Windows Media;" \
-    /* Google VLC */ \
-    "application/x-google-vlc-plugin::Google VLC plugin;" \
-    /* WAV audio */ \
-    "audio/wav:wav:WAV audio;" \
-    "audio/x-wav:wav:WAV audio;" \
-    /* 3GPP */ \
-    "audio/3gpp:3gp,3gpp:3GPP audio;" \
-    "video/3gpp:3gp,3gpp:3GPP video;" \
-    /* 3GPP2 */ \
-    "audio/3gpp2:3g2,3gpp2:3GPP2 audio;" \
-    "video/3gpp2:3g2,3gpp2:3GPP2 video;" \
-
-#endif
+/*****************************************************************************
+ * vlcplugin.h: a VLC plugin for Mozilla
+ *****************************************************************************
+ * Copyright (C) 2002-2006 the VideoLAN team
+ * $Id: vlcplugin.h 19481 2007-03-25 22:38:56Z damienf $
+ *
+ * Authors: Samuel Hocevar <sam@zoy.org>
+            Damien Fouilleul <damienf@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*******************************************************************************
+ * Instance state information about the plugin.
+ ******************************************************************************/
+#ifndef __VLCPLUGIN_H__
+#define __VLCPLUGIN_H__
+
+#include <vlc/libvlc.h>
+#include <npapi.h>
+#include "control/nporuntime.h"
+
+#if !defined(XP_MACOSX) && !defined(XP_UNIX) && !defined(XP_WIN)
+#define XP_UNIX 1
+#elif defined(XP_MACOSX)
+#undef XP_UNIX
+#endif
+
+#ifdef XP_WIN
+    /* Windows stuff */
+#   include <windows.h>
+#endif
+
+#ifdef XP_MACOSX
+    /* Mac OS X stuff */
+#   include <Quickdraw.h>
+#endif
+
+#ifdef XP_UNIX
+    /* X11 stuff */
+#   include <X11/Xlib.h>
+#   include <X11/Intrinsic.h>
+#   include <X11/StringDefs.h>
+#endif
+
+class VlcPlugin
+{
+public:
+             VlcPlugin( NPP, uint16 ); 
+    virtual ~VlcPlugin();
+
+    NPError             init(int argc, char* const argn[], char* const argv[]);
+    libvlc_instance_t*  getVLC() 
+                            { return libvlc_instance; };
+    NPP                 getBrowser()
+                            { return p_browser; };
+    char*               getAbsoluteURL(const char *url);
+    const NPWindow*     getWindow()
+                            { return &npwindow; };
+    void                setWindow(const NPWindow *window)
+                            { npwindow = *window; };
+
+    NPClass*            getScriptClass()
+                            { return p_scriptClass; };
+
+    void                setLog(libvlc_log_t *log)
+                            { libvlc_log = log; };
+    libvlc_log_t*       getLog()
+                            { return libvlc_log; };
+#if XP_WIN
+    WNDPROC             getWindowProc()
+                            { return pf_wndproc; };
+    void                setWindowProc(WNDPROC wndproc)
+                            { pf_wndproc = wndproc; };
+#endif
+
+#if XP_UNIX
+    int                 setSize(unsigned width, unsigned height);
+#endif
+
+    uint16    i_npmode; /* either NP_EMBED or NP_FULL */
+
+    /* plugin properties */
+    int      b_stream;
+    int      b_autoplay;
+    char *   psz_target;
+
+private:
+    /* VLC reference */
+    libvlc_instance_t   *libvlc_instance;
+    libvlc_log_t        *libvlc_log;
+    NPClass             *p_scriptClass;
+    NPObject            *p_scriptObject;
+    
+    /* browser reference */
+    NPP     p_browser;
+    char*   psz_baseURL;
+
+    /* display settings */
+    NPWindow  npwindow;
+#if XP_WIN
+    WNDPROC   pf_wndproc;
+#endif
+#if XP_UNIX
+    unsigned int     i_width, i_height;
+#endif
+};
+
+/*******************************************************************************
+ * Plugin properties.
+ ******************************************************************************/
+#define PLUGIN_NAME         "Songbird VLC Plugin"
+#define PLUGIN_DESCRIPTION \
+    "Version %s, copyright 1996-2007 The VideoLAN Team, some parts copyright 2006-2007 POTI, Inc." \
+    "<br><a href=\"http://www.videolan.org/\">http://www.videolan.org/</a>" \
+    "<br><a href=\"http://www.songbirdnest.com/\">http://www.songbirdnest.com/</a>"
+
+#define PLUGIN_MIMETYPES \
+    /* VLC */ \
+    "application/x-vlc-plugin:vlc:VLC plugin;" \
+    /* Songbird VLC */ \
+    "application/x-songbird-vlc-plugin::Songbird VLC plugin;" \
+    /* Google VLC */ \
+    "application/x-google-vlc-plugin::Google VLC plugin;"
+#endif

Property changes on: mozilla\vlcplugin.h
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: mozilla/vlcshell.cpp
===================================================================
--- mozilla/vlcshell.cpp	(revision 159)
+++ mozilla/vlcshell.cpp	(working copy)
@@ -1,799 +1,799 @@
-/*****************************************************************************
- * vlcshell.cpp: a VLC plugin for Mozilla
- *****************************************************************************
- * Copyright (C) 2002-2005 the VideoLAN team
- * $Id: vlcshell.cpp 19481 2007-03-25 22:38:56Z damienf $
- *
- * Authors: Samuel Hocevar <sam@zoy.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/*****************************************************************************
- * Preamble
- *****************************************************************************/
-#include "config.h"
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-
-/* Mozilla stuff */
-#ifdef HAVE_MOZILLA_CONFIG_H
-#   include <mozilla-config.h>
-#endif
-
-/* This is from mozilla java, do we really need it? */
-#if 0
-#include <jri.h>
-#endif
-
-#include "vlcplugin.h"
-
-/* Enable/disable debugging printf's for X11 resizing */
-#undef X11_RESIZE_DEBUG
-
-#define WINDOW_TEXT "(no video)"
-
-/*****************************************************************************
- * Unix-only declarations
-******************************************************************************/
-#ifdef XP_UNIX
-
-static void Redraw( Widget w, XtPointer closure, XEvent *event );
-static void Resize( Widget w, XtPointer closure, XEvent *event );
-
-#endif
-
-/*****************************************************************************
- * MacOS-only declarations
-******************************************************************************/
-#ifdef XP_MACOSX
-#endif
-
-/*****************************************************************************
- * Windows-only declarations
- *****************************************************************************/
-#ifdef XP_WIN
-
-static LRESULT CALLBACK Manage( HWND p_hwnd, UINT i_msg, WPARAM wpar, LPARAM lpar );
-
-#endif
-
-/******************************************************************************
- * UNIX-only API calls
- *****************************************************************************/
-char * NPP_GetMIMEDescription( void )
-{
-    return PLUGIN_MIMETYPES;
-}
-
-NPError NPP_GetValue( NPP instance, NPPVariable variable, void *value )
-{
-
-    static char psz_desc[1000];
-
-    /* plugin class variables */
-    switch( variable )
-    {
-        case NPPVpluginNameString:
-            *((char **)value) = PLUGIN_NAME;
-            return NPERR_NO_ERROR;
-
-        case NPPVpluginDescriptionString:
-            snprintf( psz_desc, sizeof(psz_desc), PLUGIN_DESCRIPTION, VLC_Version() );
-            *((char **)value) = psz_desc;
-            return NPERR_NO_ERROR;
-
-        default:
-            /* move on to instance variables ... */
-            ;
-    }
-
-    if( instance == NULL )
-    {
-        return NPERR_INVALID_INSTANCE_ERROR;
-    }
-
-    /* plugin instance variables */
-
-    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(instance->pdata);
-    if( NULL == p_plugin )
-    {
-        // plugin has not been initialized yet !
-        return NPERR_INVALID_INSTANCE_ERROR;
-    }
-
-    switch( variable )
-    {
-        case NPPVpluginScriptableNPObject:
-        {
-            /* retrieve plugin root class */
-            NPClass *scriptClass = p_plugin->getScriptClass();
-            if( scriptClass )
-            {
-                /* create an instance and return it */
-                *(NPObject**)value = NPN_CreateObject(instance, scriptClass);
-                return NPERR_NO_ERROR;
-            }
-            break;
-        }
-
-        default:
-            ;
-    }
-    return NPERR_GENERIC_ERROR;
-}
-
-/*
- * there is some confusion in gecko headers regarding definition of this API
- * NPPVariable is wrongly defined as NPNVariable, which sounds incorrect.
- */
-
-NPError NPP_SetValue( NPP instance, NPNVariable variable, void *value )
-{
-    return NPERR_GENERIC_ERROR;
-}
-
-/******************************************************************************
- * Mac-only API calls
- *****************************************************************************/
-#ifdef XP_MACOSX
-int16 NPP_HandleEvent( NPP instance, void * event )
-{
-    static UInt32 lastMouseUp = 0;
-
-    if( instance == NULL )
-    {
-        return false;
-    }
-
-    VlcPlugin *p_plugin = (VlcPlugin*)instance->pdata;
-
-    if( p_plugin == NULL )
-    {
-        return false;
-    }
-
-    EventRecord *myEvent = (EventRecord*)event;
-
-    switch( myEvent->what )
-    {
-        case nullEvent:
-            break;
-        case mouseDown:
-        {
-            if( (myEvent->when - lastMouseUp) < GetDblTime() )
-            {
-                /* double click */
-                libvlc_instance_t *p_vlc = p_plugin->getVLC();
-
-                if( p_vlc )
-                {
-                    if( libvlc_playlist_isplaying(p_vlc, NULL) )
-                    {
-                        libvlc_input_t *p_input = libvlc_playlist_get_input(p_vlc, NULL);
-                        if( p_input )
-                        {
-                            libvlc_toggle_fullscreen(p_input, NULL);
-                            libvlc_input_free(p_input);
-                        }
-                    }
-                }
-            }
-            return true;
-        }
-        case mouseUp:
-            lastMouseUp = myEvent->when;
-            return true;
-        case keyUp:
-        case keyDown:
-        case autoKey:
-            return true;
-        case updateEvt:
-        {
-            int needsDisplay = TRUE;
-            libvlc_instance_t *p_vlc = p_plugin->getVLC();
-
-            if( p_vlc )
-            {
-                if( libvlc_playlist_isplaying(p_vlc, NULL) )
-                {
-                    libvlc_input_t *p_input = libvlc_playlist_get_input(p_vlc, NULL);
-                    if( p_input )
-                    {
-                        needsDisplay = ! libvlc_input_has_vout(p_input, NULL);
-                        libvlc_input_free(p_input);
-                    }
-                }
-            }
-
-            const NPWindow *npwindow = p_plugin->getWindow();
-
-            if( needsDisplay && npwindow->window )
-            {
-                /* draw the beautiful "No Picture" */
-
-                ForeColor(blackColor);
-                PenMode( patCopy );
-
-                /* seems that firefox forgets to set the following on occasion (reload) */
-                SetOrigin(((NP_Port *)npwindow->window)->portx, ((NP_Port *)npwindow->window)->porty);
-
-                Rect rect;
-                rect.left = 0;
-                rect.top = 0;
-                rect.right = npwindow->width;
-                rect.bottom = npwindow->height;
-                PaintRect( &rect );
-
-                ForeColor(whiteColor);
-                MoveTo( (npwindow->width-80)/ 2  , npwindow->height / 2 );
-                DrawText( WINDOW_TEXT , 0 , strlen(WINDOW_TEXT) );
-            }
-            return true;
-        }
-        case activateEvt:
-            return false;
-        case NPEventType_GetFocusEvent:
-        case NPEventType_LoseFocusEvent:
-            return true;
-        case NPEventType_AdjustCursorEvent:
-            return false;
-        case NPEventType_MenuCommandEvent:
-            return false;
-        case NPEventType_ClippingChangedEvent:
-            return false;
-        case NPEventType_ScrollingBeginsEvent:
-        case NPEventType_ScrollingEndsEvent:
-            return true;
-        default:
-            ;
-    }
-    return false;
-}
-#endif /* XP_MACOSX */
-
-/******************************************************************************
- * General Plug-in Calls
- *****************************************************************************/
-NPError NPP_Initialize( void )
-{
-    return NPERR_NO_ERROR;
-}
-
-jref NPP_GetJavaClass( void )
-{
-    return NULL;
-}
-
-void NPP_Shutdown( void )
-{
-    ;
-}
-
-NPError NPP_New( NPMIMEType pluginType, NPP instance, uint16 mode, int16 argc,
-                 char* argn[], char* argv[], NPSavedData* saved )
-{
-    NPError status;
-
-    if( instance == NULL )
-    {
-        return NPERR_INVALID_INSTANCE_ERROR;
-    }
-
-    VlcPlugin * p_plugin = new VlcPlugin( instance, mode );
-    if( NULL == p_plugin )
-    {
-        return NPERR_OUT_OF_MEMORY_ERROR;
-    }
-
-    status = p_plugin->init(argc, argn, argv);
-    if( NPERR_NO_ERROR == status )
-    {
-        instance->pdata = reinterpret_cast<void*>(p_plugin);
-        //NPN_SetValue(instance, NPPVpluginWindowBool, (void *)false);
-        NPN_SetValue(instance, NPPVpluginTransparentBool, (void *)false);
-    }
-    else
-    {
-        delete p_plugin;
-    }
-    return status;
-}
-
-NPError NPP_Destroy( NPP instance, NPSavedData** save )
-{
-    if( NULL == instance )
-        return NPERR_INVALID_INSTANCE_ERROR;
-
-    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(instance->pdata);
-    if( NULL == p_plugin )
-        return NPERR_NO_ERROR;
-
-    instance->pdata = NULL;
-
-#if XP_WIN
-    HWND win = (HWND)p_plugin->getWindow()->window;
-    WNDPROC winproc = p_plugin->getWindowProc();
-    if( winproc )
-    {
-        /* reset WNDPROC */
-        SetWindowLong( win, GWL_WNDPROC, (LONG)winproc );
-    }
-#endif
-
-    delete p_plugin;
-
-    return NPERR_NO_ERROR;
-}
-
-NPError NPP_SetWindow( NPP instance, NPWindow* window )
-{
-    if( ! instance )
-    {
-        return NPERR_INVALID_INSTANCE_ERROR;
-    }
-
-    /* NPP_SetWindow may be called before NPP_New (Opera) */
-    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(instance->pdata);
-    if( ! p_plugin )
-    {
-        /* we should probably show a splash screen here */
-        return NPERR_NO_ERROR;
-    }
-
-    libvlc_instance_t *p_vlc = p_plugin->getVLC();
-
-    /*
-     * PLUGIN DEVELOPERS:
-     *  Before setting window to point to the
-     *  new window, you may wish to compare the new window
-     *  info to the previous window (if any) to note window
-     *  size changes, etc.
-     */
-
-    const NPWindow *curwin = p_plugin->getWindow();
-
-#ifdef XP_MACOSX
-    if( window && window->window )
-    {
-        /* check if plugin has a new parent window */
-        CGrafPtr drawable = (((NP_Port*) (window->window))->port);
-        if( !curwin->window || drawable != (((NP_Port*) (curwin->window))->port) )
-        {
-            /* set/change parent window */
-            libvlc_video_set_parent(p_vlc, (libvlc_drawable_t)drawable, NULL);
-        }
-
-        /* as MacOS X video output is windowless, set viewport */
-        libvlc_rectangle_t view, clip;
-
-        /*
-        ** browser sets port origin to top-left location of plugin relative to GrafPort
-        ** window origin is set relative to document, which of little use for drawing
-        */
-        view.top     = ((NP_Port*) (window->window))->porty;
-        view.left    = ((NP_Port*) (window->window))->portx;
-        view.bottom  = window->height+view.top;
-        view.right   = window->width+view.left;
-        /* clipRect coordinates are also relative to GrafPort */
-        clip.top     = window->clipRect.top;
-        clip.left    = window->clipRect.left;
-        clip.bottom  = window->clipRect.bottom;
-        clip.right   = window->clipRect.right;
-
-        libvlc_video_set_viewport(p_vlc, &view, &clip, NULL);
-
-        /* remember window details */
-        p_plugin->setWindow(window);
-    }
-#endif /* XP_MACOSX */
-
-#ifdef XP_WIN
-    if( window && window->window )
-    {
-        /* check if plugin has a new parent window */
-        HWND drawable = (HWND) (window->window);
-        if( !curwin->window || drawable != curwin->window )
-        {
-            /* reset previous window settings */
-            HWND oldwin = (HWND)p_plugin->getWindow()->window;
-            WNDPROC oldproc = p_plugin->getWindowProc();
-            if( oldproc )
-            {
-                /* reset WNDPROC */
-                SetWindowLong( oldwin, GWL_WNDPROC, (LONG)oldproc );
-            }
-            /* attach our plugin object */
-            SetWindowLongPtr((HWND)drawable, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(p_plugin));
-
-            /* install our WNDPROC */
-            p_plugin->setWindowProc( (WNDPROC)SetWindowLong( drawable,
-                                                           GWL_WNDPROC, (LONG)Manage ) );
-
-            /* change window style to our liking */
-            LONG style = GetWindowLong((HWND)drawable, GWL_STYLE);
-            style |= WS_CLIPCHILDREN|WS_CLIPSIBLINGS;
-            SetWindowLong((HWND)drawable, GWL_STYLE, style);
-
-            /* change/set parent */
-            libvlc_video_set_parent(p_vlc, (libvlc_drawable_t)drawable, NULL);
-        }
-
-        /* remember window details */
-        p_plugin->setWindow(window);
-
-        /* Redraw window */
-        InvalidateRect( (HWND)drawable, NULL, TRUE );
-        UpdateWindow( (HWND)drawable );
-    }
-    else
-    {
-        /* reset WNDPROC */
-        HWND oldwin = (HWND)curwin->window;
-        SetWindowLong( oldwin, GWL_WNDPROC, (LONG)(p_plugin->getWindowProc()) );
-        p_plugin->setWindowProc(NULL);
-        /* change/set parent */
-        libvlc_video_set_parent(p_vlc, 0, NULL);
-    }
-#endif /* XP_WIN */
-
-#ifdef XP_UNIX
-    if( window && window->window )
-    {
-        Window  drawable   = (Window) window->window;
-        if( !curwin->window || drawable != (Window)curwin->window )
-        {
-            Display *p_display = ((NPSetWindowCallbackStruct *)window->ws_info)->display;
-
-            XResizeWindow( p_display, drawable, window->width, window->height );
-            Widget w = XtWindowToWidget( p_display, drawable );
-
-            XtAddEventHandler( w, ExposureMask, FALSE, (XtEventHandler)Redraw, p_plugin );
-            XtAddEventHandler( w, StructureNotifyMask, FALSE, (XtEventHandler)Resize, p_plugin );
-
-            /* set/change parent window */
-            libvlc_video_set_parent(p_vlc, (libvlc_drawable_t)drawable, NULL);
-
-            /* remember window */
-            p_plugin->setWindow(window);
-
-            Redraw( w, (XtPointer)p_plugin, NULL );
-        }
-    }
-#endif /* XP_UNIX */
-
-    if( !p_plugin->b_stream )
-    {
-        if( p_plugin->psz_target )
-        {
-            if( libvlc_playlist_add( p_vlc, p_plugin->psz_target, NULL, NULL ) != -1 )
-            {
-                if( p_plugin->b_autoplay )
-                {
-                    libvlc_playlist_play(p_vlc, 0, 0, NULL, NULL);
-                }
-            }
-            p_plugin->b_stream = VLC_TRUE;
-        }
-    }
-    return NPERR_NO_ERROR;
-}
-
-NPError NPP_NewStream( NPP instance, NPMIMEType type, NPStream *stream,
-                       NPBool seekable, uint16 *stype )
-{
-    if( NULL == instance  )
-    {
-        return NPERR_INVALID_INSTANCE_ERROR;
-    }
-
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(instance->pdata);
-    if( NULL == p_plugin )
-    {
-        return NPERR_INVALID_INSTANCE_ERROR;
-    }
-
-   /*
-   ** Firefox/Mozilla may decide to open a stream from the URL specified
-   ** in the SRC parameter of the EMBED tag and pass it to us
-   **
-   ** since VLC will open the SRC URL as well, we're not interested in
-   ** that stream. Otherwise, we'll take it and queue it up in the playlist
-   */
-    if( !p_plugin->psz_target || strcmp(stream->url, p_plugin->psz_target) )
-    {
-        /* TODO: use pipes !!!! */
-        *stype = NP_ASFILEONLY;
-        return NPERR_NO_ERROR;
-    }
-    return NPERR_GENERIC_ERROR;
-}
-
-int32 NPP_WriteReady( NPP instance, NPStream *stream )
-{
-    /* TODO */
-    return 8*1024;
-}
-
-
-int32 NPP_Write( NPP instance, NPStream *stream, int32 offset,
-                 int32 len, void *buffer )
-{
-    /* TODO */
-    return len;
-}
-
-
-NPError NPP_DestroyStream( NPP instance, NPStream *stream, NPError reason )
-{
-    if( instance == NULL )
-    {
-        return NPERR_INVALID_INSTANCE_ERROR;
-    }
-    return NPERR_NO_ERROR;
-}
-
-
-void NPP_StreamAsFile( NPP instance, NPStream *stream, const char* fname )
-{
-    if( instance == NULL )
-    {
-        return;
-    }
-
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(instance->pdata);
-    if( NULL == p_plugin )
-    {
-        return;
-    }
-
-    if( libvlc_playlist_add( p_plugin->getVLC(), fname, stream->url, NULL ) != -1 )
-    {
-        if( p_plugin->b_autoplay )
-        {
-            libvlc_playlist_play( p_plugin->getVLC(), 0, 0, NULL, NULL);
-        }
-    }
-}
-
-
-void NPP_URLNotify( NPP instance, const char* url,
-                    NPReason reason, void* notifyData )
-{
-    /***** Insert NPP_URLNotify code here *****\
-    PluginInstance* p_plugin;
-    if (instance != NULL)
-        p_plugin = (PluginInstance*) instance->pdata;
-    \*********************************************/
-}
-
-
-void NPP_Print( NPP instance, NPPrint* printInfo )
-{
-    if( printInfo == NULL )
-    {
-        return;
-    }
-
-    if( instance != NULL )
-    {
-        /***** Insert NPP_Print code here *****\
-        PluginInstance* p_plugin = (PluginInstance*) instance->pdata;
-        \**************************************/
-
-        if( printInfo->mode == NP_FULL )
-        {
-            /*
-             * PLUGIN DEVELOPERS:
-             *  If your plugin would like to take over
-             *  printing completely when it is in full-screen mode,
-             *  set printInfo->pluginPrinted to TRUE and print your
-             *  plugin as you see fit.  If your plugin wants Netscape
-             *  to handle printing in this case, set
-             *  printInfo->pluginPrinted to FALSE (the default) and
-             *  do nothing.  If you do want to handle printing
-             *  yourself, printOne is true if the print button
-             *  (as opposed to the print menu) was clicked.
-             *  On the Macintosh, platformPrint is a THPrint; on
-             *  Windows, platformPrint is a structure
-             *  (defined in npapi.h) containing the printer name, port,
-             *  etc.
-             */
-
-            /***** Insert NPP_Print code here *****\
-            void* platformPrint =
-                printInfo->print.fullPrint.platformPrint;
-            NPBool printOne =
-                printInfo->print.fullPrint.printOne;
-            \**************************************/
-
-            /* Do the default*/
-            printInfo->print.fullPrint.pluginPrinted = FALSE;
-        }
-        else
-        {
-            /* If not fullscreen, we must be embedded */
-            /*
-             * PLUGIN DEVELOPERS:
-             *  If your plugin is embedded, or is full-screen
-             *  but you returned false in pluginPrinted above, NPP_Print
-             *  will be called with mode == NP_EMBED.  The NPWindow
-             *  in the printInfo gives the location and dimensions of
-             *  the embedded plugin on the printed page.  On the
-             *  Macintosh, platformPrint is the printer port; on
-             *  Windows, platformPrint is the handle to the printing
-             *  device context.
-             */
-
-            /***** Insert NPP_Print code here *****\
-            NPWindow* printWindow =
-                &(printInfo->print.embedPrint.window);
-            void* platformPrint =
-                printInfo->print.embedPrint.platformPrint;
-            \**************************************/
-        }
-    }
-}
-
-/******************************************************************************
- * Windows-only methods
- *****************************************************************************/
-#if XP_WIN
-static LRESULT CALLBACK Manage( HWND p_hwnd, UINT i_msg, WPARAM wpar, LPARAM lpar )
-{
-    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(GetWindowLongPtr(p_hwnd, GWLP_USERDATA));
-
-    switch( i_msg )
-    {
-        case WM_ERASEBKGND:
-            return 1L;
-
-        case WM_PAINT:
-        {
-            PAINTSTRUCT paintstruct;
-            HDC hdc;
-            RECT rect;
-
-            hdc = BeginPaint( p_hwnd, &paintstruct );
-
-            GetClientRect( p_hwnd, &rect );
-
-            FillRect( hdc, &rect, (HBRUSH)GetStockObject(BLACK_BRUSH) );
-            SetTextColor(hdc, RGB(255, 255, 255));
-            SetBkColor(hdc, RGB(0, 0, 0));
-            DrawText( hdc, WINDOW_TEXT, strlen(WINDOW_TEXT), &rect, DT_CENTER|DT_VCENTER|DT_SINGLELINE); 
-
-            EndPaint( p_hwnd, &paintstruct );
-            return 0L;
-        }
-        default:
-            /* delegate to default handler */
-            return p_plugin->getWindowProc()( p_hwnd, i_msg, wpar, lpar );
-    }
-}
-#endif /* XP_WIN */
-
-/******************************************************************************
- * UNIX-only methods
- *****************************************************************************/
-#ifdef XP_UNIX
-static void Redraw( Widget w, XtPointer closure, XEvent *event )
-{
-    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(closure);
-    const NPWindow *window = p_plugin->getWindow();
-    GC gc;
-    XGCValues gcv;
-
-    Window  drawable   = (Window) window->window;
-    Display *p_display = ((NPSetWindowCallbackStruct *)window->ws_info)->display;
-
-    gcv.foreground = BlackPixel( p_display, 0 );
-    gc = XCreateGC( p_display, drawable, GCForeground, &gcv );
-
-    XFillRectangle( p_display, drawable, gc,
-                    0, 0, window->width, window->height );
-
-    gcv.foreground = WhitePixel( p_display, 0 );
-    XChangeGC( p_display, gc, GCForeground, &gcv );
-
-    XDrawString( p_display, drawable, gc,
-                 window->width / 2 - 40, window->height / 2,
-                 WINDOW_TEXT, strlen(WINDOW_TEXT) );
-
-    XFreeGC( p_display, gc );
-}
-
-static void Resize ( Widget w, XtPointer closure, XEvent *event )
-{
-    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(closure);
-    const NPWindow *window = p_plugin->getWindow();
-    Window  drawable   = (Window) window->window;
-    Display *p_display = ((NPSetWindowCallbackStruct *)window->ws_info)->display;
-
-    int i_ret;
-    Window root_return, parent_return, * children_return;
-    Window base_window;
-    unsigned int i_nchildren;
-
-#ifdef X11_RESIZE_DEBUG
-    XWindowAttributes attr;
-
-    if( event && event->type == ConfigureNotify )
-    {
-        fprintf( stderr, "vlcshell::Resize() ConfigureNotify %d x %d, "
-                 "send_event ? %s\n", event->xconfigure.width,
-                 event->xconfigure.height,
-                 event->xconfigure.send_event ? "TRUE" : "FALSE" );
-    }
-#endif /* X11_RESIZE_DEBUG */
-
-    if( ! p_plugin->setSize(window->width, window->height) )
-    {
-        /* size already set */
-        return;
-    }
-
-
-    i_ret = XResizeWindow( p_display, drawable, window->width, window->height );
-
-#ifdef X11_RESIZE_DEBUG
-    fprintf( stderr,
-             "vlcshell::Resize() XResizeWindow(owner) returned %d\n", i_ret );
-
-    XGetWindowAttributes ( p_display, drawable, &attr );
-
-    /* X is asynchronous, so the current size reported here is not
-       necessarily the requested size as the Resize request may not
-       yet have been handled by the plugin host */
-    fprintf( stderr, "vlcshell::Resize() current (owner) size %d x %d\n",
-             attr.width, attr.height );
-#endif /* X11_RESIZE_DEBUG */
-
-    XQueryTree( p_display, drawable,
-                &root_return, &parent_return, &children_return,
-                &i_nchildren );
-
-    if( i_nchildren > 0 )
-    {
-        /* XXX: Make assumptions related to the window parenting structure in
-           vlc/modules/video_output/x11/xcommon.c */
-        base_window = children_return[i_nchildren - 1];
-
-#ifdef X11_RESIZE_DEBUG
-        fprintf( stderr, "vlcshell::Resize() got %d children\n", i_nchildren );
-        fprintf( stderr, "vlcshell::Resize() got base_window %p\n",
-                 base_window );
-#endif /* X11_RESIZE_DEBUG */
-
-        i_ret = XResizeWindow( p_display, base_window,
-                window->width, window->height );
-
-#ifdef X11_RESIZE_DEBUG
-        fprintf( stderr,
-                 "vlcshell::Resize() XResizeWindow(base) returned %d\n",
-                 i_ret );
-
-        XGetWindowAttributes( p_display, base_window, &attr );
-
-        fprintf( stderr, "vlcshell::Resize() new size %d x %d\n",
-                 attr.width, attr.height );
-#endif /* X11_RESIZE_DEBUG */
-    }
-}
-
-#endif /* XP_UNIX */
-
+/*****************************************************************************
+ * vlcshell.cpp: a VLC plugin for Mozilla
+ *****************************************************************************
+ * Copyright (C) 2002-2005 the VideoLAN team
+ * $Id: vlcshell.cpp 19481 2007-03-25 22:38:56Z damienf $
+ *
+ * Authors: Samuel Hocevar <sam@zoy.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+#include "config.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+/* Mozilla stuff */
+#ifdef HAVE_MOZILLA_CONFIG_H
+#   include <mozilla-config.h>
+#endif
+
+/* This is from mozilla java, do we really need it? */
+#if 0
+#include <jri.h>
+#endif
+
+#include "vlcplugin.h"
+
+/* Enable/disable debugging printf's for X11 resizing */
+#undef X11_RESIZE_DEBUG
+
+#define WINDOW_TEXT "Songbird"
+
+/*****************************************************************************
+ * Unix-only declarations
+******************************************************************************/
+#ifdef XP_UNIX
+
+static void Redraw( Widget w, XtPointer closure, XEvent *event );
+static void Resize( Widget w, XtPointer closure, XEvent *event );
+
+#endif
+
+/*****************************************************************************
+ * MacOS-only declarations
+******************************************************************************/
+#ifdef XP_MACOSX
+#endif
+
+/*****************************************************************************
+ * Windows-only declarations
+ *****************************************************************************/
+#ifdef XP_WIN
+static LRESULT CALLBACK Manage( HWND p_hwnd, UINT i_msg, WPARAM wpar, LPARAM lpar );
+#endif
+
+/******************************************************************************
+ * UNIX-only API calls
+ *****************************************************************************/
+char * NPP_GetMIMEDescription( void )
+{
+    return PLUGIN_MIMETYPES;
+}
+
+NPError NPP_GetValue( NPP instance, NPPVariable variable, void *value )
+{
+
+    static char psz_desc[1000];
+
+    /* plugin class variables */
+    switch( variable )
+    {
+        case NPPVpluginNameString:
+            *((char **)value) = PLUGIN_NAME;
+            return NPERR_NO_ERROR;
+
+        case NPPVpluginDescriptionString:
+            snprintf( psz_desc, sizeof(psz_desc), PLUGIN_DESCRIPTION, VLC_Version() );
+            *((char **)value) = psz_desc;
+            return NPERR_NO_ERROR;
+
+        default:
+            /* move on to instance variables ... */
+            ;
+    }
+
+    if( instance == NULL )
+    {
+        return NPERR_INVALID_INSTANCE_ERROR;
+    }
+
+    /* plugin instance variables */
+
+    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(instance->pdata);
+    if( NULL == p_plugin )
+    {
+        // plugin has not been initialized yet !
+        return NPERR_INVALID_INSTANCE_ERROR;
+    }
+
+    switch( variable )
+    {
+        case NPPVpluginScriptableNPObject:
+        {
+            /* retrieve plugin root class */
+            NPClass *scriptClass = p_plugin->getScriptClass();
+            if( scriptClass )
+            {
+                /* create an instance and return it */
+                *(NPObject**)value = NPN_CreateObject(instance, scriptClass);
+                return NPERR_NO_ERROR;
+            }
+            break;
+        }
+
+        default:
+            ;
+    }
+    return NPERR_GENERIC_ERROR;
+}
+
+/*
+ * there is some confusion in gecko headers regarding definition of this API
+ * NPPVariable is wrongly defined as NPNVariable, which sounds incorrect.
+ */
+
+NPError NPP_SetValue( NPP instance, NPNVariable variable, void *value )
+{
+    return NPERR_GENERIC_ERROR;
+}
+
+/******************************************************************************
+ * Mac-only API calls
+ *****************************************************************************/
+#ifdef XP_MACOSX
+int16 NPP_HandleEvent( NPP instance, void * event )
+{
+    static UInt32 lastMouseUp = 0;
+
+    if( instance == NULL )
+    {
+        return false;
+    }
+
+    VlcPlugin *p_plugin = (VlcPlugin*)instance->pdata;
+
+    if( p_plugin == NULL )
+    {
+        return false;
+    }
+
+    EventRecord *myEvent = (EventRecord*)event;
+
+    switch( myEvent->what )
+    {
+        case nullEvent:
+            break;
+        case mouseDown:
+        {
+            if( (myEvent->when - lastMouseUp) < GetDblTime() )
+            {
+                /* double click */
+                libvlc_instance_t *p_vlc = p_plugin->getVLC();
+
+                if( p_vlc )
+                {
+                    if( libvlc_playlist_isplaying(p_vlc, NULL) )
+                    {
+                        libvlc_input_t *p_input = libvlc_playlist_get_input(p_vlc, NULL);
+                        if( p_input )
+                        {
+                            libvlc_toggle_fullscreen(p_input, NULL);
+                            libvlc_input_free(p_input);
+                        }
+                    }
+                }
+            }
+            return true;
+        }
+        case mouseUp:
+            lastMouseUp = myEvent->when;
+            return true;
+        case keyUp:
+        case keyDown:
+        case autoKey:
+            return true;
+        case updateEvt:
+        {
+            int needsDisplay = TRUE;
+            libvlc_instance_t *p_vlc = p_plugin->getVLC();
+
+            if( p_vlc )
+            {
+                if( libvlc_playlist_isplaying(p_vlc, NULL) )
+                {
+                    libvlc_input_t *p_input = libvlc_playlist_get_input(p_vlc, NULL);
+                    if( p_input )
+                    {
+                        needsDisplay = ! libvlc_input_has_vout(p_input, NULL);
+                        libvlc_input_free(p_input);
+                    }
+                }
+            }
+
+            const NPWindow *npwindow = p_plugin->getWindow();
+
+            if( needsDisplay && npwindow->window )
+            {
+                /* draw the beautiful "No Picture" */
+
+                ForeColor(blackColor);
+                PenMode( patCopy );
+
+                /* seems that firefox forgets to set the following on occasion (reload) */
+                SetOrigin(((NP_Port *)npwindow->window)->portx, ((NP_Port *)npwindow->window)->porty);
+
+                Rect rect;
+                rect.left = 0;
+                rect.top = 0;
+                rect.right = npwindow->width;
+                rect.bottom = npwindow->height;
+                PaintRect( &rect );
+
+                ForeColor(whiteColor);
+                MoveTo( (npwindow->width-80)/ 2  , npwindow->height / 2 );
+                DrawText( WINDOW_TEXT , 0 , strlen(WINDOW_TEXT) );
+            }
+            return true;
+        }
+        case activateEvt:
+            return false;
+        case NPEventType_GetFocusEvent:
+        case NPEventType_LoseFocusEvent:
+            return true;
+        case NPEventType_AdjustCursorEvent:
+            return false;
+        case NPEventType_MenuCommandEvent:
+            return false;
+        case NPEventType_ClippingChangedEvent:
+            return false;
+        case NPEventType_ScrollingBeginsEvent:
+        case NPEventType_ScrollingEndsEvent:
+            return true;
+        default:
+            ;
+    }
+    return false;
+}
+#endif /* XP_MACOSX */
+
+/******************************************************************************
+ * General Plug-in Calls
+ *****************************************************************************/
+NPError NPP_Initialize( void )
+{
+    return NPERR_NO_ERROR;
+}
+
+jref NPP_GetJavaClass( void )
+{
+    return NULL;
+}
+
+void NPP_Shutdown( void )
+{
+    return;
+}
+
+NPError NPP_New( NPMIMEType pluginType, NPP instance, uint16 mode, int16 argc,
+                 char* argn[], char* argv[], NPSavedData* saved )
+{
+    NPError status;
+
+    if( instance == NULL )
+    {
+        return NPERR_INVALID_INSTANCE_ERROR;
+    }
+
+    VlcPlugin * p_plugin = new VlcPlugin( instance, mode );
+    if( NULL == p_plugin )
+    {
+        return NPERR_OUT_OF_MEMORY_ERROR;
+    }
+
+    status = p_plugin->init(argc, argn, argv);
+    if( NPERR_NO_ERROR == status )
+    {
+        instance->pdata = reinterpret_cast<void*>(p_plugin);
+        //NPN_SetValue(instance, NPPVpluginWindowBool, (void *)false);
+        NPN_SetValue(instance, NPPVpluginTransparentBool, (void *)false);
+    }
+    else
+    {
+        delete p_plugin;
+    }
+    return status;
+}
+
+NPError NPP_Destroy( NPP instance, NPSavedData** save )
+{
+    if( instance == NULL )
+    {
+        return NPERR_INVALID_INSTANCE_ERROR;
+    }
+
+    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(instance->pdata);
+
+#if XP_WIN
+    HWND win = (HWND)p_plugin->getWindow()->window;
+    WNDPROC winproc = p_plugin->getWindowProc();
+    if( winproc )
+    {
+        /* reset WNDPROC */
+        SetWindowLong( win, GWL_WNDPROC, (LONG)winproc );
+    }
+#endif
+
+    delete p_plugin;
+
+    instance->pdata = NULL;
+
+    return NPERR_NO_ERROR;
+}
+
+NPError NPP_SetWindow( NPP instance, NPWindow* window )
+{
+    if( ! instance )
+    {
+        return NPERR_INVALID_INSTANCE_ERROR;
+    }
+
+    /* NPP_SetWindow may be called before NPP_New (Opera) */
+    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(instance->pdata);
+    if( ! p_plugin )
+    {
+        /* we should probably show a splash screen here */
+        return NPERR_NO_ERROR;
+    }
+
+    libvlc_instance_t *p_vlc = p_plugin->getVLC();
+
+    /*
+     * PLUGIN DEVELOPERS:
+     *  Before setting window to point to the
+     *  new window, you may wish to compare the new window
+     *  info to the previous window (if any) to note window
+     *  size changes, etc.
+     */
+
+    const NPWindow *curwin = p_plugin->getWindow();
+
+#ifdef XP_MACOSX
+    if( window && window->window )
+    {
+        /* check if plugin has a new parent window */
+        CGrafPtr drawable = (((NP_Port*) (window->window))->port);
+        if( !curwin->window || drawable != (((NP_Port*) (curwin->window))->port) )
+        {
+            /* set/change parent window */
+            libvlc_video_set_parent(p_vlc, (libvlc_drawable_t)drawable, NULL);
+        }
+
+        /* as MacOS X video output is windowless, set viewport */
+        libvlc_rectangle_t view, clip;
+
+        /*
+        ** browser sets port origin to top-left location of plugin relative to GrafPort
+        ** window origin is set relative to document, which of little use for drawing
+        */
+        view.top     = ((NP_Port*) (window->window))->porty;
+        view.left    = ((NP_Port*) (window->window))->portx;
+        view.bottom  = window->height+view.top;
+        view.right   = window->width+view.left;
+        /* clipRect coordinates are also relative to GrafPort */
+        clip.top     = window->clipRect.top;
+        clip.left    = window->clipRect.left;
+        clip.bottom  = window->clipRect.bottom;
+        clip.right   = window->clipRect.right;
+
+        libvlc_video_set_viewport(p_vlc, &view, &clip, NULL);
+
+        /* remember window details */
+        p_plugin->setWindow(window);
+    }
+#endif /* XP_MACOSX */
+
+#ifdef XP_WIN
+    if( window && window->window )
+    {
+        /* check if plugin has a new parent window */
+        HWND drawable = (HWND) (window->window);
+        if( !curwin->window || drawable != curwin->window )
+        {
+            /* reset previous window settings */
+            HWND oldwin = (HWND)p_plugin->getWindow()->window;
+            WNDPROC oldproc = p_plugin->getWindowProc();
+            if( oldproc )
+            {
+                /* reset WNDPROC */
+                SetWindowLong( oldwin, GWL_WNDPROC, (LONG)oldproc );
+            }
+            /* attach our plugin object */
+            SetWindowLongPtr((HWND)drawable, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(p_plugin));
+
+            /* install our WNDPROC */
+            p_plugin->setWindowProc( (WNDPROC)SetWindowLong( drawable,
+                                                           GWL_WNDPROC, (LONG)Manage ) );
+
+            /* change window style to our liking */
+            LONG style = GetWindowLong((HWND)drawable, GWL_STYLE);
+            style |= WS_CLIPCHILDREN|WS_CLIPSIBLINGS;
+            SetWindowLong((HWND)drawable, GWL_STYLE, style);
+
+            /* change/set parent */
+            libvlc_video_set_parent(p_vlc, (libvlc_drawable_t)drawable, NULL);
+        }
+
+        /* remember window details */
+        p_plugin->setWindow(window);
+
+        /* Redraw window */
+        InvalidateRect( (HWND)drawable, NULL, TRUE );
+        UpdateWindow( (HWND)drawable );
+    }
+    else
+    {
+        /* reset WNDPROC */
+        HWND oldwin = (HWND)curwin->window;
+        SetWindowLong( oldwin, GWL_WNDPROC, (LONG)(p_plugin->getWindowProc()) );
+        p_plugin->setWindowProc(NULL);
+        /* change/set parent */
+        libvlc_video_set_parent(p_vlc, 0, NULL);
+    }
+#endif /* XP_WIN */
+
+#ifdef XP_UNIX
+    if( window && window->window )
+    {
+        Window  drawable   = (Window) window->window;
+        if( !curwin->window || drawable != (Window)curwin->window )
+        {
+            Display *p_display = ((NPSetWindowCallbackStruct *)window->ws_info)->display;
+
+            XResizeWindow( p_display, drawable, window->width, window->height );
+            Widget w = XtWindowToWidget( p_display, drawable );
+
+            XtAddEventHandler( w, ExposureMask, FALSE, (XtEventHandler)Redraw, p_plugin );
+            XtAddEventHandler( w, StructureNotifyMask, FALSE, (XtEventHandler)Resize, p_plugin );
+
+            /* set/change parent window */
+            libvlc_video_set_parent(p_vlc, (libvlc_drawable_t)drawable, NULL);
+
+            /* remember window */
+            p_plugin->setWindow(window);
+
+            Redraw( w, (XtPointer)p_plugin, NULL );
+        }
+    }
+#endif /* XP_UNIX */
+
+    if( !p_plugin->b_stream )
+    {
+        if( p_plugin->psz_target )
+        {
+            if( libvlc_playlist_add( p_vlc, p_plugin->psz_target, NULL, NULL ) != -1 )
+            {
+                if( p_plugin->b_autoplay )
+                {
+                    libvlc_playlist_play(p_vlc, 0, 0, NULL, NULL);
+                }
+            }
+            p_plugin->b_stream = VLC_TRUE;
+        }
+    }
+    return NPERR_NO_ERROR;
+}
+
+NPError NPP_NewStream( NPP instance, NPMIMEType type, NPStream *stream,
+                       NPBool seekable, uint16 *stype )
+{
+    if( NULL == instance  )
+    {
+        return NPERR_INVALID_INSTANCE_ERROR;
+    }
+
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(instance->pdata);
+    if( NULL == p_plugin )
+    {
+        return NPERR_INVALID_INSTANCE_ERROR;
+    }
+
+   /*
+   ** Firefox/Mozilla may decide to open a stream from the URL specified
+   ** in the SRC parameter of the EMBED tag and pass it to us
+   **
+   ** since VLC will open the SRC URL as well, we're not interested in
+   ** that stream. Otherwise, we'll take it and queue it up in the playlist
+   */
+    if( !p_plugin->psz_target || strcmp(stream->url, p_plugin->psz_target) )
+    {
+        /* TODO: use pipes !!!! */
+        *stype = NP_ASFILEONLY;
+        return NPERR_NO_ERROR;
+    }
+    return NPERR_GENERIC_ERROR;
+}
+
+int32 NPP_WriteReady( NPP instance, NPStream *stream )
+{
+    /* TODO */
+    return 8*1024;
+}
+
+
+int32 NPP_Write( NPP instance, NPStream *stream, int32 offset,
+                 int32 len, void *buffer )
+{
+    /* TODO */
+    return len;
+}
+
+
+NPError NPP_DestroyStream( NPP instance, NPStream *stream, NPError reason )
+{
+    if( instance == NULL )
+    {
+        return NPERR_INVALID_INSTANCE_ERROR;
+    }
+    return NPERR_NO_ERROR;
+}
+
+
+void NPP_StreamAsFile( NPP instance, NPStream *stream, const char* fname )
+{
+    if( instance == NULL )
+    {
+        return;
+    }
+
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(instance->pdata);
+    if( NULL == p_plugin )
+    {
+        return;
+    }
+
+    if( libvlc_playlist_add( p_plugin->getVLC(), fname, stream->url, NULL ) != -1 )
+    {
+        if( p_plugin->b_autoplay )
+        {
+            libvlc_playlist_play( p_plugin->getVLC(), 0, 0, NULL, NULL);
+        }
+    }
+}
+
+
+void NPP_URLNotify( NPP instance, const char* url,
+                    NPReason reason, void* notifyData )
+{
+    /***** Insert NPP_URLNotify code here *****\
+    PluginInstance* p_plugin;
+    if (instance != NULL)
+        p_plugin = (PluginInstance*) instance->pdata;
+    \*********************************************/
+}
+
+
+void NPP_Print( NPP instance, NPPrint* printInfo )
+{
+    if( printInfo == NULL )
+    {
+        return;
+    }
+
+    if( instance != NULL )
+    {
+        /***** Insert NPP_Print code here *****\
+        PluginInstance* p_plugin = (PluginInstance*) instance->pdata;
+        \**************************************/
+
+        if( printInfo->mode == NP_FULL )
+        {
+            /*
+             * PLUGIN DEVELOPERS:
+             *  If your plugin would like to take over
+             *  printing completely when it is in full-screen mode,
+             *  set printInfo->pluginPrinted to TRUE and print your
+             *  plugin as you see fit.  If your plugin wants Netscape
+             *  to handle printing in this case, set
+             *  printInfo->pluginPrinted to FALSE (the default) and
+             *  do nothing.  If you do want to handle printing
+             *  yourself, printOne is true if the print button
+             *  (as opposed to the print menu) was clicked.
+             *  On the Macintosh, platformPrint is a THPrint; on
+             *  Windows, platformPrint is a structure
+             *  (defined in npapi.h) containing the printer name, port,
+             *  etc.
+             */
+
+            /***** Insert NPP_Print code here *****\
+            void* platformPrint =
+                printInfo->print.fullPrint.platformPrint;
+            NPBool printOne =
+                printInfo->print.fullPrint.printOne;
+            \**************************************/
+
+            /* Do the default*/
+            printInfo->print.fullPrint.pluginPrinted = FALSE;
+        }
+        else
+        {
+            /* If not fullscreen, we must be embedded */
+            /*
+             * PLUGIN DEVELOPERS:
+             *  If your plugin is embedded, or is full-screen
+             *  but you returned false in pluginPrinted above, NPP_Print
+             *  will be called with mode == NP_EMBED.  The NPWindow
+             *  in the printInfo gives the location and dimensions of
+             *  the embedded plugin on the printed page.  On the
+             *  Macintosh, platformPrint is the printer port; on
+             *  Windows, platformPrint is the handle to the printing
+             *  device context.
+             */
+
+            /***** Insert NPP_Print code here *****\
+            NPWindow* printWindow =
+                &(printInfo->print.embedPrint.window);
+            void* platformPrint =
+                printInfo->print.embedPrint.platformPrint;
+            \**************************************/
+        }
+    }
+}
+
+/******************************************************************************
+ * Windows-only methods
+ *****************************************************************************/
+#ifdef XP_WIN
+
+static LRESULT CALLBACK Manage( HWND p_hwnd, UINT i_msg, WPARAM wpar, LPARAM lpar )
+{
+    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(GetWindowLongPtr(p_hwnd, GWLP_USERDATA));
+
+    switch( i_msg )
+    {
+        case WM_ERASEBKGND:
+            return 1L;
+
+        case WM_PAINT:
+        {
+            PAINTSTRUCT paintstruct;
+            HDC hdc;
+            RECT rect;
+
+            hdc = BeginPaint( p_hwnd, &paintstruct );
+
+            GetClientRect( p_hwnd, &rect );
+
+            FillRect( hdc, &rect, (HBRUSH)GetStockObject(BLACK_BRUSH) );
+            SetTextColor(hdc, RGB(255, 255, 255));
+            SetBkColor(hdc, RGB(0, 0, 0));
+            DrawText( hdc, WINDOW_TEXT, strlen(WINDOW_TEXT), &rect, DT_CENTER|DT_VCENTER|DT_SINGLELINE); 
+
+            EndPaint( p_hwnd, &paintstruct );
+            return 0L;
+        }
+        default:
+            /* delegate to default handler */
+            return p_plugin->getWindowProc()( p_hwnd, i_msg, wpar, lpar );
+    }
+}
+#endif /* XP_WIN */
+
+/******************************************************************************
+ * UNIX-only methods
+ *****************************************************************************/
+#ifdef XP_UNIX
+static void Redraw( Widget w, XtPointer closure, XEvent *event )
+{
+    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(closure);
+    const NPWindow *window = p_plugin->getWindow();
+    GC gc;
+    XGCValues gcv;
+
+    Window  drawable   = (Window) window->window;
+    Display *p_display = ((NPSetWindowCallbackStruct *)window->ws_info)->display;
+
+    gcv.foreground = BlackPixel( p_display, 0 );
+    gc = XCreateGC( p_display, drawable, GCForeground, &gcv );
+
+    XFillRectangle( p_display, drawable, gc,
+                    0, 0, window->width, window->height );
+
+    gcv.foreground = WhitePixel( p_display, 0 );
+    XChangeGC( p_display, gc, GCForeground, &gcv );
+
+    XDrawString( p_display, drawable, gc,
+                 window->width / 2 - 40, window->height / 2,
+                 WINDOW_TEXT, strlen(WINDOW_TEXT) );
+
+    XFreeGC( p_display, gc );
+}
+
+static void Resize ( Widget w, XtPointer closure, XEvent *event )
+{
+    VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(closure);
+    const NPWindow *window = p_plugin->getWindow();
+    Window  drawable   = (Window) window->window;
+    Display *p_display = ((NPSetWindowCallbackStruct *)window->ws_info)->display;
+
+    int i_ret;
+    Window root_return, parent_return, * children_return;
+    Window base_window;
+    unsigned int i_nchildren;
+
+#ifdef X11_RESIZE_DEBUG
+    XWindowAttributes attr;
+
+    if( event && event->type == ConfigureNotify )
+    {
+        fprintf( stderr, "vlcshell::Resize() ConfigureNotify %d x %d, "
+                 "send_event ? %s\n", event->xconfigure.width,
+                 event->xconfigure.height,
+                 event->xconfigure.send_event ? "TRUE" : "FALSE" );
+    }
+#endif /* X11_RESIZE_DEBUG */
+
+    if( ! p_plugin->setSize(window->width, window->height) )
+    {
+        /* size already set */
+        return;
+    }
+
+
+    i_ret = XResizeWindow( p_display, drawable, window->width, window->height );
+
+#ifdef X11_RESIZE_DEBUG
+    fprintf( stderr,
+             "vlcshell::Resize() XResizeWindow(owner) returned %d\n", i_ret );
+
+    XGetWindowAttributes ( p_display, drawable, &attr );
+
+    /* X is asynchronous, so the current size reported here is not
+       necessarily the requested size as the Resize request may not
+       yet have been handled by the plugin host */
+    fprintf( stderr, "vlcshell::Resize() current (owner) size %d x %d\n",
+             attr.width, attr.height );
+#endif /* X11_RESIZE_DEBUG */
+
+    XQueryTree( p_display, drawable,
+                &root_return, &parent_return, &children_return,
+                &i_nchildren );
+
+    if( i_nchildren > 0 )
+    {
+        /* XXX: Make assumptions related to the window parenting structure in
+           vlc/modules/video_output/x11/xcommon.c */
+        base_window = children_return[i_nchildren - 1];
+
+#ifdef X11_RESIZE_DEBUG
+        fprintf( stderr, "vlcshell::Resize() got %d children\n", i_nchildren );
+        fprintf( stderr, "vlcshell::Resize() got base_window %p\n",
+                 base_window );
+#endif /* X11_RESIZE_DEBUG */
+
+        i_ret = XResizeWindow( p_display, base_window,
+                window->width, window->height );
+
+#ifdef X11_RESIZE_DEBUG
+        fprintf( stderr,
+                 "vlcshell::Resize() XResizeWindow(base) returned %d\n",
+                 i_ret );
+
+        XGetWindowAttributes( p_display, base_window, &attr );
+
+        fprintf( stderr, "vlcshell::Resize() new size %d x %d\n",
+                 attr.width, attr.height );
+#endif /* X11_RESIZE_DEBUG */
+    }
+}
+
+#endif /* XP_UNIX */
+
+

Property changes on: mozilla\vlcshell.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: msvc\libvlc.dsp.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: msvc\libvlc.vcproj.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: msvc\modules_builtin_msvc.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: msvc\plugins.dsp.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: msvc\plugins.vcproj.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: msvc\vlc.dsp.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: msvc\vlc.dsw
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: msvc\vlc.vcproj.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: NEWS
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\af.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\ar.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\bn.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\ca.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\ChangeLog
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\co.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\cs.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\da.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\de.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\el.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\en_GB.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\es.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\eu.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\fr.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\fur.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\gl.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\he.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\hi.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\hu.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\it.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\ja.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\ka.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\ko.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\lt.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\lv.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\Makefile.in.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\Makevars
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\ms.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\my.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\nb.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\ne.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\nl.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\nn.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\no.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\oc.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\pa.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\pl.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\POTFILES.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\ps.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\pt_BR.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\ro.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\ru.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\sk.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\sl.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\sq.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\sv.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\tet.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\th.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\tl.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\tr.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\vlc.pot
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\zh_CN.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: po\zh_TW.po
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\Makefile
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\setup.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\vlcmodule.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\vlrs\announce.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\vlrs\cfg.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\vlrs\playlist.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\vlrs\rtsp.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\vlrs\sample-playlist
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\vlrs\sap.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\vlrs\session.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\vlrs\streamer.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: python\vlrs\vlrs.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: README
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: README.MacOSX.rtf
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\applications\vlc.desktop
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\.hosts
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\dialogs\.hosts
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\dialogs\browse
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\dialogs\footer
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\dialogs\input
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\dialogs\main
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\dialogs\mosaic
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\dialogs\playlist
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\dialogs\sout
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\dialogs\vlm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\iehacks.css
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\index.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\js\functions.js
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\js\mosaic.js
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\js\vlm.js
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\mosaic.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\.hosts
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\admin\.access
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\admin\browse.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\admin\dboxfiles.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\admin\index.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\index.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\info.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\style.css
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\vlm\edit.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\vlm\index.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\vlm\new.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\vlm\show.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\old\webcam.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\requests\browse.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\requests\playlist.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\requests\readme
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\requests\status.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\requests\vlm.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\requests\vlm_cmd.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\style.css
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\vlm.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\http\vlm_export.html
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\newres.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\osdmenu\default.cfg
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\osdmenu\dvd.cfg
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\pda-forwardb16x16.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\pda-openb16x16.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\pda-pauseb16x16.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\pda-playb16x16.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\pda-playlistb16x16.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\pda-preferencesb16x16.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\pda-rewindb16x16.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\pda-stopb16x16.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\resource.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\skins2\default\theme.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\skins2\skin.catalog
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\skins2\skin.dtd
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\skins2\winamp2.xml
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\vlc16x16.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\vlc32x32.xpm
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\vlc_win32_rc.rc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: share\vlc_wince_rc.rc
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\audio_output\common.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\audio_output\dec.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\audio_output\filters.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\audio_output\input.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\audio_output\intf.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\audio_output\mixer.c
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: src/audio_output/output.c
===================================================================
--- src/audio_output/output.c	(revision 159)
+++ src/audio_output/output.c	(working copy)
@@ -1,366 +1,418 @@
-/*****************************************************************************
- * output.c : internal management of output streams for the audio output
- *****************************************************************************
- * Copyright (C) 2002-2004 the VideoLAN team
- * $Id: output.c 14953 2006-03-28 20:29:28Z zorglub $
- *
- * Authors: Christophe Massiot <massiot@via.ecp.fr>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/*****************************************************************************
- * Preamble
- *****************************************************************************/
-#include <stdlib.h>                            /* calloc(), malloc(), free() */
-#include <string.h>
-
-#include <vlc/vlc.h>
-
-#include "audio_output.h"
-#include "aout_internal.h"
-
-/*****************************************************************************
- * aout_OutputNew : allocate a new output and rework the filter pipeline
- *****************************************************************************
- * This function is entered with the mixer lock.
- *****************************************************************************/
-int aout_OutputNew( aout_instance_t * p_aout,
-                    audio_sample_format_t * p_format )
-{
-    /* Retrieve user defaults. */
-    int i_rate = config_GetInt( p_aout, "aout-rate" );
-    vlc_value_t val, text;
-    /* kludge to avoid a fpu error when rate is 0... */
-    if( i_rate == 0 ) i_rate = -1;
-
-    memcpy( &p_aout->output.output, p_format, sizeof(audio_sample_format_t) );
-    if ( i_rate != -1 )
-        p_aout->output.output.i_rate = i_rate;
-    aout_FormatPrepare( &p_aout->output.output );
-
-    vlc_mutex_lock( &p_aout->output_fifo_lock );
-
-    /* Find the best output plug-in. */
-    p_aout->output.p_module = module_Need( p_aout, "audio output", "$aout", 0);
-    if ( p_aout->output.p_module == NULL )
-    {
-        msg_Err( p_aout, "no suitable audio output module" );
-        vlc_mutex_unlock( &p_aout->output_fifo_lock );
-        return -1;
-    }
-
-    if ( var_Type( p_aout, "audio-channels" ) ==
-             (VLC_VAR_INTEGER | VLC_VAR_HASCHOICE) )
-    {
-        /* The user may have selected a different channels configuration. */
-        var_Get( p_aout, "audio-channels", &val );
-
-        if ( val.i_int == AOUT_VAR_CHAN_RSTEREO )
-        {
-            p_aout->output.output.i_original_channels |=
-                                        AOUT_CHAN_REVERSESTEREO;
-        }
-        else if ( val.i_int == AOUT_VAR_CHAN_STEREO )
-        {
-            p_aout->output.output.i_original_channels =
-                AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT;
-        }
-        else if ( val.i_int == AOUT_VAR_CHAN_LEFT )
-        {
-            p_aout->output.output.i_original_channels = AOUT_CHAN_LEFT;
-        }
-        else if ( val.i_int == AOUT_VAR_CHAN_RIGHT )
-        {
-            p_aout->output.output.i_original_channels = AOUT_CHAN_RIGHT;
-        }
-        else if ( val.i_int == AOUT_VAR_CHAN_DOLBYS )
-        {
-            p_aout->output.output.i_original_channels
-                = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT | AOUT_CHAN_DOLBYSTEREO;
-        }
-    }
-    else if ( p_aout->output.output.i_physical_channels == AOUT_CHAN_CENTER
-              && (p_aout->output.output.i_original_channels
-                   & AOUT_CHAN_PHYSMASK) == (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT) )
-    {
-        /* Mono - create the audio-channels variable. */
-        var_Create( p_aout, "audio-channels",
-                    VLC_VAR_INTEGER | VLC_VAR_HASCHOICE );
-        text.psz_string = _("Audio Channels");
-        var_Change( p_aout, "audio-channels", VLC_VAR_SETTEXT, &text, NULL );
-
-        val.i_int = AOUT_VAR_CHAN_STEREO; text.psz_string = _("Stereo");
-        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
-        val.i_int = AOUT_VAR_CHAN_LEFT; text.psz_string = _("Left");
-        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
-        val.i_int = AOUT_VAR_CHAN_RIGHT; text.psz_string = _("Right");
-        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
-        if ( p_aout->output.output.i_original_channels & AOUT_CHAN_DUALMONO )
-        {
-            /* Go directly to the left channel. */
-            p_aout->output.output.i_original_channels = AOUT_CHAN_LEFT;
-            val.i_int = AOUT_VAR_CHAN_LEFT;
-            var_Set( p_aout, "audio-channels", val );
-        }
-        var_AddCallback( p_aout, "audio-channels", aout_ChannelsRestart,
-                         NULL );
-    }
-    else if ( p_aout->output.output.i_physical_channels ==
-               (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT)
-                && (p_aout->output.output.i_original_channels &
-                     (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT)) )
-    {
-        /* Stereo - create the audio-channels variable. */
-        var_Create( p_aout, "audio-channels",
-                    VLC_VAR_INTEGER | VLC_VAR_HASCHOICE );
-        text.psz_string = _("Audio Channels");
-        var_Change( p_aout, "audio-channels", VLC_VAR_SETTEXT, &text, NULL );
-
-        if ( p_aout->output.output.i_original_channels & AOUT_CHAN_DOLBYSTEREO )
-        {
-            val.i_int = AOUT_VAR_CHAN_DOLBYS;
-            text.psz_string = _("Dolby Surround");
-        }
-        else
-        {
-            val.i_int = AOUT_VAR_CHAN_STEREO;
-            text.psz_string = _("Stereo");
-        }
-        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
-        val.i_int = AOUT_VAR_CHAN_LEFT; text.psz_string = _("Left");
-        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
-        val.i_int = AOUT_VAR_CHAN_RIGHT; text.psz_string = _("Right");
-        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
-        val.i_int = AOUT_VAR_CHAN_RSTEREO; text.psz_string=_("Reverse stereo");
-        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
-        if ( p_aout->output.output.i_original_channels & AOUT_CHAN_DUALMONO )
-        {
-            /* Go directly to the left channel. */
-            p_aout->output.output.i_original_channels = AOUT_CHAN_LEFT;
-            val.i_int = AOUT_VAR_CHAN_LEFT;
-            var_Set( p_aout, "audio-channels", val );
-        }
-        var_AddCallback( p_aout, "audio-channels", aout_ChannelsRestart,
-                         NULL );
-    }
-    val.b_bool = VLC_TRUE;
-    var_Set( p_aout, "intf-change", val );
-
-    aout_FormatPrepare( &p_aout->output.output );
-
-    /* Prepare FIFO. */
-    aout_FifoInit( p_aout, &p_aout->output.fifo,
-                   p_aout->output.output.i_rate );
-
-    vlc_mutex_unlock( &p_aout->output_fifo_lock );
-
-    aout_FormatPrint( p_aout, "output", &p_aout->output.output );
-
-    /* Calculate the resulting mixer output format. */
-    memcpy( &p_aout->mixer.mixer, &p_aout->output.output,
-            sizeof(audio_sample_format_t) );
-    if ( !AOUT_FMT_NON_LINEAR(&p_aout->output.output) )
-    {
-        /* Non-S/PDIF mixer only deals with float32 or fixed32. */
-        p_aout->mixer.mixer.i_format
-                     = (p_aout->p_libvlc->i_cpu & CPU_CAPABILITY_FPU) ?
-                        VLC_FOURCC('f','l','3','2') :
-                        VLC_FOURCC('f','i','3','2');
-        aout_FormatPrepare( &p_aout->mixer.mixer );
-    }
-    else
-    {
-        p_aout->mixer.mixer.i_format = p_format->i_format;
-    }
-
-    aout_FormatPrint( p_aout, "mixer", &p_aout->mixer.mixer );
-
-    /* Create filters. */
-    p_aout->output.i_nb_filters = 0;
-    if ( aout_FiltersCreatePipeline( p_aout, p_aout->output.pp_filters,
-                                     &p_aout->output.i_nb_filters,
-                                     &p_aout->mixer.mixer,
-                                     &p_aout->output.output ) < 0 )
-    {
-        msg_Err( p_aout, "couldn't create audio output pipeline" );
-        module_Unneed( p_aout, p_aout->output.p_module );
-        return -1;
-    }
-
-    /* Prepare hints for the buffer allocator. */
-    p_aout->mixer.output_alloc.i_alloc_type = AOUT_ALLOC_HEAP;
-    p_aout->mixer.output_alloc.i_bytes_per_sec
-                        = p_aout->mixer.mixer.i_bytes_per_frame
-                           * p_aout->mixer.mixer.i_rate
-                           / p_aout->mixer.mixer.i_frame_length;
-
-    aout_FiltersHintBuffers( p_aout, p_aout->output.pp_filters,
-                             p_aout->output.i_nb_filters,
-                             &p_aout->mixer.output_alloc );
-
-    p_aout->output.b_error = 0;
-    return 0;
-}
-
-/*****************************************************************************
- * aout_OutputDelete : delete the output
- *****************************************************************************
- * This function is entered with the mixer lock.
- *****************************************************************************/
-void aout_OutputDelete( aout_instance_t * p_aout )
-{
-    if ( p_aout->output.b_error )
-    {
-        return;
-    }
-
-    module_Unneed( p_aout, p_aout->output.p_module );
-
-    aout_FiltersDestroyPipeline( p_aout, p_aout->output.pp_filters,
-                                 p_aout->output.i_nb_filters );
-    aout_FifoDestroy( p_aout, &p_aout->output.fifo );
-
-    p_aout->output.b_error = VLC_TRUE;
-}
-
-/*****************************************************************************
- * aout_OutputPlay : play a buffer
- *****************************************************************************
- * This function is entered with the mixer lock.
- *****************************************************************************/
-void aout_OutputPlay( aout_instance_t * p_aout, aout_buffer_t * p_buffer )
-{
-    aout_FiltersPlay( p_aout, p_aout->output.pp_filters,
-                      p_aout->output.i_nb_filters,
-                      &p_buffer );
-
-    if( p_buffer->i_nb_bytes == 0 )
-    {
-        aout_BufferFree( p_buffer );
-        return;
-    }
-
-    vlc_mutex_lock( &p_aout->output_fifo_lock );
-    aout_FifoPush( p_aout, &p_aout->output.fifo, p_buffer );
-    p_aout->output.pf_play( p_aout );
-    vlc_mutex_unlock( &p_aout->output_fifo_lock );
-}
-
-/*****************************************************************************
- * aout_OutputNextBuffer : give the audio output plug-in the right buffer
- *****************************************************************************
- * If b_can_sleek is 1, the aout core functions won't try to resample
- * new buffers to catch up - that is we suppose that the output plug-in can
- * compensate it by itself. S/PDIF outputs should always set b_can_sleek = 1.
- * This function is entered with no lock at all :-).
- *****************************************************************************/
-aout_buffer_t * aout_OutputNextBuffer( aout_instance_t * p_aout,
-                                       mtime_t start_date,
-                                       vlc_bool_t b_can_sleek )
-{
-    aout_buffer_t * p_buffer;
-
-    vlc_mutex_lock( &p_aout->output_fifo_lock );
-
-    p_buffer = p_aout->output.fifo.p_first;
-
-    /* Drop the audio sample if the audio output is really late.
-     * In the case of b_can_sleek, we don't use a resampler so we need to be
-     * a lot more severe. */
-    while ( p_buffer && p_buffer->start_date <
-            (b_can_sleek ? start_date : mdate()) - AOUT_PTS_TOLERANCE )
-    {
-        msg_Dbg( p_aout, "audio output is too slow ("I64Fd"), "
-                 "trashing "I64Fd"us", mdate() - p_buffer->start_date,
-                 p_buffer->end_date - p_buffer->start_date );
-        p_buffer = p_buffer->p_next;
-        aout_BufferFree( p_aout->output.fifo.p_first );
-        p_aout->output.fifo.p_first = p_buffer;
-    }
-
-    if ( p_buffer == NULL )
-    {
-        p_aout->output.fifo.pp_last = &p_aout->output.fifo.p_first;
-
-#if 0 /* This is bad because the audio output might just be trying to fill
-       * in it's internal buffers. And anyway, it's up to the audio output
-       * to deal with this kind of starvation. */
-
-        /* Set date to 0, to allow the mixer to send a new buffer ASAP */
-        aout_FifoSet( p_aout, &p_aout->output.fifo, 0 );
-        if ( !p_aout->output.b_starving )
-            msg_Dbg( p_aout,
-                 "audio output is starving (no input), playing silence" );
-        p_aout->output.b_starving = 1;
-#endif
-
-        vlc_mutex_unlock( &p_aout->output_fifo_lock );
-        return NULL;
-    }
-
-    /* Here we suppose that all buffers have the same duration - this is
-     * generally true, and anyway if it's wrong it won't be a disaster.
-     */
-    if ( p_buffer->start_date > start_date
-                         + (p_buffer->end_date - p_buffer->start_date) )
-    /*
-     *                   + AOUT_PTS_TOLERANCE )
-     * There is no reason to want that, it just worsen the scheduling of
-     * an audio sample after an output starvation (ie. on start or on resume)
-     * --Gibalou
-     */
-    {
-        vlc_mutex_unlock( &p_aout->output_fifo_lock );
-        if ( !p_aout->output.b_starving )
-            msg_Dbg( p_aout, "audio output is starving ("I64Fd"), "
-                     "playing silence", p_buffer->start_date - start_date );
-        p_aout->output.b_starving = 1;
-        return NULL;
-    }
-
-    p_aout->output.b_starving = 0;
-
-    if ( !b_can_sleek &&
-          ( (p_buffer->start_date - start_date > AOUT_PTS_TOLERANCE)
-             || (start_date - p_buffer->start_date > AOUT_PTS_TOLERANCE) ) )
-    {
-        /* Try to compensate the drift by doing some resampling. */
-        int i;
-        mtime_t difference = start_date - p_buffer->start_date;
-        msg_Warn( p_aout, "output date isn't PTS date, requesting "
-                  "resampling ("I64Fd")", difference );
-
-        vlc_mutex_lock( &p_aout->input_fifos_lock );
-        for ( i = 0; i < p_aout->i_nb_inputs; i++ )
-        {
-            aout_fifo_t * p_fifo = &p_aout->pp_inputs[i]->fifo;
-
-            aout_FifoMoveDates( p_aout, p_fifo, difference );
-        }
-
-        aout_FifoMoveDates( p_aout, &p_aout->output.fifo, difference );
-        vlc_mutex_unlock( &p_aout->input_fifos_lock );
-    }
-
-    p_aout->output.fifo.p_first = p_buffer->p_next;
-    if ( p_buffer->p_next == NULL )
-    {
-        p_aout->output.fifo.pp_last = &p_aout->output.fifo.p_first;
-    }
-
-    vlc_mutex_unlock( &p_aout->output_fifo_lock );
-    return p_buffer;
-}
+/*****************************************************************************
+ * output.c : internal management of output streams for the audio output
+ *****************************************************************************
+ * Copyright (C) 2002-2004 the VideoLAN team
+ * $Id: output.c 14953 2006-03-28 20:29:28Z zorglub $
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+#include <stdlib.h>                            /* calloc(), malloc(), free() */
+#include <string.h>
+
+#include <vlc/vlc.h>
+
+#include "audio_output.h"
+#include "aout_internal.h"
+
+//#define DEBUG_AOUT_DEFAULT_STEREO
+
+/*****************************************************************************
+ * aout_OutputNew : allocate a new output and rework the filter pipeline
+ *****************************************************************************
+ * This function is entered with the mixer lock.
+ *****************************************************************************/
+int aout_OutputNew( aout_instance_t * p_aout,
+                    audio_sample_format_t * p_format )
+{
+    /* Retrieve user defaults. */
+    int i_rate = config_GetInt( p_aout, "aout-rate" );
+    vlc_value_t val, text;
+
+    int i_hasSetOut = 0;
+    int i_preferred = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT;
+    int i_preferredVar = AOUT_VAR_CHAN_STEREO;
+
+    /* kludge to avoid a fpu error when rate is 0... */
+    if( i_rate == 0 ) i_rate = -1;
+
+    memcpy( &p_aout->output.output, p_format, sizeof(audio_sample_format_t) );
+    if ( i_rate != -1 )
+        p_aout->output.output.i_rate = i_rate;
+    aout_FormatPrepare( &p_aout->output.output );
+
+    vlc_mutex_lock( &p_aout->output_fifo_lock );
+
+    /* Find the best output plug-in. */
+    p_aout->output.p_module = module_Need( p_aout, "audio output", "$aout", 0);
+    if ( p_aout->output.p_module == NULL )
+    {
+        msg_Err( p_aout, "no suitable audio output module" );
+        vlc_mutex_unlock( &p_aout->output_fifo_lock );
+        return -1;
+    }
+
+    if ( var_Type( p_aout, "audio-channels" ) ==
+             (VLC_VAR_INTEGER | VLC_VAR_HASCHOICE) )
+    {
+        i_hasSetOut = 1;
+        
+        /* The user may have selected a different channels configuration. */
+        var_Get( p_aout, "audio-channels", &val );
+
+        if ( val.i_int == AOUT_VAR_CHAN_RSTEREO )
+        {
+            p_aout->output.output.i_original_channels |=
+                                        AOUT_CHAN_REVERSESTEREO;
+        }
+        else if ( val.i_int == AOUT_VAR_CHAN_STEREO )
+        {
+            p_aout->output.output.i_original_channels =
+                AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT;
+        }
+        else if ( val.i_int == AOUT_VAR_CHAN_LEFT )
+        {
+            p_aout->output.output.i_original_channels = AOUT_CHAN_LEFT;
+        }
+        else if ( val.i_int == AOUT_VAR_CHAN_RIGHT )
+        {
+            p_aout->output.output.i_original_channels = AOUT_CHAN_RIGHT;
+        }
+        else if ( val.i_int == AOUT_VAR_CHAN_DOLBYS )
+        {
+            p_aout->output.output.i_original_channels
+                = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT | AOUT_CHAN_DOLBYSTEREO;
+        }
+    }
+    else if ( p_aout->output.output.i_physical_channels == AOUT_CHAN_CENTER
+              && (p_aout->output.output.i_original_channels
+                   & AOUT_CHAN_PHYSMASK) == (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT) )
+    {
+#if defined(DEBUG_AOUT_DEFAULT_STEREO)      
+        printf("vlc: output.c: aout_OutputNew: AOUT_CHAN_CENTER -- MONO!\n");
+#endif
+        int i_preferred = AOUT_CHAN_LEFT;
+        int i_preferredVar = AOUT_VAR_CHAN_LEFT;
+  
+        /* Mono - create the audio-channels variable. */
+        var_Create( p_aout, "audio-channels",
+                    VLC_VAR_INTEGER | VLC_VAR_HASCHOICE );
+        text.psz_string = _("Audio Channels");
+        var_Change( p_aout, "audio-channels", VLC_VAR_SETTEXT, &text, NULL );
+
+        val.i_int = AOUT_VAR_CHAN_STEREO; text.psz_string = _("Stereo");
+        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
+        val.i_int = AOUT_VAR_CHAN_LEFT; text.psz_string = _("Left");
+        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
+        val.i_int = AOUT_VAR_CHAN_RIGHT; text.psz_string = _("Right");
+        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
+        if ( p_aout->output.output.i_original_channels & AOUT_CHAN_DUALMONO )
+        {
+            i_hasSetOut = 1;
+            
+            /* Go directly to the left channel. */
+            p_aout->output.output.i_original_channels = AOUT_CHAN_LEFT;
+            val.i_int = AOUT_VAR_CHAN_LEFT;
+
+#if defined(DEBUG_AOUT_DEFAULT_STEREO)      
+        printf("vlc: output.c: aout_OutputNew: MONO BUT USING LEFT CHANNEL ONLY!\n");
+#endif
+            
+            var_Set( p_aout, "audio-channels", val );
+        }
+        var_AddCallback( p_aout, "audio-channels", aout_ChannelsRestart,
+                         NULL );
+    }
+    else if ( p_aout->output.output.i_physical_channels ==
+               (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT)
+                && (p_aout->output.output.i_original_channels &
+                     (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT)) )
+    {
+#if defined(DEBUG_AOUT_DEFAULT_STEREO)      
+        printf("vlc: output.c: aout_OutputNew: AOUT_CHAN_CENTER -- STEREO!\n");
+#endif
+
+        /* Stereo - create the audio-channels variable. */
+        var_Create( p_aout, "audio-channels",
+                    VLC_VAR_INTEGER | VLC_VAR_HASCHOICE );
+        text.psz_string = _("Audio Channels");
+        var_Change( p_aout, "audio-channels", VLC_VAR_SETTEXT, &text, NULL );
+
+        if ( p_aout->output.output.i_original_channels & AOUT_CHAN_DOLBYSTEREO )
+        {
+            i_preferred = AOUT_CHAN_DOLBYSTEREO;
+            i_preferredVar = AOUT_VAR_CHAN_DOLBYS;
+            
+            val.i_int = AOUT_VAR_CHAN_DOLBYS;
+            text.psz_string = _("Dolby Surround");
+        }
+        else
+        {
+            i_preferred = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT;
+            i_preferredVar = AOUT_VAR_CHAN_STEREO;
+            
+            val.i_int = AOUT_VAR_CHAN_STEREO;
+            text.psz_string = _("Stereo");
+        }
+        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
+        val.i_int = AOUT_VAR_CHAN_LEFT; text.psz_string = _("Left");
+        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
+        val.i_int = AOUT_VAR_CHAN_RIGHT; text.psz_string = _("Right");
+        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
+        val.i_int = AOUT_VAR_CHAN_RSTEREO; text.psz_string=_("Reverse stereo");
+        var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
+        if ( p_aout->output.output.i_original_channels & AOUT_CHAN_DUALMONO )
+        {
+            i_hasSetOut = 1;
+            
+            /* Go directly to the left channel. */
+            p_aout->output.output.i_original_channels = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT;
+            val.i_int = AOUT_VAR_CHAN_STEREO;
+            
+#if defined(DEBUG_AOUT_DEFAULT_STEREO)      
+            printf("vlc: output.c: aout_OutputNew: DUAL MONO BUT USING STEREO CHANNEL ONLY!\n");
+#endif
+
+            var_Set( p_aout, "audio-channels", val );
+        }
+   
+        var_AddCallback( p_aout, "audio-channels", aout_ChannelsRestart,
+                         NULL );
+    }
+
+    if(i_hasSetOut == 0)
+    {
+#if defined(DEBUG_AOUT_DEFAULT_STEREO)      
+        printf("vlc: output.c: aout_OutputNew: STEREO -- DEFAULT TO PREFERRED: %d!\n", i_preferred);
+#endif
+        p_aout->output.output.i_original_channels = i_preferred;
+        val.i_int = i_preferredVar;
+
+        var_Change( p_aout, "audio-channels", VLC_VAR_SETVALUE, &val, NULL );
+    }
+
+    val.b_bool = VLC_TRUE;
+    var_Set( p_aout, "intf-change", val );
+
+    aout_FormatPrepare( &p_aout->output.output );
+
+    /* Prepare FIFO. */
+    aout_FifoInit( p_aout, &p_aout->output.fifo,
+                   p_aout->output.output.i_rate );
+
+    vlc_mutex_unlock( &p_aout->output_fifo_lock );
+
+    aout_FormatPrint( p_aout, "output", &p_aout->output.output );
+
+    /* Calculate the resulting mixer output format. */
+    memcpy( &p_aout->mixer.mixer, &p_aout->output.output,
+            sizeof(audio_sample_format_t) );
+    if ( !AOUT_FMT_NON_LINEAR(&p_aout->output.output) )
+    {
+        /* Non-S/PDIF mixer only deals with float32 or fixed32. */
+        p_aout->mixer.mixer.i_format
+                     = (p_aout->p_libvlc->i_cpu & CPU_CAPABILITY_FPU) ?
+                        VLC_FOURCC('f','l','3','2') :
+                        VLC_FOURCC('f','i','3','2');
+        aout_FormatPrepare( &p_aout->mixer.mixer );
+    }
+    else
+    {
+        p_aout->mixer.mixer.i_format = p_format->i_format;
+    }
+
+    aout_FormatPrint( p_aout, "mixer", &p_aout->mixer.mixer );
+
+    /* Create filters. */
+    p_aout->output.i_nb_filters = 0;
+    if ( aout_FiltersCreatePipeline( p_aout, p_aout->output.pp_filters,
+                                     &p_aout->output.i_nb_filters,
+                                     &p_aout->mixer.mixer,
+                                     &p_aout->output.output ) < 0 )
+    {
+        msg_Err( p_aout, "couldn't create audio output pipeline" );
+        module_Unneed( p_aout, p_aout->output.p_module );
+        return -1;
+    }
+
+    /* Prepare hints for the buffer allocator. */
+    p_aout->mixer.output_alloc.i_alloc_type = AOUT_ALLOC_HEAP;
+    p_aout->mixer.output_alloc.i_bytes_per_sec
+                        = p_aout->mixer.mixer.i_bytes_per_frame
+                           * p_aout->mixer.mixer.i_rate
+                           / p_aout->mixer.mixer.i_frame_length;
+
+    aout_FiltersHintBuffers( p_aout, p_aout->output.pp_filters,
+                             p_aout->output.i_nb_filters,
+                             &p_aout->mixer.output_alloc );
+
+    p_aout->output.b_error = 0;
+    return 0;
+}
+
+/*****************************************************************************
+ * aout_OutputDelete : delete the output
+ *****************************************************************************
+ * This function is entered with the mixer lock.
+ *****************************************************************************/
+void aout_OutputDelete( aout_instance_t * p_aout )
+{
+    if ( p_aout->output.b_error )
+    {
+        return;
+    }
+
+    module_Unneed( p_aout, p_aout->output.p_module );
+
+    aout_FiltersDestroyPipeline( p_aout, p_aout->output.pp_filters,
+                                 p_aout->output.i_nb_filters );
+    aout_FifoDestroy( p_aout, &p_aout->output.fifo );
+
+    p_aout->output.b_error = VLC_TRUE;
+}
+
+/*****************************************************************************
+ * aout_OutputPlay : play a buffer
+ *****************************************************************************
+ * This function is entered with the mixer lock.
+ *****************************************************************************/
+void aout_OutputPlay( aout_instance_t * p_aout, aout_buffer_t * p_buffer )
+{
+    aout_FiltersPlay( p_aout, p_aout->output.pp_filters,
+                      p_aout->output.i_nb_filters,
+                      &p_buffer );
+
+    if( p_buffer->i_nb_bytes == 0 )
+    {
+        aout_BufferFree( p_buffer );
+        return;
+    }
+
+    vlc_mutex_lock( &p_aout->output_fifo_lock );
+    aout_FifoPush( p_aout, &p_aout->output.fifo, p_buffer );
+    p_aout->output.pf_play( p_aout );
+    vlc_mutex_unlock( &p_aout->output_fifo_lock );
+}
+
+/*****************************************************************************
+ * aout_OutputNextBuffer : give the audio output plug-in the right buffer
+ *****************************************************************************
+ * If b_can_sleek is 1, the aout core functions won't try to resample
+ * new buffers to catch up - that is we suppose that the output plug-in can
+ * compensate it by itself. S/PDIF outputs should always set b_can_sleek = 1.
+ * This function is entered with no lock at all :-).
+ *****************************************************************************/
+aout_buffer_t * aout_OutputNextBuffer( aout_instance_t * p_aout,
+                                       mtime_t start_date,
+                                       vlc_bool_t b_can_sleek )
+{
+    aout_buffer_t * p_buffer;
+
+    vlc_mutex_lock( &p_aout->output_fifo_lock );
+
+    p_buffer = p_aout->output.fifo.p_first;
+
+    /* Drop the audio sample if the audio output is really late.
+     * In the case of b_can_sleek, we don't use a resampler so we need to be
+     * a lot more severe. */
+    while ( p_buffer && p_buffer->start_date <
+            (b_can_sleek ? start_date : mdate()) - AOUT_PTS_TOLERANCE )
+    {
+        msg_Dbg( p_aout, "audio output is too slow ("I64Fd"), "
+                 "trashing "I64Fd"us", mdate() - p_buffer->start_date,
+                 p_buffer->end_date - p_buffer->start_date );
+        p_buffer = p_buffer->p_next;
+        aout_BufferFree( p_aout->output.fifo.p_first );
+        p_aout->output.fifo.p_first = p_buffer;
+    }
+
+    if ( p_buffer == NULL )
+    {
+        p_aout->output.fifo.pp_last = &p_aout->output.fifo.p_first;
+
+#if 0 /* This is bad because the audio output might just be trying to fill
+       * in it's internal buffers. And anyway, it's up to the audio output
+       * to deal with this kind of starvation. */
+
+        /* Set date to 0, to allow the mixer to send a new buffer ASAP */
+        aout_FifoSet( p_aout, &p_aout->output.fifo, 0 );
+        if ( !p_aout->output.b_starving )
+            msg_Dbg( p_aout,
+                 "audio output is starving (no input), playing silence" );
+        p_aout->output.b_starving = 1;
+#endif
+
+        vlc_mutex_unlock( &p_aout->output_fifo_lock );
+        return NULL;
+    }
+
+    /* Here we suppose that all buffers have the same duration - this is
+     * generally true, and anyway if it's wrong it won't be a disaster.
+     */
+    if ( p_buffer->start_date > start_date
+                         + (p_buffer->end_date - p_buffer->start_date) )
+    /*
+     *                   + AOUT_PTS_TOLERANCE )
+     * There is no reason to want that, it just worsen the scheduling of
+     * an audio sample after an output starvation (ie. on start or on resume)
+     * --Gibalou
+     */
+    {
+        vlc_mutex_unlock( &p_aout->output_fifo_lock );
+        if ( !p_aout->output.b_starving )
+            msg_Dbg( p_aout, "audio output is starving ("I64Fd"), "
+                     "playing silence", p_buffer->start_date - start_date );
+        p_aout->output.b_starving = 1;
+        return NULL;
+    }
+
+    p_aout->output.b_starving = 0;
+
+    if ( !b_can_sleek &&
+          ( (p_buffer->start_date - start_date > AOUT_PTS_TOLERANCE)
+             || (start_date - p_buffer->start_date > AOUT_PTS_TOLERANCE) ) )
+    {
+        /* Try to compensate the drift by doing some resampling. */
+        int i;
+        mtime_t difference = start_date - p_buffer->start_date;
+        msg_Warn( p_aout, "output date isn't PTS date, requesting "
+                  "resampling ("I64Fd")", difference );
+
+        vlc_mutex_lock( &p_aout->input_fifos_lock );
+        for ( i = 0; i < p_aout->i_nb_inputs; i++ )
+        {
+            aout_fifo_t * p_fifo = &p_aout->pp_inputs[i]->fifo;
+
+            aout_FifoMoveDates( p_aout, p_fifo, difference );
+        }
+
+        aout_FifoMoveDates( p_aout, &p_aout->output.fifo, difference );
+        vlc_mutex_unlock( &p_aout->input_fifos_lock );
+    }
+
+    p_aout->output.fifo.p_first = p_buffer->p_next;
+    if ( p_buffer->p_next == NULL )
+    {
+        p_aout->output.fifo.pp_last = &p_aout->output.fifo.p_first;
+    }
+
+    vlc_mutex_unlock( &p_aout->output_fifo_lock );
+    return p_buffer;
+}

Property changes on: src\audio_output\output.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\control\audio.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\control\core.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\control\input.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\control\log.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\control\mediacontrol_audio_video.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\control\mediacontrol_core.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\control\mediacontrol_init.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\control\mediacontrol_plugin.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\control\mediacontrol_util.c
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: src/control/playlist.c
===================================================================
--- src/control/playlist.c	(revision 159)
+++ src/control/playlist.c	(working copy)
@@ -1,180 +1,245 @@
-/*****************************************************************************
- * playlist.c: libvlc new API playlist handling functions
- *****************************************************************************
- * Copyright (C) 2005 the VideoLAN team
- * $Id: playlist.c 19386 2007-03-22 14:44:14Z jpsaman $
- *
- * Authors: Clément Stenac <zorglub@videolan.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-#include <libvlc_internal.h>
-#include <vlc/libvlc.h>
-
-#include <vlc/intf.h>
-
-#include <assert.h>
-
-void libvlc_playlist_play( libvlc_instance_t *p_instance, int i_id,
-                           int i_options, char **ppsz_options,
-                           libvlc_exception_t *p_e )
-{
-    assert( p_instance->p_playlist );
-    ///\todo Handle additionnal options
-
-    if( p_instance->p_playlist->i_size == 0 ) RAISEVOID( "Empty playlist" );
-    if( i_id > 0 )
-    {
-        /* Always use the current view when using libvlc */
-        playlist_view_t *p_view;
-        playlist_item_t *p_item;
-
-        if( p_instance->p_playlist->status.i_view == -1 )
-        {
-            playlist_Control( p_instance->p_playlist, PLAYLIST_GOTO,
-                              i_id );
-        }
-        p_view = playlist_ViewFind( p_instance->p_playlist,
-                                    p_instance->p_playlist->status.i_view );
-        if( !p_view )
-        {
-             libvlc_exception_raise( p_e,
-                                     "Unable to find current playlist view ");
-             return;
-        }
-
-        p_item = playlist_ItemGetById( p_instance->p_playlist, i_id );
-
-        if( !p_item )
-        {
-            libvlc_exception_raise( p_e, "Unable to find item " );
-            return;
-        }
-        playlist_LockControl( p_instance->p_playlist, PLAYLIST_VIEWPLAY,
-                          p_instance->p_playlist->status.i_view,
-                          p_view->p_root, p_item );
-    }
-    else
-    {
-        playlist_Play( p_instance->p_playlist );
-    }
-}
-
-void libvlc_playlist_pause( libvlc_instance_t *p_instance,
-                           libvlc_exception_t *p_e )
-{
-    assert( p_instance->p_playlist );
-    if( playlist_Pause( p_instance->p_playlist ) != VLC_SUCCESS )
-        RAISEVOID( "Empty playlist" );
-}
-
-
-void libvlc_playlist_stop( libvlc_instance_t *p_instance,
-                           libvlc_exception_t *p_e )
-{
-    assert( p_instance->p_playlist );
-    if( playlist_Stop( p_instance->p_playlist ) != VLC_SUCCESS )
-        RAISEVOID( "Empty playlist" );
-}
-
-void libvlc_playlist_clear( libvlc_instance_t *p_instance,
-                           libvlc_exception_t *p_e )
-{
-    assert( p_instance->p_playlist );
-    playlist_Clear( p_instance->p_playlist );
-}
-
-void libvlc_playlist_next( libvlc_instance_t *p_instance,
-                           libvlc_exception_t *p_e )
-{
-    assert( p_instance->p_playlist );
-    if( playlist_Next( p_instance->p_playlist ) != VLC_SUCCESS )
-        RAISEVOID( "Empty playlist" );
-}
-
-void libvlc_playlist_prev( libvlc_instance_t *p_instance,
-                           libvlc_exception_t *p_e )
-{
-    if( playlist_Prev( p_instance->p_playlist ) != VLC_SUCCESS )
-        RAISEVOID( "Empty playlist" );
-}
-
-int libvlc_playlist_add( libvlc_instance_t *p_instance, const char *psz_uri,
-                         const char *psz_name, libvlc_exception_t *p_e )
-{
-    return libvlc_playlist_add_extended( p_instance, psz_uri, psz_name,
-                                         0, NULL, p_e );
-}
-
-int libvlc_playlist_add_extended( libvlc_instance_t *p_instance,
-                                  const char *psz_uri, const char *psz_name,
-                                  int i_options, const char **ppsz_options,
-                                  libvlc_exception_t *p_e )
-{
-    assert( p_instance->p_playlist );
-    return playlist_AddExt( p_instance->p_playlist, psz_uri, psz_name,
-                            PLAYLIST_INSERT, PLAYLIST_END, -1, ppsz_options,
-                            i_options );
-}
-
-int libvlc_playlist_delete_item( libvlc_instance_t *p_instance, int i_id,
-                                 libvlc_exception_t *p_e )
-{
-    assert( p_instance->p_playlist );
-    return playlist_Delete( p_instance->p_playlist, i_id );
-}
-
-
-int libvlc_playlist_isplaying( libvlc_instance_t *p_instance,
-                               libvlc_exception_t *p_e )
-{
-    assert( p_instance->p_playlist );
-    return playlist_IsPlaying( p_instance->p_playlist );
-}
-
-int libvlc_playlist_items_count( libvlc_instance_t *p_instance,
-                                 libvlc_exception_t *p_e )
-{
-    assert( p_instance->p_playlist );
-    return p_instance->p_playlist->i_size;
-}
-
-libvlc_input_t * libvlc_playlist_get_input( libvlc_instance_t *p_instance,
-                                            libvlc_exception_t *p_e )
-{
-    libvlc_input_t *p_input = NULL;
-    assert( p_instance->p_playlist );
-
-    vlc_mutex_lock( &p_instance->p_playlist->object_lock );
-    if( p_instance->p_playlist->p_input == NULL )
-    {
-        libvlc_exception_raise( p_e, "No active input" );
-        vlc_mutex_unlock( &p_instance->p_playlist->object_lock );
-        return NULL;
-    }
-    p_input = (libvlc_input_t *)malloc( sizeof( libvlc_input_t ) );
-    if( !p_input )
-    {
-        libvlc_exception_raise( p_e, "No memory left" );
-        vlc_mutex_unlock( &p_instance->p_playlist->object_lock );
-        return NULL;
-    }
-    p_input->i_input_id = p_instance->p_playlist->p_input->i_object_id;
-    p_input->p_instance = p_instance;
-    vlc_mutex_unlock( &p_instance->p_playlist->object_lock );
-
-    return p_input;
-}
+/*****************************************************************************
+ * playlist.c: libvlc new API playlist handling functions
+ *****************************************************************************
+ * Copyright (C) 2005 the VideoLAN team
+ * $Id: playlist.c 19386 2007-03-22 14:44:14Z jpsaman $
+ *
+ * Authors: Clément Stenac <zorglub@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <libvlc_internal.h>
+#include <vlc/libvlc.h>
+
+#include <vlc/intf.h>
+
+#include <assert.h>
+
+void libvlc_playlist_play( libvlc_instance_t *p_instance, int i_id,
+                           int i_options, char **ppsz_options,
+                           libvlc_exception_t *p_e )
+{
+    assert( p_instance->p_playlist );
+    ///\todo Handle additionnal options
+
+    if( p_instance->p_playlist->i_size == 0 ) RAISEVOID( "Empty playlist" );
+    if( i_id > 0 )
+    {
+        /* Always use the current view when using libvlc */
+        playlist_view_t *p_view;
+        playlist_item_t *p_item;
+
+        if( p_instance->p_playlist->status.i_view == -1 )
+        {
+            playlist_Control( p_instance->p_playlist, PLAYLIST_GOTO,
+                              i_id );
+        }
+        p_view = playlist_ViewFind( p_instance->p_playlist,
+                                    p_instance->p_playlist->status.i_view );
+        if( !p_view )
+        {
+             libvlc_exception_raise( p_e,
+                                     "Unable to find current playlist view ");
+             return;
+        }
+
+        p_item = playlist_ItemGetById( p_instance->p_playlist, i_id );
+
+        if( !p_item )
+        {
+            libvlc_exception_raise( p_e, "Unable to find item " );
+            return;
+        }
+        playlist_LockControl( p_instance->p_playlist, PLAYLIST_VIEWPLAY,
+                          p_instance->p_playlist->status.i_view,
+                          p_view->p_root, p_item );
+    }
+    else
+    {
+        playlist_Play( p_instance->p_playlist );
+    }
+}
+
+void libvlc_playlist_pause( libvlc_instance_t *p_instance,
+                           libvlc_exception_t *p_e )
+{
+    assert( p_instance->p_playlist );
+    if( playlist_Pause( p_instance->p_playlist ) != VLC_SUCCESS )
+        RAISEVOID( "Empty playlist" );
+}
+
+
+void libvlc_playlist_stop( libvlc_instance_t *p_instance,
+                           libvlc_exception_t *p_e )
+{
+    assert( p_instance->p_playlist );
+    if( playlist_Stop( p_instance->p_playlist ) != VLC_SUCCESS )
+        RAISEVOID( "Empty playlist" );
+}
+
+void libvlc_playlist_clear( libvlc_instance_t *p_instance,
+                           libvlc_exception_t *p_e )
+{
+    assert( p_instance->p_playlist );
+    playlist_Clear( p_instance->p_playlist );
+}
+
+void libvlc_playlist_next( libvlc_instance_t *p_instance,
+                           libvlc_exception_t *p_e )
+{
+    assert( p_instance->p_playlist );
+    if( playlist_Next( p_instance->p_playlist ) != VLC_SUCCESS )
+        RAISEVOID( "Empty playlist" );
+}
+
+void libvlc_playlist_prev( libvlc_instance_t *p_instance,
+                           libvlc_exception_t *p_e )
+{
+    if( playlist_Prev( p_instance->p_playlist ) != VLC_SUCCESS )
+        RAISEVOID( "Empty playlist" );
+}
+
+int libvlc_playlist_add( libvlc_instance_t *p_instance, const char *psz_uri,
+                         const char *psz_name, libvlc_exception_t *p_e )
+{
+    return libvlc_playlist_add_extended( p_instance, psz_uri, psz_name,
+                                         0, NULL, p_e );
+}
+
+int libvlc_playlist_add_extended( libvlc_instance_t *p_instance,
+                                  const char *psz_uri, const char *psz_name,
+                                  int i_options, const char **ppsz_options,
+                                  libvlc_exception_t *p_e )
+{
+    assert( p_instance->p_playlist );
+    return playlist_AddExt( p_instance->p_playlist, psz_uri, psz_name,
+                            PLAYLIST_INSERT, PLAYLIST_END, -1, ppsz_options,
+                            i_options );
+}
+
+int libvlc_playlist_delete_item( libvlc_instance_t *p_instance, int i_id,
+                                 libvlc_exception_t *p_e )
+{
+    assert( p_instance->p_playlist );
+    return playlist_Delete( p_instance->p_playlist, i_id );
+}
+
+
+int libvlc_playlist_isplaying( libvlc_instance_t *p_instance,
+                               libvlc_exception_t *p_e )
+{
+    assert( p_instance->p_playlist );
+    return playlist_IsPlaying( p_instance->p_playlist );
+}
+
+int libvlc_playlist_items_count( libvlc_instance_t *p_instance,
+                                 libvlc_exception_t *p_e )
+{
+    assert( p_instance->p_playlist );
+    return p_instance->p_playlist->i_size;
+}
+
+libvlc_input_t * libvlc_playlist_get_input( libvlc_instance_t *p_instance,
+                                            libvlc_exception_t *p_e )
+{
+    libvlc_input_t *p_input = NULL;
+    assert( p_instance->p_playlist );
+
+    vlc_mutex_lock( &p_instance->p_playlist->object_lock );
+    if( p_instance->p_playlist->p_input == NULL )
+    {
+        libvlc_exception_raise( p_e, "No active input" );
+        vlc_mutex_unlock( &p_instance->p_playlist->object_lock );
+        return NULL;
+    }
+    p_input = (libvlc_input_t *)malloc( sizeof( libvlc_input_t ) );
+    if( !p_input )
+    {
+        libvlc_exception_raise( p_e, "No memory left" );
+        vlc_mutex_unlock( &p_instance->p_playlist->object_lock );
+        return NULL;
+    }
+    p_input->i_input_id = p_instance->p_playlist->p_input->i_object_id;
+    p_input->p_instance = p_instance;
+    vlc_mutex_unlock( &p_instance->p_playlist->object_lock );
+
+    return p_input;
+}
+
+void libvlc_playlist_get_metadata( libvlc_instance_t *p_instance, vlc_meta_t **pp_meta, libvlc_exception_t *p_e )
+{
+  if( p_instance->p_playlist == NULL )
+  {
+      libvlc_exception_raise( p_e, "No playlist" );
+      return;
+  }
+
+  if( p_instance->p_playlist->status.i_status != PLAYLIST_RUNNING)
+  {
+      libvlc_exception_raise( p_e, "Playlist not running" );
+      return;
+  }
+
+  vlc_mutex_lock( &p_instance->p_playlist->object_lock );
+  //playlist_ItemGetByPos( p_instance->p_playlist, p_instance->p_playlist->i_index );
+  playlist_item_t *p_item = p_instance->p_playlist->status.p_item;
+
+  if( p_item == NULL )
+  {
+      libvlc_exception_raise( p_e, "Playlist has no currently playlist item" );
+      vlc_mutex_unlock( &p_instance->p_playlist->object_lock );
+      return;
+  }
+  
+  vlc_mutex_lock( &p_item->input.lock );
+    
+  *pp_meta = vlc_meta_New();
+  vlc_meta_t *p_meta = *pp_meta;
+  
+  vlc_meta_Add(p_meta, "Root", "Root Metadata Node");
+  
+  int i = 0;
+  for( ; i < p_item->input.i_categories; i++ )
+  {
+    p_meta->track = (vlc_meta_t**)realloc( p_meta->track, sizeof( vlc_meta_t* ) * (p_meta->i_track+1) );
+    p_meta->track[p_meta->i_track] = vlc_meta_New();
+    vlc_meta_Add(p_meta->track[p_meta->i_track], "Category", p_item->input.pp_categories[i]->psz_name);
+
+    p_meta->track[i]->track = (vlc_meta_t**)realloc( p_meta->track[i]->track, sizeof( vlc_meta_t* ) * (p_meta->track[i]->i_track+1) );
+    p_meta->track[i]->track[p_meta->track[i]->i_track] = vlc_meta_New();    
+       
+    int j = 0;
+    for( ; j < p_item->input.pp_categories[i]->i_infos; j++ )
+    {
+      if( p_item->input.pp_categories[i]->pp_infos[j]->psz_name[0] != 0 &&
+          p_item->input.pp_categories[i]->pp_infos[j]->psz_value[0] != 0 )
+      {
+        vlc_meta_Add(p_meta->track[i]->track[p_meta->track[i]->i_track], 
+                     p_item->input.pp_categories[i]->pp_infos[j]->psz_name,
+                     p_item->input.pp_categories[i]->pp_infos[j]->psz_value);
+        
+      }
+    }
+    
+    p_meta->track[i]->i_track++;    
+    p_meta->i_track++;
+  }
+  
+  vlc_mutex_unlock( &p_item->input.lock );
+  vlc_mutex_unlock( &p_instance->p_playlist->object_lock );
+  
+  return;
+}

Property changes on: src\control\playlist.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\control\video.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\control\vlm.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\extras\COPYING
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\extras\dirent.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\extras\getopt.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\extras\getopt.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\extras\getopt1.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\extras\libc.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\access.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\clock.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\control.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\decoder.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\demux.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\es_out.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\input.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\input_internal.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\mem_stream.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\stream.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\subtitles.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\input\var.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\interface\interaction.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\interface\interface.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\interface\intf_eject.c
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: src/libvlc.c
===================================================================
--- src/libvlc.c	(revision 159)
+++ src/libvlc.c	(working copy)
@@ -1,2656 +1,2735 @@
-/*****************************************************************************
- * libvlc.c: main libvlc source
- *****************************************************************************
- * Copyright (C) 1998-2006 the VideoLAN team
- * $Id: libvlc.c 17755 2006-11-14 07:17:34Z md $
- *
- * Authors: Vincent Seguin <seguin@via.ecp.fr>
- *          Samuel Hocevar <sam@zoy.org>
- *          Gildas Bazin <gbazin@videolan.org>
- *          Derk-Jan Hartman <hartman at videolan dot org>
- *          Rémi Denis-Courmont <rem # videolan : org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/*****************************************************************************
- * Pretend we are a builtin module
- *****************************************************************************/
-#define MODULE_NAME main
-#define MODULE_PATH main
-#define __BUILTIN__
-
-/*****************************************************************************
- * Preamble
- *****************************************************************************/
-#include <vlc/vlc.h>
-#include <vlc/input.h>
-
-#include <errno.h>                                                 /* ENOMEM */
-#include <stdio.h>                                              /* sprintf() */
-#include <string.h>                                            /* strerror() */
-#include <stdlib.h>                                                /* free() */
-
-#ifndef WIN32
-#   include <netinet/in.h>                            /* BSD: struct in_addr */
-#endif
-
-#ifdef HAVE_UNISTD_H
-#   include <unistd.h>
-#elif defined( WIN32 ) && !defined( UNDER_CE )
-#   include <io.h>
-#endif
-
-#ifdef WIN32                       /* optind, getopt(), included in unistd.h */
-#   include "extras/getopt.h"
-#endif
-
-#ifdef HAVE_LOCALE_H
-#   include <locale.h>
-#endif
-
-#ifdef HAVE_HAL
-#   include <hal/libhal.h>
-#endif
-
-#include "vlc_cpu.h"                                        /* CPU detection */
-#include "os_specific.h"
-
-#include "vlc_error.h"
-
-#include "vlc_playlist.h"
-#include "vlc_interface.h"
-
-#include "audio_output.h"
-
-#include "vlc_video.h"
-#include "video_output.h"
-
-#include "stream_output.h"
-#include "charset.h"
-
-#include "libvlc.h"
-
-/*****************************************************************************
- * The evil global variable. We handle it with care, don't worry.
- *****************************************************************************/
-static libvlc_t   libvlc;
-static libvlc_t * p_libvlc;
-static vlc_t *    p_static_vlc;
-
-/*****************************************************************************
- * Local prototypes
- *****************************************************************************/
-static int AddIntfInternal( int i_object, char const *psz_module,
-                             vlc_bool_t b_block, vlc_bool_t b_play,
-                             int i_options, char **ppsz_options );
-
-void LocaleInit( vlc_object_t * );
-void LocaleDeinit( void );
-static void SetLanguage   ( char const * );
-static int  GetFilenames  ( vlc_t *, int, char *[] );
-static void Help          ( vlc_t *, char const *psz_help_name );
-static void Usage         ( vlc_t *, char const *psz_module_name );
-static void ListModules   ( vlc_t * );
-static void Version       ( void );
-
-#ifdef WIN32
-static void ShowConsole   ( vlc_bool_t );
-static void PauseConsole  ( void );
-#endif
-static int  ConsoleWidth  ( void );
-
-static int  VerboseCallback( vlc_object_t *, char const *,
-                             vlc_value_t, vlc_value_t, void * );
-
-static void InitDeviceValues( vlc_t * );
-
-/*****************************************************************************
- * vlc_current_object: return the current object.
- *****************************************************************************
- * If i_object is non-zero, return the corresponding object. Otherwise,
- * return the statically allocated p_vlc object.
- *****************************************************************************/
-vlc_t * vlc_current_object( int i_object )
-{
-    if( i_object )
-    {
-         return vlc_object_get( p_libvlc, i_object );
-    }
-
-    return p_static_vlc;
-}
-
-/*****************************************************************************
- * VLC_Version: return the libvlc version.
- *****************************************************************************
- * This function returns full version string (numeric version and codename).
- *****************************************************************************/
-char const * VLC_Version( void )
-{
-    return VERSION_MESSAGE;
-}
-
-/*****************************************************************************
- * VLC_CompileBy, VLC_CompileHost, VLC_CompileDomain,
- * VLC_Compiler, VLC_Changeset
- *****************************************************************************/
-#define DECLARE_VLC_VERSION( func, var )                                    \
-char const * VLC_##func ( void )                                            \
-{                                                                           \
-    return VLC_##var ;                                                      \
-}
-
-DECLARE_VLC_VERSION( CompileBy, COMPILE_BY );
-DECLARE_VLC_VERSION( CompileHost, COMPILE_HOST );
-DECLARE_VLC_VERSION( CompileDomain, COMPILE_DOMAIN );
-DECLARE_VLC_VERSION( Compiler, COMPILER );
-
-#ifndef HAVE_SHARED_LIBVLC
-extern const char psz_vlc_changeset[];
-char const * VLC_Changeset( void )
-{
-    return psz_vlc_changeset;
-}
-#endif
-
-/*****************************************************************************
- * VLC_Error: strerror() equivalent
- *****************************************************************************
- * This function returns full version string (numeric version and codename).
- *****************************************************************************/
-char const * VLC_Error( int i_err )
-{
-    return vlc_error( i_err );
-}
-
-/*****************************************************************************
- * VLC_Create: allocate a vlc_t structure, and initialize libvlc if needed.
- *****************************************************************************
- * This function allocates a vlc_t structure and returns a negative value
- * in case of failure. Also, the thread system is initialized.
- *****************************************************************************/
-int VLC_Create( void )
-{
-    int i_ret;
-    vlc_t * p_vlc = NULL;
-    vlc_value_t lockval;
-
-    /* &libvlc never changes, so we can safely call this multiple times. */
-    p_libvlc = &libvlc;
-
-    /* vlc_threads_init *must* be the first internal call! No other call is
-     * allowed before the thread system has been initialized. */
-    i_ret = vlc_threads_init( p_libvlc );
-    if( i_ret < 0 )
-    {
-        return i_ret;
-    }
-
-    /* Now that the thread system is initialized, we don't have much, but
-     * at least we have var_Create */
-    var_Create( p_libvlc, "libvlc", VLC_VAR_MUTEX );
-    var_Get( p_libvlc, "libvlc", &lockval );
-    vlc_mutex_lock( lockval.p_address );
-    if( !libvlc.b_ready )
-    {
-        char *psz_env;
-
-        /* Guess what CPU we have */
-        libvlc.i_cpu = CPUCapabilities();
-
-        /* Find verbosity from VLC_VERBOSE environment variable */
-        psz_env = getenv( "VLC_VERBOSE" );
-        libvlc.i_verbose = psz_env ? atoi( psz_env ) : -1;
-
-#if defined( HAVE_ISATTY ) && !defined( WIN32 )
-        libvlc.b_color = isatty( 2 ); /* 2 is for stderr */
-#else
-        libvlc.b_color = VLC_FALSE;
-#endif
-
-        /* Initialize message queue */
-        msg_Create( p_libvlc );
-
-        /* Announce who we are */
-        msg_Dbg( p_libvlc, COPYRIGHT_MESSAGE );
-        msg_Dbg( p_libvlc, "libvlc was configured with %s", CONFIGURE_LINE );
-
-        /* The module bank will be initialized later */
-        libvlc.p_module_bank = NULL;
-
-        libvlc.b_ready = VLC_TRUE;
-    }
-    vlc_mutex_unlock( lockval.p_address );
-    var_Destroy( p_libvlc, "libvlc" );
-
-    /* Allocate a vlc object */
-    p_vlc = vlc_object_create( p_libvlc, VLC_OBJECT_VLC );
-    if( p_vlc == NULL )
-    {
-        return VLC_EGENERIC;
-    }
-    p_vlc->thread_id = 0;
-
-    p_vlc->psz_object_name = "root";
-
-    /* Initialize mutexes */
-    vlc_mutex_init( p_vlc, &p_vlc->config_lock );
-#ifdef __APPLE__
-    vlc_mutex_init( p_vlc, &p_vlc->quicktime_lock );
-    vlc_thread_set_priority( p_vlc, VLC_THREAD_PRIORITY_LOW );
-#endif
-
-    /* Store our newly allocated structure in the global list */
-    vlc_object_attach( p_vlc, p_libvlc );
-
-    /* Store data for the non-reentrant API */
-    p_static_vlc = p_vlc;
-
-    return p_vlc->i_object_id;
-}
-
-/*****************************************************************************
- * VLC_Init: initialize a vlc_t structure.
- *****************************************************************************
- * This function initializes a previously allocated vlc_t structure:
- *  - CPU detection
- *  - gettext initialization
- *  - message queue, module bank and playlist initialization
- *  - configuration and commandline parsing
- *****************************************************************************/
-int VLC_Init( int i_object, int i_argc, char *ppsz_argv[] )
-{
-    char         p_capabilities[200];
-    char *       p_tmp;
-    char *       psz_modules;
-    char *       psz_parser;
-    char *       psz_control;
-    vlc_bool_t   b_exit = VLC_FALSE;
-    int          i_ret = VLC_EEXIT;
-    vlc_t *      p_vlc = vlc_current_object( i_object );
-    module_t    *p_help_module;
-    playlist_t  *p_playlist;
-    vlc_value_t  val;
-#if defined( ENABLE_NLS ) \
-     && ( defined( HAVE_GETTEXT ) || defined( HAVE_INCLUDED_GETTEXT ) )
-# if defined (WIN32) || defined (__APPLE__)
-    char *       psz_language;
-#endif
-#endif
-
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    /*
-     * System specific initialization code
-     */
-    system_Init( p_vlc, &i_argc, ppsz_argv );
-
-    /* Get the executable name (similar to the basename command) */
-    if( i_argc > 0 )
-    {
-        p_vlc->psz_object_name = p_tmp = ppsz_argv[ 0 ];
-        while( *p_tmp )
-        {
-            if( *p_tmp == '/' ) p_vlc->psz_object_name = ++p_tmp;
-            else ++p_tmp;
-        }
-    }
-    else
-    {
-        p_vlc->psz_object_name = "vlc";
-    }
-
-    /*
-     * Support for gettext
-     */
-    SetLanguage( "" );
-
-    /*
-     * Global iconv, must be done after setlocale()
-     * so that vlc_current_charset() works.
-     */
-    LocaleInit( (vlc_object_t *)p_vlc );
-
-    /* Translate "C" to the language code: "fr", "en_GB", "nl", "ru"... */
-    msg_Dbg( p_vlc, "translation test: code is \"%s\"", _("C") );
-
-    /* Initialize the module bank and load the configuration of the
-     * main module. We need to do this at this stage to be able to display
-     * a short help if required by the user. (short help == main module
-     * options) */
-    module_InitBank( p_vlc );
-
-    /* Hack: insert the help module here */
-    p_help_module = vlc_object_create( p_vlc, VLC_OBJECT_MODULE );
-    if( p_help_module == NULL )
-    {
-        module_EndBank( p_vlc );
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_EGENERIC;
-    }
-    p_help_module->psz_object_name = "help";
-    p_help_module->psz_longname = N_("Help options");
-    config_Duplicate( p_help_module, p_help_config );
-    vlc_object_attach( p_help_module, libvlc.p_module_bank );
-    /* End hack */
-
-    if( config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_TRUE ) )
-    {
-        vlc_object_detach( p_help_module );
-        config_Free( p_help_module );
-        vlc_object_destroy( p_help_module );
-        module_EndBank( p_vlc );
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_EGENERIC;
-    }
-
-    /* Check for short help option */
-    if( config_GetInt( p_vlc, "help" ) )
-    {
-        Help( p_vlc, "help" );
-        b_exit = VLC_TRUE;
-        i_ret = VLC_EEXITSUCCESS;
-    }
-    /* Check for version option */
-    else if( config_GetInt( p_vlc, "version" ) )
-    {
-        Version();
-        b_exit = VLC_TRUE;
-        i_ret = VLC_EEXITSUCCESS;
-    }
-
-    /* Set the config file stuff */
-    p_vlc->psz_homedir = config_GetHomeDir();
-    p_vlc->psz_userdir = config_GetUserDir();
-    if( p_vlc->psz_userdir == NULL )
-        p_vlc->psz_userdir = strdup(p_vlc->psz_homedir);
-    p_vlc->psz_configfile = config_GetPsz( p_vlc, "config" );
-    if( p_vlc->psz_configfile != NULL && p_vlc->psz_configfile[0] == '~'
-         && p_vlc->psz_configfile[1] == '/' )
-    {
-        char *psz = malloc( strlen(p_vlc->psz_userdir)
-                             + strlen(p_vlc->psz_configfile) );
-        /* This is incomplete : we should also support the ~cmassiot/ syntax. */
-        sprintf( psz, "%s/%s", p_vlc->psz_userdir,
-                               p_vlc->psz_configfile + 2 );
-        free( p_vlc->psz_configfile );
-        p_vlc->psz_configfile = psz;
-    }
-
-    /* Check for plugins cache options */
-    if( config_GetInt( p_vlc, "reset-plugins-cache" ) )
-    {
-        libvlc.p_module_bank->b_cache_delete = VLC_TRUE;
-    }
-
-    /* Hack: remove the help module here */
-    vlc_object_detach( p_help_module );
-    /* End hack */
-
-    /* Will be re-done properly later on */
-    p_vlc->p_libvlc->i_verbose = config_GetInt( p_vlc, "verbose" );
-
-    /* Check for daemon mode */
-#ifndef WIN32
-    if( config_GetInt( p_vlc, "daemon" ) )
-    {
-#if HAVE_DAEMON
-        if( daemon( 1, 0) != 0 )
-        {
-            msg_Err( p_vlc, "Unable to fork vlc to daemon mode" );
-            b_exit = VLC_TRUE;
-        }
-
-        p_vlc->p_libvlc->b_daemon = VLC_TRUE;
-
-#else
-        pid_t i_pid;
-
-        if( ( i_pid = fork() ) < 0 )
-        {
-            msg_Err( p_vlc, "Unable to fork vlc to daemon mode" );
-            b_exit = VLC_TRUE;
-        }
-        else if( i_pid )
-        {
-            /* This is the parent, exit right now */
-            msg_Dbg( p_vlc, "closing parent process" );
-            b_exit = VLC_TRUE;
-            i_ret = VLC_EEXITSUCCESS;
-        }
-        else
-        {
-            /* We are the child */
-            msg_Dbg( p_vlc, "daemon spawned" );
-            close( STDIN_FILENO );
-            close( STDOUT_FILENO );
-            close( STDERR_FILENO );
-
-            p_vlc->p_libvlc->b_daemon = VLC_TRUE;
-        }
-#endif
-    }
-#endif
-
-    if( b_exit )
-    {
-        config_Free( p_help_module );
-        vlc_object_destroy( p_help_module );
-        module_EndBank( p_vlc );
-        if( i_object ) vlc_object_release( p_vlc );
-        return i_ret;
-    }
-
-    /* Check for translation config option */
-#if defined( ENABLE_NLS ) \
-     && ( defined( HAVE_GETTEXT ) || defined( HAVE_INCLUDED_GETTEXT ) )
-# if defined (WIN32) || defined (__APPLE__)
-    /* This ain't really nice to have to reload the config here but it seems
-     * the only way to do it. */
-    config_LoadConfigFile( p_vlc, "main" );
-    config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_TRUE );
-
-    /* Check if the user specified a custom language */
-    psz_language = config_GetPsz( p_vlc, "language" );
-    if( psz_language && *psz_language && strcmp( psz_language, "auto" ) )
-    {
-        vlc_bool_t b_cache_delete = libvlc.p_module_bank->b_cache_delete;
-
-        /* Reset the default domain */
-        SetLanguage( psz_language );
-
-        /* Translate "C" to the language code: "fr", "en_GB", "nl", "ru"... */
-        msg_Dbg( p_vlc, "translation test: code is \"%s\"", _("C") );
-
-        module_EndBank( p_vlc );
-        module_InitBank( p_vlc );
-        config_LoadConfigFile( p_vlc, "main" );
-        config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_TRUE );
-        libvlc.p_module_bank->b_cache_delete = b_cache_delete;
-    }
-    if( psz_language ) free( psz_language );
-# endif
-#endif
-
-    /*
-     * Load the builtins and plugins into the module_bank.
-     * We have to do it before config_Load*() because this also gets the
-     * list of configuration options exported by each module and loads their
-     * default values.
-     */
-    module_LoadBuiltins( p_vlc );
-    module_LoadPlugins( p_vlc );
-    if( p_vlc->b_die )
-    {
-        b_exit = VLC_TRUE;
-    }
-
-    msg_Dbg( p_vlc, "module bank initialized, found %i modules",
-                    libvlc.p_module_bank->i_children );
-
-    /* Hack: insert the help module here */
-    vlc_object_attach( p_help_module, libvlc.p_module_bank );
-    /* End hack */
-
-    /* Check for help on modules */
-    if( (p_tmp = config_GetPsz( p_vlc, "module" )) )
-    {
-        Help( p_vlc, p_tmp );
-        free( p_tmp );
-        b_exit = VLC_TRUE;
-        i_ret = VLC_EEXITSUCCESS;
-    }
-    /* Check for long help option */
-    else if( config_GetInt( p_vlc, "longhelp" ) )
-    {
-        Help( p_vlc, "longhelp" );
-        b_exit = VLC_TRUE;
-        i_ret = VLC_EEXITSUCCESS;
-    }
-    /* Check for module list option */
-    else if( config_GetInt( p_vlc, "list" ) )
-    {
-        ListModules( p_vlc );
-        b_exit = VLC_TRUE;
-        i_ret = VLC_EEXITSUCCESS;
-    }
-
-    /* Check for config file options */
-    if( config_GetInt( p_vlc, "reset-config" ) )
-    {
-        vlc_object_detach( p_help_module );
-        config_ResetAll( p_vlc );
-        config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_TRUE );
-        config_SaveConfigFile( p_vlc, NULL );
-        vlc_object_attach( p_help_module, libvlc.p_module_bank );
-    }
-    if( config_GetInt( p_vlc, "save-config" ) )
-    {
-        vlc_object_detach( p_help_module );
-        config_LoadConfigFile( p_vlc, NULL );
-        config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_TRUE );
-        config_SaveConfigFile( p_vlc, NULL );
-        vlc_object_attach( p_help_module, libvlc.p_module_bank );
-    }
-
-    /* Hack: remove the help module here */
-    vlc_object_detach( p_help_module );
-    /* End hack */
-
-    if( b_exit )
-    {
-        config_Free( p_help_module );
-        vlc_object_destroy( p_help_module );
-        module_EndBank( p_vlc );
-        if( i_object ) vlc_object_release( p_vlc );
-        return i_ret;
-    }
-
-    /*
-     * Init device values
-     */
-    InitDeviceValues( p_vlc );
-
-    /*
-     * Override default configuration with config file settings
-     */
-    config_LoadConfigFile( p_vlc, NULL );
-
-    /* Hack: insert the help module here */
-    vlc_object_attach( p_help_module, libvlc.p_module_bank );
-    /* End hack */
-
-    /*
-     * Override configuration with command line settings
-     */
-    if( config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_FALSE ) )
-    {
-#ifdef WIN32
-        ShowConsole( VLC_FALSE );
-        /* Pause the console because it's destroyed when we exit */
-        fprintf( stderr, "The command line options couldn't be loaded, check "
-                 "that they are valid.\n" );
-        PauseConsole();
-#endif
-        vlc_object_detach( p_help_module );
-        config_Free( p_help_module );
-        vlc_object_destroy( p_help_module );
-        module_EndBank( p_vlc );
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_EGENERIC;
-    }
-
-    /* Hack: remove the help module here */
-    vlc_object_detach( p_help_module );
-    config_Free( p_help_module );
-    vlc_object_destroy( p_help_module );
-    /* End hack */
-
-    /*
-     * System specific configuration
-     */
-    system_Configure( p_vlc, &i_argc, ppsz_argv );
-
-    /*
-     * Message queue options
-     */
-
-    var_Create( p_vlc, "verbose", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
-    if( config_GetInt( p_vlc, "quiet" ) )
-    {
-        val.i_int = -1;
-        var_Set( p_vlc, "verbose", val );
-    }
-    var_AddCallback( p_vlc, "verbose", VerboseCallback, NULL );
-    var_Change( p_vlc, "verbose", VLC_VAR_TRIGGER_CALLBACKS, NULL, NULL );
-
-    libvlc.b_color = libvlc.b_color && config_GetInt( p_vlc, "color" );
-
-    /*
-     * Output messages that may still be in the queue
-     */
-    msg_Flush( p_vlc );
-
-    /* p_vlc initialization. FIXME ? */
-
-    if( !config_GetInt( p_vlc, "fpu" ) )
-        libvlc.i_cpu &= ~CPU_CAPABILITY_FPU;
-
-#if defined( __i386__ ) || defined( __x86_64__ )
-    if( !config_GetInt( p_vlc, "mmx" ) )
-        libvlc.i_cpu &= ~CPU_CAPABILITY_MMX;
-    if( !config_GetInt( p_vlc, "3dn" ) )
-        libvlc.i_cpu &= ~CPU_CAPABILITY_3DNOW;
-    if( !config_GetInt( p_vlc, "mmxext" ) )
-        libvlc.i_cpu &= ~CPU_CAPABILITY_MMXEXT;
-    if( !config_GetInt( p_vlc, "sse" ) )
-        libvlc.i_cpu &= ~CPU_CAPABILITY_SSE;
-    if( !config_GetInt( p_vlc, "sse2" ) )
-        libvlc.i_cpu &= ~CPU_CAPABILITY_SSE2;
-#endif
-#if defined( __powerpc__ ) || defined( __ppc__ ) || defined( __ppc64__ )
-    if( !config_GetInt( p_vlc, "altivec" ) )
-        libvlc.i_cpu &= ~CPU_CAPABILITY_ALTIVEC;
-#endif
-
-#define PRINT_CAPABILITY( capability, string )                              \
-    if( libvlc.i_cpu & capability )                                         \
-    {                                                                       \
-        strncat( p_capabilities, string " ",                                \
-                 sizeof(p_capabilities) - strlen(p_capabilities) );         \
-        p_capabilities[sizeof(p_capabilities) - 1] = '\0';                  \
-    }
-
-    p_capabilities[0] = '\0';
-    PRINT_CAPABILITY( CPU_CAPABILITY_486, "486" );
-    PRINT_CAPABILITY( CPU_CAPABILITY_586, "586" );
-    PRINT_CAPABILITY( CPU_CAPABILITY_PPRO, "Pentium Pro" );
-    PRINT_CAPABILITY( CPU_CAPABILITY_MMX, "MMX" );
-    PRINT_CAPABILITY( CPU_CAPABILITY_3DNOW, "3DNow!" );
-    PRINT_CAPABILITY( CPU_CAPABILITY_MMXEXT, "MMXEXT" );
-    PRINT_CAPABILITY( CPU_CAPABILITY_SSE, "SSE" );
-    PRINT_CAPABILITY( CPU_CAPABILITY_SSE2, "SSE2" );
-    PRINT_CAPABILITY( CPU_CAPABILITY_ALTIVEC, "AltiVec" );
-    PRINT_CAPABILITY( CPU_CAPABILITY_FPU, "FPU" );
-    msg_Dbg( p_vlc, "CPU has capabilities %s", p_capabilities );
-
-    /*
-     * Choose the best memcpy module
-     */
-    p_vlc->p_memcpy_module = module_Need( p_vlc, "memcpy", "$memcpy", 0 );
-
-    if( p_vlc->pf_memcpy == NULL )
-    {
-        p_vlc->pf_memcpy = memcpy;
-    }
-
-    if( p_vlc->pf_memset == NULL )
-    {
-        p_vlc->pf_memset = memset;
-    }
-
-    libvlc.b_stats = config_GetInt( p_vlc, "stats" );
-    libvlc.p_stats = NULL;
-
-    /*
-     * Initialize hotkey handling
-     */
-    var_Create( p_vlc, "key-pressed", VLC_VAR_INTEGER );
-    p_vlc->p_hotkeys = malloc( sizeof(p_hotkeys) );
-    /* Do a copy (we don't need to modify the strings) */
-    memcpy( p_vlc->p_hotkeys, p_hotkeys, sizeof(p_hotkeys) );
-
-    /*
-     * Initialize playlist and get commandline files
-     */
-    p_playlist = playlist_Create( p_vlc );
-    if( !p_playlist )
-    {
-        msg_Err( p_vlc, "playlist initialization failed" );
-        if( p_vlc->p_memcpy_module != NULL )
-        {
-            module_Unneed( p_vlc, p_vlc->p_memcpy_module );
-        }
-        module_EndBank( p_vlc );
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_EGENERIC;
-    }
-
-    psz_modules = config_GetPsz( p_playlist, "services-discovery" );
-    if( psz_modules && *psz_modules )
-    {
-        /* Add service discovery modules */
-        playlist_AddSDModules( p_playlist, psz_modules );
-    }
-    if( psz_modules ) free( psz_modules );
-
-    /*
-     * Load background interfaces
-     */
-    psz_modules = config_GetPsz( p_vlc, "extraintf" );
-    psz_control = config_GetPsz( p_vlc, "control" );
-
-    if( psz_modules && *psz_modules && psz_control && *psz_control )
-    {
-        psz_modules = (char *)realloc( psz_modules, strlen( psz_modules ) +
-                                                    strlen( psz_control ) + 1 );
-        sprintf( psz_modules, "%s:%s", psz_modules, psz_control );
-    }
-    else if( psz_control && *psz_control )
-    {
-        if( psz_modules ) free( psz_modules );
-        psz_modules = strdup( psz_control );
-    }
-
-    psz_parser = psz_modules;
-    while ( psz_parser && *psz_parser )
-    {
-        char *psz_module, *psz_temp;
-        psz_module = psz_parser;
-        psz_parser = strchr( psz_module, ':' );
-        if ( psz_parser )
-        {
-            *psz_parser = '\0';
-            psz_parser++;
-        }
-        psz_temp = (char *)malloc( strlen(psz_module) + sizeof(",none") );
-        if( psz_temp )
-        {
-            sprintf( psz_temp, "%s,none", psz_module );
-            VLC_AddIntf( 0, psz_temp, VLC_FALSE, VLC_FALSE );
-            free( psz_temp );
-        }
-    }
-    if ( psz_modules )
-    {
-        free( psz_modules );
-    }
-
-    /*
-     * Always load the hotkeys interface if it exists
-     */
-    VLC_AddIntf( 0, "hotkeys,none", VLC_FALSE, VLC_FALSE );
-
-    /*
-     * If needed, load the Xscreensaver interface
-     * Currently, only for X
-     */
-#ifdef HAVE_X11_XLIB_H
-    if( config_GetInt( p_vlc, "disable-screensaver" ) == 1 )
-    {
-        VLC_AddIntf( 0, "screensaver,none", VLC_FALSE, VLC_FALSE );
-    }
-#endif
-
-    if( config_GetInt( p_vlc, "file-logging" ) == 1 )
-    {
-        VLC_AddIntf( 0, "logger,none", VLC_FALSE, VLC_FALSE );
-    }
-#ifdef HAVE_SYSLOG_H
-    if( config_GetInt( p_vlc, "syslog" ) == 1 )
-    {
-        char *psz_logmode = "logmode=syslog";
-        AddIntfInternal( 0, "logger,none", VLC_FALSE, VLC_FALSE, 1, &psz_logmode );
-    }
-#endif
-
-    if( config_GetInt( p_vlc, "show-intf" ) == 1 )
-    {
-        VLC_AddIntf( 0, "showintf,none", VLC_FALSE, VLC_FALSE );
-    }
-
-    if( config_GetInt( p_vlc, "network-synchronisation") == 1 )
-    {
-        VLC_AddIntf( 0, "netsync,none", VLC_FALSE, VLC_FALSE );
-    }
-
-    /*
-     * FIXME: kludge to use a p_vlc-local variable for the Mozilla plugin
-     */
-    var_Create( p_vlc, "drawable", VLC_VAR_INTEGER );
-    var_Create( p_vlc, "drawable-view-top", VLC_VAR_INTEGER );
-    var_Create( p_vlc, "drawable-view-left", VLC_VAR_INTEGER );
-    var_Create( p_vlc, "drawable-view-bottom", VLC_VAR_INTEGER );
-    var_Create( p_vlc, "drawable-view-right", VLC_VAR_INTEGER );
-    var_Create( p_vlc, "drawable-clip-top", VLC_VAR_INTEGER );
-    var_Create( p_vlc, "drawable-clip-left", VLC_VAR_INTEGER );
-    var_Create( p_vlc, "drawable-clip-bottom", VLC_VAR_INTEGER );
-    var_Create( p_vlc, "drawable-clip-right", VLC_VAR_INTEGER );
-
-    /* Create volume callback system. */
-    var_Create( p_vlc, "volume-change", VLC_VAR_BOOL );
-
-    /*
-     * Get input filenames given as commandline arguments
-     */
-    GetFilenames( p_vlc, i_argc, ppsz_argv );
-
-    /*
-     * Get --open argument
-     */
-    var_Create( p_vlc, "open", VLC_VAR_STRING | VLC_VAR_DOINHERIT );
-    var_Get( p_vlc, "open", &val );
-    if ( val.psz_string != NULL && *val.psz_string )
-    {
-        VLC_AddTarget( p_vlc->i_object_id, val.psz_string, NULL, 0,
-                       PLAYLIST_INSERT, 0 );
-    }
-    if ( val.psz_string != NULL ) free( val.psz_string );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-}
-
-/*****************************************************************************
- * VLC_AddIntf: add an interface
- *****************************************************************************
- * This function opens an interface plugin and runs it. If b_block is set
- * to 0, VLC_AddIntf will return immediately and let the interface run in a
- * separate thread. If b_block is set to 1, VLC_AddIntf will continue until
- * user requests to quit. If b_play is set to 1, VLC_AddIntf will start playing
- * the playlist when it is completely initialised.
- *****************************************************************************/
-int VLC_AddIntf( int i_object, char const *psz_module,
-                 vlc_bool_t b_block, vlc_bool_t b_play )
-{
-    return AddIntfInternal( i_object, psz_module, b_block, b_play, 0, NULL );
-}
-
-
-/*****************************************************************************
- * VLC_Die: ask vlc to die.
- *****************************************************************************
- * This function sets p_vlc->b_die to VLC_TRUE, but does not do any other
- * task. It is your duty to call VLC_CleanUp and VLC_Destroy afterwards.
- *****************************************************************************/
-int VLC_Die( int i_object )
-{
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_vlc->b_die = VLC_TRUE;
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-}
-
-/*****************************************************************************
- * VLC_CleanUp: CleanUp all the intf, playlist, vout, aout
- *****************************************************************************/
-int VLC_CleanUp( int i_object )
-{
-    intf_thread_t      * p_intf;
-    playlist_t         * p_playlist;
-    vout_thread_t      * p_vout;
-    aout_instance_t    * p_aout;
-    announce_handler_t * p_announce;
-    stats_handler_t    * p_stats;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    /*
-     * Ask the interfaces to stop and destroy them
-     */
-    msg_Dbg( p_vlc, "removing all interfaces" );
-    while( (p_intf = vlc_object_find( p_vlc, VLC_OBJECT_INTF, FIND_CHILD )) )
-    {
-        intf_StopThread( p_intf );
-        vlc_object_detach( p_intf );
-        vlc_object_release( p_intf );
-        intf_Destroy( p_intf );
-    }
-
-    /*
-     * Free playlist
-     */
-    msg_Dbg( p_vlc, "removing playlist handler" );
-    while( (p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST,
-                                          FIND_CHILD )) )
-    {
-        vlc_object_detach( p_playlist );
-        vlc_object_release( p_playlist );
-        playlist_Destroy( p_playlist );
-    }
-
-    /*
-     * Free video outputs
-     */
-    msg_Dbg( p_vlc, "removing all video outputs" );
-    while( (p_vout = vlc_object_find( p_vlc, VLC_OBJECT_VOUT, FIND_CHILD )) )
-    {
-        vlc_object_detach( p_vout );
-        vlc_object_release( p_vout );
-        vout_Destroy( p_vout );
-    }
-
-    /*
-     * Free audio outputs
-     */
-    msg_Dbg( p_vlc, "removing all audio outputs" );
-    while( (p_aout = vlc_object_find( p_vlc, VLC_OBJECT_AOUT, FIND_CHILD )) )
-    {
-        vlc_object_detach( (vlc_object_t *)p_aout );
-        vlc_object_release( (vlc_object_t *)p_aout );
-        aout_Delete( p_aout );
-    }
-
-    while( ( p_stats = vlc_object_find( p_vlc, VLC_OBJECT_STATS, FIND_CHILD) ))
-    {
-        stats_TimersDumpAll( p_vlc );
-        stats_HandlerDestroy( p_stats );
-        vlc_object_detach( (vlc_object_t*) p_stats );
-        vlc_object_release( (vlc_object_t *)p_stats );
-        // TODO: Delete it
-    }
-
-    /*
-     * Free announce handler(s?)
-     */
-    while( (p_announce = vlc_object_find( p_vlc, VLC_OBJECT_ANNOUNCE,
-                                                 FIND_CHILD ) ) )
-    {
-        msg_Dbg( p_vlc, "removing announce handler" );
-        vlc_object_detach( p_announce );
-        vlc_object_release( p_announce );
-        announce_HandlerDestroy( p_announce );
-    }
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-}
-
-/*****************************************************************************
- * VLC_Destroy: Destroy everything.
- *****************************************************************************
- * This function requests the running threads to finish, waits for their
- * termination, and destroys their structure.
- *****************************************************************************/
-int VLC_Destroy( int i_object )
-{
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    /*
-     * Free allocated memory
-     */
-    if( p_vlc->p_memcpy_module )
-    {
-        module_Unneed( p_vlc, p_vlc->p_memcpy_module );
-        p_vlc->p_memcpy_module = NULL;
-    }
-
-    /*
-     * Free module bank !
-     */
-    module_EndBank( p_vlc );
-
-    if( p_vlc->psz_homedir )
-    {
-        free( p_vlc->psz_homedir );
-        p_vlc->psz_homedir = NULL;
-    }
-
-    if( p_vlc->psz_userdir )
-    {
-        free( p_vlc->psz_userdir );
-        p_vlc->psz_userdir = NULL;
-    }
-
-    if( p_vlc->psz_configfile )
-    {
-        free( p_vlc->psz_configfile );
-        p_vlc->psz_configfile = NULL;
-    }
-
-    if( p_vlc->p_hotkeys )
-    {
-        free( p_vlc->p_hotkeys );
-        p_vlc->p_hotkeys = NULL;
-    }
-
-    /*
-     * System specific cleaning code
-     */
-    system_End( p_vlc );
-
-    /*
-     * Free message queue.
-     * Nobody shall use msg_* afterward.
-     */
-    msg_Flush( p_vlc );
-    msg_Destroy( p_libvlc );
-
-    /* Destroy global iconv */
-    LocaleDeinit();
-
-    /* Destroy mutexes */
-    vlc_mutex_destroy( &p_vlc->config_lock );
-
-    vlc_object_detach( p_vlc );
-
-    /* Release object before destroying it */
-    if( i_object ) vlc_object_release( p_vlc );
-
-    vlc_object_destroy( p_vlc );
-
-    /* Stop thread system: last one out please shut the door! */
-    vlc_threads_end( p_libvlc );
-
-    return VLC_SUCCESS;
-}
-
-/*****************************************************************************
- * VLC_VariableSet: set a vlc variable
- *****************************************************************************/
-int VLC_VariableSet( int i_object, char const *psz_var, vlc_value_t value )
-{
-    vlc_t *p_vlc = vlc_current_object( i_object );
-    int i_ret;
-
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    /* FIXME: Temporary hack for Mozilla, if variable starts with conf:: then
-     * we handle it as a configuration variable. Don't tell Gildas :) -- sam */
-    if( !strncmp( psz_var, "conf::", 6 ) )
-    {
-        module_config_t *p_item;
-        char const *psz_newvar = psz_var + 6;
-
-        p_item = config_FindConfig( VLC_OBJECT(p_vlc), psz_newvar );
-
-        if( p_item )
-        {
-            switch( p_item->i_type )
-            {
-                case CONFIG_ITEM_BOOL:
-                    config_PutInt( p_vlc, psz_newvar, value.b_bool );
-                    break;
-                case CONFIG_ITEM_INTEGER:
-                    config_PutInt( p_vlc, psz_newvar, value.i_int );
-                    break;
-                case CONFIG_ITEM_FLOAT:
-                    config_PutFloat( p_vlc, psz_newvar, value.f_float );
-                    break;
-                default:
-                    config_PutPsz( p_vlc, psz_newvar, value.psz_string );
-                    break;
-            }
-            if( i_object ) vlc_object_release( p_vlc );
-            return VLC_SUCCESS;
-        }
-    }
-
-    i_ret = var_Set( p_vlc, psz_var, value );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return i_ret;
-}
-
-/*****************************************************************************
- * VLC_VariableGet: get a vlc variable
- *****************************************************************************/
-int VLC_VariableGet( int i_object, char const *psz_var, vlc_value_t *p_value )
-{
-    vlc_t *p_vlc = vlc_current_object( i_object );
-    int i_ret;
-
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    i_ret = var_Get( p_vlc , psz_var, p_value );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return i_ret;
-}
-
-/*****************************************************************************
- * VLC_VariableType: get a vlc variable type
- *****************************************************************************/
-int VLC_VariableType( int i_object, char const *psz_var, int *pi_type )
-{
-    int i_type;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    /* FIXME: Temporary hack for Mozilla, if variable starts with conf:: then
-     * we handle it as a configuration variable. Don't tell Gildas :) -- sam */
-    if( !strncmp( psz_var, "conf::", 6 ) )
-    {
-        module_config_t *p_item;
-        char const *psz_newvar = psz_var + 6;
-
-        p_item = config_FindConfig( VLC_OBJECT(p_vlc), psz_newvar );
-
-        if( p_item )
-        {
-            switch( p_item->i_type )
-            {
-                case CONFIG_ITEM_BOOL:
-                    i_type = VLC_VAR_BOOL;
-                    break;
-                case CONFIG_ITEM_INTEGER:
-                    i_type = VLC_VAR_INTEGER;
-                    break;
-                case CONFIG_ITEM_FLOAT:
-                    i_type = VLC_VAR_FLOAT;
-                    break;
-                default:
-                    i_type = VLC_VAR_STRING;
-                    break;
-            }
-        }
-        else
-            i_type = 0;
-    }
-    else
-        i_type = VLC_VAR_TYPE & var_Type( p_vlc , psz_var );
-
-    if( i_object ) vlc_object_release( p_vlc );
-
-    if( i_type > 0 )
-    {
-        *pi_type = i_type;
-        return VLC_SUCCESS;
-    }
-    return VLC_ENOVAR;
-}
-
-/*****************************************************************************
- * VLC_AddTarget: adds a target for playing.
- *****************************************************************************
- * This function adds psz_target to the current playlist. If a playlist does
- * not exist, it will create one.
- *****************************************************************************/
-int VLC_AddTarget( int i_object, char const *psz_target,
-                   char const **ppsz_options, int i_options,
-                   int i_mode, int i_pos )
-{
-    int i_err;
-    playlist_t *p_playlist;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_ANYWHERE );
-
-    if( p_playlist == NULL )
-    {
-        msg_Dbg( p_vlc, "no playlist present, creating one" );
-        p_playlist = playlist_Create( p_vlc );
-
-        if( p_playlist == NULL )
-        {
-            if( i_object ) vlc_object_release( p_vlc );
-            return VLC_EGENERIC;
-        }
-
-        vlc_object_yield( p_playlist );
-    }
-
-    i_err = playlist_AddExt( p_playlist, psz_target, psz_target,
-                             i_mode, i_pos, -1, ppsz_options, i_options);
-
-    vlc_object_release( p_playlist );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return i_err;
-}
-
-/*****************************************************************************
- * VLC_Play: play the playlist
- *****************************************************************************/
-int VLC_Play( int i_object )
-{
-    playlist_t * p_playlist;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
-
-    if( !p_playlist )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    playlist_Play( p_playlist );
-    vlc_object_release( p_playlist );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-}
-
-/*****************************************************************************
- * VLC_Pause: toggle pause
- *****************************************************************************/
-int VLC_Pause( int i_object )
-{
-    playlist_t * p_playlist;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
-
-    if( !p_playlist )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    playlist_Pause( p_playlist );
-    vlc_object_release( p_playlist );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-}
-
-/*****************************************************************************
- * VLC_Stop: stop playback
- *****************************************************************************/
-int VLC_Stop( int i_object )
-{
-    playlist_t * p_playlist;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
-
-    if( !p_playlist )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    playlist_Stop( p_playlist );
-    vlc_object_release( p_playlist );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-}
-
-/*****************************************************************************
- * VLC_IsPlaying: Query for Playlist Status
- *****************************************************************************/
-vlc_bool_t VLC_IsPlaying( int i_object )
-{
-    playlist_t * p_playlist;
-    vlc_bool_t   b_playing;
-
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
-
-    if( !p_playlist )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    if( p_playlist->p_input )
-    {
-        vlc_value_t  val;
-        var_Get( p_playlist->p_input, "state", &val );
-        b_playing = ( val.i_int == PLAYING_S );
-    }
-    else
-    {
-        b_playing = playlist_IsPlaying( p_playlist );
-    }
-    vlc_object_release( p_playlist );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return b_playing;
-}
-
-/**
- * Get the current position in a input
- *
- * Return the current position as a float
- * \note For some inputs, this will be unknown.
- *
- * \param i_object a vlc object id
- * \return a float in the range of 0.0 - 1.0
- */
-float VLC_PositionGet( int i_object )
-{
-    input_thread_t *p_input;
-    vlc_value_t val;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
-
-    if( !p_input )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    var_Get( p_input, "position", &val );
-    vlc_object_release( p_input );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return val.f_float;
-}
-
-/**
- * Set the current position in a input
- *
- * Set the current position in a input and then return
- * the current position as a float.
- * \note For some inputs, this will be unknown.
- *
- * \param i_object a vlc object id
- * \param i_position a float in the range of 0.0 - 1.0
- * \return a float in the range of 0.0 - 1.0
- */
-float VLC_PositionSet( int i_object, float i_position )
-{
-    input_thread_t *p_input;
-    vlc_value_t val;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
-
-    if( !p_input )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    val.f_float = i_position;
-    var_Set( p_input, "position", val );
-    var_Get( p_input, "position", &val );
-    vlc_object_release( p_input );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return val.f_float;
-}
-
-/**
- * Get the current position in a input
- *
- * Return the current position in seconds from the start.
- * \note For some inputs, this will be unknown.
- *
- * \param i_object a vlc object id
- * \return the offset from 0:00 in seconds
- */
-int VLC_TimeGet( int i_object )
-{
-    input_thread_t *p_input;
-    vlc_value_t val;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
-
-    if( !p_input )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    var_Get( p_input, "time", &val );
-    vlc_object_release( p_input );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return val.i_time  / 1000000;
-}
-
-/**
- * Seek to a position in the current input
- *
- * Seek i_seconds in the current input. If b_relative is set,
- * then the seek will be relative to the current position, otherwise
- * it will seek to i_seconds from the beginning of the input.
- * \note For some inputs, this will be unknown.
- *
- * \param i_object a vlc object id
- * \param i_seconds seconds from current position or from beginning of input
- * \param b_relative seek relative from current position
- * \return VLC_SUCCESS on success
- */
-int VLC_TimeSet( int i_object, int i_seconds, vlc_bool_t b_relative )
-{
-    input_thread_t *p_input;
-    vlc_value_t val;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
-
-    if( !p_input )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    if( b_relative )
-    {
-        val.i_time = i_seconds;
-        val.i_time = val.i_time * 1000000L;
-        var_Set( p_input, "time-offset", val );
-    }
-    else
-    {
-        val.i_time = i_seconds;
-        val.i_time = val.i_time * 1000000L;
-        var_Set( p_input, "time", val );
-    }
-    vlc_object_release( p_input );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-}
-
-/**
- * Get the total length of a input
- *
- * Return the total length in seconds from the current input.
- * \note For some inputs, this will be unknown.
- *
- * \param i_object a vlc object id
- * \return the length in seconds
- */
-int VLC_LengthGet( int i_object )
-{
-    input_thread_t *p_input;
-    vlc_value_t val;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
-
-    if( !p_input )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    var_Get( p_input, "length", &val );
-    vlc_object_release( p_input );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return val.i_time  / 1000000L;
-}
-
-/**
- * Play the input faster than realtime
- *
- * 2x, 4x, 8x faster than realtime
- * \note For some inputs, this will be impossible.
- *
- * \param i_object a vlc object id
- * \return the current speedrate
- */
-float VLC_SpeedFaster( int i_object )
-{
-    input_thread_t *p_input;
-    vlc_value_t val;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
-
-    if( !p_input )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    val.b_bool = VLC_TRUE;
-    var_Set( p_input, "rate-faster", val );
-    var_Get( p_input, "rate", &val );
-    vlc_object_release( p_input );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return val.f_float / INPUT_RATE_DEFAULT;
-}
-
-/**
- * Play the input slower than realtime
- *
- * 1/2x, 1/4x, 1/8x slower than realtime
- * \note For some inputs, this will be impossible.
- *
- * \param i_object a vlc object id
- * \return the current speedrate
- */
-float VLC_SpeedSlower( int i_object )
-{
-    input_thread_t *p_input;
-    vlc_value_t val;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
-
-    if( !p_input )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    val.b_bool = VLC_TRUE;
-    var_Set( p_input, "rate-slower", val );
-    var_Get( p_input, "rate", &val );
-    vlc_object_release( p_input );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return val.f_float / INPUT_RATE_DEFAULT;
-}
-
-/**
- * Return the current playlist item
- *
- * Returns the index of the playlistitem that is currently selected for play.
- * This is valid even if nothing is currently playing.
- *
- * \param i_object a vlc object id
- * \return the current index
- */
-int VLC_PlaylistIndex( int i_object )
-{
-    int i_index;
-    playlist_t * p_playlist;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
-
-    if( !p_playlist )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    i_index = p_playlist->i_index;
-    vlc_object_release( p_playlist );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return i_index;
-}
-
-/**
- * Total amount of items in the playlist
- *
- * \param i_object a vlc object id
- * \return amount of playlist items
- */
-int VLC_PlaylistNumberOfItems( int i_object )
-{
-    int i_size;
-    playlist_t * p_playlist;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
-
-    if( !p_playlist )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    i_size = p_playlist->i_size;
-    vlc_object_release( p_playlist );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return i_size;
-}
-
-/**
- * Next playlist item
- *
- * Skip to the next playlistitem and play it.
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int VLC_PlaylistNext( int i_object )
-{
-    playlist_t * p_playlist;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
-
-    if( !p_playlist )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    playlist_Next( p_playlist );
-    vlc_object_release( p_playlist );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-}
-
-/**
- * Previous playlist item
- *
- * Skip to the previous playlistitem and play it.
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int VLC_PlaylistPrev( int i_object )
-{
-    playlist_t * p_playlist;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
-
-    if( !p_playlist )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    playlist_Prev( p_playlist );
-    vlc_object_release( p_playlist );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-}
-
-
-/*****************************************************************************
- * VLC_PlaylistClear: Empty the playlist
- *****************************************************************************/
-int VLC_PlaylistClear( int i_object )
-{
-    int i_err;
-    playlist_t * p_playlist;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
-
-    if( !p_playlist )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    i_err = playlist_Clear( p_playlist );
-
-    vlc_object_release( p_playlist );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return i_err;
-}
-
-/**
- * Change the volume
- *
- * \param i_object a vlc object id
- * \param i_volume something in a range from 0-200
- * \return the new volume (range 0-200 %)
- */
-int VLC_VolumeSet( int i_object, int i_volume )
-{
-    audio_volume_t i_vol = 0;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    if( i_volume >= 0 && i_volume <= 200 )
-    {
-        i_vol = i_volume * AOUT_VOLUME_MAX / 200;
-        aout_VolumeSet( p_vlc, i_vol );
-    }
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return i_vol * 200 / AOUT_VOLUME_MAX;
-}
-
-/**
- * Get the current volume
- *
- * Retrieve the current volume.
- *
- * \param i_object a vlc object id
- * \return the current volume (range 0-200 %)
- */
-int VLC_VolumeGet( int i_object )
-{
-    audio_volume_t i_volume;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    aout_VolumeGet( p_vlc, &i_volume );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return i_volume*200/AOUT_VOLUME_MAX;
-}
-
-/**
- * Mute/Unmute the volume
- *
- * \param i_object a vlc object id
- * \return VLC_SUCCESS on success
- */
-int VLC_VolumeMute( int i_object )
-{
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    /* Check that the handle is valid */
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    aout_VolumeMute( p_vlc, NULL );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-}
-
-/*****************************************************************************
- * VLC_FullScreen: toggle fullscreen mode
- *****************************************************************************/
-int VLC_FullScreen( int i_object )
-{
-    vout_thread_t *p_vout;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-    p_vout = vlc_object_find( p_vlc, VLC_OBJECT_VOUT, FIND_CHILD );
-
-    if( !p_vout )
-    {
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_ENOOBJ;
-    }
-
-    p_vout->i_changes |= VOUT_FULLSCREEN_CHANGE;
-    vlc_object_release( p_vout );
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-}
-
-/* following functions are local */
-
-
-static int  AddIntfInternal( int i_object, char const *psz_module,
-                             vlc_bool_t b_block, vlc_bool_t b_play,
-                             int i_options, char **ppsz_options )
-{
-    int i_err;
-    intf_thread_t *p_intf;
-    vlc_t *p_vlc = vlc_current_object( i_object );
-
-    if( !p_vlc )
-    {
-        return VLC_ENOOBJ;
-    }
-
-#ifndef WIN32
-    if( p_vlc->p_libvlc->b_daemon && b_block && !psz_module )
-    {
-        /* Daemon mode hack.
-         * We prefer the dummy interface if none is specified. */
-        char *psz_interface = config_GetPsz( p_vlc, "intf" );
-        if( !psz_interface || !*psz_interface ) psz_module = "dummy";
-        if( psz_interface ) free( psz_interface );
-    }
-#endif
-
-    /* Try to create the interface */
-    p_intf = intf_Create( p_vlc, psz_module ? psz_module : "$intf",
-                          i_options, ppsz_options );
-
-    if( p_intf == NULL )
-    {
-        msg_Err( p_vlc, "interface \"%s\" initialization failed", psz_module );
-        if( i_object ) vlc_object_release( p_vlc );
-        return VLC_EGENERIC;
-    }
-
-    /* Interface doesn't handle play on start so do it ourselves */
-    if( !p_intf->b_play && b_play ) VLC_Play( i_object );
-
-    /* Try to run the interface */
-    p_intf->b_play = b_play;
-    p_intf->b_block = b_block;
-    i_err = intf_RunThread( p_intf );
-    if( i_err )
-    {
-        vlc_object_detach( p_intf );
-        intf_Destroy( p_intf );
-        if( i_object ) vlc_object_release( p_vlc );
-        return i_err;
-    }
-
-    if( i_object ) vlc_object_release( p_vlc );
-    return VLC_SUCCESS;
-};
-
-
-/*****************************************************************************
- * SetLanguage: set the interface language.
- *****************************************************************************
- * We set the LC_MESSAGES locale category for interface messages and buttons,
- * as well as the LC_CTYPE category for string sorting and possible wide
- * character support.
- *****************************************************************************/
-static void SetLanguage ( char const *psz_lang )
-{
-#if defined( ENABLE_NLS ) \
-     && ( defined( HAVE_GETTEXT ) || defined( HAVE_INCLUDED_GETTEXT ) )
-
-    char *          psz_path;
-#if defined( __APPLE__ ) || defined ( WIN32 ) || defined( SYS_BEOS )
-    char            psz_tmp[1024];
-#endif
-
-    if( psz_lang && !*psz_lang )
-    {
-#   if defined( HAVE_LC_MESSAGES )
-        setlocale( LC_MESSAGES, psz_lang );
-#   endif
-        setlocale( LC_CTYPE, psz_lang );
-    }
-    else if( psz_lang )
-    {
-#ifdef __APPLE__
-        /* I need that under Darwin, please check it doesn't disturb
-         * other platforms. --Meuuh */
-        setenv( "LANG", psz_lang, 1 );
-
-#elif defined( SYS_BEOS ) || defined( WIN32 )
-        /* We set LC_ALL manually because it is the only way to set
-         * the language at runtime under eg. Windows. Beware that this
-         * makes the environment unconsistent when libvlc is unloaded and
-         * should probably be moved to a safer place like vlc.c. */
-        static char psz_lcall[20];
-        snprintf( psz_lcall, 19, "LC_ALL=%s", psz_lang );
-        psz_lcall[19] = '\0';
-        putenv( psz_lcall );
-#endif
-
-        setlocale( LC_ALL, psz_lang );
-        /* many code paths assume that float numbers are formatted according
-         * to the US standard (ie. with dot as decimal point), so we keep
-         * C for LC_NUMERIC. */
-        setlocale( LC_NUMERIC, "C" );
-    }
-
-    /* Specify where to find the locales for current domain */
-#if !defined( __APPLE__ ) && !defined( WIN32 ) && !defined( SYS_BEOS )
-    psz_path = LOCALEDIR;
-#else
-    snprintf( psz_tmp, sizeof(psz_tmp), "%s/%s", libvlc.psz_vlcpath,
-              "locale" );
-    psz_path = psz_tmp;
-#endif
-    if( !bindtextdomain( PACKAGE_NAME, psz_path ) )
-    {
-        fprintf( stderr, "warning: couldn't bind domain %s in directory %s\n",
-                 PACKAGE_NAME, psz_path );
-    }
-
-    /* Set the default domain */
-    bind_textdomain_codeset( PACKAGE_NAME, "UTF-8" );
-#endif
-}
-
-/*****************************************************************************
- * GetFilenames: parse command line options which are not flags
- *****************************************************************************
- * Parse command line for input files as well as their associated options.
- * An option always follows its associated input and begins with a ":".
- *****************************************************************************/
-static int GetFilenames( vlc_t *p_vlc, int i_argc, char *ppsz_argv[] )
-{
-    int i_opt, i_options;
-
-    /* We assume that the remaining parameters are filenames
-     * and their input options */
-    for( i_opt = i_argc - 1; i_opt >= optind; i_opt-- )
-    {
-        const char *psz_target;
-        i_options = 0;
-
-        /* Count the input options */
-        while( *ppsz_argv[ i_opt ] == ':' && i_opt > optind )
-        {
-            i_options++;
-            i_opt--;
-        }
-
-        /* TODO: write an internal function of this one, to avoid
-         *       unnecessary lookups. */
-        /* FIXME: should we convert options to UTF-8 as well ?? */
-
-#ifdef WIN32
-        if( GetVersion() < 0x80000000 )
-        {
-            VLC_AddTarget( p_vlc->i_object_id, ppsz_argv[i_opt],
-                       (char const **)( i_options ? &ppsz_argv[i_opt + 1] :
-                                        NULL ), i_options,
-                       PLAYLIST_INSERT, 0 );
-        }
-        else
-#endif
-        {
-            psz_target = FromLocale( ppsz_argv[ i_opt ] );
-            VLC_AddTarget( p_vlc->i_object_id, psz_target,
-                       (char const **)( i_options ? &ppsz_argv[i_opt + 1] :
-                                        NULL ), i_options,
-                       PLAYLIST_INSERT, 0 );
-            LocaleFree( psz_target );
-        }
-    }
-
-    return VLC_SUCCESS;
-}
-
-/*****************************************************************************
- * Help: print program help
- *****************************************************************************
- * Print a short inline help. Message interface is initialized at this stage.
- *****************************************************************************/
-static void Help( vlc_t *p_this, char const *psz_help_name )
-{
-#ifdef WIN32
-    ShowConsole( VLC_TRUE );
-#endif
-
-    if( psz_help_name && !strcmp( psz_help_name, "help" ) )
-    {
-        utf8_fprintf( stdout, VLC_USAGE, p_this->psz_object_name );
-        Usage( p_this, "help" );
-        Usage( p_this, "main" );
-    }
-    else if( psz_help_name && !strcmp( psz_help_name, "longhelp" ) )
-    {
-        utf8_fprintf( stdout, VLC_USAGE, p_this->psz_object_name );
-        Usage( p_this, NULL );
-    }
-    else if( psz_help_name )
-    {
-        Usage( p_this, psz_help_name );
-    }
-
-#ifdef WIN32        /* Pause the console because it's destroyed when we exit */
-    PauseConsole();
-#endif
-}
-
-/*****************************************************************************
- * Usage: print module usage
- *****************************************************************************
- * Print a short inline help. Message interface is initialized at this stage.
- *****************************************************************************/
-static void Usage( vlc_t *p_this, char const *psz_module_name )
-{
-#define FORMAT_STRING "  %s --%s%s%s%s%s%s%s "
-    /* short option ------'    |     | | | |  | |
-     * option name ------------'     | | | |  | |
-     * <bra -------------------------' | | |  | |
-     * option type or "" --------------' | |  | |
-     * ket> -----------------------------' |  | |
-     * padding spaces ---------------------'  | |
-     * comment -------------------------------' |
-     * comment suffix --------------------------'
-     *
-     * The purpose of having bra and ket is that we might i18n them as well.
-     */
-#define LINE_START 8
-#define PADDING_SPACES 25
-    vlc_list_t *p_list;
-    module_t *p_parser;
-    module_config_t *p_item;
-    char psz_spaces_text[PADDING_SPACES+LINE_START+1];
-    char psz_spaces_longtext[LINE_START+3];
-    char psz_format[sizeof(FORMAT_STRING)];
-    char psz_buffer[10000];
-    char psz_short[4];
-    int i_index;
-    int i_width = ConsoleWidth() - (PADDING_SPACES+LINE_START+1);
-    vlc_bool_t b_advanced = config_GetInt( p_this, "advanced" );
-    vlc_bool_t b_description;
-
-    memset( psz_spaces_text, ' ', PADDING_SPACES+LINE_START );
-    psz_spaces_text[PADDING_SPACES+LINE_START] = '\0';
-    memset( psz_spaces_longtext, ' ', LINE_START+2 );
-    psz_spaces_longtext[LINE_START+2] = '\0';
-
-    strcpy( psz_format, FORMAT_STRING );
-
-    /* List all modules */
-    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
-
-    /* Enumerate the config for each module */
-    for( i_index = 0; i_index < p_list->i_count; i_index++ )
-    {
-        vlc_bool_t b_help_module;
-
-        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
-
-        if( psz_module_name && strcmp( psz_module_name,
-                                       p_parser->psz_object_name ) )
-        {
-            continue;
-        }
-
-        /* Ignore modules without config options */
-        if( !p_parser->i_config_items )
-        {
-            continue;
-        }
-
-        /* Ignore modules with only advanced config options if requested */
-        if( !b_advanced )
-        {
-            for( p_item = p_parser->p_config;
-                 p_item->i_type != CONFIG_HINT_END;
-                 p_item++ )
-            {
-                if( (p_item->i_type & CONFIG_ITEM) &&
-                    !p_item->b_advanced ) break;
-            }
-            if( p_item->i_type == CONFIG_HINT_END ) continue;
-        }
-
-        /* Print name of module */
-        if( strcmp( "main", p_parser->psz_object_name ) )
-        utf8_fprintf( stdout, "\n %s\n", p_parser->psz_longname );
-
-        b_help_module = !strcmp( "help", p_parser->psz_object_name );
-
-        /* Print module options */
-        for( p_item = p_parser->p_config;
-             p_item->i_type != CONFIG_HINT_END;
-             p_item++ )
-        {
-            char *psz_text, *psz_spaces = psz_spaces_text;
-            char *psz_bra = NULL, *psz_type = NULL, *psz_ket = NULL;
-            char *psz_suf = "", *psz_prefix = NULL;
-            signed int i;
-
-            /* Skip deprecated options */
-            if( p_item->psz_current )
-            {
-                continue;
-            }
-            /* Skip advanced options if requested */
-            if( p_item->b_advanced && !b_advanced )
-            {
-                continue;
-            }
-
-            switch( p_item->i_type )
-            {
-            case CONFIG_HINT_CATEGORY:
-            case CONFIG_HINT_USAGE:
-                if( !strcmp( "main", p_parser->psz_object_name ) )
-                utf8_fprintf( stdout, "\n %s\n", p_item->psz_text );
-                break;
-
-            case CONFIG_ITEM_STRING:
-            case CONFIG_ITEM_FILE:
-            case CONFIG_ITEM_DIRECTORY:
-            case CONFIG_ITEM_MODULE: /* We could also have "=<" here */
-            case CONFIG_ITEM_MODULE_CAT:
-            case CONFIG_ITEM_MODULE_LIST:
-            case CONFIG_ITEM_MODULE_LIST_CAT:
-                psz_bra = " <"; psz_type = _("string"); psz_ket = ">";
-
-                if( p_item->ppsz_list )
-                {
-                    psz_bra = " {";
-                    psz_type = psz_buffer;
-                    psz_type[0] = '\0';
-                    for( i = 0; p_item->ppsz_list[i]; i++ )
-                    {
-                        if( i ) strcat( psz_type, "," );
-                        strcat( psz_type, p_item->ppsz_list[i] );
-                    }
-                    psz_ket = "}";
-                }
-                break;
-            case CONFIG_ITEM_INTEGER:
-            case CONFIG_ITEM_KEY: /* FIXME: do something a bit more clever */
-                psz_bra = " <"; psz_type = _("integer"); psz_ket = ">";
-
-                if( p_item->i_list )
-                {
-                    psz_bra = " {";
-                    psz_type = psz_buffer;
-                    psz_type[0] = '\0';
-                    for( i = 0; p_item->ppsz_list_text[i]; i++ )
-                    {
-                        if( i ) strcat( psz_type, ", " );
-                        sprintf( psz_type + strlen(psz_type), "%i (%s)",
-                                 p_item->pi_list[i],
-                                 p_item->ppsz_list_text[i] );
-                    }
-                    psz_ket = "}";
-                }
-                break;
-            case CONFIG_ITEM_FLOAT:
-                psz_bra = " <"; psz_type = _("float"); psz_ket = ">";
-                break;
-            case CONFIG_ITEM_BOOL:
-                psz_bra = ""; psz_type = ""; psz_ket = "";
-                if( !b_help_module )
-                {
-                    psz_suf = p_item->i_value ? _(" (default enabled)") :
-                                                _(" (default disabled)");
-                }
-                break;
-            }
-
-            if( !psz_type )
-            {
-                continue;
-            }
-
-            /* Add short option if any */
-            if( p_item->i_short )
-            {
-                sprintf( psz_short, "-%c,", p_item->i_short );
-            }
-            else
-            {
-                strcpy( psz_short, "   " );
-            }
-
-            i = PADDING_SPACES - strlen( p_item->psz_name )
-                 - strlen( psz_bra ) - strlen( psz_type )
-                 - strlen( psz_ket ) - 1;
-
-            if( p_item->i_type == CONFIG_ITEM_BOOL && !b_help_module )
-            {
-                psz_prefix =  ", --no-";
-                i -= strlen( p_item->psz_name ) + strlen( psz_prefix );
-            }
-
-            if( i < 0 )
-            {
-                psz_spaces[0] = '\n';
-                i = 0;
-            }
-            else
-            {
-                psz_spaces[i] = '\0';
-            }
-
-            if( p_item->i_type == CONFIG_ITEM_BOOL && !b_help_module )
-            {
-                utf8_fprintf( stdout, psz_format, psz_short, p_item->psz_name,
-                         psz_prefix, p_item->psz_name, psz_bra, psz_type,
-                         psz_ket, psz_spaces );
-            }
-            else
-            {
-                utf8_fprintf( stdout, psz_format, psz_short, p_item->psz_name,
-                         "", "", psz_bra, psz_type, psz_ket, psz_spaces );
-            }
-
-            psz_spaces[i] = ' ';
-
-            /* We wrap the rest of the output */
-            sprintf( psz_buffer, "%s%s", p_item->psz_text, psz_suf );
-            b_description = config_GetInt( p_this, "help-verbose" );
-
- description:
-            psz_text = psz_buffer;
-            while( *psz_text )
-            {
-                char *psz_parser, *psz_word;
-                size_t i_end = strlen( psz_text );
-
-                /* If the remaining text fits in a line, print it. */
-                if( i_end <= (size_t)i_width )
-                {
-                    utf8_fprintf( stdout, "%s\n", psz_text );
-                    break;
-                }
-
-                /* Otherwise, eat as many words as possible */
-                psz_parser = psz_text;
-                do
-                {
-                    psz_word = psz_parser;
-                    psz_parser = strchr( psz_word, ' ' );
-                    /* If no space was found, we reached the end of the text
-                     * block; otherwise, we skip the space we just found. */
-                    psz_parser = psz_parser ? psz_parser + 1
-                                            : psz_text + i_end;
-
-                } while( psz_parser - psz_text <= i_width );
-
-                /* We cut a word in one of these cases:
-                 *  - it's the only word in the line and it's too long.
-                 *  - we used less than 80% of the width and the word we are
-                 *    going to wrap is longer than 40% of the width, and even
-                 *    if the word would have fit in the next line. */
-                if( psz_word == psz_text
-                     || ( psz_word - psz_text < 80 * i_width / 100
-                           && psz_parser - psz_word > 40 * i_width / 100 ) )
-                {
-                    char c = psz_text[i_width];
-                    psz_text[i_width] = '\0';
-                    utf8_fprintf( stdout, "%s\n%s", psz_text, psz_spaces );
-                    psz_text += i_width;
-                    psz_text[0] = c;
-                }
-                else
-                {
-                    psz_word[-1] = '\0';
-                    utf8_fprintf( stdout, "%s\n%s", psz_text, psz_spaces );
-                    psz_text = psz_word;
-                }
-            }
-
-            if( b_description && p_item->psz_longtext )
-            {
-                sprintf( psz_buffer, "%s%s", p_item->psz_longtext, psz_suf );
-                b_description = VLC_FALSE;
-                psz_spaces = psz_spaces_longtext;
-                utf8_fprintf( stdout, "%s", psz_spaces );
-                goto description;
-            }
-        }
-    }
-
-    /* Release the module list */
-    vlc_list_release( p_list );
-}
-
-/*****************************************************************************
- * ListModules: list the available modules with their description
- *****************************************************************************
- * Print a list of all available modules (builtins and plugins) and a short
- * description for each one.
- *****************************************************************************/
-static void ListModules( vlc_t *p_this )
-{
-    vlc_list_t *p_list;
-    module_t *p_parser;
-    char psz_spaces[22];
-    int i_index;
-
-    memset( psz_spaces, ' ', 22 );
-
-#ifdef WIN32
-    ShowConsole( VLC_TRUE );
-#endif
-
-    /* List all modules */
-    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
-
-    /* Enumerate each module */
-    for( i_index = 0; i_index < p_list->i_count; i_index++ )
-    {
-        int i;
-
-        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
-
-        /* Nasty hack, but right now I'm too tired to think about a nice
-         * solution */
-        i = 22 - strlen( p_parser->psz_object_name ) - 1;
-        if( i < 0 ) i = 0;
-        psz_spaces[i] = 0;
-
-        utf8_fprintf( stdout, "  %s%s %s\n", p_parser->psz_object_name,
-                         psz_spaces, p_parser->psz_longname );
-
-        psz_spaces[i] = ' ';
-    }
-
-    vlc_list_release( p_list );
-
-#ifdef WIN32        /* Pause the console because it's destroyed when we exit */
-    PauseConsole();
-#endif
-}
-
-/*****************************************************************************
- * Version: print complete program version
- *****************************************************************************
- * Print complete program version and build number.
- *****************************************************************************/
-static void Version( void )
-{
-#ifdef WIN32
-    ShowConsole( VLC_TRUE );
-#endif
-
-    utf8_fprintf( stdout, _("VLC version %s\n"), VLC_Version() );
-    utf8_fprintf( stdout, _("Compiled by %s@%s.%s\n"),
-             VLC_CompileBy(), VLC_CompileHost(), VLC_CompileDomain() );
-    utf8_fprintf( stdout, _("Compiler: %s\n"), VLC_Compiler() );
-#ifndef HAVE_SHARED_LIBVLC
-    if( strcmp( VLC_Changeset(), "exported" ) )
-        utf8_fprintf( stdout, _("Based upon svn changeset [%s]\n"),
-                 VLC_Changeset() );
-#endif
-    utf8_fprintf( stdout, LICENSE_MSG );
-
-#ifdef WIN32        /* Pause the console because it's destroyed when we exit */
-    PauseConsole();
-#endif
-}
-
-/*****************************************************************************
- * ShowConsole: On Win32, create an output console for debug messages
- *****************************************************************************
- * This function is useful only on Win32.
- *****************************************************************************/
-#ifdef WIN32 /*  */
-static void ShowConsole( vlc_bool_t b_dofile )
-{
-#   ifndef UNDER_CE
-    FILE *f_help;
-
-    if( getenv( "PWD" ) && getenv( "PS1" ) ) return; /* cygwin shell */
-
-    AllocConsole();
-
-    freopen( "CONOUT$", "w", stderr );
-    freopen( "CONIN$", "r", stdin );
-
-    if( b_dofile && (f_help = fopen( "vlc-help.txt", "wt" )) )
-    {
-        fclose( f_help );
-        freopen( "vlc-help.txt", "wt", stdout );
-        utf8_fprintf( stderr, _("\nDumped content to vlc-help.txt file.\n") );
-    }
-
-    else freopen( "CONOUT$", "w", stdout );
-
-#   endif
-}
-#endif
-
-/*****************************************************************************
- * PauseConsole: On Win32, wait for a key press before closing the console
- *****************************************************************************
- * This function is useful only on Win32.
- *****************************************************************************/
-#ifdef WIN32 /*  */
-static void PauseConsole( void )
-{
-#   ifndef UNDER_CE
-
-    if( getenv( "PWD" ) && getenv( "PS1" ) ) return; /* cygwin shell */
-
-    utf8_fprintf( stderr, _("\nPress the RETURN key to continue...\n") );
-    getchar();
-    fclose( stdout );
-
-#   endif
-}
-#endif
-
-/*****************************************************************************
- * ConsoleWidth: Return the console width in characters
- *****************************************************************************
- * We use the stty shell command to get the console width; if this fails or
- * if the width is less than 80, we default to 80.
- *****************************************************************************/
-static int ConsoleWidth( void )
-{
-    int i_width = 80;
-
-#ifndef WIN32
-    char buf[20], *psz_parser;
-    FILE *file;
-    int i_ret;
-
-    file = popen( "stty size 2>/dev/null", "r" );
-    if( file )
-    {
-        i_ret = fread( buf, 1, 20, file );
-        if( i_ret > 0 )
-        {
-            buf[19] = '\0';
-            psz_parser = strchr( buf, ' ' );
-            if( psz_parser )
-            {
-                i_ret = atoi( psz_parser + 1 );
-                if( i_ret >= 80 )
-                {
-                    i_width = i_ret;
-                }
-            }
-        }
-
-        pclose( file );
-    }
-#endif
-
-    return i_width;
-}
-
-static int VerboseCallback( vlc_object_t *p_this, const char *psz_variable,
-                     vlc_value_t old_val, vlc_value_t new_val, void *param)
-{
-    vlc_t *p_vlc = (vlc_t *)p_this;
-
-    if( new_val.i_int >= -1 )
-    {
-        p_vlc->p_libvlc->i_verbose = __MIN( new_val.i_int, 2 );
-    }
-    return VLC_SUCCESS;
-}
-
-/*****************************************************************************
- * InitDeviceValues: initialize device values
- *****************************************************************************
- * This function inits the dvd, vcd and cd-audio values
- *****************************************************************************/
-static void InitDeviceValues( vlc_t *p_vlc )
-{
-#ifdef HAVE_HAL
-    LibHalContext * ctx;
-    int i, i_devices;
-    char **devices;
-    char *block_dev;
-    dbus_bool_t b_dvd;
-    DBusConnection *p_connection;
-    DBusError       error;
-
-#ifdef HAVE_HAL_1
-    ctx =  libhal_ctx_new();
-    if( !ctx ) return;
-    dbus_error_init( &error );
-    p_connection = dbus_bus_get ( DBUS_BUS_SYSTEM, &error );
-    if( dbus_error_is_set( &error ) )
-    {
-        dbus_error_free( &error );
-        return;
-    }
-    libhal_ctx_set_dbus_connection( ctx, p_connection );
-    if( libhal_ctx_init( ctx, &error ) )
-#else
-    if( ( ctx = hal_initialize( NULL, FALSE ) ) )
-#endif
-    {
-#ifdef HAVE_HAL_1
-        if( ( devices = libhal_get_all_devices( ctx, &i_devices, NULL ) ) )
-#else
-        if( ( devices = hal_get_all_devices( ctx, &i_devices ) ) )
-#endif
-        {
-            for( i = 0; i < i_devices; i++ )
-            {
-#ifdef HAVE_HAL_1
-                if( !libhal_device_property_exists( ctx, devices[i],
-                                                "storage.cdrom.dvd", NULL ) )
-#else
-                if( !hal_device_property_exists( ctx, devices[ i ],
-                                                "storage.cdrom.dvd" ) )
-#endif
-                {
-                    continue;
-                }
-#ifdef HAVE_HAL_1
-                b_dvd = libhal_device_get_property_bool( ctx, devices[ i ],
-                                                 "storage.cdrom.dvd", NULL  );
-                block_dev = libhal_device_get_property_string( ctx,
-                                devices[ i ], "block.device" , NULL );
-#else
-                b_dvd = hal_device_get_property_bool( ctx, devices[ i ],
-                                                      "storage.cdrom.dvd" );
-                block_dev = hal_device_get_property_string( ctx, devices[ i ],
-                                                            "block.device" );
-#endif
-                if( b_dvd )
-                {
-                    config_PutPsz( p_vlc, "dvd", block_dev );
-                }
-
-                config_PutPsz( p_vlc, "vcd", block_dev );
-                config_PutPsz( p_vlc, "cd-audio", block_dev );
-#ifdef HAVE_HAL_1
-                libhal_free_string( block_dev );
-#else
-                hal_free_string( block_dev );
-#endif
-            }
-#ifdef HAVE_HAL_1
-            libhal_free_string_array( devices );
-#else
-            hal_free_string_array( devices );
-#endif
-        }
-
-#ifdef HAVE_HAL_1
-        libhal_ctx_shutdown( ctx, NULL );
-#else
-        hal_shutdown( ctx );
-#endif
-    }
-    else
-    {
-        msg_Warn( p_vlc, "Unable to get HAL device properties" );
-    }
-#endif
-}
+/*****************************************************************************
+ * libvlc.c: main libvlc source
+ *****************************************************************************
+ * Copyright (C) 1998-2006 the VideoLAN team
+ * $Id: libvlc.c 17755 2006-11-14 07:17:34Z md $
+ *
+ * Authors: Vincent Seguin <seguin@via.ecp.fr>
+ *          Samuel Hocevar <sam@zoy.org>
+ *          Gildas Bazin <gbazin@videolan.org>
+ *          Derk-Jan Hartman <hartman at videolan dot org>
+ *          Rémi Denis-Courmont <rem # videolan : org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Pretend we are a builtin module
+ *****************************************************************************/
+#define MODULE_NAME main
+#define MODULE_PATH main
+#define __BUILTIN__
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+#include <vlc/vlc.h>
+#include <vlc/input.h>
+
+#include <errno.h>                                                 /* ENOMEM */
+#include <stdio.h>                                              /* sprintf() */
+#include <string.h>                                            /* strerror() */
+#include <stdlib.h>                                                /* free() */
+
+#ifndef WIN32
+#   include <netinet/in.h>                            /* BSD: struct in_addr */
+#endif
+
+#ifdef HAVE_UNISTD_H
+#   include <unistd.h>
+#elif defined( WIN32 ) && !defined( UNDER_CE )
+#   include <io.h>
+#endif
+
+#ifdef WIN32                       /* optind, getopt(), included in unistd.h */
+#   include "extras/getopt.h"
+#endif
+
+#ifdef HAVE_LOCALE_H
+#   include <locale.h>
+#endif
+
+#ifdef HAVE_HAL
+#   include <hal/libhal.h>
+#endif
+
+#include "vlc_cpu.h"                                        /* CPU detection */
+#include "os_specific.h"
+
+#include "vlc_error.h"
+
+#include "vlc_playlist.h"
+#include "vlc_interface.h"
+
+#include "audio_output.h"
+
+#include "vlc_video.h"
+#include "video_output.h"
+
+#include "stream_output.h"
+#include "charset.h"
+
+#include "libvlc.h"
+
+/*****************************************************************************
+ * The evil global variable. We handle it with care, don't worry.
+ *****************************************************************************/
+static libvlc_t   libvlc;
+static libvlc_t * p_libvlc;
+static vlc_t *    p_static_vlc;
+
+/*****************************************************************************
+ * Local prototypes
+ *****************************************************************************/
+static int AddIntfInternal( int i_object, char const *psz_module,
+                             vlc_bool_t b_block, vlc_bool_t b_play,
+                             int i_options, char **ppsz_options );
+
+void LocaleInit( vlc_object_t * );
+void LocaleDeinit( void );
+static void SetLanguage   ( char const * );
+static int  GetFilenames  ( vlc_t *, int, char *[] );
+static void Help          ( vlc_t *, char const *psz_help_name );
+static void Usage         ( vlc_t *, char const *psz_module_name );
+static void ListModules   ( vlc_t * );
+static void Version       ( void );
+
+#ifdef WIN32
+static void ShowConsole   ( vlc_bool_t );
+static void PauseConsole  ( void );
+#endif
+static int  ConsoleWidth  ( void );
+
+static int  VerboseCallback( vlc_object_t *, char const *,
+                             vlc_value_t, vlc_value_t, void * );
+
+static void InitDeviceValues( vlc_t * );
+
+/*****************************************************************************
+ * vlc_current_object: return the current object.
+ *****************************************************************************
+ * If i_object is non-zero, return the corresponding object. Otherwise,
+ * return the statically allocated p_vlc object.
+ *****************************************************************************/
+vlc_t * vlc_current_object( int i_object )
+{
+    if( i_object )
+    {
+         return vlc_object_get( p_libvlc, i_object );
+    }
+
+    return p_static_vlc;
+}
+
+/*****************************************************************************
+ * VLC_Version: return the libvlc version.
+ *****************************************************************************
+ * This function returns full version string (numeric version and codename).
+ *****************************************************************************/
+char const * VLC_Version( void )
+{
+    return VERSION_MESSAGE;
+}
+
+/*****************************************************************************
+ * VLC_CompileBy, VLC_CompileHost, VLC_CompileDomain,
+ * VLC_Compiler, VLC_Changeset
+ *****************************************************************************/
+#define DECLARE_VLC_VERSION( func, var )                                    \
+char const * VLC_##func ( void )                                            \
+{                                                                           \
+    return VLC_##var ;                                                      \
+}
+
+DECLARE_VLC_VERSION( CompileBy, COMPILE_BY );
+DECLARE_VLC_VERSION( CompileHost, COMPILE_HOST );
+DECLARE_VLC_VERSION( CompileDomain, COMPILE_DOMAIN );
+DECLARE_VLC_VERSION( Compiler, COMPILER );
+
+#ifndef HAVE_SHARED_LIBVLC
+extern const char psz_vlc_changeset[];
+char const * VLC_Changeset( void )
+{
+    return psz_vlc_changeset;
+}
+#endif
+
+/*****************************************************************************
+ * VLC_Error: strerror() equivalent
+ *****************************************************************************
+ * This function returns full version string (numeric version and codename).
+ *****************************************************************************/
+char const * VLC_Error( int i_err )
+{
+    return vlc_error( i_err );
+}
+
+/*****************************************************************************
+ * VLC_Create: allocate a vlc_t structure, and initialize libvlc if needed.
+ *****************************************************************************
+ * This function allocates a vlc_t structure and returns a negative value
+ * in case of failure. Also, the thread system is initialized.
+ *****************************************************************************/
+int VLC_Create( void )
+{
+    int i_ret;
+    vlc_t * p_vlc = NULL;
+    vlc_value_t lockval;
+
+    /* &libvlc never changes, so we can safely call this multiple times. */
+    p_libvlc = &libvlc;
+
+    /* vlc_threads_init *must* be the first internal call! No other call is
+     * allowed before the thread system has been initialized. */
+    i_ret = vlc_threads_init( p_libvlc );
+    if( i_ret < 0 )
+    {
+        return i_ret;
+    }
+
+    /* Now that the thread system is initialized, we don't have much, but
+     * at least we have var_Create */
+    var_Create( p_libvlc, "libvlc", VLC_VAR_MUTEX );
+    var_Get( p_libvlc, "libvlc", &lockval );
+    vlc_mutex_lock( lockval.p_address );
+    if( !libvlc.b_ready )
+    {
+        char *psz_env;
+
+        /* Guess what CPU we have */
+        libvlc.i_cpu = CPUCapabilities();
+
+        /* Find verbosity from VLC_VERBOSE environment variable */
+        psz_env = getenv( "VLC_VERBOSE" );
+        libvlc.i_verbose = psz_env ? atoi( psz_env ) : -1;
+
+#if defined( HAVE_ISATTY ) && !defined( WIN32 )
+        libvlc.b_color = isatty( 2 ); /* 2 is for stderr */
+#else
+        libvlc.b_color = VLC_FALSE;
+#endif
+
+        /* Initialize message queue */
+        msg_Create( p_libvlc );
+
+        /* Announce who we are */
+        msg_Dbg( p_libvlc, COPYRIGHT_MESSAGE );
+        msg_Dbg( p_libvlc, "libvlc was configured with %s", CONFIGURE_LINE );
+
+        /* The module bank will be initialized later */
+        libvlc.p_module_bank = NULL;
+
+        libvlc.b_ready = VLC_TRUE;
+    }
+    vlc_mutex_unlock( lockval.p_address );
+    var_Destroy( p_libvlc, "libvlc" );
+
+    /* Allocate a vlc object */
+    p_vlc = vlc_object_create( p_libvlc, VLC_OBJECT_VLC );
+    if( p_vlc == NULL )
+    {
+        return VLC_EGENERIC;
+    }
+    p_vlc->thread_id = 0;
+
+    p_vlc->psz_object_name = "root";
+
+    /* Initialize mutexes */
+    vlc_mutex_init( p_vlc, &p_vlc->config_lock );
+#ifdef __APPLE__
+    vlc_mutex_init( p_vlc, &p_vlc->quicktime_lock );
+    vlc_thread_set_priority( p_vlc, VLC_THREAD_PRIORITY_LOW );
+#endif
+
+    /* Store our newly allocated structure in the global list */
+    vlc_object_attach( p_vlc, p_libvlc );
+
+    /* Store data for the non-reentrant API */
+    p_static_vlc = p_vlc;
+
+    return p_vlc->i_object_id;
+}
+
+/*****************************************************************************
+ * VLC_Init: initialize a vlc_t structure.
+ *****************************************************************************
+ * This function initializes a previously allocated vlc_t structure:
+ *  - CPU detection
+ *  - gettext initialization
+ *  - message queue, module bank and playlist initialization
+ *  - configuration and commandline parsing
+ *****************************************************************************/
+int VLC_Init( int i_object, int i_argc, char *ppsz_argv[] )
+{
+    char         p_capabilities[200];
+    char *       p_tmp;
+    char *       psz_modules;
+    char *       psz_parser;
+    char *       psz_control;
+    vlc_bool_t   b_exit = VLC_FALSE;
+    int          i_ret = VLC_EEXIT;
+    vlc_t *      p_vlc = vlc_current_object( i_object );
+    module_t    *p_help_module;
+    playlist_t  *p_playlist;
+    vlc_value_t  val;
+#if defined( ENABLE_NLS ) \
+     && ( defined( HAVE_GETTEXT ) || defined( HAVE_INCLUDED_GETTEXT ) )
+# if defined (WIN32) || defined (__APPLE__)
+    char *       psz_language;
+#endif
+#endif
+
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    /*
+     * System specific initialization code
+     */
+    system_Init( p_vlc, &i_argc, ppsz_argv );
+
+    /* Get the executable name (similar to the basename command) */
+    if( i_argc > 0 )
+    {
+        p_vlc->psz_object_name = p_tmp = ppsz_argv[ 0 ];
+        while( *p_tmp )
+        {
+            if( *p_tmp == '/' ) p_vlc->psz_object_name = ++p_tmp;
+            else ++p_tmp;
+        }
+    }
+    else
+    {
+        p_vlc->psz_object_name = "vlc";
+    }
+
+    /*
+     * Support for gettext
+     */
+    SetLanguage( "" );
+
+    /*
+     * Global iconv, must be done after setlocale()
+     * so that vlc_current_charset() works.
+     */
+    LocaleInit( (vlc_object_t *)p_vlc );
+
+    /* Translate "C" to the language code: "fr", "en_GB", "nl", "ru"... */
+    msg_Dbg( p_vlc, "translation test: code is \"%s\"", _("C") );
+
+    /* Initialize the module bank and load the configuration of the
+     * main module. We need to do this at this stage to be able to display
+     * a short help if required by the user. (short help == main module
+     * options) */
+    module_InitBank( p_vlc );
+
+    /* Hack: insert the help module here */
+    p_help_module = vlc_object_create( p_vlc, VLC_OBJECT_MODULE );
+    if( p_help_module == NULL )
+    {
+        module_EndBank( p_vlc );
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_EGENERIC;
+    }
+    p_help_module->psz_object_name = "help";
+    p_help_module->psz_longname = N_("Help options");
+    config_Duplicate( p_help_module, p_help_config );
+    vlc_object_attach( p_help_module, libvlc.p_module_bank );
+    /* End hack */
+
+    if( config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_TRUE ) )
+    {
+        vlc_object_detach( p_help_module );
+        config_Free( p_help_module );
+        vlc_object_destroy( p_help_module );
+        module_EndBank( p_vlc );
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_EGENERIC;
+    }
+
+    /* Check for short help option */
+    if( config_GetInt( p_vlc, "help" ) )
+    {
+        Help( p_vlc, "help" );
+        b_exit = VLC_TRUE;
+        i_ret = VLC_EEXITSUCCESS;
+    }
+    /* Check for version option */
+    else if( config_GetInt( p_vlc, "version" ) )
+    {
+        Version();
+        b_exit = VLC_TRUE;
+        i_ret = VLC_EEXITSUCCESS;
+    }
+
+    /* Set the config file stuff */
+    p_vlc->psz_homedir = config_GetHomeDir();
+    p_vlc->psz_userdir = config_GetUserDir();
+    if( p_vlc->psz_userdir == NULL )
+        p_vlc->psz_userdir = strdup(p_vlc->psz_homedir);
+    p_vlc->psz_configfile = config_GetPsz( p_vlc, "config" );
+    if( p_vlc->psz_configfile != NULL && p_vlc->psz_configfile[0] == '~'
+         && p_vlc->psz_configfile[1] == '/' )
+    {
+        char *psz = malloc( strlen(p_vlc->psz_userdir)
+                             + strlen(p_vlc->psz_configfile) );
+        /* This is incomplete : we should also support the ~cmassiot/ syntax. */
+        sprintf( psz, "%s/%s", p_vlc->psz_userdir,
+                               p_vlc->psz_configfile + 2 );
+        free( p_vlc->psz_configfile );
+        p_vlc->psz_configfile = psz;
+    }
+
+    /* Check for plugins cache options */
+    if( config_GetInt( p_vlc, "reset-plugins-cache" ) )
+    {
+        libvlc.p_module_bank->b_cache_delete = VLC_TRUE;
+    }
+
+    /* Hack: remove the help module here */
+    vlc_object_detach( p_help_module );
+    /* End hack */
+
+    /* Will be re-done properly later on */
+    p_vlc->p_libvlc->i_verbose = config_GetInt( p_vlc, "verbose" );
+
+    /* Check for daemon mode */
+#ifndef WIN32
+    if( config_GetInt( p_vlc, "daemon" ) )
+    {
+#if HAVE_DAEMON
+        if( daemon( 1, 0) != 0 )
+        {
+            msg_Err( p_vlc, "Unable to fork vlc to daemon mode" );
+            b_exit = VLC_TRUE;
+        }
+
+        p_vlc->p_libvlc->b_daemon = VLC_TRUE;
+
+#else
+        pid_t i_pid;
+
+        if( ( i_pid = fork() ) < 0 )
+        {
+            msg_Err( p_vlc, "Unable to fork vlc to daemon mode" );
+            b_exit = VLC_TRUE;
+        }
+        else if( i_pid )
+        {
+            /* This is the parent, exit right now */
+            msg_Dbg( p_vlc, "closing parent process" );
+            b_exit = VLC_TRUE;
+            i_ret = VLC_EEXITSUCCESS;
+        }
+        else
+        {
+            /* We are the child */
+            msg_Dbg( p_vlc, "daemon spawned" );
+            close( STDIN_FILENO );
+            close( STDOUT_FILENO );
+            close( STDERR_FILENO );
+
+            p_vlc->p_libvlc->b_daemon = VLC_TRUE;
+        }
+#endif
+    }
+#endif
+
+    if( b_exit )
+    {
+        config_Free( p_help_module );
+        vlc_object_destroy( p_help_module );
+        module_EndBank( p_vlc );
+        if( i_object ) vlc_object_release( p_vlc );
+        return i_ret;
+    }
+
+    /* Check for translation config option */
+#if defined( ENABLE_NLS ) \
+     && ( defined( HAVE_GETTEXT ) || defined( HAVE_INCLUDED_GETTEXT ) )
+# if defined (WIN32) || defined (__APPLE__)
+    /* This ain't really nice to have to reload the config here but it seems
+     * the only way to do it. */
+    config_LoadConfigFile( p_vlc, "main" );
+    config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_TRUE );
+
+    /* Check if the user specified a custom language */
+    psz_language = config_GetPsz( p_vlc, "language" );
+    if( psz_language && *psz_language && strcmp( psz_language, "auto" ) )
+    {
+        vlc_bool_t b_cache_delete = libvlc.p_module_bank->b_cache_delete;
+
+        /* Reset the default domain */
+        SetLanguage( psz_language );
+
+        /* Translate "C" to the language code: "fr", "en_GB", "nl", "ru"... */
+        msg_Dbg( p_vlc, "translation test: code is \"%s\"", _("C") );
+
+        module_EndBank( p_vlc );
+        module_InitBank( p_vlc );
+        config_LoadConfigFile( p_vlc, "main" );
+        config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_TRUE );
+        libvlc.p_module_bank->b_cache_delete = b_cache_delete;
+    }
+    if( psz_language ) free( psz_language );
+# endif
+#endif
+
+    /*
+     * Load the builtins and plugins into the module_bank.
+     * We have to do it before config_Load*() because this also gets the
+     * list of configuration options exported by each module and loads their
+     * default values.
+     */
+    module_LoadBuiltins( p_vlc );
+    module_LoadPlugins( p_vlc );
+    if( p_vlc->b_die )
+    {
+        b_exit = VLC_TRUE;
+    }
+
+    msg_Dbg( p_vlc, "module bank initialized, found %i modules",
+                    libvlc.p_module_bank->i_children );
+
+    /* Hack: insert the help module here */
+    vlc_object_attach( p_help_module, libvlc.p_module_bank );
+    /* End hack */
+
+    /* Check for help on modules */
+    if( (p_tmp = config_GetPsz( p_vlc, "module" )) )
+    {
+        Help( p_vlc, p_tmp );
+        free( p_tmp );
+        b_exit = VLC_TRUE;
+        i_ret = VLC_EEXITSUCCESS;
+    }
+    /* Check for long help option */
+    else if( config_GetInt( p_vlc, "longhelp" ) )
+    {
+        Help( p_vlc, "longhelp" );
+        b_exit = VLC_TRUE;
+        i_ret = VLC_EEXITSUCCESS;
+    }
+    /* Check for module list option */
+    else if( config_GetInt( p_vlc, "list" ) )
+    {
+        ListModules( p_vlc );
+        b_exit = VLC_TRUE;
+        i_ret = VLC_EEXITSUCCESS;
+    }
+
+    /* Check for config file options */
+    if( config_GetInt( p_vlc, "reset-config" ) )
+    {
+        vlc_object_detach( p_help_module );
+        config_ResetAll( p_vlc );
+        config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_TRUE );
+        config_SaveConfigFile( p_vlc, NULL );
+        vlc_object_attach( p_help_module, libvlc.p_module_bank );
+    }
+    if( config_GetInt( p_vlc, "save-config" ) )
+    {
+        vlc_object_detach( p_help_module );
+        config_LoadConfigFile( p_vlc, NULL );
+        config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_TRUE );
+        config_SaveConfigFile( p_vlc, NULL );
+        vlc_object_attach( p_help_module, libvlc.p_module_bank );
+    }
+
+    /* Hack: remove the help module here */
+    vlc_object_detach( p_help_module );
+    /* End hack */
+
+    if( b_exit )
+    {
+        config_Free( p_help_module );
+        vlc_object_destroy( p_help_module );
+        module_EndBank( p_vlc );
+        if( i_object ) vlc_object_release( p_vlc );
+        return i_ret;
+    }
+
+    /*
+     * Init device values
+     */
+    InitDeviceValues( p_vlc );
+
+    /*
+     * Override default configuration with config file settings
+     */
+    config_LoadConfigFile( p_vlc, NULL );
+
+    /* Hack: insert the help module here */
+    vlc_object_attach( p_help_module, libvlc.p_module_bank );
+    /* End hack */
+
+    /*
+     * Override configuration with command line settings
+     */
+    if( config_LoadCmdLine( p_vlc, &i_argc, ppsz_argv, VLC_FALSE ) )
+    {
+#ifdef WIN32
+        ShowConsole( VLC_FALSE );
+        /* Pause the console because it's destroyed when we exit */
+        fprintf( stderr, "The command line options couldn't be loaded, check "
+                 "that they are valid.\n" );
+        PauseConsole();
+#endif
+        vlc_object_detach( p_help_module );
+        config_Free( p_help_module );
+        vlc_object_destroy( p_help_module );
+        module_EndBank( p_vlc );
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_EGENERIC;
+    }
+
+    /* Hack: remove the help module here */
+    vlc_object_detach( p_help_module );
+    config_Free( p_help_module );
+    vlc_object_destroy( p_help_module );
+    /* End hack */
+
+    /*
+     * System specific configuration
+     */
+    system_Configure( p_vlc, &i_argc, ppsz_argv );
+
+    /*
+     * Message queue options
+     */
+
+    var_Create( p_vlc, "verbose", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
+    if( config_GetInt( p_vlc, "quiet" ) )
+    {
+        val.i_int = -1;
+        var_Set( p_vlc, "verbose", val );
+    }
+    var_AddCallback( p_vlc, "verbose", VerboseCallback, NULL );
+    var_Change( p_vlc, "verbose", VLC_VAR_TRIGGER_CALLBACKS, NULL, NULL );
+
+    libvlc.b_color = libvlc.b_color && config_GetInt( p_vlc, "color" );
+
+    /*
+     * Output messages that may still be in the queue
+     */
+    msg_Flush( p_vlc );
+
+    /* p_vlc initialization. FIXME ? */
+
+    if( !config_GetInt( p_vlc, "fpu" ) )
+        libvlc.i_cpu &= ~CPU_CAPABILITY_FPU;
+
+#if defined( __i386__ ) || defined( __x86_64__ )
+    if( !config_GetInt( p_vlc, "mmx" ) )
+        libvlc.i_cpu &= ~CPU_CAPABILITY_MMX;
+    if( !config_GetInt( p_vlc, "3dn" ) )
+        libvlc.i_cpu &= ~CPU_CAPABILITY_3DNOW;
+    if( !config_GetInt( p_vlc, "mmxext" ) )
+        libvlc.i_cpu &= ~CPU_CAPABILITY_MMXEXT;
+    if( !config_GetInt( p_vlc, "sse" ) )
+        libvlc.i_cpu &= ~CPU_CAPABILITY_SSE;
+    if( !config_GetInt( p_vlc, "sse2" ) )
+        libvlc.i_cpu &= ~CPU_CAPABILITY_SSE2;
+#endif
+#if defined( __powerpc__ ) || defined( __ppc__ ) || defined( __ppc64__ )
+    if( !config_GetInt( p_vlc, "altivec" ) )
+        libvlc.i_cpu &= ~CPU_CAPABILITY_ALTIVEC;
+#endif
+
+#define PRINT_CAPABILITY( capability, string )                              \
+    if( libvlc.i_cpu & capability )                                         \
+    {                                                                       \
+        strncat( p_capabilities, string " ",                                \
+                 sizeof(p_capabilities) - strlen(p_capabilities) );         \
+        p_capabilities[sizeof(p_capabilities) - 1] = '\0';                  \
+    }
+
+    p_capabilities[0] = '\0';
+    PRINT_CAPABILITY( CPU_CAPABILITY_486, "486" );
+    PRINT_CAPABILITY( CPU_CAPABILITY_586, "586" );
+    PRINT_CAPABILITY( CPU_CAPABILITY_PPRO, "Pentium Pro" );
+    PRINT_CAPABILITY( CPU_CAPABILITY_MMX, "MMX" );
+    PRINT_CAPABILITY( CPU_CAPABILITY_3DNOW, "3DNow!" );
+    PRINT_CAPABILITY( CPU_CAPABILITY_MMXEXT, "MMXEXT" );
+    PRINT_CAPABILITY( CPU_CAPABILITY_SSE, "SSE" );
+    PRINT_CAPABILITY( CPU_CAPABILITY_SSE2, "SSE2" );
+    PRINT_CAPABILITY( CPU_CAPABILITY_ALTIVEC, "AltiVec" );
+    PRINT_CAPABILITY( CPU_CAPABILITY_FPU, "FPU" );
+    msg_Dbg( p_vlc, "CPU has capabilities %s", p_capabilities );
+
+    /*
+     * Choose the best memcpy module
+     */
+    p_vlc->p_memcpy_module = module_Need( p_vlc, "memcpy", "$memcpy", 0 );
+
+    if( p_vlc->pf_memcpy == NULL )
+    {
+        p_vlc->pf_memcpy = memcpy;
+    }
+
+    if( p_vlc->pf_memset == NULL )
+    {
+        p_vlc->pf_memset = memset;
+    }
+
+    libvlc.b_stats = config_GetInt( p_vlc, "stats" );
+    libvlc.p_stats = NULL;
+
+    /*
+     * Initialize hotkey handling
+     */
+    var_Create( p_vlc, "key-pressed", VLC_VAR_INTEGER );
+    p_vlc->p_hotkeys = malloc( sizeof(p_hotkeys) );
+    /* Do a copy (we don't need to modify the strings) */
+    memcpy( p_vlc->p_hotkeys, p_hotkeys, sizeof(p_hotkeys) );
+
+    /*
+     * Initialize playlist and get commandline files
+     */
+    p_playlist = playlist_Create( p_vlc );
+    if( !p_playlist )
+    {
+        msg_Err( p_vlc, "playlist initialization failed" );
+        if( p_vlc->p_memcpy_module != NULL )
+        {
+            module_Unneed( p_vlc, p_vlc->p_memcpy_module );
+        }
+        module_EndBank( p_vlc );
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_EGENERIC;
+    }
+
+    psz_modules = config_GetPsz( p_playlist, "services-discovery" );
+    if( psz_modules && *psz_modules )
+    {
+        /* Add service discovery modules */
+        playlist_AddSDModules( p_playlist, psz_modules );
+    }
+    if( psz_modules ) free( psz_modules );
+
+    /*
+     * Load background interfaces
+     */
+    psz_modules = config_GetPsz( p_vlc, "extraintf" );
+    psz_control = config_GetPsz( p_vlc, "control" );
+
+    if( psz_modules && *psz_modules && psz_control && *psz_control )
+    {
+        psz_modules = (char *)realloc( psz_modules, strlen( psz_modules ) +
+                                                    strlen( psz_control ) + 1 );
+        sprintf( psz_modules, "%s:%s", psz_modules, psz_control );
+    }
+    else if( psz_control && *psz_control )
+    {
+        if( psz_modules ) free( psz_modules );
+        psz_modules = strdup( psz_control );
+    }
+
+    psz_parser = psz_modules;
+    while ( psz_parser && *psz_parser )
+    {
+        char *psz_module, *psz_temp;
+        psz_module = psz_parser;
+        psz_parser = strchr( psz_module, ':' );
+        if ( psz_parser )
+        {
+            *psz_parser = '\0';
+            psz_parser++;
+        }
+        psz_temp = (char *)malloc( strlen(psz_module) + sizeof(",none") );
+        if( psz_temp )
+        {
+            sprintf( psz_temp, "%s,none", psz_module );
+            VLC_AddIntf( 0, psz_temp, VLC_FALSE, VLC_FALSE );
+            free( psz_temp );
+        }
+    }
+    if ( psz_modules )
+    {
+        free( psz_modules );
+    }
+
+    /*
+     * Always load the hotkeys interface if it exists
+     */
+    VLC_AddIntf( 0, "hotkeys,none", VLC_FALSE, VLC_FALSE );
+
+    /*
+     * If needed, load the Xscreensaver interface
+     * Currently, only for X
+     */
+#ifdef HAVE_X11_XLIB_H
+    if( config_GetInt( p_vlc, "disable-screensaver" ) == 1 )
+    {
+        VLC_AddIntf( 0, "screensaver,none", VLC_FALSE, VLC_FALSE );
+    }
+#endif
+
+    if( config_GetInt( p_vlc, "file-logging" ) == 1 )
+    {
+        VLC_AddIntf( 0, "logger,none", VLC_FALSE, VLC_FALSE );
+    }
+#ifdef HAVE_SYSLOG_H
+    if( config_GetInt( p_vlc, "syslog" ) == 1 )
+    {
+        char *psz_logmode = "logmode=syslog";
+        AddIntfInternal( 0, "logger,none", VLC_FALSE, VLC_FALSE, 1, &psz_logmode );
+    }
+#endif
+
+    if( config_GetInt( p_vlc, "show-intf" ) == 1 )
+    {
+        VLC_AddIntf( 0, "showintf,none", VLC_FALSE, VLC_FALSE );
+    }
+
+    if( config_GetInt( p_vlc, "network-synchronisation") == 1 )
+    {
+        VLC_AddIntf( 0, "netsync,none", VLC_FALSE, VLC_FALSE );
+    }
+
+    /*
+     * FIXME: kludge to use a p_vlc-local variable for the Mozilla plugin
+     */
+    var_Create( p_vlc, "drawable", VLC_VAR_INTEGER );
+    var_Create( p_vlc, "drawable-view-top", VLC_VAR_INTEGER );
+    var_Create( p_vlc, "drawable-view-left", VLC_VAR_INTEGER );
+    var_Create( p_vlc, "drawable-view-bottom", VLC_VAR_INTEGER );
+    var_Create( p_vlc, "drawable-view-right", VLC_VAR_INTEGER );
+    var_Create( p_vlc, "drawable-clip-top", VLC_VAR_INTEGER );
+    var_Create( p_vlc, "drawable-clip-left", VLC_VAR_INTEGER );
+    var_Create( p_vlc, "drawable-clip-bottom", VLC_VAR_INTEGER );
+    var_Create( p_vlc, "drawable-clip-right", VLC_VAR_INTEGER );
+
+    /* Create volume callback system. */
+    var_Create( p_vlc, "volume-change", VLC_VAR_BOOL );
+
+    /*
+     * Get input filenames given as commandline arguments
+     */
+    GetFilenames( p_vlc, i_argc, ppsz_argv );
+
+    /*
+     * Get --open argument
+     */
+    var_Create( p_vlc, "open", VLC_VAR_STRING | VLC_VAR_DOINHERIT );
+    var_Get( p_vlc, "open", &val );
+    if ( val.psz_string != NULL && *val.psz_string )
+    {
+        VLC_AddTarget( p_vlc->i_object_id, val.psz_string, NULL, 0,
+                       PLAYLIST_INSERT, 0 );
+    }
+    if ( val.psz_string != NULL ) free( val.psz_string );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * VLC_AddIntf: add an interface
+ *****************************************************************************
+ * This function opens an interface plugin and runs it. If b_block is set
+ * to 0, VLC_AddIntf will return immediately and let the interface run in a
+ * separate thread. If b_block is set to 1, VLC_AddIntf will continue until
+ * user requests to quit. If b_play is set to 1, VLC_AddIntf will start playing
+ * the playlist when it is completely initialised.
+ *****************************************************************************/
+int VLC_AddIntf( int i_object, char const *psz_module,
+                 vlc_bool_t b_block, vlc_bool_t b_play )
+{
+    return AddIntfInternal( i_object, psz_module, b_block, b_play, 0, NULL );
+}
+
+
+/*****************************************************************************
+ * VLC_Die: ask vlc to die.
+ *****************************************************************************
+ * This function sets p_vlc->b_die to VLC_TRUE, but does not do any other
+ * task. It is your duty to call VLC_CleanUp and VLC_Destroy afterwards.
+ *****************************************************************************/
+int VLC_Die( int i_object )
+{
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_vlc->b_die = VLC_TRUE;
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * VLC_CleanUp: CleanUp all the intf, playlist, vout, aout
+ *****************************************************************************/
+int VLC_CleanUp( int i_object )
+{
+    intf_thread_t      * p_intf;
+    playlist_t         * p_playlist;
+    vout_thread_t      * p_vout;
+    aout_instance_t    * p_aout;
+    announce_handler_t * p_announce;
+    stats_handler_t    * p_stats;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    /*
+     * Ask the interfaces to stop and destroy them
+     */
+    msg_Dbg( p_vlc, "removing all interfaces" );
+    while( (p_intf = vlc_object_find( p_vlc, VLC_OBJECT_INTF, FIND_CHILD )) )
+    {
+        intf_StopThread( p_intf );
+        vlc_object_detach( p_intf );
+        vlc_object_release( p_intf );
+        intf_Destroy( p_intf );
+    }
+
+    /*
+     * Free playlist
+     */
+    msg_Dbg( p_vlc, "removing playlist handler" );
+    while( (p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST,
+                                          FIND_CHILD )) )
+    {
+        vlc_object_detach( p_playlist );
+        vlc_object_release( p_playlist );
+        playlist_Destroy( p_playlist );
+    }
+
+    /*
+     * Free video outputs
+     */
+    msg_Dbg( p_vlc, "removing all video outputs" );
+    while( (p_vout = vlc_object_find( p_vlc, VLC_OBJECT_VOUT, FIND_CHILD )) )
+    {
+        vlc_object_detach( p_vout );
+        vlc_object_release( p_vout );
+        vout_Destroy( p_vout );
+    }
+
+    /*
+     * Free audio outputs
+     */
+    msg_Dbg( p_vlc, "removing all audio outputs" );
+    while( (p_aout = vlc_object_find( p_vlc, VLC_OBJECT_AOUT, FIND_CHILD )) )
+    {
+        vlc_object_detach( (vlc_object_t *)p_aout );
+        vlc_object_release( (vlc_object_t *)p_aout );
+        aout_Delete( p_aout );
+    }
+
+    while( ( p_stats = vlc_object_find( p_vlc, VLC_OBJECT_STATS, FIND_CHILD) ))
+    {
+        stats_TimersDumpAll( p_vlc );
+        stats_HandlerDestroy( p_stats );
+        vlc_object_detach( (vlc_object_t*) p_stats );
+        vlc_object_release( (vlc_object_t *)p_stats );
+        // TODO: Delete it
+    }
+
+    /*
+     * Free announce handler(s?)
+     */
+    while( (p_announce = vlc_object_find( p_vlc, VLC_OBJECT_ANNOUNCE,
+                                                 FIND_CHILD ) ) )
+    {
+        msg_Dbg( p_vlc, "removing announce handler" );
+        vlc_object_detach( p_announce );
+        vlc_object_release( p_announce );
+        announce_HandlerDestroy( p_announce );
+    }
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * VLC_Destroy: Destroy everything.
+ *****************************************************************************
+ * This function requests the running threads to finish, waits for their
+ * termination, and destroys their structure.
+ *****************************************************************************/
+int VLC_Destroy( int i_object )
+{
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    /*
+     * Free allocated memory
+     */
+    if( p_vlc->p_memcpy_module )
+    {
+        module_Unneed( p_vlc, p_vlc->p_memcpy_module );
+        p_vlc->p_memcpy_module = NULL;
+    }
+
+    /*
+     * Free module bank !
+     */
+    module_EndBank( p_vlc );
+
+    if( p_vlc->psz_homedir )
+    {
+        free( p_vlc->psz_homedir );
+        p_vlc->psz_homedir = NULL;
+    }
+
+    if( p_vlc->psz_userdir )
+    {
+        free( p_vlc->psz_userdir );
+        p_vlc->psz_userdir = NULL;
+    }
+
+    if( p_vlc->psz_configfile )
+    {
+        free( p_vlc->psz_configfile );
+        p_vlc->psz_configfile = NULL;
+    }
+
+    if( p_vlc->p_hotkeys )
+    {
+        free( p_vlc->p_hotkeys );
+        p_vlc->p_hotkeys = NULL;
+    }
+
+    /*
+     * System specific cleaning code
+     */
+    system_End( p_vlc );
+
+    /*
+     * Free message queue.
+     * Nobody shall use msg_* afterward.
+     */
+    msg_Flush( p_vlc );
+    msg_Destroy( p_libvlc );
+
+    /* Destroy global iconv */
+    LocaleDeinit();
+
+    /* Destroy mutexes */
+    vlc_mutex_destroy( &p_vlc->config_lock );
+
+    vlc_object_detach( p_vlc );
+
+    /* Release object before destroying it */
+    if( i_object ) vlc_object_release( p_vlc );
+
+    vlc_object_destroy( p_vlc );
+
+    /* Stop thread system: last one out please shut the door! */
+    vlc_threads_end( p_libvlc );
+
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * VLC_VariableSet: set a vlc variable
+ *****************************************************************************/
+int VLC_VariableSet( int i_object, char const *psz_var, vlc_value_t value )
+{
+    vlc_t *p_vlc = vlc_current_object( i_object );
+    int i_ret;
+
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    /* FIXME: Temporary hack for Mozilla, if variable starts with conf:: then
+     * we handle it as a configuration variable. Don't tell Gildas :) -- sam */
+    if( !strncmp( psz_var, "conf::", 6 ) )
+    {
+        module_config_t *p_item;
+        char const *psz_newvar = psz_var + 6;
+
+        p_item = config_FindConfig( VLC_OBJECT(p_vlc), psz_newvar );
+
+        if( p_item )
+        {
+            switch( p_item->i_type )
+            {
+                case CONFIG_ITEM_BOOL:
+                    config_PutInt( p_vlc, psz_newvar, value.b_bool );
+                    break;
+                case CONFIG_ITEM_INTEGER:
+                    config_PutInt( p_vlc, psz_newvar, value.i_int );
+                    break;
+                case CONFIG_ITEM_FLOAT:
+                    config_PutFloat( p_vlc, psz_newvar, value.f_float );
+                    break;
+                default:
+                    config_PutPsz( p_vlc, psz_newvar, value.psz_string );
+                    break;
+            }
+            if( i_object ) vlc_object_release( p_vlc );
+            return VLC_SUCCESS;
+        }
+    }
+
+    i_ret = var_Set( p_vlc, psz_var, value );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return i_ret;
+}
+
+/*****************************************************************************
+ * VLC_VariableGet: get a vlc variable
+ *****************************************************************************/
+int VLC_VariableGet( int i_object, char const *psz_var, vlc_value_t *p_value )
+{
+    vlc_t *p_vlc = vlc_current_object( i_object );
+    int i_ret;
+
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    i_ret = var_Get( p_vlc , psz_var, p_value );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return i_ret;
+}
+
+/*****************************************************************************
+ * VLC_VariableType: get a vlc variable type
+ *****************************************************************************/
+int VLC_VariableType( int i_object, char const *psz_var, int *pi_type )
+{
+    int i_type;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    /* FIXME: Temporary hack for Mozilla, if variable starts with conf:: then
+     * we handle it as a configuration variable. Don't tell Gildas :) -- sam */
+    if( !strncmp( psz_var, "conf::", 6 ) )
+    {
+        module_config_t *p_item;
+        char const *psz_newvar = psz_var + 6;
+
+        p_item = config_FindConfig( VLC_OBJECT(p_vlc), psz_newvar );
+
+        if( p_item )
+        {
+            switch( p_item->i_type )
+            {
+                case CONFIG_ITEM_BOOL:
+                    i_type = VLC_VAR_BOOL;
+                    break;
+                case CONFIG_ITEM_INTEGER:
+                    i_type = VLC_VAR_INTEGER;
+                    break;
+                case CONFIG_ITEM_FLOAT:
+                    i_type = VLC_VAR_FLOAT;
+                    break;
+                default:
+                    i_type = VLC_VAR_STRING;
+                    break;
+            }
+        }
+        else
+            i_type = 0;
+    }
+    else
+        i_type = VLC_VAR_TYPE & var_Type( p_vlc , psz_var );
+
+    if( i_object ) vlc_object_release( p_vlc );
+
+    if( i_type > 0 )
+    {
+        *pi_type = i_type;
+        return VLC_SUCCESS;
+    }
+    return VLC_ENOVAR;
+}
+
+/*****************************************************************************
+ * VLC_AddTarget: adds a target for playing.
+ *****************************************************************************
+ * This function adds psz_target to the current playlist. If a playlist does
+ * not exist, it will create one.
+ *****************************************************************************/
+int VLC_AddTarget( int i_object, char const *psz_target,
+                   char const **ppsz_options, int i_options,
+                   int i_mode, int i_pos )
+{
+    int i_err;
+    playlist_t *p_playlist;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_ANYWHERE );
+
+    if( p_playlist == NULL )
+    {
+        msg_Dbg( p_vlc, "no playlist present, creating one" );
+        p_playlist = playlist_Create( p_vlc );
+
+        if( p_playlist == NULL )
+        {
+            if( i_object ) vlc_object_release( p_vlc );
+            return VLC_EGENERIC;
+        }
+
+        vlc_object_yield( p_playlist );
+    }
+
+    i_err = playlist_AddExt( p_playlist, psz_target, psz_target,
+                             i_mode, i_pos, -1, ppsz_options, i_options);
+
+    vlc_object_release( p_playlist );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return i_err;
+}
+
+/*****************************************************************************
+ * VLC_Play: play the playlist
+ *****************************************************************************/
+int VLC_Play( int i_object )
+{
+    playlist_t * p_playlist;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
+
+    if( !p_playlist )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    playlist_Play( p_playlist );
+    vlc_object_release( p_playlist );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * VLC_Pause: toggle pause
+ *****************************************************************************/
+int VLC_Pause( int i_object )
+{
+    playlist_t * p_playlist;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
+
+    if( !p_playlist )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    playlist_Pause( p_playlist );
+    vlc_object_release( p_playlist );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * VLC_Stop: stop playback
+ *****************************************************************************/
+int VLC_Stop( int i_object )
+{
+    playlist_t * p_playlist;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
+
+    if( !p_playlist )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    playlist_Stop( p_playlist );
+    vlc_object_release( p_playlist );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * VLC_IsPlaying: Query for Playlist Status
+ *****************************************************************************/
+vlc_bool_t VLC_IsPlaying( int i_object )
+{
+    playlist_t * p_playlist;
+    vlc_bool_t   b_playing;
+
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
+
+    if( !p_playlist )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    if( p_playlist->p_input )
+    {
+        vlc_value_t  val;
+        var_Get( p_playlist->p_input, "state", &val );
+        b_playing = ( val.i_int == PLAYING_S );
+    }
+    else
+    {
+        b_playing = playlist_IsPlaying( p_playlist );
+    }
+    vlc_object_release( p_playlist );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return b_playing;
+}
+
+/**
+ * Get the current position in a input
+ *
+ * Return the current position as a float
+ * \note For some inputs, this will be unknown.
+ *
+ * \param i_object a vlc object id
+ * \return a float in the range of 0.0 - 1.0
+ */
+float VLC_PositionGet( int i_object )
+{
+    input_thread_t *p_input;
+    vlc_value_t val;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
+
+    if( !p_input )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    var_Get( p_input, "position", &val );
+    vlc_object_release( p_input );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return val.f_float;
+}
+
+/**
+ * Set the current position in a input
+ *
+ * Set the current position in a input and then return
+ * the current position as a float.
+ * \note For some inputs, this will be unknown.
+ *
+ * \param i_object a vlc object id
+ * \param i_position a float in the range of 0.0 - 1.0
+ * \return a float in the range of 0.0 - 1.0
+ */
+float VLC_PositionSet( int i_object, float i_position )
+{
+    input_thread_t *p_input;
+    vlc_value_t val;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
+
+    if( !p_input )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    val.f_float = i_position;
+    var_Set( p_input, "position", val );
+    var_Get( p_input, "position", &val );
+    vlc_object_release( p_input );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return val.f_float;
+}
+
+/**
+ * Get the current position in a input
+ *
+ * Return the current position in seconds from the start.
+ * \note For some inputs, this will be unknown.
+ *
+ * \param i_object a vlc object id
+ * \return the offset from 0:00 in seconds
+ */
+int VLC_TimeGet( int i_object )
+{
+    input_thread_t *p_input;
+    vlc_value_t val;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
+
+    if( !p_input )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    var_Get( p_input, "time", &val );
+    vlc_object_release( p_input );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return val.i_time  / 1000000;
+}
+
+/**
+ * Seek to a position in the current input
+ *
+ * Seek i_seconds in the current input. If b_relative is set,
+ * then the seek will be relative to the current position, otherwise
+ * it will seek to i_seconds from the beginning of the input.
+ * \note For some inputs, this will be unknown.
+ *
+ * \param i_object a vlc object id
+ * \param i_seconds seconds from current position or from beginning of input
+ * \param b_relative seek relative from current position
+ * \return VLC_SUCCESS on success
+ */
+int VLC_TimeSet( int i_object, int i_seconds, vlc_bool_t b_relative )
+{
+    input_thread_t *p_input;
+    vlc_value_t val;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
+
+    if( !p_input )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    if( b_relative )
+    {
+        val.i_time = i_seconds;
+        val.i_time = val.i_time * 1000000L;
+        var_Set( p_input, "time-offset", val );
+    }
+    else
+    {
+        val.i_time = i_seconds;
+        val.i_time = val.i_time * 1000000L;
+        var_Set( p_input, "time", val );
+    }
+    vlc_object_release( p_input );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+}
+
+/**
+ * Get the total length of a input
+ *
+ * Return the total length in seconds from the current input.
+ * \note For some inputs, this will be unknown.
+ *
+ * \param i_object a vlc object id
+ * \return the length in seconds
+ */
+int VLC_LengthGet( int i_object )
+{
+    input_thread_t *p_input;
+    vlc_value_t val;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
+
+    if( !p_input )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    var_Get( p_input, "length", &val );
+    vlc_object_release( p_input );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return val.i_time  / 1000000L;
+}
+
+/**
+ * Play the input faster than realtime
+ *
+ * 2x, 4x, 8x faster than realtime
+ * \note For some inputs, this will be impossible.
+ *
+ * \param i_object a vlc object id
+ * \return the current speedrate
+ */
+float VLC_SpeedFaster( int i_object )
+{
+    input_thread_t *p_input;
+    vlc_value_t val;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
+
+    if( !p_input )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    val.b_bool = VLC_TRUE;
+    var_Set( p_input, "rate-faster", val );
+    var_Get( p_input, "rate", &val );
+    vlc_object_release( p_input );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return val.f_float / INPUT_RATE_DEFAULT;
+}
+
+/**
+ * Play the input slower than realtime
+ *
+ * 1/2x, 1/4x, 1/8x slower than realtime
+ * \note For some inputs, this will be impossible.
+ *
+ * \param i_object a vlc object id
+ * \return the current speedrate
+ */
+float VLC_SpeedSlower( int i_object )
+{
+    input_thread_t *p_input;
+    vlc_value_t val;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_input = vlc_object_find( p_vlc, VLC_OBJECT_INPUT, FIND_CHILD );
+
+    if( !p_input )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    val.b_bool = VLC_TRUE;
+    var_Set( p_input, "rate-slower", val );
+    var_Get( p_input, "rate", &val );
+    vlc_object_release( p_input );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return val.f_float / INPUT_RATE_DEFAULT;
+}
+
+/**
+ * Return the current playlist item
+ *
+ * Returns the index of the playlistitem that is currently selected for play.
+ * This is valid even if nothing is currently playing.
+ *
+ * \param i_object a vlc object id
+ * \return the current index
+ */
+int VLC_PlaylistIndex( int i_object )
+{
+    int i_index;
+    playlist_t * p_playlist;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
+
+    if( !p_playlist )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    i_index = p_playlist->i_index;
+    vlc_object_release( p_playlist );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return i_index;
+}
+
+/**
+ * Total amount of items in the playlist
+ *
+ * \param i_object a vlc object id
+ * \return amount of playlist items
+ */
+int VLC_PlaylistNumberOfItems( int i_object )
+{
+    int i_size;
+    playlist_t * p_playlist;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
+
+    if( !p_playlist )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    i_size = p_playlist->i_size;
+    vlc_object_release( p_playlist );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return i_size;
+}
+
+/**
+ * Next playlist item
+ *
+ * Skip to the next playlistitem and play it.
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int VLC_PlaylistNext( int i_object )
+{
+    playlist_t * p_playlist;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
+
+    if( !p_playlist )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    playlist_Next( p_playlist );
+    vlc_object_release( p_playlist );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+}
+
+/**
+ * Previous playlist item
+ *
+ * Skip to the previous playlistitem and play it.
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int VLC_PlaylistPrev( int i_object )
+{
+    playlist_t * p_playlist;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
+
+    if( !p_playlist )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    playlist_Prev( p_playlist );
+    vlc_object_release( p_playlist );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+}
+
+
+/*****************************************************************************
+ * VLC_PlaylistClear: Empty the playlist
+ *****************************************************************************/
+int VLC_PlaylistClear( int i_object )
+{
+    int i_err;
+    playlist_t * p_playlist;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
+
+    if( !p_playlist )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    i_err = playlist_Clear( p_playlist );
+
+    vlc_object_release( p_playlist );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return i_err;
+}
+
+/* BEGIN SONGBIRD EDIT */
+/** 
+ * Get Item Metadata. 
+ * 
+ * \param i_object
+ * \param i_index
+ * \param pp_meta
+ * \return 
+ */
+int VLC_PlaylistGetItemMetadata( int i_object, int i_index, vlc_meta_t ** pp_meta)
+{
+  playlist_t *p_playlist = NULL;
+  vlc_t *p_vlc = vlc_current_object( i_object );
+
+  /* Check that the handle is valid */
+  if( !p_vlc )
+  {
+    return VLC_ENOOBJ;
+  }
+  
+  p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
+  
+  if( !p_playlist )
+  {
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_ENOOBJ;
+  }
+ 
+  playlist_item_t *p_item = playlist_ItemGetByPos( p_playlist, i_index );
+  
+  if( !p_item )
+  {
+    vlc_object_release( p_playlist );
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_ENOOBJ;
+  }
+  
+  vlc_mutex_lock( &p_item->input.lock );
+  
+  *pp_meta = vlc_meta_New();
+  vlc_meta_t *p_meta = *pp_meta;
+  
+  vlc_meta_Add(p_meta, "Root", "Root Metadata Node");
+  
+  int i = 0;
+  for( ; i < p_item->input.i_categories; i++ )
+  {
+    p_meta->track = (vlc_meta_t**)realloc( p_meta->track, sizeof( vlc_meta_t* ) * (p_meta->i_track+1) );
+    p_meta->track[p_meta->i_track] = vlc_meta_New();
+    vlc_meta_Add(p_meta->track[p_meta->i_track], "Category", p_item->input.pp_categories[i]->psz_name);
+
+    p_meta->track[i]->track = (vlc_meta_t**)realloc( p_meta->track[i]->track, sizeof( vlc_meta_t* ) * (p_meta->track[i]->i_track+1) );
+    p_meta->track[i]->track[p_meta->track[i]->i_track] = vlc_meta_New();    
+       
+    int j = 0;
+    for( ; j < p_item->input.pp_categories[i]->i_infos; j++ )
+    {
+      if( p_item->input.pp_categories[i]->pp_infos[j]->psz_name[0] != 0 &&
+          p_item->input.pp_categories[i]->pp_infos[j]->psz_value[0] != 0 )
+      {
+        vlc_meta_Add(p_meta->track[i]->track[p_meta->track[i]->i_track], 
+                     p_item->input.pp_categories[i]->pp_infos[j]->psz_name,
+                     p_item->input.pp_categories[i]->pp_infos[j]->psz_value);
+        
+      }
+    }
+    
+    p_meta->track[i]->i_track++;    
+    p_meta->i_track++;
+  }
+  
+  vlc_mutex_unlock( &p_item->input.lock );
+  vlc_object_release( p_playlist );
+  
+  if( i_object ) vlc_object_release( p_vlc );
+  
+  return VLC_SUCCESS;
+}
+
+/**
+ * Change the volume
+ *
+ * \param i_object a vlc object id
+ * \param i_volume something in a range from 0-200
+ * \return the new volume (range 0-200 %)
+ */
+int VLC_VolumeSet( int i_object, int i_volume )
+{
+    audio_volume_t i_vol = 0;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    if( i_volume >= 0 && i_volume <= 200 )
+    {
+        i_vol = i_volume * AOUT_VOLUME_MAX / 200;
+        aout_VolumeSet( p_vlc, i_vol );
+    }
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return i_vol * 200 / AOUT_VOLUME_MAX;
+}
+
+/**
+ * Get the current volume
+ *
+ * Retrieve the current volume.
+ *
+ * \param i_object a vlc object id
+ * \return the current volume (range 0-200 %)
+ */
+int VLC_VolumeGet( int i_object )
+{
+    audio_volume_t i_volume;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    aout_VolumeGet( p_vlc, &i_volume );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return i_volume*200/AOUT_VOLUME_MAX;
+}
+
+/**
+ * Mute/Unmute the volume
+ *
+ * \param i_object a vlc object id
+ * \return VLC_SUCCESS on success
+ */
+int VLC_VolumeMute( int i_object )
+{
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    /* Check that the handle is valid */
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    aout_VolumeMute( p_vlc, NULL );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * VLC_FullScreen: toggle fullscreen mode
+ *****************************************************************************/
+int VLC_FullScreen( int i_object )
+{
+    vout_thread_t *p_vout;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+    p_vout = vlc_object_find( p_vlc, VLC_OBJECT_VOUT, FIND_CHILD );
+
+    if( !p_vout )
+    {
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_ENOOBJ;
+    }
+
+    p_vout->i_changes |= VOUT_FULLSCREEN_CHANGE;
+    vlc_object_release( p_vout );
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+}
+
+/* following functions are local */
+
+
+static int  AddIntfInternal( int i_object, char const *psz_module,
+                             vlc_bool_t b_block, vlc_bool_t b_play,
+                             int i_options, char **ppsz_options )
+{
+    int i_err;
+    intf_thread_t *p_intf;
+    vlc_t *p_vlc = vlc_current_object( i_object );
+
+    if( !p_vlc )
+    {
+        return VLC_ENOOBJ;
+    }
+
+#ifndef WIN32
+    if( p_vlc->p_libvlc->b_daemon && b_block && !psz_module )
+    {
+        /* Daemon mode hack.
+         * We prefer the dummy interface if none is specified. */
+        char *psz_interface = config_GetPsz( p_vlc, "intf" );
+        if( !psz_interface || !*psz_interface ) psz_module = "dummy";
+        if( psz_interface ) free( psz_interface );
+    }
+#endif
+
+    /* Try to create the interface */
+    p_intf = intf_Create( p_vlc, psz_module ? psz_module : "$intf",
+                          i_options, ppsz_options );
+
+    if( p_intf == NULL )
+    {
+        msg_Err( p_vlc, "interface \"%s\" initialization failed", psz_module );
+        if( i_object ) vlc_object_release( p_vlc );
+        return VLC_EGENERIC;
+    }
+
+    /* Interface doesn't handle play on start so do it ourselves */
+    if( !p_intf->b_play && b_play ) VLC_Play( i_object );
+
+    /* Try to run the interface */
+    p_intf->b_play = b_play;
+    p_intf->b_block = b_block;
+    i_err = intf_RunThread( p_intf );
+    if( i_err )
+    {
+        vlc_object_detach( p_intf );
+        intf_Destroy( p_intf );
+        if( i_object ) vlc_object_release( p_vlc );
+        return i_err;
+    }
+
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_SUCCESS;
+};
+
+
+/*****************************************************************************
+ * SetLanguage: set the interface language.
+ *****************************************************************************
+ * We set the LC_MESSAGES locale category for interface messages and buttons,
+ * as well as the LC_CTYPE category for string sorting and possible wide
+ * character support.
+ *****************************************************************************/
+static void SetLanguage ( char const *psz_lang )
+{
+#if defined( ENABLE_NLS ) \
+     && ( defined( HAVE_GETTEXT ) || defined( HAVE_INCLUDED_GETTEXT ) )
+
+    char *          psz_path;
+#if defined( __APPLE__ ) || defined ( WIN32 ) || defined( SYS_BEOS )
+    char            psz_tmp[1024];
+#endif
+
+    if( psz_lang && !*psz_lang )
+    {
+#   if defined( HAVE_LC_MESSAGES )
+        setlocale( LC_MESSAGES, psz_lang );
+#   endif
+        setlocale( LC_CTYPE, psz_lang );
+    }
+    else if( psz_lang )
+    {
+#ifdef __APPLE__
+        /* I need that under Darwin, please check it doesn't disturb
+         * other platforms. --Meuuh */
+        setenv( "LANG", psz_lang, 1 );
+
+#elif defined( SYS_BEOS ) || defined( WIN32 )
+        /* We set LC_ALL manually because it is the only way to set
+         * the language at runtime under eg. Windows. Beware that this
+         * makes the environment unconsistent when libvlc is unloaded and
+         * should probably be moved to a safer place like vlc.c. */
+        static char psz_lcall[20];
+        snprintf( psz_lcall, 19, "LC_ALL=%s", psz_lang );
+        psz_lcall[19] = '\0';
+        putenv( psz_lcall );
+#endif
+
+        setlocale( LC_ALL, psz_lang );
+        /* many code paths assume that float numbers are formatted according
+         * to the US standard (ie. with dot as decimal point), so we keep
+         * C for LC_NUMERIC. */
+        setlocale( LC_NUMERIC, "C" );
+    }
+
+    /* Specify where to find the locales for current domain */
+#if !defined( __APPLE__ ) && !defined( WIN32 ) && !defined( SYS_BEOS )
+    psz_path = LOCALEDIR;
+#else
+    snprintf( psz_tmp, sizeof(psz_tmp), "%s/%s", libvlc.psz_vlcpath,
+              "locale" );
+    psz_path = psz_tmp;
+#endif
+    if( !bindtextdomain( PACKAGE_NAME, psz_path ) )
+    {
+        fprintf( stderr, "warning: couldn't bind domain %s in directory %s\n",
+                 PACKAGE_NAME, psz_path );
+    }
+
+    /* Set the default domain */
+    bind_textdomain_codeset( PACKAGE_NAME, "UTF-8" );
+#endif
+}
+
+/*****************************************************************************
+ * GetFilenames: parse command line options which are not flags
+ *****************************************************************************
+ * Parse command line for input files as well as their associated options.
+ * An option always follows its associated input and begins with a ":".
+ *****************************************************************************/
+static int GetFilenames( vlc_t *p_vlc, int i_argc, char *ppsz_argv[] )
+{
+    int i_opt, i_options;
+
+    /* We assume that the remaining parameters are filenames
+     * and their input options */
+    for( i_opt = i_argc - 1; i_opt >= optind; i_opt-- )
+    {
+        const char *psz_target;
+        i_options = 0;
+
+        /* Count the input options */
+        while( *ppsz_argv[ i_opt ] == ':' && i_opt > optind )
+        {
+            i_options++;
+            i_opt--;
+        }
+
+        /* TODO: write an internal function of this one, to avoid
+         *       unnecessary lookups. */
+        /* FIXME: should we convert options to UTF-8 as well ?? */
+
+#ifdef WIN32
+        if( GetVersion() < 0x80000000 )
+        {
+            VLC_AddTarget( p_vlc->i_object_id, ppsz_argv[i_opt],
+                       (char const **)( i_options ? &ppsz_argv[i_opt + 1] :
+                                        NULL ), i_options,
+                       PLAYLIST_INSERT, 0 );
+        }
+        else
+#endif
+        {
+            psz_target = FromLocale( ppsz_argv[ i_opt ] );
+            VLC_AddTarget( p_vlc->i_object_id, psz_target,
+                       (char const **)( i_options ? &ppsz_argv[i_opt + 1] :
+                                        NULL ), i_options,
+                       PLAYLIST_INSERT, 0 );
+            LocaleFree( psz_target );
+        }
+    }
+
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * Help: print program help
+ *****************************************************************************
+ * Print a short inline help. Message interface is initialized at this stage.
+ *****************************************************************************/
+static void Help( vlc_t *p_this, char const *psz_help_name )
+{
+#ifdef WIN32
+    ShowConsole( VLC_TRUE );
+#endif
+
+    if( psz_help_name && !strcmp( psz_help_name, "help" ) )
+    {
+        utf8_fprintf( stdout, VLC_USAGE, p_this->psz_object_name );
+        Usage( p_this, "help" );
+        Usage( p_this, "main" );
+    }
+    else if( psz_help_name && !strcmp( psz_help_name, "longhelp" ) )
+    {
+        utf8_fprintf( stdout, VLC_USAGE, p_this->psz_object_name );
+        Usage( p_this, NULL );
+    }
+    else if( psz_help_name )
+    {
+        Usage( p_this, psz_help_name );
+    }
+
+#ifdef WIN32        /* Pause the console because it's destroyed when we exit */
+    PauseConsole();
+#endif
+}
+
+/*****************************************************************************
+ * Usage: print module usage
+ *****************************************************************************
+ * Print a short inline help. Message interface is initialized at this stage.
+ *****************************************************************************/
+static void Usage( vlc_t *p_this, char const *psz_module_name )
+{
+#define FORMAT_STRING "  %s --%s%s%s%s%s%s%s "
+    /* short option ------'    |     | | | |  | |
+     * option name ------------'     | | | |  | |
+     * <bra -------------------------' | | |  | |
+     * option type or "" --------------' | |  | |
+     * ket> -----------------------------' |  | |
+     * padding spaces ---------------------'  | |
+     * comment -------------------------------' |
+     * comment suffix --------------------------'
+     *
+     * The purpose of having bra and ket is that we might i18n them as well.
+     */
+#define LINE_START 8
+#define PADDING_SPACES 25
+    vlc_list_t *p_list;
+    module_t *p_parser;
+    module_config_t *p_item;
+    char psz_spaces_text[PADDING_SPACES+LINE_START+1];
+    char psz_spaces_longtext[LINE_START+3];
+    char psz_format[sizeof(FORMAT_STRING)];
+    char psz_buffer[10000];
+    char psz_short[4];
+    int i_index;
+    int i_width = ConsoleWidth() - (PADDING_SPACES+LINE_START+1);
+    vlc_bool_t b_advanced = config_GetInt( p_this, "advanced" );
+    vlc_bool_t b_description;
+
+    memset( psz_spaces_text, ' ', PADDING_SPACES+LINE_START );
+    psz_spaces_text[PADDING_SPACES+LINE_START] = '\0';
+    memset( psz_spaces_longtext, ' ', LINE_START+2 );
+    psz_spaces_longtext[LINE_START+2] = '\0';
+
+    strcpy( psz_format, FORMAT_STRING );
+
+    /* List all modules */
+    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
+
+    /* Enumerate the config for each module */
+    for( i_index = 0; i_index < p_list->i_count; i_index++ )
+    {
+        vlc_bool_t b_help_module;
+
+        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
+
+        if( psz_module_name && strcmp( psz_module_name,
+                                       p_parser->psz_object_name ) )
+        {
+            continue;
+        }
+
+        /* Ignore modules without config options */
+        if( !p_parser->i_config_items )
+        {
+            continue;
+        }
+
+        /* Ignore modules with only advanced config options if requested */
+        if( !b_advanced )
+        {
+            for( p_item = p_parser->p_config;
+                 p_item->i_type != CONFIG_HINT_END;
+                 p_item++ )
+            {
+                if( (p_item->i_type & CONFIG_ITEM) &&
+                    !p_item->b_advanced ) break;
+            }
+            if( p_item->i_type == CONFIG_HINT_END ) continue;
+        }
+
+        /* Print name of module */
+        if( strcmp( "main", p_parser->psz_object_name ) )
+        utf8_fprintf( stdout, "\n %s\n", p_parser->psz_longname );
+
+        b_help_module = !strcmp( "help", p_parser->psz_object_name );
+
+        /* Print module options */
+        for( p_item = p_parser->p_config;
+             p_item->i_type != CONFIG_HINT_END;
+             p_item++ )
+        {
+            char *psz_text, *psz_spaces = psz_spaces_text;
+            char *psz_bra = NULL, *psz_type = NULL, *psz_ket = NULL;
+            char *psz_suf = "", *psz_prefix = NULL;
+            signed int i;
+
+            /* Skip deprecated options */
+            if( p_item->psz_current )
+            {
+                continue;
+            }
+            /* Skip advanced options if requested */
+            if( p_item->b_advanced && !b_advanced )
+            {
+                continue;
+            }
+
+            switch( p_item->i_type )
+            {
+            case CONFIG_HINT_CATEGORY:
+            case CONFIG_HINT_USAGE:
+                if( !strcmp( "main", p_parser->psz_object_name ) )
+                utf8_fprintf( stdout, "\n %s\n", p_item->psz_text );
+                break;
+
+            case CONFIG_ITEM_STRING:
+            case CONFIG_ITEM_FILE:
+            case CONFIG_ITEM_DIRECTORY:
+            case CONFIG_ITEM_MODULE: /* We could also have "=<" here */
+            case CONFIG_ITEM_MODULE_CAT:
+            case CONFIG_ITEM_MODULE_LIST:
+            case CONFIG_ITEM_MODULE_LIST_CAT:
+                psz_bra = " <"; psz_type = _("string"); psz_ket = ">";
+
+                if( p_item->ppsz_list )
+                {
+                    psz_bra = " {";
+                    psz_type = psz_buffer;
+                    psz_type[0] = '\0';
+                    for( i = 0; p_item->ppsz_list[i]; i++ )
+                    {
+                        if( i ) strcat( psz_type, "," );
+                        strcat( psz_type, p_item->ppsz_list[i] );
+                    }
+                    psz_ket = "}";
+                }
+                break;
+            case CONFIG_ITEM_INTEGER:
+            case CONFIG_ITEM_KEY: /* FIXME: do something a bit more clever */
+                psz_bra = " <"; psz_type = _("integer"); psz_ket = ">";
+
+                if( p_item->i_list )
+                {
+                    psz_bra = " {";
+                    psz_type = psz_buffer;
+                    psz_type[0] = '\0';
+                    for( i = 0; p_item->ppsz_list_text[i]; i++ )
+                    {
+                        if( i ) strcat( psz_type, ", " );
+                        sprintf( psz_type + strlen(psz_type), "%i (%s)",
+                                 p_item->pi_list[i],
+                                 p_item->ppsz_list_text[i] );
+                    }
+                    psz_ket = "}";
+                }
+                break;
+            case CONFIG_ITEM_FLOAT:
+                psz_bra = " <"; psz_type = _("float"); psz_ket = ">";
+                break;
+            case CONFIG_ITEM_BOOL:
+                psz_bra = ""; psz_type = ""; psz_ket = "";
+                if( !b_help_module )
+                {
+                    psz_suf = p_item->i_value ? _(" (default enabled)") :
+                                                _(" (default disabled)");
+                }
+                break;
+            }
+
+            if( !psz_type )
+            {
+                continue;
+            }
+
+            /* Add short option if any */
+            if( p_item->i_short )
+            {
+                sprintf( psz_short, "-%c,", p_item->i_short );
+            }
+            else
+            {
+                strcpy( psz_short, "   " );
+            }
+
+            i = PADDING_SPACES - strlen( p_item->psz_name )
+                 - strlen( psz_bra ) - strlen( psz_type )
+                 - strlen( psz_ket ) - 1;
+
+            if( p_item->i_type == CONFIG_ITEM_BOOL && !b_help_module )
+            {
+                psz_prefix =  ", --no-";
+                i -= strlen( p_item->psz_name ) + strlen( psz_prefix );
+            }
+
+            if( i < 0 )
+            {
+                psz_spaces[0] = '\n';
+                i = 0;
+            }
+            else
+            {
+                psz_spaces[i] = '\0';
+            }
+
+            if( p_item->i_type == CONFIG_ITEM_BOOL && !b_help_module )
+            {
+                utf8_fprintf( stdout, psz_format, psz_short, p_item->psz_name,
+                         psz_prefix, p_item->psz_name, psz_bra, psz_type,
+                         psz_ket, psz_spaces );
+            }
+            else
+            {
+                utf8_fprintf( stdout, psz_format, psz_short, p_item->psz_name,
+                         "", "", psz_bra, psz_type, psz_ket, psz_spaces );
+            }
+
+            psz_spaces[i] = ' ';
+
+            /* We wrap the rest of the output */
+            sprintf( psz_buffer, "%s%s", p_item->psz_text, psz_suf );
+            b_description = config_GetInt( p_this, "help-verbose" );
+
+ description:
+            psz_text = psz_buffer;
+            while( *psz_text )
+            {
+                char *psz_parser, *psz_word;
+                size_t i_end = strlen( psz_text );
+
+                /* If the remaining text fits in a line, print it. */
+                if( i_end <= (size_t)i_width )
+                {
+                    utf8_fprintf( stdout, "%s\n", psz_text );
+                    break;
+                }
+
+                /* Otherwise, eat as many words as possible */
+                psz_parser = psz_text;
+                do
+                {
+                    psz_word = psz_parser;
+                    psz_parser = strchr( psz_word, ' ' );
+                    /* If no space was found, we reached the end of the text
+                     * block; otherwise, we skip the space we just found. */
+                    psz_parser = psz_parser ? psz_parser + 1
+                                            : psz_text + i_end;
+
+                } while( psz_parser - psz_text <= i_width );
+
+                /* We cut a word in one of these cases:
+                 *  - it's the only word in the line and it's too long.
+                 *  - we used less than 80% of the width and the word we are
+                 *    going to wrap is longer than 40% of the width, and even
+                 *    if the word would have fit in the next line. */
+                if( psz_word == psz_text
+                     || ( psz_word - psz_text < 80 * i_width / 100
+                           && psz_parser - psz_word > 40 * i_width / 100 ) )
+                {
+                    char c = psz_text[i_width];
+                    psz_text[i_width] = '\0';
+                    utf8_fprintf( stdout, "%s\n%s", psz_text, psz_spaces );
+                    psz_text += i_width;
+                    psz_text[0] = c;
+                }
+                else
+                {
+                    psz_word[-1] = '\0';
+                    utf8_fprintf( stdout, "%s\n%s", psz_text, psz_spaces );
+                    psz_text = psz_word;
+                }
+            }
+
+            if( b_description && p_item->psz_longtext )
+            {
+                sprintf( psz_buffer, "%s%s", p_item->psz_longtext, psz_suf );
+                b_description = VLC_FALSE;
+                psz_spaces = psz_spaces_longtext;
+                utf8_fprintf( stdout, "%s", psz_spaces );
+                goto description;
+            }
+        }
+    }
+
+    /* Release the module list */
+    vlc_list_release( p_list );
+}
+
+/*****************************************************************************
+ * ListModules: list the available modules with their description
+ *****************************************************************************
+ * Print a list of all available modules (builtins and plugins) and a short
+ * description for each one.
+ *****************************************************************************/
+static void ListModules( vlc_t *p_this )
+{
+    vlc_list_t *p_list;
+    module_t *p_parser;
+    char psz_spaces[22];
+    int i_index;
+
+    memset( psz_spaces, ' ', 22 );
+
+#ifdef WIN32
+    ShowConsole( VLC_TRUE );
+#endif
+
+    /* List all modules */
+    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
+
+    /* Enumerate each module */
+    for( i_index = 0; i_index < p_list->i_count; i_index++ )
+    {
+        int i;
+
+        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
+
+        /* Nasty hack, but right now I'm too tired to think about a nice
+         * solution */
+        i = 22 - strlen( p_parser->psz_object_name ) - 1;
+        if( i < 0 ) i = 0;
+        psz_spaces[i] = 0;
+
+        utf8_fprintf( stdout, "  %s%s %s\n", p_parser->psz_object_name,
+                         psz_spaces, p_parser->psz_longname );
+
+        psz_spaces[i] = ' ';
+    }
+
+    vlc_list_release( p_list );
+
+#ifdef WIN32        /* Pause the console because it's destroyed when we exit */
+    PauseConsole();
+#endif
+}
+
+/*****************************************************************************
+ * Version: print complete program version
+ *****************************************************************************
+ * Print complete program version and build number.
+ *****************************************************************************/
+static void Version( void )
+{
+#ifdef WIN32
+    ShowConsole( VLC_TRUE );
+#endif
+
+    utf8_fprintf( stdout, _("VLC version %s\n"), VLC_Version() );
+    utf8_fprintf( stdout, _("Compiled by %s@%s.%s\n"),
+             VLC_CompileBy(), VLC_CompileHost(), VLC_CompileDomain() );
+    utf8_fprintf( stdout, _("Compiler: %s\n"), VLC_Compiler() );
+#ifndef HAVE_SHARED_LIBVLC
+    if( strcmp( VLC_Changeset(), "exported" ) )
+        utf8_fprintf( stdout, _("Based upon svn changeset [%s]\n"),
+                 VLC_Changeset() );
+#endif
+    utf8_fprintf( stdout, LICENSE_MSG );
+
+#ifdef WIN32        /* Pause the console because it's destroyed when we exit */
+    PauseConsole();
+#endif
+}
+
+/*****************************************************************************
+ * ShowConsole: On Win32, create an output console for debug messages
+ *****************************************************************************
+ * This function is useful only on Win32.
+ *****************************************************************************/
+#ifdef WIN32 /*  */
+static void ShowConsole( vlc_bool_t b_dofile )
+{
+#   ifndef UNDER_CE
+    FILE *f_help;
+
+    if( getenv( "PWD" ) && getenv( "PS1" ) ) return; /* cygwin shell */
+
+    AllocConsole();
+
+    freopen( "CONOUT$", "w", stderr );
+    freopen( "CONIN$", "r", stdin );
+
+    if( b_dofile && (f_help = fopen( "vlc-help.txt", "wt" )) )
+    {
+        fclose( f_help );
+        freopen( "vlc-help.txt", "wt", stdout );
+        utf8_fprintf( stderr, _("\nDumped content to vlc-help.txt file.\n") );
+    }
+
+    else freopen( "CONOUT$", "w", stdout );
+
+#   endif
+}
+#endif
+
+/*****************************************************************************
+ * PauseConsole: On Win32, wait for a key press before closing the console
+ *****************************************************************************
+ * This function is useful only on Win32.
+ *****************************************************************************/
+#ifdef WIN32 /*  */
+static void PauseConsole( void )
+{
+#   ifndef UNDER_CE
+
+    if( getenv( "PWD" ) && getenv( "PS1" ) ) return; /* cygwin shell */
+
+    utf8_fprintf( stderr, _("\nPress the RETURN key to continue...\n") );
+    getchar();
+    fclose( stdout );
+
+#   endif
+}
+#endif
+
+/*****************************************************************************
+ * ConsoleWidth: Return the console width in characters
+ *****************************************************************************
+ * We use the stty shell command to get the console width; if this fails or
+ * if the width is less than 80, we default to 80.
+ *****************************************************************************/
+static int ConsoleWidth( void )
+{
+    int i_width = 80;
+
+#ifndef WIN32
+    char buf[20], *psz_parser;
+    FILE *file;
+    int i_ret;
+
+    file = popen( "stty size 2>/dev/null", "r" );
+    if( file )
+    {
+        i_ret = fread( buf, 1, 20, file );
+        if( i_ret > 0 )
+        {
+            buf[19] = '\0';
+            psz_parser = strchr( buf, ' ' );
+            if( psz_parser )
+            {
+                i_ret = atoi( psz_parser + 1 );
+                if( i_ret >= 80 )
+                {
+                    i_width = i_ret;
+                }
+            }
+        }
+
+        pclose( file );
+    }
+#endif
+
+    return i_width;
+}
+
+static int VerboseCallback( vlc_object_t *p_this, const char *psz_variable,
+                     vlc_value_t old_val, vlc_value_t new_val, void *param)
+{
+    vlc_t *p_vlc = (vlc_t *)p_this;
+
+    if( new_val.i_int >= -1 )
+    {
+        p_vlc->p_libvlc->i_verbose = __MIN( new_val.i_int, 2 );
+    }
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * InitDeviceValues: initialize device values
+ *****************************************************************************
+ * This function inits the dvd, vcd and cd-audio values
+ *****************************************************************************/
+static void InitDeviceValues( vlc_t *p_vlc )
+{
+#ifdef HAVE_HAL
+    LibHalContext * ctx;
+    int i, i_devices;
+    char **devices;
+    char *block_dev;
+    dbus_bool_t b_dvd;
+    DBusConnection *p_connection;
+    DBusError       error;
+
+#ifdef HAVE_HAL_1
+    ctx =  libhal_ctx_new();
+    if( !ctx ) return;
+    dbus_error_init( &error );
+    p_connection = dbus_bus_get ( DBUS_BUS_SYSTEM, &error );
+    if( dbus_error_is_set( &error ) )
+    {
+        dbus_error_free( &error );
+        return;
+    }
+    libhal_ctx_set_dbus_connection( ctx, p_connection );
+    if( libhal_ctx_init( ctx, &error ) )
+#else
+    if( ( ctx = hal_initialize( NULL, FALSE ) ) )
+#endif
+    {
+#ifdef HAVE_HAL_1
+        if( ( devices = libhal_get_all_devices( ctx, &i_devices, NULL ) ) )
+#else
+        if( ( devices = hal_get_all_devices( ctx, &i_devices ) ) )
+#endif
+        {
+            for( i = 0; i < i_devices; i++ )
+            {
+#ifdef HAVE_HAL_1
+                if( !libhal_device_property_exists( ctx, devices[i],
+                                                "storage.cdrom.dvd", NULL ) )
+#else
+                if( !hal_device_property_exists( ctx, devices[ i ],
+                                                "storage.cdrom.dvd" ) )
+#endif
+                {
+                    continue;
+                }
+#ifdef HAVE_HAL_1
+                b_dvd = libhal_device_get_property_bool( ctx, devices[ i ],
+                                                 "storage.cdrom.dvd", NULL  );
+                block_dev = libhal_device_get_property_string( ctx,
+                                devices[ i ], "block.device" , NULL );
+#else
+                b_dvd = hal_device_get_property_bool( ctx, devices[ i ],
+                                                      "storage.cdrom.dvd" );
+                block_dev = hal_device_get_property_string( ctx, devices[ i ],
+                                                            "block.device" );
+#endif
+                if( b_dvd )
+                {
+                    config_PutPsz( p_vlc, "dvd", block_dev );
+                }
+
+                config_PutPsz( p_vlc, "vcd", block_dev );
+                config_PutPsz( p_vlc, "cd-audio", block_dev );
+#ifdef HAVE_HAL_1
+                libhal_free_string( block_dev );
+#else
+                hal_free_string( block_dev );
+#endif
+            }
+#ifdef HAVE_HAL_1
+            libhal_free_string_array( devices );
+#else
+            hal_free_string_array( devices );
+#endif
+        }
+
+#ifdef HAVE_HAL_1
+        libhal_ctx_shutdown( ctx, NULL );
+#else
+        hal_shutdown( ctx );
+#endif
+    }
+    else
+    {
+        msg_Warn( p_vlc, "Unable to get HAL device properties" );
+    }
+#endif
+}

Property changes on: src\libvlc.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\libvlc.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\beos_specific.cpp
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\block.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\charset.c
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: src/misc/configuration.c
===================================================================
--- src/misc/configuration.c	(revision 159)
+++ src/misc/configuration.c	(working copy)
@@ -1,1899 +1,1916 @@
-/*****************************************************************************
- * configuration.c management of the modules configuration
- *****************************************************************************
- * Copyright (C) 2001-2004 the VideoLAN team
- * $Id: configuration.c 19493 2007-03-27 08:41:07Z jpsaman $
- *
- * Authors: Gildas Bazin <gbazin@videolan.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-#include <vlc/vlc.h>
-#include "vlc_keys.h"
-#include "charset.h"
-
-#include <stdio.h>                                              /* sprintf() */
-#include <stdlib.h>                                      /* free(), strtol() */
-#include <string.h>                                              /* strdup() */
-#include <errno.h>                                                  /* errno */
-
-#ifdef HAVE_LIMITS_H
-#   include <limits.h>
-#endif
-
-#ifdef HAVE_UNISTD_H
-#    include <unistd.h>                                          /* getuid() */
-#endif
-
-#ifdef HAVE_GETOPT_LONG
-#   ifdef HAVE_GETOPT_H
-#       include <getopt.h>                                       /* getopt() */
-#   endif
-#else
-#   include "../extras/getopt.h"
-#endif
-
-#if defined(HAVE_GETPWUID)
-#   include <pwd.h>                                            /* getpwuid() */
-#endif
-
-#if defined( HAVE_SYS_STAT_H )
-#   include <sys/stat.h>
-#endif
-#if defined( HAVE_SYS_TYPES_H )
-#   include <sys/types.h>
-#endif
-#if defined( WIN32 )
-#   if !defined( UNDER_CE )
-#       include <direct.h>
-#   endif
-#include <tchar.h>
-#endif
-
-#if defined( WIN32 ) || defined( UNDER_CE )
-#   define DIR_SEP "\\"
-#else
-#   define DIR_SEP "/"
-#endif
-
-static int ConfigStringToKey( char * );
-static char *ConfigKeyToString( int );
-
-/*****************************************************************************
- * config_GetType: get the type of a variable (bool, int, float, string)
- *****************************************************************************
- * This function is used to get the type of a variable from its name.
- * Beware, this is quite slow.
- *****************************************************************************/
-int __config_GetType( vlc_object_t *p_this, const char *psz_name )
-{
-    module_config_t *p_config;
-    int i_type;
-
-    p_config = config_FindConfig( p_this, psz_name );
-
-    /* sanity checks */
-    if( !p_config )
-    {
-        return 0;
-    }
-
-    switch( p_config->i_type )
-    {
-    case CONFIG_ITEM_BOOL:
-        i_type = VLC_VAR_BOOL;
-        break;
-
-    case CONFIG_ITEM_INTEGER:
-        i_type = VLC_VAR_INTEGER;
-        break;
-
-    case CONFIG_ITEM_FLOAT:
-        i_type = VLC_VAR_FLOAT;
-        break;
-
-    case CONFIG_ITEM_MODULE:
-    case CONFIG_ITEM_MODULE_CAT:
-    case CONFIG_ITEM_MODULE_LIST:
-    case CONFIG_ITEM_MODULE_LIST_CAT:
-        i_type = VLC_VAR_MODULE;
-        break;
-
-    case CONFIG_ITEM_STRING:
-        i_type = VLC_VAR_STRING;
-        break;
-
-    case CONFIG_ITEM_FILE:
-        i_type = VLC_VAR_FILE;
-        break;
-
-    case CONFIG_ITEM_DIRECTORY:
-        i_type = VLC_VAR_DIRECTORY;
-        break;
-
-    default:
-        i_type = 0;
-        break;
-    }
-
-    return i_type;
-}
-
-/*****************************************************************************
- * config_GetInt: get the value of an int variable
- *****************************************************************************
- * This function is used to get the value of variables which are internally
- * represented by an integer (CONFIG_ITEM_INTEGER and
- * CONFIG_ITEM_BOOL).
- *****************************************************************************/
-int __config_GetInt( vlc_object_t *p_this, const char *psz_name )
-{
-    module_config_t *p_config;
-
-    p_config = config_FindConfig( p_this, psz_name );
-
-    /* sanity checks */
-    if( !p_config )
-    {
-        msg_Err( p_this, "option %s does not exist", psz_name );
-        return -1;
-    }
-    if( (p_config->i_type!=CONFIG_ITEM_INTEGER) &&
-        (p_config->i_type!=CONFIG_ITEM_KEY) &&
-        (p_config->i_type!=CONFIG_ITEM_BOOL) )
-    {
-        msg_Err( p_this, "option %s does not refer to an int", psz_name );
-        return -1;
-    }
-
-    return p_config->i_value;
-}
-
-/*****************************************************************************
- * config_GetFloat: get the value of a float variable
- *****************************************************************************
- * This function is used to get the value of variables which are internally
- * represented by a float (CONFIG_ITEM_FLOAT).
- *****************************************************************************/
-float __config_GetFloat( vlc_object_t *p_this, const char *psz_name )
-{
-    module_config_t *p_config;
-
-    p_config = config_FindConfig( p_this, psz_name );
-
-    /* sanity checks */
-    if( !p_config )
-    {
-        msg_Err( p_this, "option %s does not exist", psz_name );
-        return -1;
-    }
-    if( p_config->i_type != CONFIG_ITEM_FLOAT )
-    {
-        msg_Err( p_this, "option %s does not refer to a float", psz_name );
-        return -1;
-    }
-
-    return p_config->f_value;
-}
-
-/*****************************************************************************
- * config_GetPsz: get the string value of a string variable
- *****************************************************************************
- * This function is used to get the value of variables which are internally
- * represented by a string (CONFIG_ITEM_STRING, CONFIG_ITEM_FILE,
- * CONFIG_ITEM_DIRECTORY, and CONFIG_ITEM_MODULE).
- *
- * Important note: remember to free() the returned char* because it's a
- *   duplicate of the actual value. It isn't safe to return a pointer to the
- *   actual value as it can be modified at any time.
- *****************************************************************************/
-char * __config_GetPsz( vlc_object_t *p_this, const char *psz_name )
-{
-    module_config_t *p_config;
-    char *psz_value = NULL;
-
-    p_config = config_FindConfig( p_this, psz_name );
-
-    /* sanity checks */
-    if( !p_config )
-    {
-        msg_Err( p_this, "option %s does not exist", psz_name );
-        return NULL;
-    }
-    if( (p_config->i_type!=CONFIG_ITEM_STRING) &&
-        (p_config->i_type!=CONFIG_ITEM_FILE) &&
-        (p_config->i_type!=CONFIG_ITEM_DIRECTORY) &&
-        (p_config->i_type!=CONFIG_ITEM_MODULE_LIST) &&
-        (p_config->i_type!=CONFIG_ITEM_MODULE_LIST_CAT) &&
-        (p_config->i_type!=CONFIG_ITEM_MODULE_CAT) &&
-        (p_config->i_type!=CONFIG_ITEM_MODULE) )
-    {
-        msg_Err( p_this, "option %s does not refer to a string", psz_name );
-        return NULL;
-    }
-
-
-    /* return a copy of the string */
-    vlc_mutex_lock( p_config->p_lock );
-    if( p_config->psz_value ) psz_value = strdup( p_config->psz_value );
-    vlc_mutex_unlock( p_config->p_lock );
-
-    return psz_value;
-}
-
-/*****************************************************************************
- * config_PutPsz: set the string value of a string variable
- *****************************************************************************
- * This function is used to set the value of variables which are internally
- * represented by a string (CONFIG_ITEM_STRING, CONFIG_ITEM_FILE,
- * CONFIG_ITEM_DIRECTORY, and CONFIG_ITEM_MODULE).
- *****************************************************************************/
-void __config_PutPsz( vlc_object_t *p_this,
-                      const char *psz_name, const char *psz_value )
-{
-    module_config_t *p_config;
-    vlc_value_t oldval, val;
-
-    p_config = config_FindConfig( p_this, psz_name );
-
-
-    /* sanity checks */
-    if( !p_config )
-    {
-        msg_Warn( p_this, "option %s does not exist", psz_name );
-        return;
-    }
-    if( (p_config->i_type!=CONFIG_ITEM_STRING) &&
-        (p_config->i_type!=CONFIG_ITEM_FILE) &&
-        (p_config->i_type!=CONFIG_ITEM_DIRECTORY) &&
-        (p_config->i_type!=CONFIG_ITEM_MODULE_LIST) &&
-        (p_config->i_type!=CONFIG_ITEM_MODULE_CAT) &&
-        (p_config->i_type!=CONFIG_ITEM_MODULE_LIST_CAT) &&
-        (p_config->i_type!=CONFIG_ITEM_MODULE) )
-    {
-        msg_Err( p_this, "option %s does not refer to a string", psz_name );
-        return;
-    }
-
-    vlc_mutex_lock( p_config->p_lock );
-
-    /* backup old value */
-    oldval.psz_string = p_config->psz_value;
-
-    if( psz_value && *psz_value ) p_config->psz_value = strdup( psz_value );
-    else p_config->psz_value = NULL;
-
-    p_config->b_dirty = VLC_TRUE;
-
-    val.psz_string = p_config->psz_value;
-
-    vlc_mutex_unlock( p_config->p_lock );
-
-    if( p_config->pf_callback )
-    {
-        p_config->pf_callback( p_this, psz_name, oldval, val,
-                               p_config->p_callback_data );
-    }
-
-    /* free old string */
-    if( oldval.psz_string ) free( oldval.psz_string );
-}
-
-/*****************************************************************************
- * config_PutInt: set the integer value of an int variable
- *****************************************************************************
- * This function is used to set the value of variables which are internally
- * represented by an integer (CONFIG_ITEM_INTEGER and
- * CONFIG_ITEM_BOOL).
- *****************************************************************************/
-void __config_PutInt( vlc_object_t *p_this, const char *psz_name, int i_value )
-{
-    module_config_t *p_config;
-    vlc_value_t oldval, val;
-
-    p_config = config_FindConfig( p_this, psz_name );
-
-    /* sanity checks */
-    if( !p_config )
-    {
-        msg_Warn( p_this, "option %s does not exist", psz_name );
-        return;
-    }
-    if( (p_config->i_type!=CONFIG_ITEM_INTEGER) &&
-        (p_config->i_type!=CONFIG_ITEM_KEY) &&
-        (p_config->i_type!=CONFIG_ITEM_BOOL) )
-    {
-        msg_Err( p_this, "option %s does not refer to an int", psz_name );
-        return;
-    }
-
-    /* backup old value */
-    oldval.i_int = p_config->i_value;
-
-    /* if i_min == i_max == 0, then do not use them */
-    if ((p_config->i_min == 0) && (p_config->i_max == 0))
-    {
-        p_config->i_value = i_value;
-    }
-    else if (i_value < p_config->i_min)
-    {
-        p_config->i_value = p_config->i_min;
-    }
-    else if (i_value > p_config->i_max)
-    {
-        p_config->i_value = p_config->i_max;
-    }
-    else
-    {
-        p_config->i_value = i_value;
-    }
-
-    p_config->b_dirty = VLC_TRUE;
-
-    val.i_int = p_config->i_value;
-
-    if( p_config->pf_callback )
-    {
-        p_config->pf_callback( p_this, psz_name, oldval, val,
-                               p_config->p_callback_data );
-    }
-}
-
-/*****************************************************************************
- * config_PutFloat: set the value of a float variable
- *****************************************************************************
- * This function is used to set the value of variables which are internally
- * represented by a float (CONFIG_ITEM_FLOAT).
- *****************************************************************************/
-void __config_PutFloat( vlc_object_t *p_this,
-                        const char *psz_name, float f_value )
-{
-    module_config_t *p_config;
-    vlc_value_t oldval, val;
-
-    p_config = config_FindConfig( p_this, psz_name );
-
-    /* sanity checks */
-    if( !p_config )
-    {
-        msg_Warn( p_this, "option %s does not exist", psz_name );
-        return;
-    }
-    if( p_config->i_type != CONFIG_ITEM_FLOAT )
-    {
-        msg_Err( p_this, "option %s does not refer to a float", psz_name );
-        return;
-    }
-
-    /* backup old value */
-    oldval.f_float = p_config->f_value;
-
-    /* if f_min == f_max == 0, then do not use them */
-    if ((p_config->f_min == 0) && (p_config->f_max == 0))
-    {
-        p_config->f_value = f_value;
-    }
-    else if (f_value < p_config->f_min)
-    {
-        p_config->f_value = p_config->f_min;
-    }
-    else if (f_value > p_config->f_max)
-    {
-        p_config->f_value = p_config->f_max;
-    }
-    else
-    {
-        p_config->f_value = f_value;
-    }
-
-    p_config->b_dirty = VLC_TRUE;
-
-    val.f_float = p_config->f_value;
-
-    if( p_config->pf_callback )
-    {
-        p_config->pf_callback( p_this, psz_name, oldval, val,
-                               p_config->p_callback_data );
-    }
-}
-
-/*****************************************************************************
- * config_FindConfig: find the config structure associated with an option.
- *****************************************************************************
- * FIXME: This function really needs to be optimized.
- * FIXME: And now even more.
- *****************************************************************************/
-module_config_t *config_FindConfig( vlc_object_t *p_this, const char *psz_name )
-{
-    vlc_list_t *p_list;
-    module_t *p_parser;
-    module_config_t *p_item;
-    int i_index;
-
-    if( !psz_name ) return NULL;
-
-    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
-
-    for( i_index = 0; i_index < p_list->i_count; i_index++ )
-    {
-        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
-
-        if( !p_parser->i_config_items )
-            continue;
-
-        for( p_item = p_parser->p_config;
-             p_item->i_type != CONFIG_HINT_END;
-             p_item++ )
-        {
-            if( p_item->i_type & CONFIG_HINT )
-                /* ignore hints */
-                continue;
-            if( !strcmp( psz_name, p_item->psz_name ) )
-            {
-                vlc_list_release( p_list );
-                return p_item;
-            }
-        }
-    }
-
-    vlc_list_release( p_list );
-
-    return NULL;
-}
-
-/*****************************************************************************
- * config_FindModule: find a specific module structure.
- *****************************************************************************/
-module_t *config_FindModule( vlc_object_t *p_this, const char *psz_name )
-{
-    vlc_list_t *p_list;
-    module_t *p_module, *p_result = NULL;
-    int i_index;
-
-    if( !psz_name ) return NULL;
-
-    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
-
-    for( i_index = 0; i_index < p_list->i_count; i_index++ )
-    {
-        p_module = (module_t *)p_list->p_values[i_index].p_object;
-        if( !strcmp( p_module->psz_object_name, psz_name ) )
-        {
-             p_result = p_module;
-             break;
-        }
-    }
-
-    vlc_list_release( p_list );
-
-    return p_result;
-}
-
-/*****************************************************************************
- * config_Duplicate: creates a duplicate of a module's configuration data.
- *****************************************************************************
- * Unfortunatly we cannot work directly with the module's config data as
- * this module might be unloaded from memory at any time (remember HideModule).
- * This is why we need to create an exact copy of the config data.
- *****************************************************************************/
-void config_Duplicate( module_t *p_module, module_config_t *p_orig )
-{
-    int i, j, i_lines = 1;
-    module_config_t *p_item;
-
-    /* Calculate the structure length */
-    p_module->i_config_items = 0;
-    p_module->i_bool_items = 0;
-
-    for( p_item = p_orig; p_item->i_type != CONFIG_HINT_END; p_item++ )
-    {
-        i_lines++;
-
-        if( p_item->i_type & CONFIG_ITEM )
-        {
-            p_module->i_config_items++;
-        }
-
-        if( p_item->i_type == CONFIG_ITEM_BOOL )
-        {
-            p_module->i_bool_items++;
-        }
-    }
-
-    /* Allocate memory */
-    p_module->p_config = (module_config_t *)malloc( sizeof(module_config_t)
-                                                     * i_lines );
-    if( p_module->p_config == NULL )
-    {
-        msg_Err( p_module, "config error: can't duplicate p_config" );
-        return;
-    }
-
-    /* Do the duplication job */
-    for( i = 0; i < i_lines ; i++ )
-    {
-        p_module->p_config[i] = p_orig[i];
-
-        p_module->p_config[i].i_value_orig = p_orig[i].i_value;
-        p_module->p_config[i].f_value_orig = p_orig[i].f_value;
-        p_module->p_config[i].i_value_saved = p_orig[i].i_value;
-        p_module->p_config[i].f_value_saved = p_orig[i].f_value;
-        p_module->p_config[i].psz_value_saved = 0;
-
-        p_module->p_config[i].psz_type = p_orig[i].psz_type ?
-                                   strdup( p_orig[i].psz_type ) : NULL;
-        p_module->p_config[i].psz_name = p_orig[i].psz_name ?
-                                   strdup( p_orig[i].psz_name ) : NULL;
-        p_module->p_config[i].psz_current = p_orig[i].psz_current?
-                                   strdup( p_orig[i].psz_current ) : NULL;
-        p_module->p_config[i].psz_text = p_orig[i].psz_text ?
-                                   strdup( _(p_orig[i].psz_text) ) : NULL;
-        p_module->p_config[i].psz_longtext = p_orig[i].psz_longtext ?
-                                   strdup( _(p_orig[i].psz_longtext) ) : NULL;
-        p_module->p_config[i].psz_value = p_orig[i].psz_value ?
-                                   strdup( p_orig[i].psz_value ) : NULL;
-        p_module->p_config[i].psz_value_orig = p_orig[i].psz_value ?
-                                   strdup( p_orig[i].psz_value ) : NULL;
-
-        p_module->p_config[i].p_lock = &p_module->object_lock;
-
-        /* duplicate the string list */
-        if( p_orig[i].i_list )
-        {
-            if( p_orig[i].ppsz_list )
-            {
-                p_module->p_config[i].ppsz_list =
-                    malloc( (p_orig[i].i_list + 1) * sizeof(char *) );
-                if( p_module->p_config[i].ppsz_list )
-                {
-                    for( j = 0; j < p_orig[i].i_list; j++ )
-                        p_module->p_config[i].ppsz_list[j] = p_orig[i].ppsz_list[j] ?
-                            strdup( p_orig[i].ppsz_list[j] ) : NULL ;
-                    p_module->p_config[i].ppsz_list[j] = NULL;
-                }
-            }
-            if( p_orig[i].ppsz_list_text )
-            {
-                p_module->p_config[i].ppsz_list_text =
-                    malloc( (p_orig[i].i_list + 1) * sizeof(char *) );
-                if( p_module->p_config[i].ppsz_list_text )
-                {
-                    for( j = 0; j < p_orig[i].i_list; j++ )
-                        p_module->p_config[i].ppsz_list_text[j] = _(p_orig[i].ppsz_list_text[j]) ?
-                            strdup( _(p_orig[i].ppsz_list_text[j] ) ) : NULL ;
-                    p_module->p_config[i].ppsz_list_text[j] = NULL;
-                }
-            }
-            if( p_orig[i].pi_list )
-            {
-                p_module->p_config[i].pi_list =
-                    malloc( (p_orig[i].i_list + 1) * sizeof(int) );
-                if( p_module->p_config[i].pi_list )
-                {
-                    for( j = 0; j < p_orig[i].i_list; j++ )
-                        p_module->p_config[i].pi_list[j] =
-                            p_orig[i].pi_list[j];
-                }
-            }
-        }
-
-        /* duplicate the actions list */
-        if( p_orig[i].i_action )
-        {
-            int j;
-
-            p_module->p_config[i].ppf_action =
-                malloc( p_orig[i].i_action * sizeof(void *) );
-            p_module->p_config[i].ppsz_action_text =
-                malloc( p_orig[i].i_action * sizeof(char *) );
-
-            for( j = 0; j < p_orig[i].i_action; j++ )
-            {
-                p_module->p_config[i].ppf_action[j] =
-                    p_orig[i].ppf_action[j];
-                p_module->p_config[i].ppsz_action_text[j] =
-                    p_orig[i].ppsz_action_text[j] ?
-                    strdup( p_orig[i].ppsz_action_text[j] ) : NULL;
-            }
-        }
-
-        p_module->p_config[i].pf_callback = p_orig[i].pf_callback;
-    }
-}
-
-/*****************************************************************************
- * config_Free: frees a duplicated module's configuration data.
- *****************************************************************************
- * This function frees all the data duplicated by config_Duplicate.
- *****************************************************************************/
-void config_Free( module_t *p_module )
-{
-    module_config_t *p_item = p_module->p_config;
-    int i;
-
-    if( p_item == NULL )
-    {
-        return;
-    }
-
-    for( ; p_item->i_type != CONFIG_HINT_END ; p_item++ )
-    {
-        if( p_item->psz_type )
-            free( p_item->psz_type );
-
-        if( p_item->psz_name )
-            free( p_item->psz_name );
-
-        if( p_item->psz_current )
-            free( p_item->psz_current );
-
-        if( p_item->psz_text )
-            free( p_item->psz_text );
-
-        if( p_item->psz_longtext )
-            free( p_item->psz_longtext );
-
-        if( p_item->psz_value )
-            free( p_item->psz_value );
-
-        if( p_item->psz_value_orig )
-            free( p_item->psz_value_orig );
-
-        if( p_item->psz_value_saved )
-            free( p_item->psz_value_saved );
-
-        if( p_item->i_list )
-        {
-            for( i = 0; i < p_item->i_list; i++ )
-            {
-                if( p_item->ppsz_list && p_item->ppsz_list[i] )
-                    free( p_item->ppsz_list[i] );
-                if( p_item->ppsz_list_text && p_item->ppsz_list_text[i] )
-                    free( p_item->ppsz_list_text[i] );
-            }
-            if( p_item->ppsz_list ) free( p_item->ppsz_list );
-            if( p_item->ppsz_list_text ) free( p_item->ppsz_list_text );
-            if( p_item->pi_list ) free( p_item->pi_list );
-        }
-
-        if( p_item->i_action )
-        {
-            for( i = 0; i < p_item->i_action; i++ )
-            {
-                if( p_item->ppsz_action_text[i] )
-                    free( p_item->ppsz_action_text[i] );
-            }
-            if( p_item->ppf_action ) free( p_item->ppf_action );
-            if( p_item->ppsz_action_text ) free( p_item->ppsz_action_text );
-        }
-    }
-
-    free( p_module->p_config );
-    p_module->p_config = NULL;
-}
-
-/*****************************************************************************
- * config_SetCallbacks: sets callback functions in the duplicate p_config.
- *****************************************************************************
- * Unfortunatly we cannot work directly with the module's config data as
- * this module might be unloaded from memory at any time (remember HideModule).
- * This is why we need to duplicate callbacks each time we reload the module.
- *****************************************************************************/
-void config_SetCallbacks( module_config_t *p_new, module_config_t *p_orig )
-{
-    while( p_new->i_type != CONFIG_HINT_END )
-    {
-        p_new->pf_callback = p_orig->pf_callback;
-        p_new++;
-        p_orig++;
-    }
-}
-
-/*****************************************************************************
- * config_UnsetCallbacks: unsets callback functions in the duplicate p_config.
- *****************************************************************************
- * We simply undo what we did in config_SetCallbacks.
- *****************************************************************************/
-void config_UnsetCallbacks( module_config_t *p_new )
-{
-    while( p_new->i_type != CONFIG_HINT_END )
-    {
-        p_new->pf_callback = NULL;
-        p_new++;
-    }
-}
-
-/*****************************************************************************
- * config_ResetAll: reset the configuration data for all the modules.
- *****************************************************************************/
-void __config_ResetAll( vlc_object_t *p_this )
-{
-    int i_index, i;
-    vlc_list_t *p_list;
-    module_t *p_module;
-
-    /* Acquire config file lock */
-    vlc_mutex_lock( &p_this->p_vlc->config_lock );
-
-    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
-
-    for( i_index = 0; i_index < p_list->i_count; i_index++ )
-    {
-        p_module = (module_t *)p_list->p_values[i_index].p_object ;
-        if( p_module->b_submodule ) continue;
-
-        for( i = 0; p_module->p_config[i].i_type != CONFIG_HINT_END; i++ )
-        {
-            p_module->p_config[i].i_value = p_module->p_config[i].i_value_orig;
-            p_module->p_config[i].f_value = p_module->p_config[i].f_value_orig;
-            if( p_module->p_config[i].psz_value )
-                free( p_module->p_config[i].psz_value );
-            p_module->p_config[i].psz_value =
-                p_module->p_config[i].psz_value_orig ?
-                strdup( p_module->p_config[i].psz_value_orig ) : NULL;
-        }
-    }
-
-    vlc_list_release( p_list );
-    vlc_mutex_unlock( &p_this->p_vlc->config_lock );
-}
-
-/*****************************************************************************
- * config_LoadConfigFile: loads the configuration file.
- *****************************************************************************
- * This function is called to load the config options stored in the config
- * file.
- *****************************************************************************/
-int __config_LoadConfigFile( vlc_object_t *p_this, const char *psz_module_name )
-{
-    vlc_list_t *p_list;
-    module_t *p_parser;
-    module_config_t *p_item;
-    FILE *file;
-    char line[1024];
-    char *p_index, *psz_option_name, *psz_option_value;
-    char *psz_filename, *psz_homedir, *psz_configfile;
-    int i_index;
-
-    psz_configfile = p_this->p_vlc->psz_configfile;
-    if( !psz_configfile || !psz_configfile )
-    {
-        psz_homedir = p_this->p_vlc->psz_homedir;
-        if( !psz_homedir )
-        {
-            msg_Err( p_this, "psz_homedir is null" );
-            return -1;
-        }
-        psz_filename = (char *)malloc( sizeof("/" CONFIG_DIR "/" CONFIG_FILE) +
-                                       strlen(psz_homedir) );
-        if( psz_filename )
-            sprintf( psz_filename,
-                     "%s" DIR_SEP CONFIG_DIR DIR_SEP CONFIG_FILE,
-                     psz_homedir );
-    }
-    else
-    {
-        psz_filename = strdup( psz_configfile );
-    }
-
-    if( !psz_filename )
-    {
-        msg_Err( p_this, "out of memory" );
-        return -1;
-    }
-
-    msg_Dbg( p_this, "opening config file %s", psz_filename );
-
-    /* Acquire config file lock */
-    vlc_mutex_lock( &p_this->p_vlc->config_lock );
-
-    file = utf8_fopen( psz_filename, "rt" );
-    if( !file )
-    {
-        msg_Warn( p_this, "config file %s does not exist yet", psz_filename );
-        free( psz_filename );
-        vlc_mutex_unlock( &p_this->p_vlc->config_lock );
-        return -1;
-    }
-
-    /* Look for the selected module, if NULL then save everything */
-    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
-
-    for( i_index = 0; i_index < p_list->i_count; i_index++ )
-    {
-        char * (*convert) (const char *) = FromLocaleDup;
-        char bom[3];
-
-        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
-
-        if( psz_module_name
-             && strcmp( psz_module_name, p_parser->psz_object_name ) )
-        {
-            continue;
-        }
-
-        /* The config file is organized in sections, one per module. Look for
-         * the interesting section ( a section is of the form [foo] ) */
-        fseek( file, 0L, SEEK_SET );
-
-        /* Look for UTF-8 Byte Order Mark */
-
-        if ((fread (bom, 1, 3, file) == 3)
-         && (memcmp (bom, "\xEF\xBB\xBF", 3) == 0))
-            convert = strdup;
-        else
-            rewind (file); // no BOM, rewind
-
-        while( fgets( line, 1024, file ) )
-        {
-            if( (line[0] == '[')
-               && (p_index = strchr(line,']'))
-               && (p_index - &line[1]
-                    == (int)strlen(p_parser->psz_object_name))
-               && !memcmp( &line[1], p_parser->psz_object_name,
-                           strlen(p_parser->psz_object_name) ) )
-            {
-#if 0
-                msg_Dbg( p_this, "loading config for module \"%s\"",
-                                 p_parser->psz_object_name );
-#endif
-
-                break;
-            }
-        }
-        /* either we found the section or we're at the EOF */
-
-        /* Now try to load the options in this section */
-        while( fgets( line, 1024, file ) )
-        {
-            if( line[0] == '[' ) break; /* end of section */
-
-            /* ignore comments or empty lines */
-            if( (line[0] == '#') || (line[0] == '\n') || (line[0] == (char)0) )
-                continue;
-
-            /* get rid of line feed */
-            if( line[strlen(line)-1] == '\n' )
-                line[strlen(line)-1] = (char)0;
-
-            /* look for option name */
-            psz_option_name = line;
-            psz_option_value = NULL;
-            p_index = strchr( line, '=' );
-            if( !p_index ) break; /* this ain't an option!!! */
-
-            *p_index = (char)0;
-            psz_option_value = p_index + 1;
-
-            if( !p_parser->i_config_items )
-            {
-                continue;
-            }
-
-            /* try to match this option with one of the module's options */
-            for( p_item = p_parser->p_config;
-                 p_item->i_type != CONFIG_HINT_END;
-                 p_item++ )
-            {
-                if( p_item->i_type & CONFIG_HINT )
-                    /* ignore hints */
-                    continue;
-
-                if( !strcmp( p_item->psz_name, psz_option_name ) )
-                {
-                    /* We found it */
-                    switch( p_item->i_type )
-                    {
-                    case CONFIG_ITEM_BOOL:
-                    case CONFIG_ITEM_INTEGER:
-                        if( !*psz_option_value )
-                            break;                    /* ignore empty option */
-                        p_item->i_value = strtol( psz_option_value, 0, 0 );
-                        p_item->i_value_saved = p_item->i_value;
-#if 0
-                        msg_Dbg( p_this, "option \"%s\", value %i",
-                                 p_item->psz_name, p_item->i_value );
-#endif
-                        break;
-
-                    case CONFIG_ITEM_FLOAT:
-                        if( !*psz_option_value )
-                            break;                    /* ignore empty option */
-                        p_item->f_value = (float)i18n_atof( psz_option_value);
-                        p_item->f_value_saved = p_item->f_value;
-#if 0
-                        msg_Dbg( p_this, "option \"%s\", value %f",
-                                 p_item->psz_name, (double)p_item->f_value );
-#endif
-                        break;
-                    case CONFIG_ITEM_KEY:
-                        if( !*psz_option_value )
-                            break;                    /* ignore empty option */
-                        p_item->i_value = ConfigStringToKey(psz_option_value);
-                        p_item->i_value_saved = p_item->i_value;
-                        break;
-
-                    default:
-                        vlc_mutex_lock( p_item->p_lock );
-
-                        /* free old string */
-                        if( p_item->psz_value )
-                            free( p_item->psz_value );
-
-                        p_item->psz_value = *psz_option_value ?
-                            convert( psz_option_value ) : NULL;
-
-                        if( p_item->psz_value_saved )
-                            free( p_item->psz_value_saved );
-                        p_item->psz_value_saved = 0;
-                        if( !p_item->psz_value || !p_item->psz_value_orig ||
-                            (p_item->psz_value && p_item->psz_value_orig &&
-                             strcmp(p_item->psz_value,p_item->psz_value_orig)))
-                            p_item->psz_value_saved = p_item->psz_value ?
-                                strdup( p_item->psz_value ) : 0;
-
-                        vlc_mutex_unlock( p_item->p_lock );
-
-#if 0
-                        msg_Dbg( p_this, "option \"%s\", value \"%s\"",
-                                 p_item->psz_name,
-                                 p_item->psz_value ? p_item->psz_value : "" );
-#endif
-                        break;
-                    }
-                }
-            }
-        }
-
-    }
-
-    vlc_list_release( p_list );
-
-    fclose( file );
-    free( psz_filename );
-
-    vlc_mutex_unlock( &p_this->p_vlc->config_lock );
-
-    return 0;
-}
-
-/*****************************************************************************
- * config_CreateDir: Create configuration directory if it doesn't exist.
- *****************************************************************************/
-int config_CreateDir( vlc_object_t *p_this, const char *psz_dirname )
-{
-    if( !psz_dirname && !*psz_dirname ) return -1;
-
-    if( utf8_mkdir( psz_dirname ) && ( errno != EEXIST ) )
-    {
-        msg_Err( p_this, "could not create %s (%s)",
-                 psz_dirname, strerror(errno) );
-        return -1;
-    }
-
-    return 0;
-}
-
-/*****************************************************************************
- * config_SaveConfigFile: Save a module's config options.
- *****************************************************************************
- * This will save the specified module's config options to the config file.
- * If psz_module_name is NULL then we save all the modules config options.
- * It's no use to save the config options that kept their default values, so
- * we'll try to be a bit clever here.
- *
- * When we save we mustn't delete the config options of the modules that
- * haven't been loaded. So we cannot just create a new config file with the
- * config structures we've got in memory.
- * I don't really know how to deal with this nicely, so I will use a completly
- * dumb method ;-)
- * I will load the config file in memory, but skipping all the sections of the
- * modules we want to save. Then I will create a brand new file, dump the file
- * loaded in memory and then append the sections of the modules we want to
- * save.
- * Really stupid no ?
- *****************************************************************************/
-static int SaveConfigFile( vlc_object_t *p_this, const char *psz_module_name,
-                           vlc_bool_t b_autosave )
-{
-    module_t *p_parser;
-    vlc_list_t *p_list;
-    module_config_t *p_item;
-    FILE *file;
-    char p_line[1024], *p_index2;
-    int i_sizebuf = 0;
-    char *p_bigbuffer, *p_index;
-    vlc_bool_t b_backup;
-    char *psz_filename, *psz_homedir, *psz_configfile;
-    int i_index;
-
-    /* Acquire config file lock */
-    vlc_mutex_lock( &p_this->p_vlc->config_lock );
-
-    psz_configfile = p_this->p_vlc->psz_configfile;
-    if( !psz_configfile || !psz_configfile )
-    {
-        psz_homedir = p_this->p_vlc->psz_homedir;
-        if( !psz_homedir )
-        {
-            msg_Err( p_this, "psz_homedir is null" );
-            vlc_mutex_unlock( &p_this->p_vlc->config_lock );
-            return -1;
-        }
-        psz_filename = (char *)malloc( sizeof("/" CONFIG_DIR "/" CONFIG_FILE) +
-                                       strlen(psz_homedir) );
-
-        if( psz_filename )
-            sprintf( psz_filename, "%s" DIR_SEP CONFIG_DIR, psz_homedir );
-
-        if( !psz_filename )
-        {
-            msg_Err( p_this, "out of memory" );
-            vlc_mutex_unlock( &p_this->p_vlc->config_lock );
-            return -1;
-        }
-
-        config_CreateDir( p_this, psz_filename );
-
-        strcat( psz_filename, DIR_SEP CONFIG_FILE );
-    }
-    else
-    {
-        psz_filename = strdup( psz_configfile );
-        if( !psz_filename )
-        {
-            msg_Err( p_this, "out of memory" );
-            vlc_mutex_unlock( &p_this->p_vlc->config_lock );
-            return -1;
-        }
-    }
-
-    msg_Dbg( p_this, "opening config file %s", psz_filename );
-
-    file = utf8_fopen( psz_filename, "rt" );
-    if( !file )
-    {
-        msg_Warn( p_this, "config file %s does not exist yet", psz_filename );
-    }
-    else
-    {
-        /* look for file size */
-        fseek( file, 0L, SEEK_END );
-        i_sizebuf = ftell( file );
-        fseek( file, 0L, SEEK_SET );
-    }
-
-    p_bigbuffer = p_index = malloc( i_sizebuf+1 );
-    if( !p_bigbuffer )
-    {
-        msg_Err( p_this, "out of memory" );
-        if( file ) fclose( file );
-        free( psz_filename );
-        vlc_mutex_unlock( &p_this->p_vlc->config_lock );
-        return -1;
-    }
-    p_bigbuffer[0] = 0;
-
-    /* List all available modules */
-    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
-
-    /* backup file into memory, we only need to backup the sections we won't
-     * save later on */
-    b_backup = 0;
-    while( file && fgets( p_line, 1024, file ) )
-    {
-        if( (p_line[0] == '[') && (p_index2 = strchr(p_line,']')))
-        {
-
-            /* we found a section, check if we need to do a backup */
-            for( i_index = 0; i_index < p_list->i_count; i_index++ )
-            {
-                p_parser = (module_t *)p_list->p_values[i_index].p_object ;
-
-                if( ((p_index2 - &p_line[1])
-                       == (int)strlen(p_parser->psz_object_name) )
-                    && !memcmp( &p_line[1], p_parser->psz_object_name,
-                                strlen(p_parser->psz_object_name) ) )
-                {
-                    if( !psz_module_name )
-                        break;
-                    else if( !strcmp( psz_module_name,
-                                      p_parser->psz_object_name ) )
-                        break;
-                }
-            }
-
-            if( i_index == p_list->i_count )
-            {
-                /* we don't have this section in our list so we need to back
-                 * it up */
-                *p_index2 = 0;
-#if 0
-                msg_Dbg( p_this, "backing up config for unknown module \"%s\"",
-                                 &p_line[1] );
-#endif
-                *p_index2 = ']';
-
-                b_backup = 1;
-            }
-            else
-            {
-                b_backup = 0;
-            }
-        }
-
-        /* save line if requested and line is valid (doesn't begin with a
-         * space, tab, or eol) */
-        if( b_backup && (p_line[0] != '\n') && (p_line[0] != ' ')
-            && (p_line[0] != '\t') )
-        {
-            strcpy( p_index, p_line );
-            p_index += strlen( p_line );
-        }
-    }
-    if( file ) fclose( file );
-
-
-    /*
-     * Save module config in file
-     */
-
-    file = utf8_fopen( psz_filename, "wt" );
-    if( !file )
-    {
-        msg_Warn( p_this, "could not open config file %s for writing",
-                          psz_filename );
-        free( psz_filename );
-        vlc_list_release( p_list );
-        vlc_mutex_unlock( &p_this->p_vlc->config_lock );
-        return -1;
-    }
-    
-#ifdef WIN32
-    /* Ugly kludge to not save --started-from-file (and not break the ABI). 
-     * See [17898] and   #871 */
-    /* Just use the first mofule found*/
-    config_PutInt( (module_t *)p_list->p_values[0].p_object, 
-                   "started-from-file", 0 );
-
-#endif
-
-    fprintf( file, "\xEF\xBB\xBF###\n###  " COPYRIGHT_MESSAGE "\n###\n\n"
-       "###\n### lines begining with a '#' character are comments\n###\n\n" );
-
-    /* Look for the selected module, if NULL then save everything */
-    for( i_index = 0; i_index < p_list->i_count; i_index++ )
-    {
-        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
-
-        if( psz_module_name && strcmp( psz_module_name,
-                                       p_parser->psz_object_name ) )
-            continue;
-
-        if( !p_parser->i_config_items )
-            continue;
-
-        if( psz_module_name )
-            msg_Dbg( p_this, "saving config for module \"%s\"",
-                     p_parser->psz_object_name );
-
-        fprintf( file, "[%s]", p_parser->psz_object_name );
-        if( p_parser->psz_longname )
-            fprintf( file, " # %s\n\n", p_parser->psz_longname );
-        else
-            fprintf( file, "\n\n" );
-
-        for( p_item = p_parser->p_config;
-             p_item->i_type != CONFIG_HINT_END;
-             p_item++ )
-        {
-            char  *psz_key;
-            int   i_value = p_item->i_value;
-            float f_value = p_item->f_value;
-            char  *psz_value = p_item->psz_value;
-
-            if( p_item->i_type & CONFIG_HINT )
-                /* ignore hints */
-                continue;
-            /* Ignore deprecated options */
-            if( p_item->psz_current )
-                continue;
-            if( b_autosave && !p_item->b_autosave )
-            {
-                i_value = p_item->i_value_saved;
-                f_value = p_item->f_value_saved;
-                psz_value = p_item->psz_value_saved;
-                if( !psz_value ) psz_value = p_item->psz_value_orig;
-            }
-            else
-            {
-                p_item->b_dirty = VLC_FALSE;
-            }
-
-            switch( p_item->i_type )
-            {
-            case CONFIG_ITEM_BOOL:
-            case CONFIG_ITEM_INTEGER:
-                if( p_item->psz_text )
-                    fprintf( file, "# %s (%s)\n", p_item->psz_text,
-                             (p_item->i_type == CONFIG_ITEM_BOOL) ?
-                             _("boolean") : _("integer") );
-                if( i_value == p_item->i_value_orig )
-                    fputc( '#', file );
-                fprintf( file, "%s=%i\n", p_item->psz_name, i_value );
-
-                p_item->i_value_saved = i_value;
-                break;
-
-            case CONFIG_ITEM_KEY:
-                if( p_item->psz_text )
-                    fprintf( file, "# %s (%s)\n", p_item->psz_text,
-                             _("key") );
-                if( i_value == p_item->i_value_orig )
-                    fputc( '#', file );
-                psz_key = ConfigKeyToString( i_value );
-                fprintf( file, "%s=%s\n", p_item->psz_name,
-                         psz_key ? psz_key : "" );
-                if ( psz_key ) free( psz_key );
-
-                p_item->i_value_saved = i_value;
-                break;
-
-            case CONFIG_ITEM_FLOAT:
-                if( p_item->psz_text )
-                    fprintf( file, "# %s (%s)\n", p_item->psz_text,
-                             _("float") );
-                if( f_value == p_item->f_value_orig )
-                    fputc( '#', file );
-                fprintf( file, "%s=%f\n", p_item->psz_name, (double)f_value );
-
-                p_item->f_value_saved = f_value;
-                break;
-
-            default:
-                if( p_item->psz_text )
-                    fprintf( file, "# %s (%s)\n", p_item->psz_text,
-                             _("string") );
-                if( (!psz_value && !p_item->psz_value_orig) ||
-                    (psz_value && p_item->psz_value_orig &&
-                     !strcmp( psz_value, p_item->psz_value_orig )) )
-                    fputc( '#', file );
-                fprintf( file, "%s=%s\n", p_item->psz_name,
-                         psz_value ? psz_value : "" );
-
-                if( b_autosave && !p_item->b_autosave ) break;
-
-                if( p_item->psz_value_saved ) free( p_item->psz_value_saved );
-                p_item->psz_value_saved = 0;
-                if( (psz_value && p_item->psz_value_orig &&
-                     strcmp( psz_value, p_item->psz_value_orig )) ||
-                    !psz_value || !p_item->psz_value_orig)
-                    p_item->psz_value_saved = psz_value ? strdup(psz_value):0;
-            }
-        }
-
-        fputc( '\n', file );
-    }
-
-    vlc_list_release( p_list );
-
-    /*
-     * Restore old settings from the config in file
-     */
-    fputs( p_bigbuffer, file );
-    free( p_bigbuffer );
-
-    fclose( file );
-    free( psz_filename );
-    vlc_mutex_unlock( &p_this->p_vlc->config_lock );
-
-    return 0;
-}
-
-int config_AutoSaveConfigFile( vlc_object_t *p_this )
-{
-    vlc_list_t *p_list;
-    module_t *p_parser;
-    module_config_t *p_item;
-    int i_index, i_count;
-
-    /* Check if there's anything to save */
-    vlc_mutex_lock( &p_this->p_vlc->config_lock );
-    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
-    i_count = p_list->i_count;
-    for( i_index = 0; i_index < i_count; i_index++ )
-    {
-        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
-
-        if( !p_parser->i_config_items ) continue;
-
-        for( p_item = p_parser->p_config;
-             p_item->i_type != CONFIG_HINT_END;
-             p_item++ )
-        {
-            if( p_item->b_autosave && p_item->b_dirty ) break;
-        }
-        if( p_item->i_type != CONFIG_HINT_END ) break;
-    }
-    vlc_list_release( p_list );
-    vlc_mutex_unlock( &p_this->p_vlc->config_lock );
-
-    if( i_index == i_count ) return VLC_SUCCESS;
-    return SaveConfigFile( p_this, 0, VLC_TRUE );
-}
-
-int __config_SaveConfigFile( vlc_object_t *p_this, const char *psz_module_name )
-{
-    return SaveConfigFile( p_this, psz_module_name, VLC_FALSE );
-}
-
-/*****************************************************************************
- * config_LoadCmdLine: parse command line
- *****************************************************************************
- * Parse command line for configuration options.
- * Now that the module_bank has been initialized, we can dynamically
- * generate the longopts structure used by getops. We have to do it this way
- * because we don't know (and don't want to know) in advance the configuration
- * options used (ie. exported) by each module.
- *****************************************************************************/
-int __config_LoadCmdLine( vlc_object_t *p_this, int *pi_argc, char *ppsz_argv[],
-                          vlc_bool_t b_ignore_errors )
-{
-    int i_cmd, i_index, i_opts, i_shortopts, flag, i_verbose = 0;
-    module_t *p_parser;
-    vlc_list_t *p_list;
-    module_config_t *p_item;
-    struct option *p_longopts;
-    int i_modules_index;
-
-    /* Short options */
-    module_config_t *pp_shortopts[256];
-    char *psz_shortopts;
-
-    /* Set default configuration and copy arguments */
-    p_this->p_vlc->i_argc    = *pi_argc;
-    p_this->p_vlc->ppsz_argv = ppsz_argv;
-
-#ifdef __APPLE__
-    /* When VLC.app is run by double clicking in Mac OS X, the 2nd arg
-     * is the PSN - process serial number (a unique PID-ish thingie)
-     * still ok for real Darwin & when run from command line */
-    if ( (*pi_argc > 1) && (strncmp( ppsz_argv[ 1 ] , "-psn" , 4 ) == 0) )
-                                        /* for example -psn_0_9306113 */
-    {
-        /* GDMF!... I can't do this or else the MacOSX window server will
-         * not pick up the PSN and not register the app and we crash...
-         * hence the following kludge otherwise we'll get confused w/ argv[1]
-         * being an input file name */
-#if 0
-        ppsz_argv[ 1 ] = NULL;
-#endif
-        *pi_argc = *pi_argc - 1;
-        pi_argc--;
-        return 0;
-    }
-#endif
-
-    /* List all modules */
-    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
-
-    /*
-     * Generate the longopts and shortopts structures used by getopt_long
-     */
-
-    i_opts = 0;
-    for( i_modules_index = 0; i_modules_index < p_list->i_count;
-         i_modules_index++ )
-    {
-        p_parser = (module_t *)p_list->p_values[i_modules_index].p_object ;
-
-        /* count the number of exported configuration options (to allocate
-         * longopts). We also need to allocate space for two options when
-         * dealing with boolean to allow for --foo and --no-foo */
-        i_opts += p_parser->i_config_items
-                     + 2 * p_parser->i_bool_items;
-    }
-
-    p_longopts = malloc( sizeof(struct option) * (i_opts + 1) );
-    if( p_longopts == NULL )
-    {
-        msg_Err( p_this, "out of memory" );
-        vlc_list_release( p_list );
-        return -1;
-    }
-
-    psz_shortopts = malloc( sizeof( char ) * (2 * i_opts + 1) );
-    if( psz_shortopts == NULL )
-    {
-        msg_Err( p_this, "out of memory" );
-        free( p_longopts );
-        vlc_list_release( p_list );
-        return -1;
-    }
-
-    /* If we are requested to ignore errors, then we must work on a copy
-     * of the ppsz_argv array, otherwise getopt_long will reorder it for
-     * us, ignoring the arity of the options */
-    if( b_ignore_errors )
-    {
-        ppsz_argv = (char**)malloc( *pi_argc * sizeof(char *) );
-        if( ppsz_argv == NULL )
-        {
-            msg_Err( p_this, "out of memory" );
-            free( psz_shortopts );
-            free( p_longopts );
-            vlc_list_release( p_list );
-            return -1;
-        }
-        memcpy( ppsz_argv, p_this->p_vlc->ppsz_argv,
-                *pi_argc * sizeof(char *) );
-    }
-
-    i_shortopts = 0;
-    for( i_index = 0; i_index < 256; i_index++ )
-    {
-        pp_shortopts[i_index] = NULL;
-    }
-
-    /* Fill the p_longopts and psz_shortopts structures */
-    i_index = 0;
-    for( i_modules_index = 0; i_modules_index < p_list->i_count;
-         i_modules_index++ )
-    {
-        p_parser = (module_t *)p_list->p_values[i_modules_index].p_object ;
-
-        if( !p_parser->i_config_items )
-            continue;
-
-        for( p_item = p_parser->p_config;
-             p_item->i_type != CONFIG_HINT_END;
-             p_item++ )
-        {
-            /* Ignore hints */
-            if( p_item->i_type & CONFIG_HINT )
-                continue;
-
-            /* Add item to long options */
-            p_longopts[i_index].name = strdup( p_item->psz_name );
-            if( p_longopts[i_index].name == NULL ) continue;
-            p_longopts[i_index].has_arg =
-                (p_item->i_type == CONFIG_ITEM_BOOL)?
-                                               no_argument : required_argument;
-            p_longopts[i_index].flag = &flag;
-            p_longopts[i_index].val = 0;
-            i_index++;
-
-            /* When dealing with bools we also need to add the --no-foo
-             * option */
-            if( p_item->i_type == CONFIG_ITEM_BOOL )
-            {
-                char *psz_name = malloc( strlen(p_item->psz_name) + 3 );
-                if( psz_name == NULL ) continue;
-                strcpy( psz_name, "no" );
-                strcat( psz_name, p_item->psz_name );
-
-                p_longopts[i_index].name = psz_name;
-                p_longopts[i_index].has_arg = no_argument;
-                p_longopts[i_index].flag = &flag;
-                p_longopts[i_index].val = 1;
-                i_index++;
-
-                psz_name = malloc( strlen(p_item->psz_name) + 4 );
-                if( psz_name == NULL ) continue;
-                strcpy( psz_name, "no-" );
-                strcat( psz_name, p_item->psz_name );
-
-                p_longopts[i_index].name = psz_name;
-                p_longopts[i_index].has_arg = no_argument;
-                p_longopts[i_index].flag = &flag;
-                p_longopts[i_index].val = 1;
-                i_index++;
-            }
-
-            /* If item also has a short option, add it */
-            if( p_item->i_short )
-            {
-                pp_shortopts[(int)p_item->i_short] = p_item;
-                psz_shortopts[i_shortopts] = p_item->i_short;
-                i_shortopts++;
-                if( p_item->i_type != CONFIG_ITEM_BOOL )
-                {
-                    psz_shortopts[i_shortopts] = ':';
-                    i_shortopts++;
-
-                    if( p_item->i_short == 'v' )
-                    {
-                        psz_shortopts[i_shortopts] = ':';
-                        i_shortopts++;
-                    }
-                }
-            }
-        }
-    }
-
-    /* We don't need the module list anymore */
-    vlc_list_release( p_list );
-
-    /* Close the longopts and shortopts structures */
-    memset( &p_longopts[i_index], 0, sizeof(struct option) );
-    psz_shortopts[i_shortopts] = '\0';
-
-    /*
-     * Parse the command line options
-     */
-    opterr = 0;
-    optind = 0; /* set to 0 to tell GNU getopt to reinitialize */
-    while( ( i_cmd = getopt_long( *pi_argc, ppsz_argv, psz_shortopts,
-                                  p_longopts, &i_index ) ) != EOF )
-    {
-        /* A long option has been recognized */
-        if( i_cmd == 0 )
-        {
-            module_config_t *p_conf;
-            char *psz_name = (char *)p_longopts[i_index].name;
-
-            /* Check if we deal with a --nofoo or --no-foo long option */
-            if( flag ) psz_name += psz_name[2] == '-' ? 3 : 2;
-
-            /* Store the configuration option */
-            p_conf = config_FindConfig( p_this, psz_name );
-            if( p_conf )
-            {
-                /* Check if the option is deprecated */
-                if( p_conf->psz_current )
-                {
-                    if( !strcmp(p_conf->psz_current,"SUPPRESSED") )
-                    {
-                        if( !b_ignore_errors )
-                        {
-                            fprintf(stderr,
-                                    "Warning: option --%s is no longer used.\n",
-                                    p_conf->psz_name);
-                        }
-                       continue;
-                    }
-                    if( !b_ignore_errors )
-                    {
-                        if( p_conf->b_strict )
-                        {
-                            fprintf( stderr,
-                                     "Error: option --%s is deprecated. "
-                                     "Use --%s instead.\n",
-                                     p_conf->psz_name, p_conf->psz_current);
-                            /*free */
-                            for( i_index = 0; p_longopts[i_index].name; i_index++ )
-                                free( (char *)p_longopts[i_index].name );
-
-                            free( p_longopts );
-                            free( psz_shortopts );
-                            return -1;
-                        }
-                        fprintf(stderr,
-                                "Warning: option --%s is deprecated. "
-                                "You should use --%s instead.\n",
-                                p_conf->psz_name, p_conf->psz_current);
-                    }
-                    psz_name=p_conf->psz_current;
-                    p_conf = config_FindConfig( p_this, psz_name );
-                }
-
-                switch( p_conf->i_type )
-                {
-                    case CONFIG_ITEM_STRING:
-                    case CONFIG_ITEM_FILE:
-                    case CONFIG_ITEM_DIRECTORY:
-                    case CONFIG_ITEM_MODULE:
-                    case CONFIG_ITEM_MODULE_LIST:
-                    case CONFIG_ITEM_MODULE_LIST_CAT:
-                    case CONFIG_ITEM_MODULE_CAT:
-                        config_PutPsz( p_this, psz_name, optarg );
-                        break;
-                    case CONFIG_ITEM_INTEGER:
-                        config_PutInt( p_this, psz_name, strtol(optarg, 0, 0));
-                        break;
-                    case CONFIG_ITEM_FLOAT:
-                        config_PutFloat( p_this, psz_name, (float)atof(optarg) );
-                        break;
-                    case CONFIG_ITEM_KEY:
-                        config_PutInt( p_this, psz_name, ConfigStringToKey( optarg ) );
-                        break;
-                    case CONFIG_ITEM_BOOL:
-                        config_PutInt( p_this, psz_name, !flag );
-                        break;
-                }
-                continue;
-            }
-        }
-
-        /* A short option has been recognized */
-        if( pp_shortopts[i_cmd] != NULL )
-        {
-            switch( pp_shortopts[i_cmd]->i_type )
-            {
-                case CONFIG_ITEM_STRING:
-                case CONFIG_ITEM_FILE:
-                case CONFIG_ITEM_DIRECTORY:
-                case CONFIG_ITEM_MODULE:
-                case CONFIG_ITEM_MODULE_CAT:
-                case CONFIG_ITEM_MODULE_LIST:
-                case CONFIG_ITEM_MODULE_LIST_CAT:
-                    config_PutPsz( p_this, pp_shortopts[i_cmd]->psz_name, optarg );
-                    break;
-                case CONFIG_ITEM_INTEGER:
-                    if( i_cmd == 'v' )
-                    {
-                        if( optarg )
-                        {
-                            if( *optarg == 'v' ) /* eg. -vvv */
-                            {
-                                i_verbose++;
-                                while( *optarg == 'v' )
-                                {
-                                    i_verbose++;
-                                    optarg++;
-                                }
-                            }
-                            else
-                            {
-                                i_verbose += atoi( optarg ); /* eg. -v2 */
-                            }
-                        }
-                        else
-                        {
-                            i_verbose++; /* -v */
-                        }
-                        config_PutInt( p_this, pp_shortopts[i_cmd]->psz_name,
-                                               i_verbose );
-                    }
-                    else
-                    {
-                        config_PutInt( p_this, pp_shortopts[i_cmd]->psz_name,
-                                               strtol(optarg, 0, 0) );
-                    }
-                    break;
-                case CONFIG_ITEM_BOOL:
-                    config_PutInt( p_this, pp_shortopts[i_cmd]->psz_name, 1 );
-                    break;
-            }
-
-            continue;
-        }
-
-        /* Internal error: unknown option */
-        if( !b_ignore_errors )
-        {
-            fprintf( stderr, "%s: unknown option"
-                     " or missing mandatory argument ",
-                     p_this->p_vlc->psz_object_name );
-            if( optopt )
-            {
-                fprintf( stderr, "`-%c'\n", optopt );
-            }
-            else
-            {
-                fprintf( stderr, "`%s'\n", ppsz_argv[optind-1] );
-            }
-            fprintf( stderr, "Try `%s --help' for more information.\n",
-                             p_this->p_vlc->psz_object_name );
-
-            for( i_index = 0; p_longopts[i_index].name; i_index++ )
-                free( (char *)p_longopts[i_index].name );
-            free( p_longopts );
-            free( psz_shortopts );
-            return -1;
-        }
-    }
-
-    /* Free allocated resources */
-    for( i_index = 0; p_longopts[i_index].name; i_index++ )
-        free( (char *)p_longopts[i_index].name );
-    free( p_longopts );
-    free( psz_shortopts );
-    if( b_ignore_errors ) free( ppsz_argv );
-
-    return 0;
-}
-
-/**
- * config_GetDataDir: find directory where shared data is installed
- *
- * @return a string (always succeeds).
- */
-const char *config_GetDataDir( const vlc_object_t *p_this )
-{
-#if defined (WIN32) || defined (UNDER_CE)
-    return p_this->p_libvlc->psz_vlcpath;
-#elif defined(__APPLE__) || defined (SYS_BEOS)
-    static char path[PATH_MAX] = "";
-
-    if( *path == '\0' )
-    {
-        snprintf( path, sizeof( path ), "%s/share",
-                  p_this->p_libvlc->psz_vlcpath );
-        path[sizeof( path ) - 1] = '\0';
-    }
-    return path;
-#else
-    return DATA_PATH;
-#endif
-}
-
-/*****************************************************************************
- * config_GetHomeDir, config_GetUserDir: find the user's home directory.
- *****************************************************************************
- * This function will try by different ways to find the user's home path.
- * Note that this function is not reentrant, it should be called only once
- * at the beginning of main where the result will be stored for later use.
- *****************************************************************************/
-static char *GetDir( vlc_bool_t b_appdata )
-{
-    char *psz_localhome = NULL;
-
-#if defined(HAVE_GETPWUID)
-    struct passwd *p_pw = NULL;
-#endif
-
-#if defined(WIN32) && !defined(UNDER_CE)
-    typedef HRESULT (WINAPI *SHGETFOLDERPATH)( HWND, int, HANDLE, DWORD,
-                                               LPSTR );
-#ifndef CSIDL_FLAG_CREATE
-#   define CSIDL_FLAG_CREATE 0x8000
-#endif
-#ifndef CSIDL_APPDATA
-#   define CSIDL_APPDATA 0x1A
-#endif
-#ifndef CSIDL_PROFILE
-#   define CSIDL_PROFILE 0x28
-#endif
-#ifndef SHGFP_TYPE_CURRENT
-#   define SHGFP_TYPE_CURRENT 0
-#endif
-
-    HINSTANCE shfolder_dll;
-    SHGETFOLDERPATH SHGetFolderPath ;
-
-    /* load the shfolder dll to retrieve SHGetFolderPath */
-    if( ( shfolder_dll = LoadLibrary( _T("SHFolder.dll") ) ) != NULL )
-    {
-        SHGetFolderPath = (void *)GetProcAddress( shfolder_dll,
-                                                  _T("SHGetFolderPathA") );
-        if ( SHGetFolderPath != NULL )
-        {
-            char psz_ACPhome[MAX_PATH];
-
-            /* get the "Application Data" folder for the current user */
-            if( S_OK == SHGetFolderPath( NULL,
-                                         (b_appdata ? CSIDL_APPDATA :
-                                           CSIDL_PROFILE) | CSIDL_FLAG_CREATE,
-                                         NULL, SHGFP_TYPE_CURRENT,
-                                         psz_ACPhome ) )
-            {
-                FreeLibrary( shfolder_dll );
-                return FromLocaleDup( psz_ACPhome );
-            }
-        }
-        FreeLibrary( shfolder_dll );
-    }
-
-#elif defined(UNDER_CE)
-
-#ifndef CSIDL_APPDATA
-#   define CSIDL_APPDATA 0x1A
-#endif
-
-    wchar_t p_whomedir[MAX_PATH];
-
-    /* get the "Application Data" folder for the current user */
-    if( SHGetSpecialFolderPath( NULL, p_whomedir, CSIDL_APPDATA, 1 ) )
-    {
-        char psz_ACPhome[2 * MAX_PATH];
-
-        sprintf( psz_ACPhome, "%ls", p_whomedir );
-        return FromLocaleDup( psz_ACPhome );
-    }
-#endif
-
-#if defined(HAVE_GETPWUID)
-    if( ( p_pw = getpwuid( getuid() ) ) == NULL )
-#endif
-    {
-        psz_localhome = getenv( "HOME" );
-        if( psz_localhome == NULL )
-        {
-            psz_localhome = getenv( "TMP" );
-            if( psz_localhome == NULL )
-                psz_localhome = "/tmp";
-        }
-    }
-#if defined(HAVE_GETPWUID)
-    else
-        psz_localhome = p_pw->pw_dir;
-#endif
-
-    return FromLocaleDup( psz_localhome );
-}
-
-char *config_GetHomeDir( void )
-{
-    return GetDir( VLC_TRUE );
-}
-
-char *config_GetUserDir( void )
-{
-    return GetDir( VLC_FALSE );
-}
-
-
-static int ConfigStringToKey( char *psz_key )
-{
-    int i_key = 0;
-    unsigned int i;
-    char *psz_parser = strchr( psz_key, '-' );
-    while( psz_parser && psz_parser != psz_key )
-    {
-        for( i = 0; i < sizeof(vlc_modifiers) / sizeof(key_descriptor_t); i++ )
-        {
-            if( !strncasecmp( vlc_modifiers[i].psz_key_string, psz_key,
-                              strlen( vlc_modifiers[i].psz_key_string ) ) )
-            {
-                i_key |= vlc_modifiers[i].i_key_code;
-            }
-        }
-        psz_key = psz_parser + 1;
-        psz_parser = strchr( psz_key, '-' );
-    }
-    for( i = 0; i < sizeof(vlc_keys) / sizeof( key_descriptor_t ); i++ )
-    {
-        if( !strcasecmp( vlc_keys[i].psz_key_string, psz_key ) )
-        {
-            i_key |= vlc_keys[i].i_key_code;
-            break;
-        }
-    }
-    return i_key;
-}
-
-static char *ConfigKeyToString( int i_key )
-{
-    char *psz_key = malloc( 100 );
-    char *p;
-    size_t index;
-
-    if ( !psz_key )
-    {
-        return NULL;
-    }
-    *psz_key = '\0';
-    p = psz_key;
-    for( index = 0; index < (sizeof(vlc_modifiers) / sizeof(key_descriptor_t));
-         index++ )
-    {
-        if( i_key & vlc_modifiers[index].i_key_code )
-        {
-            p += sprintf( p, "%s-", vlc_modifiers[index].psz_key_string );
-        }
-    }
-    for( index = 0; index < (sizeof(vlc_keys) / sizeof( key_descriptor_t));
-         index++)
-    {
-        if( (int)( i_key & ~KEY_MODIFIER ) == vlc_keys[index].i_key_code )
-        {
-            p += sprintf( p, "%s", vlc_keys[index].psz_key_string );
-            break;
-        }
-    }
-    return psz_key;
-}
+/*****************************************************************************
+ * configuration.c management of the modules configuration
+ *****************************************************************************
+ * Copyright (C) 2001-2004 the VideoLAN team
+ * $Id: configuration.c 19493 2007-03-27 08:41:07Z jpsaman $
+ *
+ * Authors: Gildas Bazin <gbazin@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <vlc/vlc.h>
+#include "vlc_keys.h"
+#include "charset.h"
+
+#include <stdio.h>                                              /* sprintf() */
+#include <stdlib.h>                                      /* free(), strtol() */
+#include <string.h>                                              /* strdup() */
+#include <errno.h>                                                  /* errno */
+
+#ifdef HAVE_LIMITS_H
+#   include <limits.h>
+#endif
+
+#ifdef HAVE_UNISTD_H
+#    include <unistd.h>                                          /* getuid() */
+#endif
+
+#ifdef HAVE_GETOPT_LONG
+#   ifdef HAVE_GETOPT_H
+#       include <getopt.h>                                       /* getopt() */
+#   endif
+#else
+#   include "../extras/getopt.h"
+#endif
+
+#if defined(HAVE_GETPWUID)
+#   include <pwd.h>                                            /* getpwuid() */
+#endif
+
+#if defined( HAVE_SYS_STAT_H )
+#   include <sys/stat.h>
+#endif
+#if defined( HAVE_SYS_TYPES_H )
+#   include <sys/types.h>
+#endif
+#if defined( WIN32 )
+#   if !defined( UNDER_CE )
+#       include <direct.h>
+#   endif
+/* BEGIN SONGBIRD EDIT */
+#   if !defined(CSIDL_COMMON_APPDATA)
+#      define CSIDL_COMMON_APPDATA (0x0023)
+#   endif
+/* END SONGBIRD EDIT */
+#include <tchar.h>
+#endif
+
+#if defined( WIN32 ) || defined( UNDER_CE )
+#   define DIR_SEP "\\"
+#else
+#   define DIR_SEP "/"
+#endif
+
+static int ConfigStringToKey( char * );
+static char *ConfigKeyToString( int );
+
+/*****************************************************************************
+ * config_GetType: get the type of a variable (bool, int, float, string)
+ *****************************************************************************
+ * This function is used to get the type of a variable from its name.
+ * Beware, this is quite slow.
+ *****************************************************************************/
+int __config_GetType( vlc_object_t *p_this, const char *psz_name )
+{
+    module_config_t *p_config;
+    int i_type;
+
+    p_config = config_FindConfig( p_this, psz_name );
+
+    /* sanity checks */
+    if( !p_config )
+    {
+        return 0;
+    }
+
+    switch( p_config->i_type )
+    {
+    case CONFIG_ITEM_BOOL:
+        i_type = VLC_VAR_BOOL;
+        break;
+
+    case CONFIG_ITEM_INTEGER:
+        i_type = VLC_VAR_INTEGER;
+        break;
+
+    case CONFIG_ITEM_FLOAT:
+        i_type = VLC_VAR_FLOAT;
+        break;
+
+    case CONFIG_ITEM_MODULE:
+    case CONFIG_ITEM_MODULE_CAT:
+    case CONFIG_ITEM_MODULE_LIST:
+    case CONFIG_ITEM_MODULE_LIST_CAT:
+        i_type = VLC_VAR_MODULE;
+        break;
+
+    case CONFIG_ITEM_STRING:
+        i_type = VLC_VAR_STRING;
+        break;
+
+    case CONFIG_ITEM_FILE:
+        i_type = VLC_VAR_FILE;
+        break;
+
+    case CONFIG_ITEM_DIRECTORY:
+        i_type = VLC_VAR_DIRECTORY;
+        break;
+
+    default:
+        i_type = 0;
+        break;
+    }
+
+    return i_type;
+}
+
+/*****************************************************************************
+ * config_GetInt: get the value of an int variable
+ *****************************************************************************
+ * This function is used to get the value of variables which are internally
+ * represented by an integer (CONFIG_ITEM_INTEGER and
+ * CONFIG_ITEM_BOOL).
+ *****************************************************************************/
+int __config_GetInt( vlc_object_t *p_this, const char *psz_name )
+{
+    module_config_t *p_config;
+
+    p_config = config_FindConfig( p_this, psz_name );
+
+    /* sanity checks */
+    if( !p_config )
+    {
+        msg_Err( p_this, "option %s does not exist", psz_name );
+        return -1;
+    }
+    if( (p_config->i_type!=CONFIG_ITEM_INTEGER) &&
+        (p_config->i_type!=CONFIG_ITEM_KEY) &&
+        (p_config->i_type!=CONFIG_ITEM_BOOL) )
+    {
+        msg_Err( p_this, "option %s does not refer to an int", psz_name );
+        return -1;
+    }
+
+    return p_config->i_value;
+}
+
+/*****************************************************************************
+ * config_GetFloat: get the value of a float variable
+ *****************************************************************************
+ * This function is used to get the value of variables which are internally
+ * represented by a float (CONFIG_ITEM_FLOAT).
+ *****************************************************************************/
+float __config_GetFloat( vlc_object_t *p_this, const char *psz_name )
+{
+    module_config_t *p_config;
+
+    p_config = config_FindConfig( p_this, psz_name );
+
+    /* sanity checks */
+    if( !p_config )
+    {
+        msg_Err( p_this, "option %s does not exist", psz_name );
+        return -1;
+    }
+    if( p_config->i_type != CONFIG_ITEM_FLOAT )
+    {
+        msg_Err( p_this, "option %s does not refer to a float", psz_name );
+        return -1;
+    }
+
+    return p_config->f_value;
+}
+
+/*****************************************************************************
+ * config_GetPsz: get the string value of a string variable
+ *****************************************************************************
+ * This function is used to get the value of variables which are internally
+ * represented by a string (CONFIG_ITEM_STRING, CONFIG_ITEM_FILE,
+ * CONFIG_ITEM_DIRECTORY, and CONFIG_ITEM_MODULE).
+ *
+ * Important note: remember to free() the returned char* because it's a
+ *   duplicate of the actual value. It isn't safe to return a pointer to the
+ *   actual value as it can be modified at any time.
+ *****************************************************************************/
+char * __config_GetPsz( vlc_object_t *p_this, const char *psz_name )
+{
+    module_config_t *p_config;
+    char *psz_value = NULL;
+
+    p_config = config_FindConfig( p_this, psz_name );
+
+    /* sanity checks */
+    if( !p_config )
+    {
+        msg_Err( p_this, "option %s does not exist", psz_name );
+        return NULL;
+    }
+    if( (p_config->i_type!=CONFIG_ITEM_STRING) &&
+        (p_config->i_type!=CONFIG_ITEM_FILE) &&
+        (p_config->i_type!=CONFIG_ITEM_DIRECTORY) &&
+        (p_config->i_type!=CONFIG_ITEM_MODULE_LIST) &&
+        (p_config->i_type!=CONFIG_ITEM_MODULE_LIST_CAT) &&
+        (p_config->i_type!=CONFIG_ITEM_MODULE_CAT) &&
+        (p_config->i_type!=CONFIG_ITEM_MODULE) )
+    {
+        msg_Err( p_this, "option %s does not refer to a string", psz_name );
+        return NULL;
+    }
+
+
+    /* return a copy of the string */
+    vlc_mutex_lock( p_config->p_lock );
+    if( p_config->psz_value ) psz_value = strdup( p_config->psz_value );
+    vlc_mutex_unlock( p_config->p_lock );
+
+    return psz_value;
+}
+
+/*****************************************************************************
+ * config_PutPsz: set the string value of a string variable
+ *****************************************************************************
+ * This function is used to set the value of variables which are internally
+ * represented by a string (CONFIG_ITEM_STRING, CONFIG_ITEM_FILE,
+ * CONFIG_ITEM_DIRECTORY, and CONFIG_ITEM_MODULE).
+ *****************************************************************************/
+void __config_PutPsz( vlc_object_t *p_this,
+                      const char *psz_name, const char *psz_value )
+{
+    module_config_t *p_config;
+    vlc_value_t oldval, val;
+
+    p_config = config_FindConfig( p_this, psz_name );
+
+
+    /* sanity checks */
+    if( !p_config )
+    {
+        msg_Warn( p_this, "option %s does not exist", psz_name );
+        return;
+    }
+    if( (p_config->i_type!=CONFIG_ITEM_STRING) &&
+        (p_config->i_type!=CONFIG_ITEM_FILE) &&
+        (p_config->i_type!=CONFIG_ITEM_DIRECTORY) &&
+        (p_config->i_type!=CONFIG_ITEM_MODULE_LIST) &&
+        (p_config->i_type!=CONFIG_ITEM_MODULE_CAT) &&
+        (p_config->i_type!=CONFIG_ITEM_MODULE_LIST_CAT) &&
+        (p_config->i_type!=CONFIG_ITEM_MODULE) )
+    {
+        msg_Err( p_this, "option %s does not refer to a string", psz_name );
+        return;
+    }
+
+    vlc_mutex_lock( p_config->p_lock );
+
+    /* backup old value */
+    oldval.psz_string = p_config->psz_value;
+
+    if( psz_value && *psz_value ) p_config->psz_value = strdup( psz_value );
+    else p_config->psz_value = NULL;
+
+    p_config->b_dirty = VLC_TRUE;
+
+    val.psz_string = p_config->psz_value;
+
+    vlc_mutex_unlock( p_config->p_lock );
+
+    if( p_config->pf_callback )
+    {
+        p_config->pf_callback( p_this, psz_name, oldval, val,
+                               p_config->p_callback_data );
+    }
+
+    /* free old string */
+    if( oldval.psz_string ) free( oldval.psz_string );
+}
+
+/*****************************************************************************
+ * config_PutInt: set the integer value of an int variable
+ *****************************************************************************
+ * This function is used to set the value of variables which are internally
+ * represented by an integer (CONFIG_ITEM_INTEGER and
+ * CONFIG_ITEM_BOOL).
+ *****************************************************************************/
+void __config_PutInt( vlc_object_t *p_this, const char *psz_name, int i_value )
+{
+    module_config_t *p_config;
+    vlc_value_t oldval, val;
+
+    p_config = config_FindConfig( p_this, psz_name );
+
+    /* sanity checks */
+    if( !p_config )
+    {
+        msg_Warn( p_this, "option %s does not exist", psz_name );
+        return;
+    }
+    if( (p_config->i_type!=CONFIG_ITEM_INTEGER) &&
+        (p_config->i_type!=CONFIG_ITEM_KEY) &&
+        (p_config->i_type!=CONFIG_ITEM_BOOL) )
+    {
+        msg_Err( p_this, "option %s does not refer to an int", psz_name );
+        return;
+    }
+
+    /* backup old value */
+    oldval.i_int = p_config->i_value;
+
+    /* if i_min == i_max == 0, then do not use them */
+    if ((p_config->i_min == 0) && (p_config->i_max == 0))
+    {
+        p_config->i_value = i_value;
+    }
+    else if (i_value < p_config->i_min)
+    {
+        p_config->i_value = p_config->i_min;
+    }
+    else if (i_value > p_config->i_max)
+    {
+        p_config->i_value = p_config->i_max;
+    }
+    else
+    {
+        p_config->i_value = i_value;
+    }
+
+    p_config->b_dirty = VLC_TRUE;
+
+    val.i_int = p_config->i_value;
+
+    if( p_config->pf_callback )
+    {
+        p_config->pf_callback( p_this, psz_name, oldval, val,
+                               p_config->p_callback_data );
+    }
+}
+
+/*****************************************************************************
+ * config_PutFloat: set the value of a float variable
+ *****************************************************************************
+ * This function is used to set the value of variables which are internally
+ * represented by a float (CONFIG_ITEM_FLOAT).
+ *****************************************************************************/
+void __config_PutFloat( vlc_object_t *p_this,
+                        const char *psz_name, float f_value )
+{
+    module_config_t *p_config;
+    vlc_value_t oldval, val;
+
+    p_config = config_FindConfig( p_this, psz_name );
+
+    /* sanity checks */
+    if( !p_config )
+    {
+        msg_Warn( p_this, "option %s does not exist", psz_name );
+        return;
+    }
+    if( p_config->i_type != CONFIG_ITEM_FLOAT )
+    {
+        msg_Err( p_this, "option %s does not refer to a float", psz_name );
+        return;
+    }
+
+    /* backup old value */
+    oldval.f_float = p_config->f_value;
+
+    /* if f_min == f_max == 0, then do not use them */
+    if ((p_config->f_min == 0) && (p_config->f_max == 0))
+    {
+        p_config->f_value = f_value;
+    }
+    else if (f_value < p_config->f_min)
+    {
+        p_config->f_value = p_config->f_min;
+    }
+    else if (f_value > p_config->f_max)
+    {
+        p_config->f_value = p_config->f_max;
+    }
+    else
+    {
+        p_config->f_value = f_value;
+    }
+
+    p_config->b_dirty = VLC_TRUE;
+
+    val.f_float = p_config->f_value;
+
+    if( p_config->pf_callback )
+    {
+        p_config->pf_callback( p_this, psz_name, oldval, val,
+                               p_config->p_callback_data );
+    }
+}
+
+/*****************************************************************************
+ * config_FindConfig: find the config structure associated with an option.
+ *****************************************************************************
+ * FIXME: This function really needs to be optimized.
+ * FIXME: And now even more.
+ *****************************************************************************/
+module_config_t *config_FindConfig( vlc_object_t *p_this, const char *psz_name )
+{
+    vlc_list_t *p_list;
+    module_t *p_parser;
+    module_config_t *p_item;
+    int i_index;
+
+    if( !psz_name ) return NULL;
+
+    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
+
+    for( i_index = 0; i_index < p_list->i_count; i_index++ )
+    {
+        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
+
+        if( !p_parser->i_config_items )
+            continue;
+
+        for( p_item = p_parser->p_config;
+             p_item->i_type != CONFIG_HINT_END;
+             p_item++ )
+        {
+            if( p_item->i_type & CONFIG_HINT )
+                /* ignore hints */
+                continue;
+            if( !strcmp( psz_name, p_item->psz_name ) )
+            {
+                vlc_list_release( p_list );
+                return p_item;
+            }
+        }
+    }
+
+    vlc_list_release( p_list );
+
+    return NULL;
+}
+
+/*****************************************************************************
+ * config_FindModule: find a specific module structure.
+ *****************************************************************************/
+module_t *config_FindModule( vlc_object_t *p_this, const char *psz_name )
+{
+    vlc_list_t *p_list;
+    module_t *p_module, *p_result = NULL;
+    int i_index;
+
+    if( !psz_name ) return NULL;
+
+    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
+
+    for( i_index = 0; i_index < p_list->i_count; i_index++ )
+    {
+        p_module = (module_t *)p_list->p_values[i_index].p_object;
+        if( !strcmp( p_module->psz_object_name, psz_name ) )
+        {
+             p_result = p_module;
+             break;
+        }
+    }
+
+    vlc_list_release( p_list );
+
+    return p_result;
+}
+
+/*****************************************************************************
+ * config_Duplicate: creates a duplicate of a module's configuration data.
+ *****************************************************************************
+ * Unfortunatly we cannot work directly with the module's config data as
+ * this module might be unloaded from memory at any time (remember HideModule).
+ * This is why we need to create an exact copy of the config data.
+ *****************************************************************************/
+void config_Duplicate( module_t *p_module, module_config_t *p_orig )
+{
+    int i, j, i_lines = 1;
+    module_config_t *p_item;
+
+    /* Calculate the structure length */
+    p_module->i_config_items = 0;
+    p_module->i_bool_items = 0;
+
+    for( p_item = p_orig; p_item->i_type != CONFIG_HINT_END; p_item++ )
+    {
+        i_lines++;
+
+        if( p_item->i_type & CONFIG_ITEM )
+        {
+            p_module->i_config_items++;
+        }
+
+        if( p_item->i_type == CONFIG_ITEM_BOOL )
+        {
+            p_module->i_bool_items++;
+        }
+    }
+
+    /* Allocate memory */
+    p_module->p_config = (module_config_t *)malloc( sizeof(module_config_t)
+                                                     * i_lines );
+    if( p_module->p_config == NULL )
+    {
+        msg_Err( p_module, "config error: can't duplicate p_config" );
+        return;
+    }
+
+    /* Do the duplication job */
+    for( i = 0; i < i_lines ; i++ )
+    {
+        p_module->p_config[i] = p_orig[i];
+
+        p_module->p_config[i].i_value_orig = p_orig[i].i_value;
+        p_module->p_config[i].f_value_orig = p_orig[i].f_value;
+        p_module->p_config[i].i_value_saved = p_orig[i].i_value;
+        p_module->p_config[i].f_value_saved = p_orig[i].f_value;
+        p_module->p_config[i].psz_value_saved = 0;
+
+        p_module->p_config[i].psz_type = p_orig[i].psz_type ?
+                                   strdup( p_orig[i].psz_type ) : NULL;
+        p_module->p_config[i].psz_name = p_orig[i].psz_name ?
+                                   strdup( p_orig[i].psz_name ) : NULL;
+        p_module->p_config[i].psz_current = p_orig[i].psz_current?
+                                   strdup( p_orig[i].psz_current ) : NULL;
+        p_module->p_config[i].psz_text = p_orig[i].psz_text ?
+                                   strdup( _(p_orig[i].psz_text) ) : NULL;
+        p_module->p_config[i].psz_longtext = p_orig[i].psz_longtext ?
+                                   strdup( _(p_orig[i].psz_longtext) ) : NULL;
+        p_module->p_config[i].psz_value = p_orig[i].psz_value ?
+                                   strdup( p_orig[i].psz_value ) : NULL;
+        p_module->p_config[i].psz_value_orig = p_orig[i].psz_value ?
+                                   strdup( p_orig[i].psz_value ) : NULL;
+
+        p_module->p_config[i].p_lock = &p_module->object_lock;
+
+        /* duplicate the string list */
+        if( p_orig[i].i_list )
+        {
+            if( p_orig[i].ppsz_list )
+            {
+                p_module->p_config[i].ppsz_list =
+                    malloc( (p_orig[i].i_list + 1) * sizeof(char *) );
+                if( p_module->p_config[i].ppsz_list )
+                {
+                    for( j = 0; j < p_orig[i].i_list; j++ )
+                        p_module->p_config[i].ppsz_list[j] = p_orig[i].ppsz_list[j] ?
+                            strdup( p_orig[i].ppsz_list[j] ) : NULL ;
+                    p_module->p_config[i].ppsz_list[j] = NULL;
+                }
+            }
+            if( p_orig[i].ppsz_list_text )
+            {
+                p_module->p_config[i].ppsz_list_text =
+                    malloc( (p_orig[i].i_list + 1) * sizeof(char *) );
+                if( p_module->p_config[i].ppsz_list_text )
+                {
+                    for( j = 0; j < p_orig[i].i_list; j++ )
+                        p_module->p_config[i].ppsz_list_text[j] = _(p_orig[i].ppsz_list_text[j]) ?
+                            strdup( _(p_orig[i].ppsz_list_text[j] ) ) : NULL ;
+                    p_module->p_config[i].ppsz_list_text[j] = NULL;
+                }
+            }
+            if( p_orig[i].pi_list )
+            {
+                p_module->p_config[i].pi_list =
+                    malloc( (p_orig[i].i_list + 1) * sizeof(int) );
+                if( p_module->p_config[i].pi_list )
+                {
+                    for( j = 0; j < p_orig[i].i_list; j++ )
+                        p_module->p_config[i].pi_list[j] =
+                            p_orig[i].pi_list[j];
+                }
+            }
+        }
+
+        /* duplicate the actions list */
+        if( p_orig[i].i_action )
+        {
+            int j;
+
+            p_module->p_config[i].ppf_action =
+                malloc( p_orig[i].i_action * sizeof(void *) );
+            p_module->p_config[i].ppsz_action_text =
+                malloc( p_orig[i].i_action * sizeof(char *) );
+
+            for( j = 0; j < p_orig[i].i_action; j++ )
+            {
+                p_module->p_config[i].ppf_action[j] =
+                    p_orig[i].ppf_action[j];
+                p_module->p_config[i].ppsz_action_text[j] =
+                    p_orig[i].ppsz_action_text[j] ?
+                    strdup( p_orig[i].ppsz_action_text[j] ) : NULL;
+            }
+        }
+
+        p_module->p_config[i].pf_callback = p_orig[i].pf_callback;
+    }
+}
+
+/*****************************************************************************
+ * config_Free: frees a duplicated module's configuration data.
+ *****************************************************************************
+ * This function frees all the data duplicated by config_Duplicate.
+ *****************************************************************************/
+void config_Free( module_t *p_module )
+{
+    module_config_t *p_item = p_module->p_config;
+    int i;
+
+    if( p_item == NULL )
+    {
+        return;
+    }
+
+    for( ; p_item->i_type != CONFIG_HINT_END ; p_item++ )
+    {
+        if( p_item->psz_type )
+            free( p_item->psz_type );
+
+        if( p_item->psz_name )
+            free( p_item->psz_name );
+
+        if( p_item->psz_current )
+            free( p_item->psz_current );
+
+        if( p_item->psz_text )
+            free( p_item->psz_text );
+
+        if( p_item->psz_longtext )
+            free( p_item->psz_longtext );
+
+        if( p_item->psz_value )
+            free( p_item->psz_value );
+
+        if( p_item->psz_value_orig )
+            free( p_item->psz_value_orig );
+
+        if( p_item->psz_value_saved )
+            free( p_item->psz_value_saved );
+
+        if( p_item->i_list )
+        {
+            for( i = 0; i < p_item->i_list; i++ )
+            {
+                if( p_item->ppsz_list && p_item->ppsz_list[i] )
+                    free( p_item->ppsz_list[i] );
+                if( p_item->ppsz_list_text && p_item->ppsz_list_text[i] )
+                    free( p_item->ppsz_list_text[i] );
+            }
+            if( p_item->ppsz_list ) free( p_item->ppsz_list );
+            if( p_item->ppsz_list_text ) free( p_item->ppsz_list_text );
+            if( p_item->pi_list ) free( p_item->pi_list );
+        }
+
+        if( p_item->i_action )
+        {
+            for( i = 0; i < p_item->i_action; i++ )
+            {
+                if( p_item->ppsz_action_text[i] )
+                    free( p_item->ppsz_action_text[i] );
+            }
+            if( p_item->ppf_action ) free( p_item->ppf_action );
+            if( p_item->ppsz_action_text ) free( p_item->ppsz_action_text );
+        }
+    }
+
+    free( p_module->p_config );
+    p_module->p_config = NULL;
+}
+
+/*****************************************************************************
+ * config_SetCallbacks: sets callback functions in the duplicate p_config.
+ *****************************************************************************
+ * Unfortunatly we cannot work directly with the module's config data as
+ * this module might be unloaded from memory at any time (remember HideModule).
+ * This is why we need to duplicate callbacks each time we reload the module.
+ *****************************************************************************/
+void config_SetCallbacks( module_config_t *p_new, module_config_t *p_orig )
+{
+    while( p_new->i_type != CONFIG_HINT_END )
+    {
+        p_new->pf_callback = p_orig->pf_callback;
+        p_new++;
+        p_orig++;
+    }
+}
+
+/*****************************************************************************
+ * config_UnsetCallbacks: unsets callback functions in the duplicate p_config.
+ *****************************************************************************
+ * We simply undo what we did in config_SetCallbacks.
+ *****************************************************************************/
+void config_UnsetCallbacks( module_config_t *p_new )
+{
+    while( p_new->i_type != CONFIG_HINT_END )
+    {
+        p_new->pf_callback = NULL;
+        p_new++;
+    }
+}
+
+/*****************************************************************************
+ * config_ResetAll: reset the configuration data for all the modules.
+ *****************************************************************************/
+void __config_ResetAll( vlc_object_t *p_this )
+{
+    int i_index, i;
+    vlc_list_t *p_list;
+    module_t *p_module;
+
+    /* Acquire config file lock */
+    vlc_mutex_lock( &p_this->p_vlc->config_lock );
+
+    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
+
+    for( i_index = 0; i_index < p_list->i_count; i_index++ )
+    {
+        p_module = (module_t *)p_list->p_values[i_index].p_object ;
+        if( p_module->b_submodule ) continue;
+
+        for( i = 0; p_module->p_config[i].i_type != CONFIG_HINT_END; i++ )
+        {
+            p_module->p_config[i].i_value = p_module->p_config[i].i_value_orig;
+            p_module->p_config[i].f_value = p_module->p_config[i].f_value_orig;
+            if( p_module->p_config[i].psz_value )
+                free( p_module->p_config[i].psz_value );
+            p_module->p_config[i].psz_value =
+                p_module->p_config[i].psz_value_orig ?
+                strdup( p_module->p_config[i].psz_value_orig ) : NULL;
+        }
+    }
+
+    vlc_list_release( p_list );
+    vlc_mutex_unlock( &p_this->p_vlc->config_lock );
+}
+
+/*****************************************************************************
+ * config_LoadConfigFile: loads the configuration file.
+ *****************************************************************************
+ * This function is called to load the config options stored in the config
+ * file.
+ *****************************************************************************/
+int __config_LoadConfigFile( vlc_object_t *p_this, const char *psz_module_name )
+{
+    vlc_list_t *p_list;
+    module_t *p_parser;
+    module_config_t *p_item;
+    FILE *file;
+    char line[1024];
+    char *p_index, *psz_option_name, *psz_option_value;
+    char *psz_filename, *psz_homedir, *psz_configfile;
+    int i_index;
+
+    psz_configfile = p_this->p_vlc->psz_configfile;
+    if( !psz_configfile || !psz_configfile )
+    {
+        psz_homedir = p_this->p_vlc->psz_homedir;
+        if( !psz_homedir )
+        {
+            msg_Err( p_this, "psz_homedir is null" );
+            return -1;
+        }
+        psz_filename = (char *)malloc( sizeof("/" CONFIG_DIR "/" CONFIG_FILE) +
+                                       strlen(psz_homedir) );
+        if( psz_filename )
+            sprintf( psz_filename,
+                     "%s" DIR_SEP CONFIG_DIR DIR_SEP CONFIG_FILE,
+                     psz_homedir );
+    }
+    else
+    {
+        psz_filename = strdup( psz_configfile );
+    }
+
+    if( !psz_filename )
+    {
+        msg_Err( p_this, "out of memory" );
+        return -1;
+    }
+
+    msg_Dbg( p_this, "opening config file %s", psz_filename );
+
+    /* Acquire config file lock */
+    vlc_mutex_lock( &p_this->p_vlc->config_lock );
+
+    file = utf8_fopen( psz_filename, "rt" );
+    if( !file )
+    {
+        msg_Warn( p_this, "config file %s does not exist yet", psz_filename );
+        free( psz_filename );
+        vlc_mutex_unlock( &p_this->p_vlc->config_lock );
+        return -1;
+    }
+
+    /* Look for the selected module, if NULL then save everything */
+    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
+
+    for( i_index = 0; i_index < p_list->i_count; i_index++ )
+    {
+        char * (*convert) (const char *) = FromLocaleDup;
+        char bom[3];
+
+        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
+
+        if( psz_module_name
+             && strcmp( psz_module_name, p_parser->psz_object_name ) )
+        {
+            continue;
+        }
+
+        /* The config file is organized in sections, one per module. Look for
+         * the interesting section ( a section is of the form [foo] ) */
+        fseek( file, 0L, SEEK_SET );
+
+        /* Look for UTF-8 Byte Order Mark */
+
+        if ((fread (bom, 1, 3, file) == 3)
+         && (memcmp (bom, "\xEF\xBB\xBF", 3) == 0))
+            convert = strdup;
+        else
+            rewind (file); // no BOM, rewind
+
+        while( fgets( line, 1024, file ) )
+        {
+            if( (line[0] == '[')
+               && (p_index = strchr(line,']'))
+               && (p_index - &line[1]
+                    == (int)strlen(p_parser->psz_object_name))
+               && !memcmp( &line[1], p_parser->psz_object_name,
+                           strlen(p_parser->psz_object_name) ) )
+            {
+#if 0
+                msg_Dbg( p_this, "loading config for module \"%s\"",
+                                 p_parser->psz_object_name );
+#endif
+
+                break;
+            }
+        }
+        /* either we found the section or we're at the EOF */
+
+        /* Now try to load the options in this section */
+        while( fgets( line, 1024, file ) )
+        {
+            if( line[0] == '[' ) break; /* end of section */
+
+            /* ignore comments or empty lines */
+            if( (line[0] == '#') || (line[0] == '\n') || (line[0] == (char)0) )
+                continue;
+
+            /* get rid of line feed */
+            if( line[strlen(line)-1] == '\n' )
+                line[strlen(line)-1] = (char)0;
+
+            /* look for option name */
+            psz_option_name = line;
+            psz_option_value = NULL;
+            p_index = strchr( line, '=' );
+            if( !p_index ) break; /* this ain't an option!!! */
+
+            *p_index = (char)0;
+            psz_option_value = p_index + 1;
+
+            if( !p_parser->i_config_items )
+            {
+                continue;
+            }
+
+            /* try to match this option with one of the module's options */
+            for( p_item = p_parser->p_config;
+                 p_item->i_type != CONFIG_HINT_END;
+                 p_item++ )
+            {
+                if( p_item->i_type & CONFIG_HINT )
+                    /* ignore hints */
+                    continue;
+
+                if( !strcmp( p_item->psz_name, psz_option_name ) )
+                {
+                    /* We found it */
+                    switch( p_item->i_type )
+                    {
+                    case CONFIG_ITEM_BOOL:
+                    case CONFIG_ITEM_INTEGER:
+                        if( !*psz_option_value )
+                            break;                    /* ignore empty option */
+                        p_item->i_value = strtol( psz_option_value, 0, 0 );
+                        p_item->i_value_saved = p_item->i_value;
+#if 0
+                        msg_Dbg( p_this, "option \"%s\", value %i",
+                                 p_item->psz_name, p_item->i_value );
+#endif
+                        break;
+
+                    case CONFIG_ITEM_FLOAT:
+                        if( !*psz_option_value )
+                            break;                    /* ignore empty option */
+                        p_item->f_value = (float)i18n_atof( psz_option_value);
+                        p_item->f_value_saved = p_item->f_value;
+#if 0
+                        msg_Dbg( p_this, "option \"%s\", value %f",
+                                 p_item->psz_name, (double)p_item->f_value );
+#endif
+                        break;
+                    case CONFIG_ITEM_KEY:
+                        if( !*psz_option_value )
+                            break;                    /* ignore empty option */
+                        p_item->i_value = ConfigStringToKey(psz_option_value);
+                        p_item->i_value_saved = p_item->i_value;
+                        break;
+
+                    default:
+                        vlc_mutex_lock( p_item->p_lock );
+
+                        /* free old string */
+                        if( p_item->psz_value )
+                            free( p_item->psz_value );
+
+                        p_item->psz_value = *psz_option_value ?
+                            convert( psz_option_value ) : NULL;
+
+                        if( p_item->psz_value_saved )
+                            free( p_item->psz_value_saved );
+                        p_item->psz_value_saved = 0;
+                        if( !p_item->psz_value || !p_item->psz_value_orig ||
+                            (p_item->psz_value && p_item->psz_value_orig &&
+                             strcmp(p_item->psz_value,p_item->psz_value_orig)))
+                            p_item->psz_value_saved = p_item->psz_value ?
+                                strdup( p_item->psz_value ) : 0;
+
+                        vlc_mutex_unlock( p_item->p_lock );
+
+#if 0
+                        msg_Dbg( p_this, "option \"%s\", value \"%s\"",
+                                 p_item->psz_name,
+                                 p_item->psz_value ? p_item->psz_value : "" );
+#endif
+                        break;
+                    }
+                }
+            }
+        }
+
+    }
+
+    vlc_list_release( p_list );
+
+    fclose( file );
+    free( psz_filename );
+
+    vlc_mutex_unlock( &p_this->p_vlc->config_lock );
+
+    return 0;
+}
+
+/*****************************************************************************
+ * config_CreateDir: Create configuration directory if it doesn't exist.
+ *****************************************************************************/
+int config_CreateDir( vlc_object_t *p_this, const char *psz_dirname )
+{
+    if( !psz_dirname && !*psz_dirname ) return -1;
+
+    if( utf8_mkdir( psz_dirname ) && ( errno != EEXIST ) )
+    {
+        msg_Err( p_this, "could not create %s (%s)",
+                 psz_dirname, strerror(errno) );
+        return -1;
+    }
+
+    return 0;
+}
+
+/*****************************************************************************
+ * config_SaveConfigFile: Save a module's config options.
+ *****************************************************************************
+ * This will save the specified module's config options to the config file.
+ * If psz_module_name is NULL then we save all the modules config options.
+ * It's no use to save the config options that kept their default values, so
+ * we'll try to be a bit clever here.
+ *
+ * When we save we mustn't delete the config options of the modules that
+ * haven't been loaded. So we cannot just create a new config file with the
+ * config structures we've got in memory.
+ * I don't really know how to deal with this nicely, so I will use a completly
+ * dumb method ;-)
+ * I will load the config file in memory, but skipping all the sections of the
+ * modules we want to save. Then I will create a brand new file, dump the file
+ * loaded in memory and then append the sections of the modules we want to
+ * save.
+ * Really stupid no ?
+ *****************************************************************************/
+static int SaveConfigFile( vlc_object_t *p_this, const char *psz_module_name,
+                           vlc_bool_t b_autosave )
+{
+    module_t *p_parser;
+    vlc_list_t *p_list;
+    module_config_t *p_item;
+    FILE *file;
+    char p_line[1024], *p_index2;
+    int i_sizebuf = 0;
+    char *p_bigbuffer, *p_index;
+    vlc_bool_t b_backup;
+    char *psz_filename, *psz_homedir, *psz_configfile;
+    int i_index;
+
+    /* Acquire config file lock */
+    vlc_mutex_lock( &p_this->p_vlc->config_lock );
+
+    psz_configfile = p_this->p_vlc->psz_configfile;
+    if( !psz_configfile || !psz_configfile )
+    {
+        psz_homedir = p_this->p_vlc->psz_homedir;
+        if( !psz_homedir )
+        {
+            msg_Err( p_this, "psz_homedir is null" );
+            vlc_mutex_unlock( &p_this->p_vlc->config_lock );
+            return -1;
+        }
+        psz_filename = (char *)malloc( sizeof("/" CONFIG_DIR "/" CONFIG_FILE) +
+                                       strlen(psz_homedir) );
+
+        if( psz_filename )
+            sprintf( psz_filename, "%s" DIR_SEP CONFIG_DIR, psz_homedir );
+
+        if( !psz_filename )
+        {
+            msg_Err( p_this, "out of memory" );
+            vlc_mutex_unlock( &p_this->p_vlc->config_lock );
+            return -1;
+        }
+
+        config_CreateDir( p_this, psz_filename );
+
+        strcat( psz_filename, DIR_SEP CONFIG_FILE );
+    }
+    else
+    {
+        psz_filename = strdup( psz_configfile );
+        if( !psz_filename )
+        {
+            msg_Err( p_this, "out of memory" );
+            vlc_mutex_unlock( &p_this->p_vlc->config_lock );
+            return -1;
+        }
+    }
+
+    msg_Dbg( p_this, "opening config file %s", psz_filename );
+
+    file = utf8_fopen( psz_filename, "rt" );
+    if( !file )
+    {
+        msg_Warn( p_this, "config file %s does not exist yet", psz_filename );
+    }
+    else
+    {
+        /* look for file size */
+        fseek( file, 0L, SEEK_END );
+        i_sizebuf = ftell( file );
+        fseek( file, 0L, SEEK_SET );
+    }
+
+    p_bigbuffer = p_index = malloc( i_sizebuf+1 );
+    if( !p_bigbuffer )
+    {
+        msg_Err( p_this, "out of memory" );
+        if( file ) fclose( file );
+        free( psz_filename );
+        vlc_mutex_unlock( &p_this->p_vlc->config_lock );
+        return -1;
+    }
+    p_bigbuffer[0] = 0;
+
+    /* List all available modules */
+    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
+
+    /* backup file into memory, we only need to backup the sections we won't
+     * save later on */
+    b_backup = 0;
+    while( file && fgets( p_line, 1024, file ) )
+    {
+        if( (p_line[0] == '[') && (p_index2 = strchr(p_line,']')))
+        {
+
+            /* we found a section, check if we need to do a backup */
+            for( i_index = 0; i_index < p_list->i_count; i_index++ )
+            {
+                p_parser = (module_t *)p_list->p_values[i_index].p_object ;
+
+                if( ((p_index2 - &p_line[1])
+                       == (int)strlen(p_parser->psz_object_name) )
+                    && !memcmp( &p_line[1], p_parser->psz_object_name,
+                                strlen(p_parser->psz_object_name) ) )
+                {
+                    if( !psz_module_name )
+                        break;
+                    else if( !strcmp( psz_module_name,
+                                      p_parser->psz_object_name ) )
+                        break;
+                }
+            }
+
+            if( i_index == p_list->i_count )
+            {
+                /* we don't have this section in our list so we need to back
+                 * it up */
+                *p_index2 = 0;
+#if 0
+                msg_Dbg( p_this, "backing up config for unknown module \"%s\"",
+                                 &p_line[1] );
+#endif
+                *p_index2 = ']';
+
+                b_backup = 1;
+            }
+            else
+            {
+                b_backup = 0;
+            }
+        }
+
+        /* save line if requested and line is valid (doesn't begin with a
+         * space, tab, or eol) */
+        if( b_backup && (p_line[0] != '\n') && (p_line[0] != ' ')
+            && (p_line[0] != '\t') )
+        {
+            strcpy( p_index, p_line );
+            p_index += strlen( p_line );
+        }
+    }
+    if( file ) fclose( file );
+
+
+    /*
+     * Save module config in file
+     */
+
+    file = utf8_fopen( psz_filename, "wt" );
+    if( !file )
+    {
+        msg_Warn( p_this, "could not open config file %s for writing",
+                          psz_filename );
+        free( psz_filename );
+        vlc_list_release( p_list );
+        vlc_mutex_unlock( &p_this->p_vlc->config_lock );
+        return -1;
+    }
+    
+#ifdef WIN32
+    /* Ugly kludge to not save --started-from-file (and not break the ABI). 
+     * See [17898] and   #871 */
+    /* Just use the first mofule found*/
+    config_PutInt( (module_t *)p_list->p_values[0].p_object, 
+                   "started-from-file", 0 );
+
+#endif
+
+    fprintf( file, "\xEF\xBB\xBF###\n###  " COPYRIGHT_MESSAGE "\n###\n\n"
+       "###\n### lines begining with a '#' character are comments\n###\n\n" );
+
+    /* Look for the selected module, if NULL then save everything */
+    for( i_index = 0; i_index < p_list->i_count; i_index++ )
+    {
+        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
+
+        if( psz_module_name && strcmp( psz_module_name,
+                                       p_parser->psz_object_name ) )
+            continue;
+
+        if( !p_parser->i_config_items )
+            continue;
+
+        if( psz_module_name )
+            msg_Dbg( p_this, "saving config for module \"%s\"",
+                     p_parser->psz_object_name );
+
+        fprintf( file, "[%s]", p_parser->psz_object_name );
+        if( p_parser->psz_longname )
+            fprintf( file, " # %s\n\n", p_parser->psz_longname );
+        else
+            fprintf( file, "\n\n" );
+
+        for( p_item = p_parser->p_config;
+             p_item->i_type != CONFIG_HINT_END;
+             p_item++ )
+        {
+            char  *psz_key;
+            int   i_value = p_item->i_value;
+            float f_value = p_item->f_value;
+            char  *psz_value = p_item->psz_value;
+
+            if( p_item->i_type & CONFIG_HINT )
+                /* ignore hints */
+                continue;
+            /* Ignore deprecated options */
+            if( p_item->psz_current )
+                continue;
+            if( b_autosave && !p_item->b_autosave )
+            {
+                i_value = p_item->i_value_saved;
+                f_value = p_item->f_value_saved;
+                psz_value = p_item->psz_value_saved;
+                if( !psz_value ) psz_value = p_item->psz_value_orig;
+            }
+            else
+            {
+                p_item->b_dirty = VLC_FALSE;
+            }
+
+            switch( p_item->i_type )
+            {
+            case CONFIG_ITEM_BOOL:
+            case CONFIG_ITEM_INTEGER:
+                if( p_item->psz_text )
+                    fprintf( file, "# %s (%s)\n", p_item->psz_text,
+                             (p_item->i_type == CONFIG_ITEM_BOOL) ?
+                             _("boolean") : _("integer") );
+                if( i_value == p_item->i_value_orig )
+                    fputc( '#', file );
+                fprintf( file, "%s=%i\n", p_item->psz_name, i_value );
+
+                p_item->i_value_saved = i_value;
+                break;
+
+            case CONFIG_ITEM_KEY:
+                if( p_item->psz_text )
+                    fprintf( file, "# %s (%s)\n", p_item->psz_text,
+                             _("key") );
+                if( i_value == p_item->i_value_orig )
+                    fputc( '#', file );
+                psz_key = ConfigKeyToString( i_value );
+                fprintf( file, "%s=%s\n", p_item->psz_name,
+                         psz_key ? psz_key : "" );
+                if ( psz_key ) free( psz_key );
+
+                p_item->i_value_saved = i_value;
+                break;
+
+            case CONFIG_ITEM_FLOAT:
+                if( p_item->psz_text )
+                    fprintf( file, "# %s (%s)\n", p_item->psz_text,
+                             _("float") );
+                if( f_value == p_item->f_value_orig )
+                    fputc( '#', file );
+                fprintf( file, "%s=%f\n", p_item->psz_name, (double)f_value );
+
+                p_item->f_value_saved = f_value;
+                break;
+
+            default:
+                if( p_item->psz_text )
+                    fprintf( file, "# %s (%s)\n", p_item->psz_text,
+                             _("string") );
+                if( (!psz_value && !p_item->psz_value_orig) ||
+                    (psz_value && p_item->psz_value_orig &&
+                     !strcmp( psz_value, p_item->psz_value_orig )) )
+                    fputc( '#', file );
+                fprintf( file, "%s=%s\n", p_item->psz_name,
+                         psz_value ? psz_value : "" );
+
+                if( b_autosave && !p_item->b_autosave ) break;
+
+                if( p_item->psz_value_saved ) free( p_item->psz_value_saved );
+                p_item->psz_value_saved = 0;
+                if( (psz_value && p_item->psz_value_orig &&
+                     strcmp( psz_value, p_item->psz_value_orig )) ||
+                    !psz_value || !p_item->psz_value_orig)
+                    p_item->psz_value_saved = psz_value ? strdup(psz_value):0;
+            }
+        }
+
+        fputc( '\n', file );
+    }
+
+    vlc_list_release( p_list );
+
+    /*
+     * Restore old settings from the config in file
+     */
+    fputs( p_bigbuffer, file );
+    free( p_bigbuffer );
+
+    fclose( file );
+    free( psz_filename );
+    vlc_mutex_unlock( &p_this->p_vlc->config_lock );
+
+    return 0;
+}
+
+int config_AutoSaveConfigFile( vlc_object_t *p_this )
+{
+    vlc_list_t *p_list;
+    module_t *p_parser;
+    module_config_t *p_item;
+    int i_index, i_count;
+
+    /* Check if there's anything to save */
+    vlc_mutex_lock( &p_this->p_vlc->config_lock );
+    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
+    i_count = p_list->i_count;
+    for( i_index = 0; i_index < i_count; i_index++ )
+    {
+        p_parser = (module_t *)p_list->p_values[i_index].p_object ;
+
+        if( !p_parser->i_config_items ) continue;
+
+        for( p_item = p_parser->p_config;
+             p_item->i_type != CONFIG_HINT_END;
+             p_item++ )
+        {
+            if( p_item->b_autosave && p_item->b_dirty ) break;
+        }
+        if( p_item->i_type != CONFIG_HINT_END ) break;
+    }
+    vlc_list_release( p_list );
+    vlc_mutex_unlock( &p_this->p_vlc->config_lock );
+
+    if( i_index == i_count ) return VLC_SUCCESS;
+    return SaveConfigFile( p_this, 0, VLC_TRUE );
+}
+
+int __config_SaveConfigFile( vlc_object_t *p_this, const char *psz_module_name )
+{
+    return SaveConfigFile( p_this, psz_module_name, VLC_FALSE );
+}
+
+/*****************************************************************************
+ * config_LoadCmdLine: parse command line
+ *****************************************************************************
+ * Parse command line for configuration options.
+ * Now that the module_bank has been initialized, we can dynamically
+ * generate the longopts structure used by getops. We have to do it this way
+ * because we don't know (and don't want to know) in advance the configuration
+ * options used (ie. exported) by each module.
+ *****************************************************************************/
+int __config_LoadCmdLine( vlc_object_t *p_this, int *pi_argc, char *ppsz_argv[],
+                          vlc_bool_t b_ignore_errors )
+{
+    int i_cmd, i_index, i_opts, i_shortopts, flag, i_verbose = 0;
+    module_t *p_parser;
+    vlc_list_t *p_list;
+    module_config_t *p_item;
+    struct option *p_longopts;
+    int i_modules_index;
+
+    /* Short options */
+    module_config_t *pp_shortopts[256];
+    char *psz_shortopts;
+
+    /* Set default configuration and copy arguments */
+    p_this->p_vlc->i_argc    = *pi_argc;
+    p_this->p_vlc->ppsz_argv = ppsz_argv;
+
+#ifdef __APPLE__
+    /* When VLC.app is run by double clicking in Mac OS X, the 2nd arg
+     * is the PSN - process serial number (a unique PID-ish thingie)
+     * still ok for real Darwin & when run from command line */
+    if ( (*pi_argc > 1) && (strncmp( ppsz_argv[ 1 ] , "-psn" , 4 ) == 0) )
+                                        /* for example -psn_0_9306113 */
+    {
+        /* GDMF!... I can't do this or else the MacOSX window server will
+         * not pick up the PSN and not register the app and we crash...
+         * hence the following kludge otherwise we'll get confused w/ argv[1]
+         * being an input file name */
+#if 0
+        ppsz_argv[ 1 ] = NULL;
+#endif
+        *pi_argc = *pi_argc - 1;
+        pi_argc--;
+        return 0;
+    }
+#endif
+
+    /* List all modules */
+    p_list = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
+
+    /*
+     * Generate the longopts and shortopts structures used by getopt_long
+     */
+
+    i_opts = 0;
+    for( i_modules_index = 0; i_modules_index < p_list->i_count;
+         i_modules_index++ )
+    {
+        p_parser = (module_t *)p_list->p_values[i_modules_index].p_object ;
+
+        /* count the number of exported configuration options (to allocate
+         * longopts). We also need to allocate space for two options when
+         * dealing with boolean to allow for --foo and --no-foo */
+        i_opts += p_parser->i_config_items
+                     + 2 * p_parser->i_bool_items;
+    }
+
+    p_longopts = malloc( sizeof(struct option) * (i_opts + 1) );
+    if( p_longopts == NULL )
+    {
+        msg_Err( p_this, "out of memory" );
+        vlc_list_release( p_list );
+        return -1;
+    }
+
+    psz_shortopts = malloc( sizeof( char ) * (2 * i_opts + 1) );
+    if( psz_shortopts == NULL )
+    {
+        msg_Err( p_this, "out of memory" );
+        free( p_longopts );
+        vlc_list_release( p_list );
+        return -1;
+    }
+
+    /* If we are requested to ignore errors, then we must work on a copy
+     * of the ppsz_argv array, otherwise getopt_long will reorder it for
+     * us, ignoring the arity of the options */
+    if( b_ignore_errors )
+    {
+        ppsz_argv = (char**)malloc( *pi_argc * sizeof(char *) );
+        if( ppsz_argv == NULL )
+        {
+            msg_Err( p_this, "out of memory" );
+            free( psz_shortopts );
+            free( p_longopts );
+            vlc_list_release( p_list );
+            return -1;
+        }
+        memcpy( ppsz_argv, p_this->p_vlc->ppsz_argv,
+                *pi_argc * sizeof(char *) );
+    }
+
+    i_shortopts = 0;
+    for( i_index = 0; i_index < 256; i_index++ )
+    {
+        pp_shortopts[i_index] = NULL;
+    }
+
+    /* Fill the p_longopts and psz_shortopts structures */
+    i_index = 0;
+    for( i_modules_index = 0; i_modules_index < p_list->i_count;
+         i_modules_index++ )
+    {
+        p_parser = (module_t *)p_list->p_values[i_modules_index].p_object ;
+
+        if( !p_parser->i_config_items )
+            continue;
+
+        for( p_item = p_parser->p_config;
+             p_item->i_type != CONFIG_HINT_END;
+             p_item++ )
+        {
+            /* Ignore hints */
+            if( p_item->i_type & CONFIG_HINT )
+                continue;
+
+            /* Add item to long options */
+            p_longopts[i_index].name = strdup( p_item->psz_name );
+            if( p_longopts[i_index].name == NULL ) continue;
+            p_longopts[i_index].has_arg =
+                (p_item->i_type == CONFIG_ITEM_BOOL)?
+                                               no_argument : required_argument;
+            p_longopts[i_index].flag = &flag;
+            p_longopts[i_index].val = 0;
+            i_index++;
+
+            /* When dealing with bools we also need to add the --no-foo
+             * option */
+            if( p_item->i_type == CONFIG_ITEM_BOOL )
+            {
+                char *psz_name = malloc( strlen(p_item->psz_name) + 3 );
+                if( psz_name == NULL ) continue;
+                strcpy( psz_name, "no" );
+                strcat( psz_name, p_item->psz_name );
+
+                p_longopts[i_index].name = psz_name;
+                p_longopts[i_index].has_arg = no_argument;
+                p_longopts[i_index].flag = &flag;
+                p_longopts[i_index].val = 1;
+                i_index++;
+
+                psz_name = malloc( strlen(p_item->psz_name) + 4 );
+                if( psz_name == NULL ) continue;
+                strcpy( psz_name, "no-" );
+                strcat( psz_name, p_item->psz_name );
+
+                p_longopts[i_index].name = psz_name;
+                p_longopts[i_index].has_arg = no_argument;
+                p_longopts[i_index].flag = &flag;
+                p_longopts[i_index].val = 1;
+                i_index++;
+            }
+
+            /* If item also has a short option, add it */
+            if( p_item->i_short )
+            {
+                pp_shortopts[(int)p_item->i_short] = p_item;
+                psz_shortopts[i_shortopts] = p_item->i_short;
+                i_shortopts++;
+                if( p_item->i_type != CONFIG_ITEM_BOOL )
+                {
+                    psz_shortopts[i_shortopts] = ':';
+                    i_shortopts++;
+
+                    if( p_item->i_short == 'v' )
+                    {
+                        psz_shortopts[i_shortopts] = ':';
+                        i_shortopts++;
+                    }
+                }
+            }
+        }
+    }
+
+    /* We don't need the module list anymore */
+    vlc_list_release( p_list );
+
+    /* Close the longopts and shortopts structures */
+    memset( &p_longopts[i_index], 0, sizeof(struct option) );
+    psz_shortopts[i_shortopts] = '\0';
+
+    /*
+     * Parse the command line options
+     */
+    opterr = 0;
+    optind = 0; /* set to 0 to tell GNU getopt to reinitialize */
+    while( ( i_cmd = getopt_long( *pi_argc, ppsz_argv, psz_shortopts,
+                                  p_longopts, &i_index ) ) != EOF )
+    {
+        /* A long option has been recognized */
+        if( i_cmd == 0 )
+        {
+            module_config_t *p_conf;
+            char *psz_name = (char *)p_longopts[i_index].name;
+
+            /* Check if we deal with a --nofoo or --no-foo long option */
+            if( flag ) psz_name += psz_name[2] == '-' ? 3 : 2;
+
+            /* Store the configuration option */
+            p_conf = config_FindConfig( p_this, psz_name );
+            if( p_conf )
+            {
+                /* Check if the option is deprecated */
+                if( p_conf->psz_current )
+                {
+                    if( !strcmp(p_conf->psz_current,"SUPPRESSED") )
+                    {
+                        if( !b_ignore_errors )
+                        {
+                            fprintf(stderr,
+                                    "Warning: option --%s is no longer used.\n",
+                                    p_conf->psz_name);
+                        }
+                       continue;
+                    }
+                    if( !b_ignore_errors )
+                    {
+                        if( p_conf->b_strict )
+                        {
+                            fprintf( stderr,
+                                     "Error: option --%s is deprecated. "
+                                     "Use --%s instead.\n",
+                                     p_conf->psz_name, p_conf->psz_current);
+                            /*free */
+                            for( i_index = 0; p_longopts[i_index].name; i_index++ )
+                                free( (char *)p_longopts[i_index].name );
+
+                            free( p_longopts );
+                            free( psz_shortopts );
+                            return -1;
+                        }
+                        fprintf(stderr,
+                                "Warning: option --%s is deprecated. "
+                                "You should use --%s instead.\n",
+                                p_conf->psz_name, p_conf->psz_current);
+                    }
+                    psz_name=p_conf->psz_current;
+                    p_conf = config_FindConfig( p_this, psz_name );
+                }
+
+                switch( p_conf->i_type )
+                {
+                    case CONFIG_ITEM_STRING:
+                    case CONFIG_ITEM_FILE:
+                    case CONFIG_ITEM_DIRECTORY:
+                    case CONFIG_ITEM_MODULE:
+                    case CONFIG_ITEM_MODULE_LIST:
+                    case CONFIG_ITEM_MODULE_LIST_CAT:
+                    case CONFIG_ITEM_MODULE_CAT:
+                        config_PutPsz( p_this, psz_name, optarg );
+                        break;
+                    case CONFIG_ITEM_INTEGER:
+                        config_PutInt( p_this, psz_name, strtol(optarg, 0, 0));
+                        break;
+                    case CONFIG_ITEM_FLOAT:
+                        config_PutFloat( p_this, psz_name, (float)atof(optarg) );
+                        break;
+                    case CONFIG_ITEM_KEY:
+                        config_PutInt( p_this, psz_name, ConfigStringToKey( optarg ) );
+                        break;
+                    case CONFIG_ITEM_BOOL:
+                        config_PutInt( p_this, psz_name, !flag );
+                        break;
+                }
+                continue;
+            }
+        }
+
+        /* A short option has been recognized */
+        if( pp_shortopts[i_cmd] != NULL )
+        {
+            switch( pp_shortopts[i_cmd]->i_type )
+            {
+                case CONFIG_ITEM_STRING:
+                case CONFIG_ITEM_FILE:
+                case CONFIG_ITEM_DIRECTORY:
+                case CONFIG_ITEM_MODULE:
+                case CONFIG_ITEM_MODULE_CAT:
+                case CONFIG_ITEM_MODULE_LIST:
+                case CONFIG_ITEM_MODULE_LIST_CAT:
+                    config_PutPsz( p_this, pp_shortopts[i_cmd]->psz_name, optarg );
+                    break;
+                case CONFIG_ITEM_INTEGER:
+                    if( i_cmd == 'v' )
+                    {
+                        if( optarg )
+                        {
+                            if( *optarg == 'v' ) /* eg. -vvv */
+                            {
+                                i_verbose++;
+                                while( *optarg == 'v' )
+                                {
+                                    i_verbose++;
+                                    optarg++;
+                                }
+                            }
+                            else
+                            {
+                                i_verbose += atoi( optarg ); /* eg. -v2 */
+                            }
+                        }
+                        else
+                        {
+                            i_verbose++; /* -v */
+                        }
+                        config_PutInt( p_this, pp_shortopts[i_cmd]->psz_name,
+                                               i_verbose );
+                    }
+                    else
+                    {
+                        config_PutInt( p_this, pp_shortopts[i_cmd]->psz_name,
+                                               strtol(optarg, 0, 0) );
+                    }
+                    break;
+                case CONFIG_ITEM_BOOL:
+                    config_PutInt( p_this, pp_shortopts[i_cmd]->psz_name, 1 );
+                    break;
+            }
+
+            continue;
+        }
+
+        /* Internal error: unknown option */
+        if( !b_ignore_errors )
+        {
+            fprintf( stderr, "%s: unknown option"
+                     " or missing mandatory argument ",
+                     p_this->p_vlc->psz_object_name );
+            if( optopt )
+            {
+                fprintf( stderr, "`-%c'\n", optopt );
+            }
+            else
+            {
+                fprintf( stderr, "`%s'\n", ppsz_argv[optind-1] );
+            }
+            fprintf( stderr, "Try `%s --help' for more information.\n",
+                             p_this->p_vlc->psz_object_name );
+
+            for( i_index = 0; p_longopts[i_index].name; i_index++ )
+                free( (char *)p_longopts[i_index].name );
+            free( p_longopts );
+            free( psz_shortopts );
+            return -1;
+        }
+    }
+
+    /* Free allocated resources */
+    for( i_index = 0; p_longopts[i_index].name; i_index++ )
+        free( (char *)p_longopts[i_index].name );
+    free( p_longopts );
+    free( psz_shortopts );
+    if( b_ignore_errors ) free( ppsz_argv );
+
+    return 0;
+}
+
+/**
+ * config_GetDataDir: find directory where shared data is installed
+ *
+ * @return a string (always succeeds).
+ */
+const char *config_GetDataDir( const vlc_object_t *p_this )
+{
+#if defined (WIN32) || defined (UNDER_CE)
+    return p_this->p_libvlc->psz_vlcpath;
+#elif defined(__APPLE__) || defined (SYS_BEOS)
+    static char path[PATH_MAX] = "";
+
+    if( *path == '\0' )
+    {
+        snprintf( path, sizeof( path ), "%s/share",
+                  p_this->p_libvlc->psz_vlcpath );
+        path[sizeof( path ) - 1] = '\0';
+    }
+    return path;
+#else
+    return DATA_PATH;
+#endif
+}
+
+/*****************************************************************************
+ * config_GetHomeDir, config_GetUserDir: find the user's home directory.
+ *****************************************************************************
+ * This function will try by different ways to find the user's home path.
+ * Note that this function is not reentrant, it should be called only once
+ * at the beginning of main where the result will be stored for later use.
+ *****************************************************************************/
+static char *GetDir( vlc_bool_t b_appdata )
+{
+    char *psz_localhome = NULL;
+
+#if defined(HAVE_GETPWUID)
+    struct passwd *p_pw = NULL;
+#endif
+
+#if defined(WIN32) && !defined(UNDER_CE)
+    typedef HRESULT (WINAPI *SHGETFOLDERPATH)( HWND, int, HANDLE, DWORD,
+                                               LPSTR );
+#ifndef CSIDL_FLAG_CREATE
+#   define CSIDL_FLAG_CREATE 0x8000
+#endif
+#ifndef CSIDL_APPDATA
+#   define CSIDL_APPDATA 0x1A
+#endif
+#ifndef CSIDL_PROFILE
+#   define CSIDL_PROFILE 0x28
+#endif
+#ifndef SHGFP_TYPE_CURRENT
+#   define SHGFP_TYPE_CURRENT 0
+#endif
+
+    HINSTANCE shfolder_dll;
+    SHGETFOLDERPATH SHGetFolderPath ;
+
+    /* load the shfolder dll to retrieve SHGetFolderPath */
+    if( ( shfolder_dll = LoadLibrary( _T("SHFolder.dll") ) ) != NULL )
+    {
+        SHGetFolderPath = (void *)GetProcAddress( shfolder_dll,
+                                                  _T("SHGetFolderPathA") );
+        if ( SHGetFolderPath != NULL )
+        {
+            char psz_ACPhome[MAX_PATH];
+
+/*BEGIN SONGBIRD EDIT*/
+/* Original unmodified code block */
+/*
+            // get the "Application Data" folder for the current user
+            if( S_OK == SHGetFolderPath( NULL,
+                                         (b_appdata ? CSIDL_APPDATA :
+                                           CSIDL_PROFILE) | CSIDL_FLAG_CREATE,
+                                         NULL, SHGFP_TYPE_CURRENT,
+                                         psz_ACPhome ) )
+            {
+*/
+            /* get the "Application Data" folder for the all users */
+            if( S_OK == SHGetFolderPath( NULL,
+                                         (b_appdata ? CSIDL_COMMON_APPDATA :
+                                           CSIDL_PROFILE) | CSIDL_FLAG_CREATE,
+                                         NULL, SHGFP_TYPE_CURRENT,
+                                         psz_ACPhome ) )
+            {
+/*END SONGBIRD EDIT*/
+                FreeLibrary( shfolder_dll );
+                return FromLocaleDup( psz_ACPhome );
+            }
+        }
+        FreeLibrary( shfolder_dll );
+    }
+
+#elif defined(UNDER_CE)
+
+#ifndef CSIDL_APPDATA
+#   define CSIDL_APPDATA 0x1A
+#endif
+
+    wchar_t p_whomedir[MAX_PATH];
+
+    /* get the "Application Data" folder for the current user */
+    if( SHGetSpecialFolderPath( NULL, p_whomedir, CSIDL_APPDATA, 1 ) )
+    {
+        char psz_ACPhome[2 * MAX_PATH];
+
+        sprintf( psz_ACPhome, "%ls", p_whomedir );
+        return FromLocaleDup( psz_ACPhome );
+    }
+#endif
+
+#if defined(HAVE_GETPWUID)
+    if( ( p_pw = getpwuid( getuid() ) ) == NULL )
+#endif
+    {
+        psz_localhome = getenv( "HOME" );
+        if( psz_localhome == NULL )
+        {
+            psz_localhome = getenv( "TMP" );
+            if( psz_localhome == NULL )
+                psz_localhome = "/tmp";
+        }
+    }
+#if defined(HAVE_GETPWUID)
+    else
+        psz_localhome = p_pw->pw_dir;
+#endif
+
+    return FromLocaleDup( psz_localhome );
+}
+
+char *config_GetHomeDir( void )
+{
+    return GetDir( VLC_TRUE );
+}
+
+char *config_GetUserDir( void )
+{
+    return GetDir( VLC_FALSE );
+}
+
+
+static int ConfigStringToKey( char *psz_key )
+{
+    int i_key = 0;
+    unsigned int i;
+    char *psz_parser = strchr( psz_key, '-' );
+    while( psz_parser && psz_parser != psz_key )
+    {
+        for( i = 0; i < sizeof(vlc_modifiers) / sizeof(key_descriptor_t); i++ )
+        {
+            if( !strncasecmp( vlc_modifiers[i].psz_key_string, psz_key,
+                              strlen( vlc_modifiers[i].psz_key_string ) ) )
+            {
+                i_key |= vlc_modifiers[i].i_key_code;
+            }
+        }
+        psz_key = psz_parser + 1;
+        psz_parser = strchr( psz_key, '-' );
+    }
+    for( i = 0; i < sizeof(vlc_keys) / sizeof( key_descriptor_t ); i++ )
+    {
+        if( !strcasecmp( vlc_keys[i].psz_key_string, psz_key ) )
+        {
+            i_key |= vlc_keys[i].i_key_code;
+            break;
+        }
+    }
+    return i_key;
+}
+
+static char *ConfigKeyToString( int i_key )
+{
+    char *psz_key = malloc( 100 );
+    char *p;
+    size_t index;
+
+    if ( !psz_key )
+    {
+        return NULL;
+    }
+    *psz_key = '\0';
+    p = psz_key;
+    for( index = 0; index < (sizeof(vlc_modifiers) / sizeof(key_descriptor_t));
+         index++ )
+    {
+        if( i_key & vlc_modifiers[index].i_key_code )
+        {
+            p += sprintf( p, "%s-", vlc_modifiers[index].psz_key_string );
+        }
+    }
+    for( index = 0; index < (sizeof(vlc_keys) / sizeof( key_descriptor_t));
+         index++)
+    {
+        if( (int)( i_key & ~KEY_MODIFIER ) == vlc_keys[index].i_key_code )
+        {
+            p += sprintf( p, "%s", vlc_keys[index].psz_key_string );
+            break;
+        }
+    }
+    return psz_key;
+}

Property changes on: src\misc\configuration.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\cpu.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\darwin_specific.m
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\error.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\hashtables.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\image.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\iso-639_def.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\iso_lang.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\md5.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\messages.c
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: src/misc/modules.c
===================================================================
--- src/misc/modules.c	(revision 159)
+++ src/misc/modules.c	(working copy)
@@ -1,2193 +1,2252 @@
-/*****************************************************************************
- * modules.c : Builtin and plugin modules management functions
- *****************************************************************************
- * Copyright (C) 2001-2004 the VideoLAN team
- * $Id: modules.c 17957 2006-11-22 16:12:56Z courmisch $
- *
- * Authors: Sam Hocevar <sam@zoy.org>
- *          Ethan C. Baldridge <BaldridgeE@cadmus.com>
- *          Hans-Peter Jansen <hpj@urpla.net>
- *          Gildas Bazin <gbazin@videolan.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/* Some faulty libcs have a broken struct dirent when _FILE_OFFSET_BITS
- * is set to 64. Don't try to be cleverer. */
-#ifdef _FILE_OFFSET_BITS
-#undef _FILE_OFFSET_BITS
-#endif
-
-#include <stdlib.h>                                      /* free(), strtol() */
-#include <stdio.h>                                              /* sprintf() */
-#include <string.h>                                              /* strdup() */
-
-#include <vlc/vlc.h>
-#include <vlc/input.h>
-
-#ifdef HAVE_DIRENT_H
-#   include <dirent.h>
-#endif
-
-#ifdef HAVE_SYS_TYPES_H
-#   include <sys/types.h>
-#endif
-#ifdef HAVE_SYS_STAT_H
-#   include <sys/stat.h>
-#endif
-#ifdef HAVE_UNISTD_H
-#   include <unistd.h>
-#endif
-
-#if !defined(HAVE_DYNAMIC_PLUGINS)
-    /* no support for plugins */
-#elif defined(HAVE_DL_DYLD)
-#   if defined(HAVE_MACH_O_DYLD_H)
-#       include <mach-o/dyld.h>
-#   endif
-#elif defined(HAVE_DL_BEOS)
-#   if defined(HAVE_IMAGE_H)
-#       include <image.h>
-#   endif
-#elif defined(HAVE_DL_WINDOWS)
-#   include <windows.h>
-#elif defined(HAVE_DL_DLOPEN)
-#   if defined(HAVE_DLFCN_H) /* Linux, BSD, Hurd */
-#       include <dlfcn.h>
-#   endif
-#   if defined(HAVE_SYS_DL_H)
-#       include <sys/dl.h>
-#   endif
-#elif defined(HAVE_DL_SHL_LOAD)
-#   if defined(HAVE_DL_H)
-#       include <dl.h>
-#   endif
-#endif
-
-#include "vlc_error.h"
-
-#include "vlc_interface.h"
-#include "vlc_interaction.h"
-#include "intf_eject.h"
-
-#include "vlc_playlist.h"
-
-#include "vlc_video.h"
-#include "video_output.h"
-#include "vout_synchro.h"
-#include "vlc_spu.h"
-
-#include "audio_output.h"
-#include "aout_internal.h"
-
-#include "stream_output.h"
-#include "vlc_httpd.h"
-#include "vlc_acl.h"
-#include "vlc_tls.h"
-#include "vlc_md5.h"
-#include "vlc_xml.h"
-#include "vlc_url.h"
-
-#include "iso_lang.h"
-#include "charset.h"
-
-#include "vlc_block.h"
-
-#include "vlc_vlm.h"
-
-#include "vlc_image.h"
-#include "vlc_osd.h"
-
-#include "vlc_update.h"
-#include "vlc_strings.h"
-
-#if defined( _MSC_VER ) && defined( UNDER_CE )
-#    include "modules_builtin_evc.h"
-#elif defined( _MSC_VER )
-#    include "modules_builtin_msvc.h"
-#else
-#    include "modules_builtin.h"
-#endif
-#include "network.h"
-
-#if defined( WIN32 ) || defined( UNDER_CE )
-    /* Avoid name collisions */
-#   define LoadModule(a,b,c) LoadVlcModule(a,b,c)
-#endif
-
-/*****************************************************************************
- * Local prototypes
- *****************************************************************************/
-#ifdef HAVE_DYNAMIC_PLUGINS
-static void AllocateAllPlugins  ( vlc_object_t * );
-static void AllocatePluginDir   ( vlc_object_t *, const char *, int );
-static int  AllocatePluginFile  ( vlc_object_t *, char *, int64_t, int64_t );
-static module_t * AllocatePlugin( vlc_object_t *, char * );
-#endif
-static int  AllocateBuiltinModule( vlc_object_t *, int ( * ) ( module_t * ) );
-static int  DeleteModule ( module_t * );
-#ifdef HAVE_DYNAMIC_PLUGINS
-static void   DupModule        ( module_t * );
-static void   UndupModule      ( module_t * );
-static int    CallEntry        ( module_t * );
-static int    LoadModule       ( vlc_object_t *, char *, module_handle_t * );
-static void   CloseModule      ( module_handle_t );
-static void * GetSymbol        ( module_handle_t, const char * );
-static void   CacheLoad        ( vlc_object_t * );
-static int    CacheLoadConfig  ( module_t *, FILE * );
-static void   CacheSave        ( vlc_object_t * );
-static void   CacheSaveConfig  ( module_t *, FILE * );
-static char * CacheName        ( void );
-static void   CacheMerge       ( vlc_object_t *, module_t *, module_t * );
-static module_cache_t * CacheFind( vlc_object_t *, char *, int64_t, int64_t );
-
-#if defined(HAVE_DL_WINDOWS)
-static char * GetWindowsError  ( void );
-#endif
-#endif
-
-
-/* Sub-version number
- * (only used to avoid breakage in dev version when cache structure changes) */
-#define CACHE_SUBVERSION_NUM 1
-
-/*****************************************************************************
- * module_InitBank: create the module bank.
- *****************************************************************************
- * This function creates a module bank structure which will be filled later
- * on with all the modules found.
- *****************************************************************************/
-void __module_InitBank( vlc_object_t *p_this )
-{
-    module_bank_t *p_bank;
-    vlc_value_t  lockval;
-
-    var_Create( p_this->p_libvlc, "libvlc", VLC_VAR_MUTEX );
-    var_Get( p_this->p_libvlc, "libvlc", &lockval );
-    vlc_mutex_lock( lockval.p_address );
-    if( p_this->p_libvlc->p_module_bank )
-    {
-        p_this->p_libvlc->p_module_bank->i_usage++;
-        vlc_mutex_unlock( lockval.p_address );
-        var_Destroy( p_this->p_libvlc, "libvlc" );
-        return;
-    }
-    vlc_mutex_unlock( lockval.p_address );
-    var_Destroy( p_this->p_libvlc, "libvlc" );
-
-    p_bank = vlc_object_create( p_this, sizeof(module_bank_t) );
-    p_bank->psz_object_name = "module bank";
-    p_bank->i_usage = 1;
-    p_bank->i_cache = p_bank->i_loaded_cache = 0;
-    p_bank->pp_cache = p_bank->pp_loaded_cache = 0;
-    p_bank->b_cache = p_bank->b_cache_dirty =
-        p_bank->b_cache_delete = VLC_FALSE;
-
-    /*
-     * Store the symbols to be exported
-     */
-#if defined (HAVE_DYNAMIC_PLUGINS) && !defined (HAVE_SHARED_LIBVLC)
-    STORE_SYMBOLS( &p_bank->symbols );
-#endif
-
-    /* Everything worked, attach the object */
-    p_this->p_libvlc->p_module_bank = p_bank;
-    vlc_object_attach( p_bank, p_this->p_libvlc );
-
-    module_LoadMain( p_this );
-
-    return;
-}
-
-/*****************************************************************************
- * module_ResetBank: reset the module bank.
- *****************************************************************************
- * This function resets the module bank by unloading all unused plugin
- * modules.
- *****************************************************************************/
-void __module_ResetBank( vlc_object_t *p_this )
-{
-    msg_Err( p_this, "FIXME: module_ResetBank unimplemented" );
-    return;
-}
-
-/*****************************************************************************
- * module_EndBank: empty the module bank.
- *****************************************************************************
- * This function unloads all unused plugin modules and empties the module
- * bank in case of success.
- *****************************************************************************/
-void __module_EndBank( vlc_object_t *p_this )
-{
-    module_t * p_next;
-    vlc_value_t lockval;
-
-    var_Create( p_this->p_libvlc, "libvlc", VLC_VAR_MUTEX );
-    var_Get( p_this->p_libvlc, "libvlc", &lockval );
-    vlc_mutex_lock( lockval.p_address );
-    if( !p_this->p_libvlc->p_module_bank )
-    {
-        vlc_mutex_unlock( lockval.p_address );
-        var_Destroy( p_this->p_libvlc, "libvlc" );
-        return;
-    }
-    if( --p_this->p_libvlc->p_module_bank->i_usage )
-    {
-        vlc_mutex_unlock( lockval.p_address );
-        var_Destroy( p_this->p_libvlc, "libvlc" );
-        return;
-    }
-    vlc_mutex_unlock( lockval.p_address );
-    var_Destroy( p_this->p_libvlc, "libvlc" );
-
-    config_AutoSaveConfigFile( p_this );
-
-#ifdef HAVE_DYNAMIC_PLUGINS
-#define p_bank p_this->p_libvlc->p_module_bank
-    if( p_bank->b_cache ) CacheSave( p_this );
-    while( p_bank->i_loaded_cache-- )
-    {
-        free( p_bank->pp_loaded_cache[p_bank->i_loaded_cache]->psz_file );
-        free( p_bank->pp_loaded_cache[p_bank->i_loaded_cache] );
-    }
-    if( p_bank->pp_loaded_cache )
-        free( p_bank->pp_loaded_cache );
-
-    while( p_bank->i_cache-- )
-    {
-        free( p_bank->pp_cache[p_bank->i_cache]->psz_file );
-        free( p_bank->pp_cache[p_bank->i_cache] );
-    }
-    if( p_bank->pp_cache )
-        free( p_bank->pp_cache );
-#undef p_bank
-#endif
-
-    vlc_object_detach( p_this->p_libvlc->p_module_bank );
-
-    while( p_this->p_libvlc->p_module_bank->i_children )
-    {
-        p_next = (module_t *)p_this->p_libvlc->p_module_bank->pp_children[0];
-
-        if( DeleteModule( p_next ) )
-        {
-            /* Module deletion failed */
-            msg_Err( p_this, "module \"%s\" can't be removed, trying harder",
-                     p_next->psz_object_name );
-
-            /* We just free the module by hand. Niahahahahaha. */
-            vlc_object_detach( p_next );
-            vlc_object_destroy( p_next );
-        }
-    }
-
-    vlc_object_destroy( p_this->p_libvlc->p_module_bank );
-    p_this->p_libvlc->p_module_bank = NULL;
-
-    return;
-}
-
-/*****************************************************************************
- * module_LoadMain: load the main program info into the module bank.
- *****************************************************************************
- * This function fills the module bank structure with the main module infos.
- * This is very useful as it will allow us to consider the main program just
- * as another module, and for instance the configuration options of main will
- * be available in the module bank structure just as for every other module.
- *****************************************************************************/
-void __module_LoadMain( vlc_object_t *p_this )
-{
-    vlc_value_t lockval;
-
-    var_Create( p_this->p_libvlc, "libvlc", VLC_VAR_MUTEX );
-    var_Get( p_this->p_libvlc, "libvlc", &lockval );
-    vlc_mutex_lock( lockval.p_address );
-    if( p_this->p_libvlc->p_module_bank->b_main )
-    {
-        vlc_mutex_unlock( lockval.p_address );
-        var_Destroy( p_this->p_libvlc, "libvlc" );
-        return;
-    }
-    p_this->p_libvlc->p_module_bank->b_main = VLC_TRUE;
-    vlc_mutex_unlock( lockval.p_address );
-    var_Destroy( p_this->p_libvlc, "libvlc" );
-
-    AllocateBuiltinModule( p_this, vlc_entry__main );
-}
-
-/*****************************************************************************
- * module_LoadBuiltins: load all modules which we built with.
- *****************************************************************************
- * This function fills the module bank structure with the builtin modules.
- *****************************************************************************/
-void __module_LoadBuiltins( vlc_object_t * p_this )
-{
-    vlc_value_t lockval;
-
-    var_Create( p_this->p_libvlc, "libvlc", VLC_VAR_MUTEX );
-    var_Get( p_this->p_libvlc, "libvlc", &lockval );
-    vlc_mutex_lock( lockval.p_address );
-    if( p_this->p_libvlc->p_module_bank->b_builtins )
-    {
-        vlc_mutex_unlock( lockval.p_address );
-        var_Destroy( p_this->p_libvlc, "libvlc" );
-        return;
-    }
-    p_this->p_libvlc->p_module_bank->b_builtins = VLC_TRUE;
-    vlc_mutex_unlock( lockval.p_address );
-    var_Destroy( p_this->p_libvlc, "libvlc" );
-
-    msg_Dbg( p_this, "checking builtin modules" );
-    ALLOCATE_ALL_BUILTINS();
-}
-
-/*****************************************************************************
- * module_LoadPlugins: load all plugin modules we can find.
- *****************************************************************************
- * This function fills the module bank structure with the plugin modules.
- *****************************************************************************/
-void __module_LoadPlugins( vlc_object_t * p_this )
-{
-#ifdef HAVE_DYNAMIC_PLUGINS
-    vlc_value_t lockval;
-
-    var_Create( p_this->p_libvlc, "libvlc", VLC_VAR_MUTEX );
-    var_Get( p_this->p_libvlc, "libvlc", &lockval );
-    vlc_mutex_lock( lockval.p_address );
-    if( p_this->p_libvlc->p_module_bank->b_plugins )
-    {
-        vlc_mutex_unlock( lockval.p_address );
-        var_Destroy( p_this->p_libvlc, "libvlc" );
-        return;
-    }
-    p_this->p_libvlc->p_module_bank->b_plugins = VLC_TRUE;
-    vlc_mutex_unlock( lockval.p_address );
-    var_Destroy( p_this->p_libvlc, "libvlc" );
-
-    msg_Dbg( p_this, "checking plugin modules" );
-
-    if( config_GetInt( p_this, "plugins-cache" ) )
-        p_this->p_libvlc->p_module_bank->b_cache = VLC_TRUE;
-
-    if( p_this->p_libvlc->p_module_bank->b_cache ||
-        p_this->p_libvlc->p_module_bank->b_cache_delete ) CacheLoad( p_this );
-
-    AllocateAllPlugins( p_this );
-#endif
-}
-
-/*****************************************************************************
- * module_Need: return the best module function, given a capability list.
- *****************************************************************************
- * This function returns the module that best fits the asked capabilities.
- *****************************************************************************/
-module_t * __module_Need( vlc_object_t *p_this, const char *psz_capability,
-                          const char *psz_name, vlc_bool_t b_strict )
-{
-    typedef struct module_list_t module_list_t;
-
-    struct module_list_t
-    {
-        module_t *p_module;
-        int i_score;
-        vlc_bool_t b_force;
-        module_list_t *p_next;
-    };
-
-    module_list_t *p_list, *p_first, *p_tmp;
-    vlc_list_t *p_all;
-
-    int i_which_module, i_index = 0;
-    vlc_bool_t b_intf = VLC_FALSE;
-
-    module_t *p_module;
-
-    int   i_shortcuts = 0;
-    char *psz_shortcuts = NULL, *psz_var = NULL;
-    vlc_bool_t b_force_backup = p_this->b_force;
-
-
-    /* Deal with variables */
-    if( psz_name && psz_name[0] == '$' )
-    {
-        vlc_value_t val;
-        var_Create( p_this, psz_name + 1, VLC_VAR_MODULE | VLC_VAR_DOINHERIT );
-        var_Get( p_this, psz_name + 1, &val );
-        psz_var = val.psz_string;
-        psz_name = psz_var;
-    }
-
-    /* Count how many different shortcuts were asked for */
-    if( psz_name && *psz_name )
-    {
-        char *psz_parser, *psz_last_shortcut;
-
-        /* If the user wants none, give him none. */
-        if( !strcmp( psz_name, "none" ) )
-        {
-            if( psz_var ) free( psz_var );
-            return NULL;
-        }
-
-        i_shortcuts++;
-        psz_shortcuts = psz_last_shortcut = strdup( psz_name );
-
-        for( psz_parser = psz_shortcuts; *psz_parser; psz_parser++ )
-        {
-            if( *psz_parser == ',' )
-            {
-                 *psz_parser = '\0';
-                 i_shortcuts++;
-                 psz_last_shortcut = psz_parser + 1;
-            }
-        }
-
-        /* Check if the user wants to override the "strict" mode */
-        if( psz_last_shortcut )
-        {
-            if( !strcmp(psz_last_shortcut, "none") )
-            {
-                b_strict = VLC_TRUE;
-                i_shortcuts--;
-            }
-            else if( !strcmp(psz_last_shortcut, "any") )
-            {
-                b_strict = VLC_FALSE;
-                i_shortcuts--;
-            }
-        }
-    }
-
-    /* Sort the modules and test them */
-    p_all = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
-    p_list = malloc( p_all->i_count * sizeof( module_list_t ) );
-    p_first = NULL;
-
-    /* Parse the module list for capabilities and probe each of them */
-    for( i_which_module = 0; i_which_module < p_all->i_count; i_which_module++ )
-    {
-        int i_shortcut_bonus = 0;
-
-        p_module = (module_t *)p_all->p_values[i_which_module].p_object;
-
-        /* Test that this module can do what we need */
-        if( strcmp( p_module->psz_capability, psz_capability ) )
-        {
-            /* Don't recurse through the sub-modules because vlc_list_find()
-             * will list them anyway. */
-            continue;
-        }
-
-        /* Test if we have the required CPU */
-        if( (p_module->i_cpu & p_this->p_libvlc->i_cpu) != p_module->i_cpu )
-        {
-            continue;
-        }
-
-        /* If we required a shortcut, check this plugin provides it. */
-        if( i_shortcuts > 0 )
-        {
-            vlc_bool_t b_trash;
-            int i_dummy, i_short = i_shortcuts;
-            char *psz_name = psz_shortcuts;
-
-            /* Let's drop modules with a <= 0 score (unless they are
-             * explicitly requested) */
-            b_trash = p_module->i_score <= 0;
-
-            while( i_short > 0 )
-            {
-                for( i_dummy = 0; p_module->pp_shortcuts[i_dummy]; i_dummy++ )
-                {
-                    if( !strcasecmp( psz_name,
-                                     p_module->pp_shortcuts[i_dummy] ) )
-                    {
-                        /* Found it */
-                        b_trash = VLC_FALSE;
-                        i_shortcut_bonus = i_short * 10000;
-                        break;
-                    }
-                }
-
-                if( i_shortcut_bonus )
-                {
-                    /* We found it... remember ? */
-                    break;
-                }
-
-                /* Go to the next shortcut... This is so lame! */
-                while( *psz_name )
-                {
-                    psz_name++;
-                }
-                psz_name++;
-                i_short--;
-            }
-
-            /* If we are in "strict" mode and we couldn't
-             * find the module in the list of provided shortcuts,
-             * then kick the bastard out of here!!! */
-            if( i_short == 0 && b_strict )
-            {
-                b_trash = VLC_TRUE;
-            }
-
-            if( b_trash )
-            {
-                continue;
-            }
-        }
-        /* If we didn't require a shortcut, trash <= 0 scored plugins */
-        else if( p_module->i_score <= 0 )
-        {
-            continue;
-        }
-
-        /* Special case: test if we requested a particular intf plugin */
-        if( !i_shortcuts && p_module->psz_program
-             && !strcmp( psz_capability, "interface" )
-             && !strcmp( p_module->psz_program,
-                         p_this->p_vlc->psz_object_name ) )
-        {
-            if( !b_intf )
-            {
-                /* Remove previous non-matching plugins */
-                i_index = 0;
-                b_intf = VLC_TRUE;
-            }
-        }
-        else if( b_intf )
-        {
-            /* This one doesn't match */
-            continue;
-        }
-
-        /* Store this new module */
-        p_list[ i_index ].p_module = p_module;
-        p_list[ i_index ].i_score = p_module->i_score + i_shortcut_bonus;
-        p_list[ i_index ].b_force = i_shortcut_bonus && b_strict;
-
-        /* Add it to the modules-to-probe list */
-        if( i_index == 0 )
-        {
-            p_list[ 0 ].p_next = NULL;
-            p_first = p_list;
-        }
-        else
-        {
-            /* Ok, so at school you learned that quicksort is quick, and
-             * bubble sort sucks raw eggs. But that's when dealing with
-             * thousands of items. Here we have barely 50. */
-            module_list_t *p_newlist = p_first;
-
-            if( p_first->i_score < p_list[ i_index ].i_score )
-            {
-                p_list[ i_index ].p_next = p_first;
-                p_first = &p_list[ i_index ];
-            }
-            else
-            {
-                while( p_newlist->p_next != NULL &&
-                    p_newlist->p_next->i_score >= p_list[ i_index ].i_score )
-                {
-                    p_newlist = p_newlist->p_next;
-                }
-
-                p_list[ i_index ].p_next = p_newlist->p_next;
-                p_newlist->p_next = &p_list[ i_index ];
-            }
-        }
-
-        i_index++;
-    }
-
-    msg_Dbg( p_this, "looking for %s module: %i candidate%s", psz_capability,
-                                            i_index, i_index == 1 ? "" : "s" );
-
-    /* Lock all candidate modules */
-    p_tmp = p_first;
-    while( p_tmp != NULL )
-    {
-        vlc_object_yield( p_tmp->p_module );
-        p_tmp = p_tmp->p_next;
-    }
-
-    /* We can release the list, interesting modules were yielded */
-    vlc_list_release( p_all );
-
-    /* Parse the linked list and use the first successful module */
-    p_tmp = p_first;
-    while( p_tmp != NULL )
-    {
-#ifdef HAVE_DYNAMIC_PLUGINS
-        /* Make sure the module is loaded in mem */
-        module_t *p_module = p_tmp->p_module->b_submodule ?
-            (module_t *)p_tmp->p_module->p_parent : p_tmp->p_module;
-        if( !p_module->b_builtin && !p_module->b_loaded )
-        {
-            module_t *p_new_module =
-                AllocatePlugin( p_this, p_module->psz_filename );
-            if( p_new_module )
-            {
-                CacheMerge( p_this, p_module, p_new_module );
-                vlc_object_attach( p_new_module, p_module );
-                DeleteModule( p_new_module );
-            }
-        }
-#endif
-
-        p_this->b_force = p_tmp->b_force;
-        if( p_tmp->p_module->pf_activate
-             && p_tmp->p_module->pf_activate( p_this ) == VLC_SUCCESS )
-        {
-            break;
-        }
-
-        vlc_object_release( p_tmp->p_module );
-        p_tmp = p_tmp->p_next;
-    }
-
-    /* Store the locked module value */
-    if( p_tmp != NULL )
-    {
-        p_module = p_tmp->p_module;
-        p_tmp = p_tmp->p_next;
-    }
-    else
-    {
-        p_module = NULL;
-    }
-
-    /* Unlock the remaining modules */
-    while( p_tmp != NULL )
-    {
-        vlc_object_release( p_tmp->p_module );
-        p_tmp = p_tmp->p_next;
-    }
-
-    free( p_list );
-    p_this->b_force = b_force_backup;
-
-    if( p_module != NULL )
-    {
-        msg_Dbg( p_this, "using %s module \"%s\"",
-                 psz_capability, p_module->psz_object_name );
-    }
-    else if( p_first == NULL )
-    {
-        if( !strcmp( psz_capability, "access_demux" ) )
-        {
-            msg_Warn( p_this, "no %s module matched \"%s\"",
-                 psz_capability, (psz_name && *psz_name) ? psz_name : "any" );
-        }
-        else
-        {
-            msg_Err( p_this, "no %s module matched \"%s\"",
-                 psz_capability, (psz_name && *psz_name) ? psz_name : "any" );
-        }
-    }
-    else if( psz_name != NULL && *psz_name )
-    {
-        msg_Warn( p_this, "no %s module matching \"%s\" could be loaded",
-                  psz_capability, (psz_name && *psz_name) ? psz_name : "any" );
-    }
-
-    if( psz_shortcuts )
-    {
-        free( psz_shortcuts );
-    }
-
-    if( psz_var )
-    {
-        free( psz_var );
-    }
-
-    /* Don't forget that the module is still locked */
-    return p_module;
-}
-
-/*****************************************************************************
- * module_Unneed: decrease the usage count of a module.
- *****************************************************************************
- * This function must be called by the thread that called module_Need, to
- * decrease the reference count and allow for hiding of modules.
- *****************************************************************************/
-void __module_Unneed( vlc_object_t * p_this, module_t * p_module )
-{
-    /* Use the close method */
-    if( p_module->pf_deactivate )
-    {
-        p_module->pf_deactivate( p_this );
-    }
-
-    msg_Dbg( p_this, "removing module \"%s\"", p_module->psz_object_name );
-
-    vlc_object_release( p_module );
-
-    return;
-}
-
-/*****************************************************************************
- * Following functions are local.
- *****************************************************************************/
-
-/*****************************************************************************
- * AllocateAllPlugins: load all plugin modules we can find.
- *****************************************************************************/
-#ifdef HAVE_DYNAMIC_PLUGINS
-static void AllocateAllPlugins( vlc_object_t *p_this )
-{
-    /* Yes, there are two NULLs because we replace one with "plugin-path". */
-#if defined( WIN32 ) || defined( UNDER_CE )
-    char *path[] = { "modules", "", "plugins", 0, 0 };
-#else
-    char *path[] = { "modules", PLUGIN_PATH, "plugins", 0, 0 };
-#endif
-
-    char **ppsz_path = path;
-    char *psz_fullpath;
-
-    /* If the user provided a plugin path, we add it to the list */
-    path[ sizeof(path)/sizeof(char*) - 2 ] =
-        config_GetPsz( p_this, "plugin-path" );
-
-    for( ; *ppsz_path != NULL ; ppsz_path++ )
-    {
-        if( !(*ppsz_path)[0] ) continue;
-
-#if defined( SYS_BEOS ) || defined( __APPLE__ ) || defined( WIN32 )
-
-        /* Handle relative as well as absolute paths */
-#ifdef WIN32
-        if( (*ppsz_path)[0] != '\\' && (*ppsz_path)[0] != '/' &&
-            (*ppsz_path)[1] != ':' )
-#else
-        if( (*ppsz_path)[0] != '/' )
-#endif
-        {
-            int i_dirlen = strlen( *ppsz_path );
-            i_dirlen += strlen( p_this->p_libvlc->psz_vlcpath ) + 2;
-
-            psz_fullpath = malloc( i_dirlen );
-            if( psz_fullpath == NULL )
-            {
-                continue;
-            }
-#ifdef WIN32
-            sprintf( psz_fullpath, "%s\\%s",
-                     p_this->p_libvlc->psz_vlcpath, *ppsz_path );
-#else
-            sprintf( psz_fullpath, "%s/%s",
-                     p_this->p_libvlc->psz_vlcpath, *ppsz_path );
-#endif
-        }
-        else
-#endif
-        {
-            psz_fullpath = strdup( *ppsz_path );
-        }
-
-        msg_Dbg( p_this, "recursively browsing `%s'", psz_fullpath );
-
-        /* Don't go deeper than 5 subdirectories */
-        AllocatePluginDir( p_this, psz_fullpath, 5 );
-
-        free( psz_fullpath );
-    }
-
-    /* Free plugin-path */
-    if( path[ sizeof(path)/sizeof(char*) - 2 ] )
-        free( path[ sizeof(path)/sizeof(char*) - 2 ] );
-    path[ sizeof(path)/sizeof(char*) - 2 ] = NULL;
-}
-
-/*****************************************************************************
- * AllocatePluginDir: recursively parse a directory to look for plugins
- *****************************************************************************/
-static void AllocatePluginDir( vlc_object_t *p_this, const char *psz_dir,
-                               int i_maxdepth )
-{
-#if defined( UNDER_CE ) || defined( _MSC_VER )
-#ifdef UNDER_CE
-    wchar_t psz_wpath[MAX_PATH + 256];
-    wchar_t psz_wdir[MAX_PATH];
-#endif
-    char psz_path[MAX_PATH + 256];
-    WIN32_FIND_DATA finddata;
-    HANDLE handle;
-    int rc;
-#else
-    int    i_dirlen;
-    DIR *  dir;
-    struct dirent * file;
-#endif
-    char * psz_file;
-
-    if( p_this->p_vlc->b_die || i_maxdepth < 0 )
-    {
-        return;
-    }
-
-#if defined( UNDER_CE ) || defined( _MSC_VER )
-#ifdef UNDER_CE
-    MultiByteToWideChar( CP_ACP, 0, psz_dir, -1, psz_wdir, MAX_PATH );
-
-    rc = GetFileAttributes( psz_wdir );
-    if( rc<0 || !(rc&FILE_ATTRIBUTE_DIRECTORY) ) return; /* Not a directory */
-
-    /* Parse all files in the directory */
-    swprintf( psz_wpath, L"%ls\\*", psz_wdir );
-#else
-    rc = GetFileAttributes( psz_dir );
-    if( rc<0 || !(rc&FILE_ATTRIBUTE_DIRECTORY) ) return; /* Not a directory */
-#endif
-
-    /* Parse all files in the directory */
-    sprintf( psz_path, "%s\\*", psz_dir );
-
-#ifdef UNDER_CE
-    handle = FindFirstFile( psz_wpath, &finddata );
-#else
-    handle = FindFirstFile( psz_path, &finddata );
-#endif
-    if( handle == INVALID_HANDLE_VALUE )
-    {
-        /* Empty directory */
-        return;
-    }
-
-    /* Parse the directory and try to load all files it contains. */
-    do
-    {
-#ifdef UNDER_CE
-        unsigned int i_len = wcslen( finddata.cFileName );
-        swprintf( psz_wpath, L"%ls\\%ls", psz_wdir, finddata.cFileName );
-        sprintf( psz_path, "%s\\%ls", psz_dir, finddata.cFileName );
-#else
-        unsigned int i_len = strlen( finddata.cFileName );
-        sprintf( psz_path, "%s\\%s", psz_dir, finddata.cFileName );
-#endif
-
-        /* Skip ".", ".." */
-        if( !*finddata.cFileName || !strcmp( finddata.cFileName, "." )
-         || !strcmp( finddata.cFileName, ".." ) )
-        {
-            if( !FindNextFile( handle, &finddata ) ) break;
-            continue;
-        }
-
-#ifdef UNDER_CE
-        if( GetFileAttributes( psz_wpath ) & FILE_ATTRIBUTE_DIRECTORY )
-#else
-        if( GetFileAttributes( psz_path ) & FILE_ATTRIBUTE_DIRECTORY )
-#endif
-        {
-            AllocatePluginDir( p_this, psz_path, i_maxdepth - 1 );
-        }
-        else if( i_len > strlen( LIBEXT )
-                  /* We only load files ending with LIBEXT */
-                  && !strncasecmp( psz_path + strlen( psz_path)
-                                   - strlen( LIBEXT ),
-                                   LIBEXT, strlen( LIBEXT ) ) )
-        {
-            WIN32_FILE_ATTRIBUTE_DATA attrbuf;
-            int64_t i_time = 0, i_size = 0;
-
-#ifdef UNDER_CE
-            if( GetFileAttributesEx( psz_wpath, GetFileExInfoStandard,
-                                     &attrbuf ) )
-#else
-            if( GetFileAttributesEx( psz_path, GetFileExInfoStandard,
-                                     &attrbuf ) )
-#endif
-            {
-                i_time = attrbuf.ftLastWriteTime.dwHighDateTime;
-                i_time <<= 32;
-                i_time |= attrbuf.ftLastWriteTime.dwLowDateTime;
-                i_size = attrbuf.nFileSizeHigh;
-                i_size <<= 32;
-                i_size |= attrbuf.nFileSizeLow;
-            }
-            psz_file = psz_path;
-
-            AllocatePluginFile( p_this, psz_file, i_time, i_size );
-        }
-    }
-    while( !p_this->p_vlc->b_die && FindNextFile( handle, &finddata ) );
-
-    /* Close the directory */
-    FindClose( handle );
-
-#else
-    dir = opendir( psz_dir );
-    if( !dir )
-    {
-        return;
-    }
-
-    i_dirlen = strlen( psz_dir );
-
-    /* Parse the directory and try to load all files it contains. */
-    while( !p_this->p_vlc->b_die && (file = readdir( dir )) )
-    {
-        struct stat statbuf;
-        unsigned int i_len;
-        int i_stat;
-
-        /* Skip ".", ".." */
-        if( !*file->d_name || !strcmp( file->d_name, "." )
-         || !strcmp( file->d_name, ".." ) )
-        {
-            continue;
-        }
-
-        i_len = strlen( file->d_name );
-        psz_file = malloc( i_dirlen + 1 + i_len + 1 );
-#ifdef WIN32
-        sprintf( psz_file, "%s\\%s", psz_dir, file->d_name );
-#else
-        sprintf( psz_file, "%s/%s", psz_dir, file->d_name );
-#endif
-
-        i_stat = stat( psz_file, &statbuf );
-        if( !i_stat && statbuf.st_mode & S_IFDIR )
-        {
-            AllocatePluginDir( p_this, psz_file, i_maxdepth - 1 );
-        }
-        else if( i_len > strlen( LIBEXT )
-                  /* We only load files ending with LIBEXT */
-                  && !strncasecmp( file->d_name + i_len - strlen( LIBEXT ),
-                                   LIBEXT, strlen( LIBEXT ) ) )
-        {
-            int64_t i_time = 0, i_size = 0;
-
-            if( !i_stat )
-            {
-                i_time = statbuf.st_mtime;
-                i_size = statbuf.st_size;
-            }
-
-            AllocatePluginFile( p_this, psz_file, i_time, i_size );
-        }
-
-        free( psz_file );
-    }
-
-    /* Close the directory */
-    closedir( dir );
-
-#endif
-}
-
-/*****************************************************************************
- * AllocatePluginFile: load a module into memory and initialize it.
- *****************************************************************************
- * This function loads a dynamically loadable module and allocates a structure
- * for its information data. The module can then be handled by module_Need
- * and module_Unneed. It can be removed by DeleteModule.
- *****************************************************************************/
-static int AllocatePluginFile( vlc_object_t * p_this, char * psz_file,
-                               int64_t i_file_time, int64_t i_file_size )
-{
-    module_t * p_module;
-    module_cache_t *p_cache_entry = NULL;
-
-    /*
-     * Check our plugins cache first then load plugin if needed
-     */
-    p_cache_entry =
-        CacheFind( p_this, psz_file, i_file_time, i_file_size );
-
-    if( !p_cache_entry )
-    {
-        p_module = AllocatePlugin( p_this, psz_file );
-    }
-    else
-    {
-        /* If junk dll, don't try to load it */
-        if( p_cache_entry->b_junk )
-        {
-            p_module = NULL;
-        }
-        else
-        {
-            module_config_t *p_item;
-
-            p_module = p_cache_entry->p_module;
-            p_module->b_loaded = VLC_FALSE;
-
-            /* For now we force loading if the module's config contains
-             * callbacks or actions.
-             * Could be optimized by adding an API call.*/
-            for( p_item = p_module->p_config;
-                 p_item->i_type != CONFIG_HINT_END; p_item++ )
-            {
-                if( p_item->pf_callback || p_item->i_action )
-                    p_module = AllocatePlugin( p_this, psz_file );
-            }
-        }
-    }
-
-    if( p_module )
-    {
-        /* Everything worked fine !
-         * The module is ready to be added to the list. */
-        p_module->b_builtin = VLC_FALSE;
-
-        /* msg_Dbg( p_this, "plugin \"%s\", %s",
-                    p_module->psz_object_name, p_module->psz_longname ); */
-
-        vlc_object_attach( p_module, p_this->p_libvlc->p_module_bank );
-    }
-
-    if( !p_this->p_libvlc->p_module_bank->b_cache ) return 0;
-
-    /* Add entry to cache */
-#define p_bank p_this->p_libvlc->p_module_bank
-    p_bank->pp_cache =
-        realloc( p_bank->pp_cache, (p_bank->i_cache + 1) * sizeof(void *) );
-    p_bank->pp_cache[p_bank->i_cache] = malloc( sizeof(module_cache_t) );
-    p_bank->pp_cache[p_bank->i_cache]->psz_file = strdup( psz_file );
-    p_bank->pp_cache[p_bank->i_cache]->i_time = i_file_time;
-    p_bank->pp_cache[p_bank->i_cache]->i_size = i_file_size;
-    p_bank->pp_cache[p_bank->i_cache]->b_junk = p_module ? 0 : 1;
-    p_bank->pp_cache[p_bank->i_cache]->p_module = p_module;
-    p_bank->i_cache++;
-
-    return p_module ? 0 : -1;
-}
-
-/*****************************************************************************
- * AllocatePlugin: load a module into memory and initialize it.
- *****************************************************************************
- * This function loads a dynamically loadable module and allocates a structure
- * for its information data. The module can then be handled by module_Need
- * and module_Unneed. It can be removed by DeleteModule.
- *****************************************************************************/
-static module_t * AllocatePlugin( vlc_object_t * p_this, char * psz_file )
-{
-    module_t * p_module;
-    module_handle_t handle;
-
-    if( LoadModule( p_this, psz_file, &handle ) ) return NULL;
-
-    /* Now that we have successfully loaded the module, we can
-     * allocate a structure for it */
-    p_module = vlc_object_create( p_this, VLC_OBJECT_MODULE );
-    if( p_module == NULL )
-    {
-        msg_Err( p_this, "out of memory" );
-        CloseModule( handle );
-        return NULL;
-    }
-
-    /* We need to fill these since they may be needed by CallEntry() */
-    p_module->psz_filename = psz_file;
-    p_module->handle = handle;
-#ifndef HAVE_SHARED_LIBVLC
-    p_module->p_symbols = &p_this->p_libvlc->p_module_bank->symbols;
-#endif
-    p_module->b_loaded = VLC_TRUE;
-
-    /* Initialize the module: fill p_module, default config */
-    if( CallEntry( p_module ) != 0 )
-    {
-        /* We couldn't call module_init() */
-        vlc_object_destroy( p_module );
-        CloseModule( handle );
-        return NULL;
-    }
-
-    DupModule( p_module );
-    p_module->psz_filename = strdup( p_module->psz_filename );
-
-    /* Everything worked fine ! The module is ready to be added to the list. */
-    p_module->b_builtin = VLC_FALSE;
-
-    return p_module;
-}
-
-/*****************************************************************************
- * DupModule: make a plugin module standalone.
- *****************************************************************************
- * This function duplicates all strings in the module, so that the dynamic
- * object can be unloaded. It acts recursively on submodules.
- *****************************************************************************/
-static void DupModule( module_t *p_module )
-{
-    char **pp_shortcut;
-    int i_submodule;
-
-    for( pp_shortcut = p_module->pp_shortcuts ; *pp_shortcut ; pp_shortcut++ )
-    {
-        *pp_shortcut = strdup( *pp_shortcut );
-    }
-
-    /* We strdup() these entries so that they are still valid when the
-     * module is unloaded. */
-    p_module->psz_object_name = strdup( p_module->psz_object_name );
-    p_module->psz_capability = strdup( p_module->psz_capability );
-    p_module->psz_shortname = p_module->psz_shortname ?
-                                 strdup( p_module->psz_shortname ) : NULL;
-    p_module->psz_longname = strdup( p_module->psz_longname );
-
-    if( p_module->psz_program != NULL )
-    {
-        p_module->psz_program = strdup( p_module->psz_program );
-    }
-
-    for( i_submodule = 0; i_submodule < p_module->i_children; i_submodule++ )
-    {
-        DupModule( (module_t*)p_module->pp_children[ i_submodule ] );
-    }
-}
-
-/*****************************************************************************
- * UndupModule: free a duplicated module.
- *****************************************************************************
- * This function frees the allocations done in DupModule().
- *****************************************************************************/
-static void UndupModule( module_t *p_module )
-{
-    char **pp_shortcut;
-    int i_submodule;
-
-    for( i_submodule = 0; i_submodule < p_module->i_children; i_submodule++ )
-    {
-        UndupModule( (module_t*)p_module->pp_children[ i_submodule ] );
-    }
-
-    for( pp_shortcut = p_module->pp_shortcuts ; *pp_shortcut ; pp_shortcut++ )
-    {
-        free( *pp_shortcut );
-    }
-
-    free( p_module->psz_object_name );
-    free( p_module->psz_capability );
-    if( p_module->psz_shortname ) free( p_module->psz_shortname );
-    free( p_module->psz_longname );
-
-    if( p_module->psz_program != NULL )
-    {
-        free( p_module->psz_program );
-    }
-}
-
-#endif /* HAVE_DYNAMIC_PLUGINS */
-
-/*****************************************************************************
- * AllocateBuiltinModule: initialize a builtin module.
- *****************************************************************************
- * This function registers a builtin module and allocates a structure
- * for its information data. The module can then be handled by module_Need
- * and module_Unneed. It can be removed by DeleteModule.
- *****************************************************************************/
-static int AllocateBuiltinModule( vlc_object_t * p_this,
-                                  int ( *pf_entry ) ( module_t * ) )
-{
-    module_t * p_module;
-
-    /* Now that we have successfully loaded the module, we can
-     * allocate a structure for it */
-    p_module = vlc_object_create( p_this, VLC_OBJECT_MODULE );
-    if( p_module == NULL )
-    {
-        msg_Err( p_this, "out of memory" );
-        return -1;
-    }
-
-    /* Initialize the module : fill p_module->psz_object_name, etc. */
-    if( pf_entry( p_module ) != 0 )
-    {
-        /* With a well-written module we shouldn't have to print an
-         * additional error message here, but just make sure. */
-        msg_Err( p_this, "failed calling entry point in builtin module" );
-        vlc_object_destroy( p_module );
-        return -1;
-    }
-
-    /* Everything worked fine ! The module is ready to be added to the list. */
-    p_module->b_builtin = VLC_TRUE;
-
-    /* msg_Dbg( p_this, "builtin \"%s\", %s",
-                p_module->psz_object_name, p_module->psz_longname ); */
-
-    vlc_object_attach( p_module, p_this->p_libvlc->p_module_bank );
-
-    return 0;
-}
-
-/*****************************************************************************
- * DeleteModule: delete a module and its structure.
- *****************************************************************************
- * This function can only be called if the module isn't being used.
- *****************************************************************************/
-static int DeleteModule( module_t * p_module )
-{
-    vlc_object_detach( p_module );
-
-    /* We free the structures that we strdup()ed in Allocate*Module(). */
-#ifdef HAVE_DYNAMIC_PLUGINS
-    if( !p_module->b_builtin )
-    {
-        if( p_module->b_loaded && p_module->b_unloadable )
-        {
-            CloseModule( p_module->handle );
-        }
-        UndupModule( p_module );
-        free( p_module->psz_filename );
-    }
-#endif
-
-    /* Free and detach the object's children */
-    while( p_module->i_children )
-    {
-        vlc_object_t *p_this = p_module->pp_children[0];
-        vlc_object_detach( p_this );
-        vlc_object_destroy( p_this );
-    }
-
-    config_Free( p_module );
-    vlc_object_destroy( p_module );
-
-    return 0;
-}
-
-#ifdef HAVE_DYNAMIC_PLUGINS
-/*****************************************************************************
- * CallEntry: call an entry point.
- *****************************************************************************
- * This function calls a symbol given its name and a module structure. The
- * symbol MUST refer to a function returning int and taking a module_t* as
- * an argument.
- *****************************************************************************/
-static int CallEntry( module_t * p_module )
-{
-    static char *psz_name = "vlc_entry" MODULE_SUFFIX;
-    int (* pf_symbol) ( module_t * p_module );
-
-    /* Try to resolve the symbol */
-    pf_symbol = (int (*)(module_t *)) GetSymbol( p_module->handle, psz_name );
-
-    if( pf_symbol == NULL )
-    {
-#if defined(HAVE_DL_DYLD) || defined(HAVE_DL_BEOS)
-        msg_Warn( p_module, "cannot find symbol \"%s\" in file `%s'",
-                            psz_name, p_module->psz_filename );
-#elif defined(HAVE_DL_WINDOWS)
-        char *psz_error = GetWindowsError();
-        msg_Warn( p_module, "cannot find symbol \"%s\" in file `%s' (%s)",
-                            psz_name, p_module->psz_filename, psz_error );
-        free( psz_error );
-#elif defined(HAVE_DL_DLOPEN)
-        msg_Warn( p_module, "cannot find symbol \"%s\" in file `%s' (%s)",
-                            psz_name, p_module->psz_filename, dlerror() );
-#elif defined(HAVE_DL_SHL_LOAD)
-        msg_Warn( p_module, "cannot find symbol \"%s\" in file `%s' (%s)",
-                            psz_name, p_module->psz_filename, strerror(errno) );
-#else
-#   error "Something is wrong in modules.c"
-#endif
-        return -1;
-    }
-
-    /* We can now try to call the symbol */
-    if( pf_symbol( p_module ) != 0 )
-    {
-        /* With a well-written module we shouldn't have to print an
-         * additional error message here, but just make sure. */
-        msg_Err( p_module, "Failed to call symbol \"%s\" in file `%s'",
-                           psz_name, p_module->psz_filename );
-        return -1;
-    }
-
-    /* Everything worked fine, we can return */
-    return 0;
-}
-
-/*****************************************************************************
- * LoadModule: loads a dynamic library
- *****************************************************************************
- * This function loads a dynamically linked library using a system dependant
- * method. Will return 0 on success as well as the module handle.
- *****************************************************************************/
-static int LoadModule( vlc_object_t *p_this, char *psz_file,
-                       module_handle_t *p_handle )
-{
-    module_handle_t handle;
-
-#if defined(HAVE_DL_DYLD)
-    NSObjectFileImage image;
-    NSObjectFileImageReturnCode ret;
-
-    ret = NSCreateObjectFileImageFromFile( psz_file, &image );
-
-    if( ret != NSObjectFileImageSuccess )
-    {
-        msg_Warn( p_this, "cannot create image from `%s'", psz_file );
-        return -1;
-    }
-
-    /* Open the dynamic module */
-    handle = NSLinkModule( image, psz_file,
-                           NSLINKMODULE_OPTION_RETURN_ON_ERROR );
-
-    if( !handle )
-    {
-        NSLinkEditErrors errors;
-        const char *psz_file, *psz_err;
-        int i_errnum;
-        NSLinkEditError( &errors, &i_errnum, &psz_file, &psz_err );
-        msg_Warn( p_this, "cannot link module `%s' (%s)", psz_file, psz_err );
-        NSDestroyObjectFileImage( image );
-        return -1;
-    }
-
-    /* Destroy our image, we won't need it */
-    NSDestroyObjectFileImage( image );
-
-#elif defined(HAVE_DL_BEOS)
-    handle = load_add_on( psz_file );
-    if( handle < 0 )
-    {
-        msg_Warn( p_this, "cannot load module `%s'", psz_file );
-        return -1;
-    }
-
-#elif defined(HAVE_DL_WINDOWS)
-#ifdef UNDER_CE
-    {
-        wchar_t psz_wfile[MAX_PATH];
-        MultiByteToWideChar( CP_ACP, 0, psz_file, -1, psz_wfile, MAX_PATH );
-        handle = LoadLibrary( psz_wfile );
-    }
-#else
-    handle = LoadLibrary( psz_file );
-#endif
-    if( handle == NULL )
-    {
-        char *psz_err = GetWindowsError();
-        msg_Warn( p_this, "cannot load module `%s' (%s)", psz_file, psz_err );
-        free( psz_err );
-        return -1;
-    }
-
-#elif defined(HAVE_DL_DLOPEN) && defined(RTLD_NOW)
-    /* static is OK, we are called atomically */
-
-#   if defined(SYS_LINUX)
-    /* XXX HACK #1 - we should NOT open modules with RTLD_GLOBAL, or we
-     * are going to get namespace collisions when two modules have common
-     * public symbols, but ALSA is being a pest here. */
-    if( strstr( psz_file, "alsa_plugin" ) )
-    {
-        handle = dlopen( psz_file, RTLD_NOW | RTLD_GLOBAL );
-        if( handle == NULL )
-        {
-            msg_Warn( p_this, "cannot load module `%s' (%s)",
-                              psz_file, dlerror() );
-            return -1;
-        }
-    }
-#   endif
-
-    handle = dlopen( psz_file, RTLD_NOW );
-    if( handle == NULL )
-    {
-        msg_Warn( p_this, "cannot load module `%s' (%s)",
-                          psz_file, dlerror() );
-        return -1;
-    }
-
-#elif defined(HAVE_DL_DLOPEN)
-#   if defined(DL_LAZY)
-    handle = dlopen( psz_file, DL_LAZY );
-#   else
-    handle = dlopen( psz_file, 0 );
-#   endif
-    if( handle == NULL )
-    {
-        msg_Warn( p_this, "cannot load module `%s' (%s)",
-                          psz_file, dlerror() );
-        return -1;
-    }
-
-#elif defined(HAVE_DL_SHL_LOAD)
-    handle = shl_load( psz_file, BIND_IMMEDIATE | BIND_NONFATAL, NULL );
-    if( handle == NULL )
-    {
-        msg_Warn( p_this, "cannot load module `%s' (%s)",
-                          psz_file, strerror(errno) );
-        return -1;
-    }
-
-#else
-#   error "Something is wrong in modules.c"
-
-#endif
-
-    *p_handle = handle;
-    return 0;
-}
-
-/*****************************************************************************
- * CloseModule: unload a dynamic library
- *****************************************************************************
- * This function unloads a previously opened dynamically linked library
- * using a system dependant method. No return value is taken in consideration,
- * since some libraries sometimes refuse to close properly.
- *****************************************************************************/
-static void CloseModule( module_handle_t handle )
-{
-#if defined(HAVE_DL_DYLD)
-    NSUnLinkModule( handle, FALSE );
-
-#elif defined(HAVE_DL_BEOS)
-    unload_add_on( handle );
-
-#elif defined(HAVE_DL_WINDOWS)
-    FreeLibrary( handle );
-
-#elif defined(HAVE_DL_DLOPEN)
-    dlclose( handle );
-
-#elif defined(HAVE_DL_SHL_LOAD)
-    shl_unload( handle );
-
-#endif
-    return;
-}
-
-/*****************************************************************************
- * GetSymbol: get a symbol from a dynamic library
- *****************************************************************************
- * This function queries a loaded library for a symbol specified in a
- * string, and returns a pointer to it. We don't check for dlerror() or
- * similar functions, since we want a non-NULL symbol anyway.
- *****************************************************************************/
-static void * _module_getsymbol( module_handle_t, const char * );
-
-static void * GetSymbol( module_handle_t handle, const char * psz_function )
-{
-    void * p_symbol = _module_getsymbol( handle, psz_function );
-
-    /* MacOS X dl library expects symbols to begin with "_". So do
-     * some other operating systems. That's really lame, but hey, what
-     * can we do ? */
-    if( p_symbol == NULL )
-    {
-        char *psz_call = malloc( strlen( psz_function ) + 2 );
-
-        strcpy( psz_call + 1, psz_function );
-        psz_call[ 0 ] = '_';
-        p_symbol = _module_getsymbol( handle, psz_call );
-        free( psz_call );
-    }
-
-    return p_symbol;
-}
-
-static void * _module_getsymbol( module_handle_t handle,
-                                 const char * psz_function )
-{
-#if defined(HAVE_DL_DYLD)
-    NSSymbol sym = NSLookupSymbolInModule( handle, psz_function );
-    return NSAddressOfSymbol( sym );
-
-#elif defined(HAVE_DL_BEOS)
-    void * p_symbol;
-    if( B_OK == get_image_symbol( handle, psz_function,
-                                  B_SYMBOL_TYPE_TEXT, &p_symbol ) )
-    {
-        return p_symbol;
-    }
-    else
-    {
-        return NULL;
-    }
-
-#elif defined(HAVE_DL_WINDOWS) && defined(UNDER_CE)
-    wchar_t psz_real[256];
-    MultiByteToWideChar( CP_ACP, 0, psz_function, -1, psz_real, 256 );
-
-    return (void *)GetProcAddress( handle, psz_real );
-
-#elif defined(HAVE_DL_WINDOWS) && defined(WIN32)
-    return (void *)GetProcAddress( handle, (char *)psz_function );
-
-#elif defined(HAVE_DL_DLOPEN)
-    return dlsym( handle, psz_function );
-
-#elif defined(HAVE_DL_SHL_LOAD)
-    void *p_sym;
-    shl_findsym( &handle, psz_function, TYPE_UNDEFINED, &p_sym );
-    return p_sym;
-
-#endif
-}
-
-#if defined(HAVE_DL_WINDOWS)
-static char * GetWindowsError( void )
-{
-#if defined(UNDER_CE)
-    wchar_t psz_tmp[MAX_PATH];
-    char * psz_buffer = malloc( MAX_PATH );
-#else
-    char * psz_tmp = malloc( MAX_PATH );
-#endif
-    int i = 0, i_error = GetLastError();
-
-    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
-                   NULL, i_error, MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
-                   (LPTSTR)psz_tmp, MAX_PATH, NULL );
-
-    /* Go to the end of the string */
-    while( psz_tmp[i] && psz_tmp[i] != _T('\r') && psz_tmp[i] != _T('\n') )
-    {
-        i++;
-    }
-
-    if( psz_tmp[i] )
-    {
-#if defined(UNDER_CE)
-        swprintf( psz_tmp + i, L" (error %i)", i_error );
-        psz_tmp[ 255 ] = L'\0';
-#else
-        snprintf( psz_tmp + i, 256 - i, " (error %i)", i_error );
-        psz_tmp[ 255 ] = '\0';
-#endif
-    }
-
-#if defined(UNDER_CE)
-    wcstombs( psz_buffer, psz_tmp, MAX_PATH );
-    return psz_buffer;
-#else
-    return psz_tmp;
-#endif
-}
-#endif /* HAVE_DL_WINDOWS */
-
-/*****************************************************************************
- * LoadPluginsCache: loads the plugins cache file
- *****************************************************************************
- * This function will load the plugin cache if present and valid. This cache
- * will in turn be queried by AllocateAllPlugins() to see if it needs to
- * actually load the dynamically loadable module.
- * This allows us to only fully load plugins when they are actually used.
- *****************************************************************************/
-static void CacheLoad( vlc_object_t *p_this )
-{
-    char *psz_filename, *psz_homedir;
-    FILE *file;
-    int i, j, i_size, i_read;
-    char p_cachestring[sizeof(PLUGINSCACHE_DIR COPYRIGHT_MESSAGE)];
-    char p_cachelang[6], p_lang[6];
-    int i_cache;
-    module_cache_t **pp_cache = 0;
-    int32_t i_file_size, i_marker;
-
-    psz_homedir = p_this->p_vlc->psz_homedir;
-    if( !psz_homedir )
-    {
-        msg_Err( p_this, "psz_homedir is null" );
-        return;
-    }
-
-    i_size = asprintf( &psz_filename, "%s/%s/%s/%s", psz_homedir, CONFIG_DIR,
-                       PLUGINSCACHE_DIR, CacheName() );
-    if( i_size <= 0 )
-    {
-        msg_Err( p_this, "out of memory" );
-        return;
-    }
-
-    if( p_this->p_libvlc->p_module_bank->b_cache_delete )
-    {
-#if !defined( UNDER_CE )
-        unlink( psz_filename );
-#else
-        wchar_t psz_wf[MAX_PATH];
-        MultiByteToWideChar( CP_ACP, 0, psz_filename, -1, psz_wf, MAX_PATH );
-        DeleteFile( psz_wf );
-#endif
-        msg_Dbg( p_this, "removing plugins cache file %s", psz_filename );
-        free( psz_filename );
-        return;
-    }
-
-    msg_Dbg( p_this, "loading plugins cache file %s", psz_filename );
-
-    file = utf8_fopen( psz_filename, "rb" );
-    if( !file )
-    {
-        msg_Warn( p_this, "could not open plugins cache file %s for reading",
-                  psz_filename );
-        free( psz_filename );
-        return;
-    }
-    free( psz_filename );
-
-    /* Check the file size */
-    i_read = fread( &i_file_size, sizeof(char), sizeof(i_file_size), file );
-    if( i_read != sizeof(i_file_size) )
-    {
-        msg_Warn( p_this, "This doesn't look like a valid plugins cache "
-                  "(too short)" );
-        fclose( file );
-        return;
-    }
-
-    fseek( file, 0, SEEK_END );
-    if( ftell( file ) != i_file_size )
-    {
-        msg_Warn( p_this, "This doesn't look like a valid plugins cache "
-                  "(corrupted size)" );
-        fclose( file );
-        return;
-    }
-    fseek( file, sizeof(i_file_size), SEEK_SET );
-
-    /* Check the file is a plugins cache */
-    i_size = sizeof(PLUGINSCACHE_DIR COPYRIGHT_MESSAGE) - 1;
-    i_read = fread( p_cachestring, sizeof(char), i_size, file );
-    if( i_read != i_size ||
-        memcmp( p_cachestring, PLUGINSCACHE_DIR COPYRIGHT_MESSAGE, i_size ) )
-    {
-        msg_Warn( p_this, "This doesn't look like a valid plugins cache" );
-        fclose( file );
-        return;
-    }
-
-    /* Check Sub-version number */
-    i_read = fread( &i_marker, sizeof(char), sizeof(i_marker), file );
-    if( i_read != sizeof(i_marker) || i_marker != CACHE_SUBVERSION_NUM )
-    {
-        msg_Warn( p_this, "This doesn't look like a valid plugins cache "
-                  "(corrupted header)" );
-        fclose( file );
-        return;
-    }
-
-    /* Check the language hasn't changed */
-    sprintf( p_lang, "%5.5s", _("C") ); i_size = 5;
-    i_read = fread( p_cachelang, sizeof(char), i_size, file );
-    if( i_read != i_size || memcmp( p_cachelang, p_lang, i_size ) )
-    {
-        msg_Warn( p_this, "This doesn't look like a valid plugins cache "
-                  "(language changed)" );
-        fclose( file );
-        return;
-    }
-
-    /* Check header marker */
-    i_read = fread( &i_marker, sizeof(char), sizeof(i_marker), file );
-    if( i_read != sizeof(i_marker) ||
-        i_marker != ftell( file ) - (int)sizeof(i_marker) )
-    {
-        msg_Warn( p_this, "This doesn't look like a valid plugins cache "
-                  "(corrupted header)" );
-        fclose( file );
-        return;
-    }
-
-    p_this->p_libvlc->p_module_bank->i_loaded_cache = 0;
-    fread( &i_cache, sizeof(char), sizeof(i_cache), file );
-    if( i_cache )
-        pp_cache = p_this->p_libvlc->p_module_bank->pp_loaded_cache =
-                   malloc( i_cache * sizeof(void *) );
-
-#define LOAD_IMMEDIATE(a) \
-    if( fread( &a, sizeof(char), sizeof(a), file ) != sizeof(a) ) goto error
-#define LOAD_STRING(a) \
-    { if( fread( &i_size, sizeof(char), sizeof(i_size), file ) \
-          != sizeof(i_size) ) goto error; \
-      if( i_size && i_size < 16384 ) { \
-          a = malloc( i_size ); \
-          if( fread( a, sizeof(char), i_size, file ) != (size_t)i_size ) \
-              goto error; \
-          if( a[i_size-1] ) { \
-              free( a ); a = 0; \
-              goto error; } \
-      } else a = 0; \
-    } while(0)
-
-
-    for( i = 0; i < i_cache; i++ )
-    {
-        uint16_t i_size;
-        int i_submodules;
-
-        pp_cache[i] = malloc( sizeof(module_cache_t) );
-        p_this->p_libvlc->p_module_bank->i_loaded_cache++;
-
-        /* Load common info */
-        LOAD_STRING( pp_cache[i]->psz_file );
-        LOAD_IMMEDIATE( pp_cache[i]->i_time );
-        LOAD_IMMEDIATE( pp_cache[i]->i_size );
-        LOAD_IMMEDIATE( pp_cache[i]->b_junk );
-
-        if( pp_cache[i]->b_junk ) continue;
-
-        pp_cache[i]->p_module = vlc_object_create( p_this, VLC_OBJECT_MODULE );
-
-        /* Load additional infos */
-        LOAD_STRING( pp_cache[i]->p_module->psz_object_name );
-        LOAD_STRING( pp_cache[i]->p_module->psz_shortname );
-        LOAD_STRING( pp_cache[i]->p_module->psz_longname );
-        LOAD_STRING( pp_cache[i]->p_module->psz_program );
-        for( j = 0; j < MODULE_SHORTCUT_MAX; j++ )
-        {
-            LOAD_STRING( pp_cache[i]->p_module->pp_shortcuts[j] ); // FIX
-        }
-        LOAD_STRING( pp_cache[i]->p_module->psz_capability );
-        LOAD_IMMEDIATE( pp_cache[i]->p_module->i_score );
-        LOAD_IMMEDIATE( pp_cache[i]->p_module->i_cpu );
-        LOAD_IMMEDIATE( pp_cache[i]->p_module->b_unloadable );
-        LOAD_IMMEDIATE( pp_cache[i]->p_module->b_reentrant );
-        LOAD_IMMEDIATE( pp_cache[i]->p_module->b_submodule );
-
-        /* Config stuff */
-        if( CacheLoadConfig( pp_cache[i]->p_module, file ) != VLC_SUCCESS )
-            goto error;
-
-        LOAD_STRING( pp_cache[i]->p_module->psz_filename );
-
-        LOAD_IMMEDIATE( i_submodules );
-
-        while( i_submodules-- )
-        {
-            module_t *p_module = vlc_object_create( p_this, VLC_OBJECT_MODULE);
-            vlc_object_attach( p_module, pp_cache[i]->p_module );
-            p_module->b_submodule = VLC_TRUE;
-
-            LOAD_STRING( p_module->psz_object_name );
-            LOAD_STRING( p_module->psz_shortname );
-            LOAD_STRING( p_module->psz_longname );
-            LOAD_STRING( p_module->psz_program );
-            for( j = 0; j < MODULE_SHORTCUT_MAX; j++ )
-            {
-                LOAD_STRING( p_module->pp_shortcuts[j] ); // FIX
-            }
-            LOAD_STRING( p_module->psz_capability );
-            LOAD_IMMEDIATE( p_module->i_score );
-            LOAD_IMMEDIATE( p_module->i_cpu );
-            LOAD_IMMEDIATE( p_module->b_unloadable );
-            LOAD_IMMEDIATE( p_module->b_reentrant );
-        }
-    }
-
-    fclose( file );
-    return;
-
- error:
-
-    msg_Warn( p_this, "plugins cache not loaded (corrupted)" );
-
-    /* TODO: cleanup */
-    p_this->p_libvlc->p_module_bank->i_loaded_cache = 0;
-
-    fclose( file );
-    return;
-}
-
-int CacheLoadConfig( module_t *p_module, FILE *file )
-{
-    int i, j, i_lines;
-    uint16_t i_size;
-
-    /* Calculate the structure length */
-    LOAD_IMMEDIATE( p_module->i_config_items );
-    LOAD_IMMEDIATE( p_module->i_bool_items );
-
-    LOAD_IMMEDIATE( i_lines );
-
-    /* Allocate memory */
-    p_module->p_config =
-        (module_config_t *)malloc( sizeof(module_config_t) * (i_lines + 1));
-    if( p_module->p_config == NULL )
-    {
-        msg_Err( p_module, "config error: can't duplicate p_config" );
-        return VLC_ENOMEM;
-    }
-
-    /* Do the duplication job */
-    for( i = 0; i < i_lines ; i++ )
-    {
-        LOAD_IMMEDIATE( p_module->p_config[i] );
-
-        LOAD_STRING( p_module->p_config[i].psz_type );
-        LOAD_STRING( p_module->p_config[i].psz_name );
-        LOAD_STRING( p_module->p_config[i].psz_text );
-        LOAD_STRING( p_module->p_config[i].psz_longtext );
-        LOAD_STRING( p_module->p_config[i].psz_current );
-        LOAD_STRING( p_module->p_config[i].psz_value_orig );
-
-        p_module->p_config[i].psz_value =
-            p_module->p_config[i].psz_value_orig ?
-                strdup( p_module->p_config[i].psz_value_orig ) : 0;
-        p_module->p_config[i].i_value = p_module->p_config[i].i_value_orig;
-        p_module->p_config[i].f_value = p_module->p_config[i].f_value_orig;
-        p_module->p_config[i].i_value_saved = p_module->p_config[i].i_value;
-        p_module->p_config[i].f_value_saved = p_module->p_config[i].f_value;
-        p_module->p_config[i].psz_value_saved = 0;
-        p_module->p_config[i].b_dirty = VLC_FALSE;
-
-        p_module->p_config[i].p_lock = &p_module->object_lock;
-
-        if( p_module->p_config[i].i_list )
-        {
-            if( p_module->p_config[i].ppsz_list )
-            {
-                p_module->p_config[i].ppsz_list =
-                    malloc( (p_module->p_config[i].i_list+1) * sizeof(char *));
-                if( p_module->p_config[i].ppsz_list )
-                {
-                    for( j = 0; j < p_module->p_config[i].i_list; j++ )
-                        LOAD_STRING( p_module->p_config[i].ppsz_list[j] );
-                    p_module->p_config[i].ppsz_list[j] = NULL;
-                }
-            }
-            if( p_module->p_config[i].ppsz_list_text )
-            {
-                p_module->p_config[i].ppsz_list_text =
-                    malloc( (p_module->p_config[i].i_list+1) * sizeof(char *));
-                if( p_module->p_config[i].ppsz_list_text )
-                {
-                  for( j = 0; j < p_module->p_config[i].i_list; j++ )
-                      LOAD_STRING( p_module->p_config[i].ppsz_list_text[j] );
-                  p_module->p_config[i].ppsz_list_text[j] = NULL;
-                }
-            }
-            if( p_module->p_config[i].pi_list )
-            {
-                p_module->p_config[i].pi_list =
-                    malloc( (p_module->p_config[i].i_list + 1) * sizeof(int) );
-                if( p_module->p_config[i].pi_list )
-                {
-                    for( j = 0; j < p_module->p_config[i].i_list; j++ )
-                        LOAD_IMMEDIATE( p_module->p_config[i].pi_list[j] );
-                }
-            }
-        }
-
-        if( p_module->p_config[i].i_action )
-        {
-            p_module->p_config[i].ppf_action =
-                malloc( p_module->p_config[i].i_action * sizeof(void *) );
-            p_module->p_config[i].ppsz_action_text =
-                malloc( p_module->p_config[i].i_action * sizeof(char *) );
-
-            for( j = 0; j < p_module->p_config[i].i_action; j++ )
-            {
-                p_module->p_config[i].ppf_action[j] = 0;
-                LOAD_STRING( p_module->p_config[i].ppsz_action_text[j] );
-            }
-        }
-
-        LOAD_IMMEDIATE( p_module->p_config[i].pf_callback );
-    }
-
-    p_module->p_config[i].i_type = CONFIG_HINT_END;
-
-    return VLC_SUCCESS;
-
- error:
-
-    return VLC_EGENERIC;
-}
-
-/*****************************************************************************
- * SavePluginsCache: saves the plugins cache to a file
- *****************************************************************************/
-static void CacheSave( vlc_object_t *p_this )
-{
-    static char const psz_tag[] =
-        "Signature: 8a477f597d28d172789f06886806bc55\r\n"
-        "# This file is a cache directory tag created by VLC.\r\n"
-        "# For information about cache directory tags, see:\r\n"
-        "#   http://www.brynosaurus.com/cachedir/\r\n";
-
-    char *psz_filename, *psz_homedir;
-    FILE *file;
-    int i, j, i_cache;
-    module_cache_t **pp_cache;
-    int32_t i_file_size = 0;
-
-    psz_homedir = p_this->p_vlc->psz_homedir;
-    if( !psz_homedir )
-    {
-        msg_Err( p_this, "psz_homedir is null" );
-        return;
-    }
-    psz_filename =
-       (char *)malloc( sizeof("/" CONFIG_DIR "/" PLUGINSCACHE_DIR "/" ) +
-                       strlen(psz_homedir) + strlen(CacheName()) );
-
-    if( !psz_filename )
-    {
-        msg_Err( p_this, "out of memory" );
-        return;
-    }
-
-    sprintf( psz_filename, "%s/%s", psz_homedir, CONFIG_DIR );
-
-    config_CreateDir( p_this, psz_filename );
-
-    strcat( psz_filename, "/" PLUGINSCACHE_DIR );
-
-    config_CreateDir( p_this, psz_filename );
-
-    strcat( psz_filename, "/CACHEDIR.TAG" );
-
-    file = utf8_fopen( psz_filename, "wb" );
-    if( file )
-    {
-        fwrite( psz_tag, 1, strlen(psz_tag), file );
-        fclose( file );
-    }
-
-    sprintf( psz_filename, "%s/%s/%s/%s", psz_homedir, CONFIG_DIR,
-             PLUGINSCACHE_DIR, CacheName() );
-
-    msg_Dbg( p_this, "saving plugins cache file %s", psz_filename );
-
-    file = utf8_fopen( psz_filename, "wb" );
-    if( !file )
-    {
-        msg_Warn( p_this, "could not open plugins cache file %s for writing",
-                  psz_filename );
-        free( psz_filename );
-        return;
-    }
-    free( psz_filename );
-
-    /* Empty space for file size */
-    fwrite( &i_file_size, sizeof(char), sizeof(i_file_size), file );
-
-    /* Contains version number */
-    fprintf( file, "%s", PLUGINSCACHE_DIR COPYRIGHT_MESSAGE );
-
-    /* Sub-version number (to avoid breakage in the dev version when cache
-     * structure changes) */
-    i_file_size = CACHE_SUBVERSION_NUM;
-    fwrite( &i_file_size, sizeof(char), sizeof(i_file_size), file );
-
-    /* Language */
-    fprintf( file, "%5.5s", _("C") );
-
-    /* Header marker */
-    i_file_size = ftell( file );
-    fwrite( &i_file_size, sizeof(char), sizeof(i_file_size), file );
-
-    i_cache = p_this->p_libvlc->p_module_bank->i_cache;
-    pp_cache = p_this->p_libvlc->p_module_bank->pp_cache;
-
-    fwrite( &i_cache, sizeof(char), sizeof(i_cache), file );
-
-#define SAVE_IMMEDIATE(a) \
-    fwrite( &a, sizeof(char), sizeof(a), file )
-#define SAVE_STRING(a) \
-    { i_size = a ? strlen( a ) + 1 : 0; \
-      fwrite( &i_size, sizeof(char), sizeof(i_size), file ); \
-      if( a ) fwrite( a, sizeof(char), i_size, file ); \
-    } while(0)
-
-    for( i = 0; i < i_cache; i++ )
-    {
-        uint16_t i_size;
-        uint32_t i_submodule;
-
-        /* Save common info */
-        SAVE_STRING( pp_cache[i]->psz_file );
-        SAVE_IMMEDIATE( pp_cache[i]->i_time );
-        SAVE_IMMEDIATE( pp_cache[i]->i_size );
-        SAVE_IMMEDIATE( pp_cache[i]->b_junk );
-
-        if( pp_cache[i]->b_junk ) continue;
-
-        /* Save additional infos */
-        SAVE_STRING( pp_cache[i]->p_module->psz_object_name );
-        SAVE_STRING( pp_cache[i]->p_module->psz_shortname );
-        SAVE_STRING( pp_cache[i]->p_module->psz_longname );
-        SAVE_STRING( pp_cache[i]->p_module->psz_program );
-        for( j = 0; j < MODULE_SHORTCUT_MAX; j++ )
-        {
-            SAVE_STRING( pp_cache[i]->p_module->pp_shortcuts[j] ); // FIX
-        }
-        SAVE_STRING( pp_cache[i]->p_module->psz_capability );
-        SAVE_IMMEDIATE( pp_cache[i]->p_module->i_score );
-        SAVE_IMMEDIATE( pp_cache[i]->p_module->i_cpu );
-        SAVE_IMMEDIATE( pp_cache[i]->p_module->b_unloadable );
-        SAVE_IMMEDIATE( pp_cache[i]->p_module->b_reentrant );
-        SAVE_IMMEDIATE( pp_cache[i]->p_module->b_submodule );
-
-        /* Config stuff */
-        CacheSaveConfig( pp_cache[i]->p_module, file );
-
-        SAVE_STRING( pp_cache[i]->p_module->psz_filename );
-
-        i_submodule = pp_cache[i]->p_module->i_children;
-        SAVE_IMMEDIATE( i_submodule );
-        for( i_submodule = 0; i_submodule < (unsigned)pp_cache[i]->p_module->i_children;
-             i_submodule++ )
-        {
-            module_t *p_module =
-                (module_t *)pp_cache[i]->p_module->pp_children[i_submodule];
-
-            SAVE_STRING( p_module->psz_object_name );
-            SAVE_STRING( p_module->psz_shortname );
-            SAVE_STRING( p_module->psz_longname );
-            SAVE_STRING( p_module->psz_program );
-            for( j = 0; j < MODULE_SHORTCUT_MAX; j++ )
-            {
-                SAVE_STRING( p_module->pp_shortcuts[j] ); // FIX
-            }
-            SAVE_STRING( p_module->psz_capability );
-            SAVE_IMMEDIATE( p_module->i_score );
-            SAVE_IMMEDIATE( p_module->i_cpu );
-            SAVE_IMMEDIATE( p_module->b_unloadable );
-            SAVE_IMMEDIATE( p_module->b_reentrant );
-        }
-    }
-
-    /* Fill-up file size */
-    i_file_size = ftell( file );
-    fseek( file, 0, SEEK_SET );
-    fwrite( &i_file_size, sizeof(char), sizeof(i_file_size), file );
-
-    fclose( file );
-
-    return;
-}
-
-void CacheSaveConfig( module_t *p_module, FILE *file )
-{
-    int i, j, i_lines = 0;
-    module_config_t *p_item;
-    uint16_t i_size;
-
-    SAVE_IMMEDIATE( p_module->i_config_items );
-    SAVE_IMMEDIATE( p_module->i_bool_items );
-
-    for( p_item = p_module->p_config; p_item->i_type != CONFIG_HINT_END;
-         p_item++ ) i_lines++;
-
-    SAVE_IMMEDIATE( i_lines );
-
-    for( i = 0; i < i_lines ; i++ )
-    {
-        SAVE_IMMEDIATE( p_module->p_config[i] );
-
-        SAVE_STRING( p_module->p_config[i].psz_type );
-        SAVE_STRING( p_module->p_config[i].psz_name );
-        SAVE_STRING( p_module->p_config[i].psz_text );
-        SAVE_STRING( p_module->p_config[i].psz_longtext );
-        SAVE_STRING( p_module->p_config[i].psz_current );
-        SAVE_STRING( p_module->p_config[i].psz_value_orig );
-
-        if( p_module->p_config[i].i_list )
-        {
-            if( p_module->p_config[i].ppsz_list )
-            {
-                for( j = 0; j < p_module->p_config[i].i_list; j++ )
-                    SAVE_STRING( p_module->p_config[i].ppsz_list[j] );
-            }
-
-            if( p_module->p_config[i].ppsz_list_text )
-            {
-                for( j = 0; j < p_module->p_config[i].i_list; j++ )
-                    SAVE_STRING( p_module->p_config[i].ppsz_list_text[j] );
-            }
-            if( p_module->p_config[i].pi_list )
-            {
-                for( j = 0; j < p_module->p_config[i].i_list; j++ )
-                    SAVE_IMMEDIATE( p_module->p_config[i].pi_list[j] );
-            }
-        }
-
-        for( j = 0; j < p_module->p_config[i].i_action; j++ )
-            SAVE_STRING( p_module->p_config[i].ppsz_action_text[j] );
-
-        SAVE_IMMEDIATE( p_module->p_config[i].pf_callback );
-    }
-}
-
-/*****************************************************************************
- * CacheName: Return the cache file name for this platform.
- *****************************************************************************/
-static char *CacheName( void )
-{
-    static char psz_cachename[32];
-
-    /* Code int size, pointer size and endianness in the filename */
-    int32_t x = 0xbe00001e;
-    sprintf( psz_cachename, "plugins-%.2x%.2x%.2x.dat", sizeof(int),
-             sizeof(void *), (unsigned int)((unsigned char *)&x)[0] );
-    return psz_cachename;
-}
-
-/*****************************************************************************
- * CacheMerge: Merge a cache module descriptor with a full module descriptor.
- *****************************************************************************/
-static void CacheMerge( vlc_object_t *p_this, module_t *p_cache,
-                        module_t *p_module )
-{
-    int i_submodule;
-
-    p_cache->pf_activate = p_module->pf_activate;
-    p_cache->pf_deactivate = p_module->pf_deactivate;
-#ifndef HAVE_SHARED_LIBVLC
-    p_cache->p_symbols = p_module->p_symbols;
-#endif
-    p_cache->handle = p_module->handle;
-
-    for( i_submodule = 0; i_submodule < p_module->i_children; i_submodule++ )
-    {
-        module_t *p_child = (module_t*)p_module->pp_children[i_submodule];
-        module_t *p_cchild = (module_t*)p_cache->pp_children[i_submodule];
-        p_cchild->pf_activate = p_child->pf_activate;
-        p_cchild->pf_deactivate = p_child->pf_deactivate;
-#ifndef HAVE_SHARED_LIBVLC
-        p_cchild->p_symbols = p_child->p_symbols;
-#endif
-    }
-
-    p_cache->b_loaded = VLC_TRUE;
-    p_module->b_loaded = VLC_FALSE;
-}
-
-/*****************************************************************************
- * FindPluginCache: finds the cache entry corresponding to a file
- *****************************************************************************/
-static module_cache_t *CacheFind( vlc_object_t *p_this, char *psz_file,
-                                  int64_t i_time, int64_t i_size )
-{
-    module_cache_t **pp_cache;
-    int i_cache, i;
-
-    pp_cache = p_this->p_libvlc->p_module_bank->pp_loaded_cache;
-    i_cache = p_this->p_libvlc->p_module_bank->i_loaded_cache;
-
-    for( i = 0; i < i_cache; i++ )
-    {
-        if( !strcmp( pp_cache[i]->psz_file, psz_file ) &&
-            pp_cache[i]->i_time == i_time &&
-            pp_cache[i]->i_size == i_size ) return pp_cache[i];
-    }
-
-    return NULL;
-}
-
-#endif /* HAVE_DYNAMIC_PLUGINS */
+/*****************************************************************************
+ * modules.c : Builtin and plugin modules management functions
+ *****************************************************************************
+ * Copyright (C) 2001-2004 the VideoLAN team
+ * $Id: modules.c 17957 2006-11-22 16:12:56Z courmisch $
+ *
+ * Authors: Sam Hocevar <sam@zoy.org>
+ *          Ethan C. Baldridge <BaldridgeE@cadmus.com>
+ *          Hans-Peter Jansen <hpj@urpla.net>
+ *          Gildas Bazin <gbazin@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/* Some faulty libcs have a broken struct dirent when _FILE_OFFSET_BITS
+ * is set to 64. Don't try to be cleverer. */
+#ifdef _FILE_OFFSET_BITS
+#undef _FILE_OFFSET_BITS
+#endif
+
+#include <stdlib.h>                                      /* free(), strtol() */
+#include <stdio.h>                                              /* sprintf() */
+#include <string.h>                                              /* strdup() */
+
+#include <vlc/vlc.h>
+#include <vlc/input.h>
+
+#ifdef HAVE_DIRENT_H
+#   include <dirent.h>
+#endif
+
+#ifdef HAVE_SYS_TYPES_H
+#   include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+#   include <sys/stat.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#   include <unistd.h>
+#endif
+
+#if !defined(HAVE_DYNAMIC_PLUGINS)
+    /* no support for plugins */
+#elif defined(HAVE_DL_DYLD)
+#   if defined(HAVE_MACH_O_DYLD_H)
+#       include <mach-o/dyld.h>
+#   endif
+#elif defined(HAVE_DL_BEOS)
+#   if defined(HAVE_IMAGE_H)
+#       include <image.h>
+#   endif
+#elif defined(HAVE_DL_WINDOWS)
+#   include <windows.h>
+#elif defined(HAVE_DL_DLOPEN)
+#   if defined(HAVE_DLFCN_H) /* Linux, BSD, Hurd */
+#       include <dlfcn.h>
+#   endif
+#   if defined(HAVE_SYS_DL_H)
+#       include <sys/dl.h>
+#   endif
+#elif defined(HAVE_DL_SHL_LOAD)
+#   if defined(HAVE_DL_H)
+#       include <dl.h>
+#   endif
+#endif
+
+#include "vlc_error.h"
+
+#include "vlc_interface.h"
+#include "vlc_interaction.h"
+#include "intf_eject.h"
+
+#include "vlc_playlist.h"
+
+#include "vlc_video.h"
+#include "video_output.h"
+#include "vout_synchro.h"
+#include "vlc_spu.h"
+
+#include "audio_output.h"
+#include "aout_internal.h"
+
+#include "stream_output.h"
+#include "vlc_httpd.h"
+#include "vlc_acl.h"
+#include "vlc_tls.h"
+#include "vlc_md5.h"
+#include "vlc_xml.h"
+#include "vlc_url.h"
+
+#include "iso_lang.h"
+#include "charset.h"
+
+#include "vlc_block.h"
+
+#include "vlc_vlm.h"
+
+#include "vlc_image.h"
+#include "vlc_osd.h"
+
+#include "vlc_update.h"
+#include "vlc_strings.h"
+
+#if defined( _MSC_VER ) && defined( UNDER_CE )
+#    include "modules_builtin_evc.h"
+#elif defined( _MSC_VER )
+#    include "modules_builtin_msvc.h"
+#else
+#    include "modules_builtin.h"
+#endif
+#include "network.h"
+
+#if defined( WIN32 ) || defined( UNDER_CE )
+    /* Avoid name collisions */
+#   define LoadModule(a,b,c) LoadVlcModule(a,b,c)
+#endif
+
+#define SONGBIRD_VLC_PLUGINSDIR_WIN "plugins\\vlcmodules"
+
+/*****************************************************************************
+ * Local prototypes
+ *****************************************************************************/
+#ifdef HAVE_DYNAMIC_PLUGINS
+static void AllocateAllPlugins  ( vlc_object_t * );
+static void AllocatePluginDir   ( vlc_object_t *, const char *, int );
+static int  AllocatePluginFile  ( vlc_object_t *, char *, int64_t, int64_t );
+static module_t * AllocatePlugin( vlc_object_t *, char * );
+#endif
+static int  AllocateBuiltinModule( vlc_object_t *, int ( * ) ( module_t * ) );
+static int  DeleteModule ( module_t * );
+#ifdef HAVE_DYNAMIC_PLUGINS
+static void   DupModule        ( module_t * );
+static void   UndupModule      ( module_t * );
+static int    CallEntry        ( module_t * );
+static int    LoadModule       ( vlc_object_t *, char *, module_handle_t * );
+static void   CloseModule      ( module_handle_t );
+static void * GetSymbol        ( module_handle_t, const char * );
+static void   CacheLoad        ( vlc_object_t * );
+static int    CacheLoadConfig  ( module_t *, FILE * );
+static void   CacheSave        ( vlc_object_t * );
+static void   CacheSaveConfig  ( module_t *, FILE * );
+static char * CacheName        ( void );
+static void   CacheMerge       ( vlc_object_t *, module_t *, module_t * );
+static module_cache_t * CacheFind( vlc_object_t *, char *, int64_t, int64_t );
+
+#if defined(HAVE_DL_WINDOWS)
+static char * GetWindowsError  ( void );
+#endif
+#endif
+
+
+/* Sub-version number
+ * (only used to avoid breakage in dev version when cache structure changes) */
+#define CACHE_SUBVERSION_NUM 1
+
+/*****************************************************************************
+ * module_InitBank: create the module bank.
+ *****************************************************************************
+ * This function creates a module bank structure which will be filled later
+ * on with all the modules found.
+ *****************************************************************************/
+void __module_InitBank( vlc_object_t *p_this )
+{
+    module_bank_t *p_bank;
+    vlc_value_t  lockval;
+
+    var_Create( p_this->p_libvlc, "libvlc", VLC_VAR_MUTEX );
+    var_Get( p_this->p_libvlc, "libvlc", &lockval );
+    vlc_mutex_lock( lockval.p_address );
+    if( p_this->p_libvlc->p_module_bank )
+    {
+        p_this->p_libvlc->p_module_bank->i_usage++;
+        vlc_mutex_unlock( lockval.p_address );
+        var_Destroy( p_this->p_libvlc, "libvlc" );
+        return;
+    }
+    vlc_mutex_unlock( lockval.p_address );
+    var_Destroy( p_this->p_libvlc, "libvlc" );
+
+    p_bank = vlc_object_create( p_this, sizeof(module_bank_t) );
+    p_bank->psz_object_name = "module bank";
+    p_bank->i_usage = 1;
+    p_bank->i_cache = p_bank->i_loaded_cache = 0;
+    p_bank->pp_cache = p_bank->pp_loaded_cache = 0;
+    p_bank->b_cache = p_bank->b_cache_dirty =
+        p_bank->b_cache_delete = VLC_FALSE;
+
+    /*
+     * Store the symbols to be exported
+     */
+#if defined (HAVE_DYNAMIC_PLUGINS) && !defined (HAVE_SHARED_LIBVLC)
+    STORE_SYMBOLS( &p_bank->symbols );
+#endif
+
+    /* Everything worked, attach the object */
+    p_this->p_libvlc->p_module_bank = p_bank;
+    vlc_object_attach( p_bank, p_this->p_libvlc );
+
+    module_LoadMain( p_this );
+
+    return;
+}
+
+/*****************************************************************************
+ * module_ResetBank: reset the module bank.
+ *****************************************************************************
+ * This function resets the module bank by unloading all unused plugin
+ * modules.
+ *****************************************************************************/
+void __module_ResetBank( vlc_object_t *p_this )
+{
+    msg_Err( p_this, "FIXME: module_ResetBank unimplemented" );
+    return;
+}
+
+/*****************************************************************************
+ * module_EndBank: empty the module bank.
+ *****************************************************************************
+ * This function unloads all unused plugin modules and empties the module
+ * bank in case of success.
+ *****************************************************************************/
+void __module_EndBank( vlc_object_t *p_this )
+{
+    module_t * p_next;
+    vlc_value_t lockval;
+
+    var_Create( p_this->p_libvlc, "libvlc", VLC_VAR_MUTEX );
+    var_Get( p_this->p_libvlc, "libvlc", &lockval );
+    vlc_mutex_lock( lockval.p_address );
+    if( !p_this->p_libvlc->p_module_bank )
+    {
+        vlc_mutex_unlock( lockval.p_address );
+        var_Destroy( p_this->p_libvlc, "libvlc" );
+        return;
+    }
+    if( --p_this->p_libvlc->p_module_bank->i_usage )
+    {
+        vlc_mutex_unlock( lockval.p_address );
+        var_Destroy( p_this->p_libvlc, "libvlc" );
+        return;
+    }
+    vlc_mutex_unlock( lockval.p_address );
+    var_Destroy( p_this->p_libvlc, "libvlc" );
+
+    config_AutoSaveConfigFile( p_this );
+
+#ifdef HAVE_DYNAMIC_PLUGINS
+#define p_bank p_this->p_libvlc->p_module_bank
+    if( p_bank->b_cache ) CacheSave( p_this );
+    while( p_bank->i_loaded_cache-- )
+    {
+        free( p_bank->pp_loaded_cache[p_bank->i_loaded_cache]->psz_file );
+        free( p_bank->pp_loaded_cache[p_bank->i_loaded_cache] );
+    }
+    if( p_bank->pp_loaded_cache )
+        free( p_bank->pp_loaded_cache );
+
+    while( p_bank->i_cache-- )
+    {
+        free( p_bank->pp_cache[p_bank->i_cache]->psz_file );
+        free( p_bank->pp_cache[p_bank->i_cache] );
+    }
+    if( p_bank->pp_cache )
+        free( p_bank->pp_cache );
+#undef p_bank
+#endif
+
+    vlc_object_detach( p_this->p_libvlc->p_module_bank );
+
+    while( p_this->p_libvlc->p_module_bank->i_children )
+    {
+        p_next = (module_t *)p_this->p_libvlc->p_module_bank->pp_children[0];
+
+        if( DeleteModule( p_next ) )
+        {
+            /* Module deletion failed */
+            msg_Err( p_this, "module \"%s\" can't be removed, trying harder",
+                     p_next->psz_object_name );
+
+            /* We just free the module by hand. Niahahahahaha. */
+            vlc_object_detach( p_next );
+            vlc_object_destroy( p_next );
+        }
+    }
+
+    vlc_object_destroy( p_this->p_libvlc->p_module_bank );
+    p_this->p_libvlc->p_module_bank = NULL;
+
+    return;
+}
+
+/*****************************************************************************
+ * module_LoadMain: load the main program info into the module bank.
+ *****************************************************************************
+ * This function fills the module bank structure with the main module infos.
+ * This is very useful as it will allow us to consider the main program just
+ * as another module, and for instance the configuration options of main will
+ * be available in the module bank structure just as for every other module.
+ *****************************************************************************/
+void __module_LoadMain( vlc_object_t *p_this )
+{
+    vlc_value_t lockval;
+
+    var_Create( p_this->p_libvlc, "libvlc", VLC_VAR_MUTEX );
+    var_Get( p_this->p_libvlc, "libvlc", &lockval );
+    vlc_mutex_lock( lockval.p_address );
+    if( p_this->p_libvlc->p_module_bank->b_main )
+    {
+        vlc_mutex_unlock( lockval.p_address );
+        var_Destroy( p_this->p_libvlc, "libvlc" );
+        return;
+    }
+    p_this->p_libvlc->p_module_bank->b_main = VLC_TRUE;
+    vlc_mutex_unlock( lockval.p_address );
+    var_Destroy( p_this->p_libvlc, "libvlc" );
+
+    AllocateBuiltinModule( p_this, vlc_entry__main );
+}
+
+/*****************************************************************************
+ * module_LoadBuiltins: load all modules which we built with.
+ *****************************************************************************
+ * This function fills the module bank structure with the builtin modules.
+ *****************************************************************************/
+void __module_LoadBuiltins( vlc_object_t * p_this )
+{
+    vlc_value_t lockval;
+
+    var_Create( p_this->p_libvlc, "libvlc", VLC_VAR_MUTEX );
+    var_Get( p_this->p_libvlc, "libvlc", &lockval );
+    vlc_mutex_lock( lockval.p_address );
+    if( p_this->p_libvlc->p_module_bank->b_builtins )
+    {
+        vlc_mutex_unlock( lockval.p_address );
+        var_Destroy( p_this->p_libvlc, "libvlc" );
+        return;
+    }
+    p_this->p_libvlc->p_module_bank->b_builtins = VLC_TRUE;
+    vlc_mutex_unlock( lockval.p_address );
+    var_Destroy( p_this->p_libvlc, "libvlc" );
+
+    msg_Dbg( p_this, "checking builtin modules" );
+    ALLOCATE_ALL_BUILTINS();
+}
+
+/*****************************************************************************
+ * module_LoadPlugins: load all plugin modules we can find.
+ *****************************************************************************
+ * This function fills the module bank structure with the plugin modules.
+ *****************************************************************************/
+void __module_LoadPlugins( vlc_object_t * p_this )
+{
+#ifdef HAVE_DYNAMIC_PLUGINS
+    vlc_value_t lockval;
+
+    var_Create( p_this->p_libvlc, "libvlc", VLC_VAR_MUTEX );
+    var_Get( p_this->p_libvlc, "libvlc", &lockval );
+    vlc_mutex_lock( lockval.p_address );
+    if( p_this->p_libvlc->p_module_bank->b_plugins )
+    {
+        vlc_mutex_unlock( lockval.p_address );
+        var_Destroy( p_this->p_libvlc, "libvlc" );
+        return;
+    }
+    p_this->p_libvlc->p_module_bank->b_plugins = VLC_TRUE;
+    vlc_mutex_unlock( lockval.p_address );
+    var_Destroy( p_this->p_libvlc, "libvlc" );
+
+    msg_Dbg( p_this, "checking plugin modules" );
+
+    if( config_GetInt( p_this, "plugins-cache" ) )
+        p_this->p_libvlc->p_module_bank->b_cache = VLC_TRUE;
+
+    if( p_this->p_libvlc->p_module_bank->b_cache ||
+        p_this->p_libvlc->p_module_bank->b_cache_delete ) CacheLoad( p_this );
+
+    AllocateAllPlugins( p_this );
+#endif
+}
+
+/*****************************************************************************
+ * module_Need: return the best module function, given a capability list.
+ *****************************************************************************
+ * This function returns the module that best fits the asked capabilities.
+ *****************************************************************************/
+module_t * __module_Need( vlc_object_t *p_this, const char *psz_capability,
+                          const char *psz_name, vlc_bool_t b_strict )
+{
+    typedef struct module_list_t module_list_t;
+
+    struct module_list_t
+    {
+        module_t *p_module;
+        int i_score;
+        vlc_bool_t b_force;
+        module_list_t *p_next;
+    };
+
+    module_list_t *p_list, *p_first, *p_tmp;
+    vlc_list_t *p_all;
+
+    int i_which_module, i_index = 0;
+    vlc_bool_t b_intf = VLC_FALSE;
+
+    module_t *p_module;
+
+    int   i_shortcuts = 0;
+    char *psz_shortcuts = NULL, *psz_var = NULL;
+    vlc_bool_t b_force_backup = p_this->b_force;
+
+
+    /* Deal with variables */
+    if( psz_name && psz_name[0] == '$' )
+    {
+        vlc_value_t val;
+        var_Create( p_this, psz_name + 1, VLC_VAR_MODULE | VLC_VAR_DOINHERIT );
+        var_Get( p_this, psz_name + 1, &val );
+        psz_var = val.psz_string;
+        psz_name = psz_var;
+    }
+
+    /* Count how many different shortcuts were asked for */
+    if( psz_name && *psz_name )
+    {
+        char *psz_parser, *psz_last_shortcut;
+
+        /* If the user wants none, give him none. */
+        if( !strcmp( psz_name, "none" ) )
+        {
+            if( psz_var ) free( psz_var );
+            return NULL;
+        }
+
+        i_shortcuts++;
+        psz_shortcuts = psz_last_shortcut = strdup( psz_name );
+
+        for( psz_parser = psz_shortcuts; *psz_parser; psz_parser++ )
+        {
+            if( *psz_parser == ',' )
+            {
+                 *psz_parser = '\0';
+                 i_shortcuts++;
+                 psz_last_shortcut = psz_parser + 1;
+            }
+        }
+
+        /* Check if the user wants to override the "strict" mode */
+        if( psz_last_shortcut )
+        {
+            if( !strcmp(psz_last_shortcut, "none") )
+            {
+                b_strict = VLC_TRUE;
+                i_shortcuts--;
+            }
+            else if( !strcmp(psz_last_shortcut, "any") )
+            {
+                b_strict = VLC_FALSE;
+                i_shortcuts--;
+            }
+        }
+    }
+
+    /* Sort the modules and test them */
+    p_all = vlc_list_find( p_this, VLC_OBJECT_MODULE, FIND_ANYWHERE );
+    p_list = malloc( p_all->i_count * sizeof( module_list_t ) );
+    p_first = NULL;
+
+    /* Parse the module list for capabilities and probe each of them */
+    for( i_which_module = 0; i_which_module < p_all->i_count; i_which_module++ )
+    {
+        int i_shortcut_bonus = 0;
+
+        p_module = (module_t *)p_all->p_values[i_which_module].p_object;
+
+        /* Test that this module can do what we need */
+        if( strcmp( p_module->psz_capability, psz_capability ) )
+        {
+            /* Don't recurse through the sub-modules because vlc_list_find()
+             * will list them anyway. */
+            continue;
+        }
+
+        /* Test if we have the required CPU */
+        if( (p_module->i_cpu & p_this->p_libvlc->i_cpu) != p_module->i_cpu )
+        {
+            continue;
+        }
+
+        /* If we required a shortcut, check this plugin provides it. */
+        if( i_shortcuts > 0 )
+        {
+            vlc_bool_t b_trash;
+            int i_dummy, i_short = i_shortcuts;
+            char *psz_name = psz_shortcuts;
+
+            /* Let's drop modules with a <= 0 score (unless they are
+             * explicitly requested) */
+            b_trash = p_module->i_score <= 0;
+
+            while( i_short > 0 )
+            {
+                for( i_dummy = 0; p_module->pp_shortcuts[i_dummy]; i_dummy++ )
+                {
+                    if( !strcasecmp( psz_name,
+                                     p_module->pp_shortcuts[i_dummy] ) )
+                    {
+                        /* Found it */
+                        b_trash = VLC_FALSE;
+                        i_shortcut_bonus = i_short * 10000;
+                        break;
+                    }
+                }
+
+                if( i_shortcut_bonus )
+                {
+                    /* We found it... remember ? */
+                    break;
+                }
+
+                /* Go to the next shortcut... This is so lame! */
+                while( *psz_name )
+                {
+                    psz_name++;
+                }
+                psz_name++;
+                i_short--;
+            }
+
+            /* If we are in "strict" mode and we couldn't
+             * find the module in the list of provided shortcuts,
+             * then kick the bastard out of here!!! */
+            if( i_short == 0 && b_strict )
+            {
+                b_trash = VLC_TRUE;
+            }
+
+            if( b_trash )
+            {
+                continue;
+            }
+        }
+        /* If we didn't require a shortcut, trash <= 0 scored plugins */
+        else if( p_module->i_score <= 0 )
+        {
+            continue;
+        }
+
+        /* Special case: test if we requested a particular intf plugin */
+        if( !i_shortcuts && p_module->psz_program
+             && !strcmp( psz_capability, "interface" )
+             && !strcmp( p_module->psz_program,
+                         p_this->p_vlc->psz_object_name ) )
+        {
+            if( !b_intf )
+            {
+                /* Remove previous non-matching plugins */
+                i_index = 0;
+                b_intf = VLC_TRUE;
+            }
+        }
+        else if( b_intf )
+        {
+            /* This one doesn't match */
+            continue;
+        }
+
+        /* Store this new module */
+        p_list[ i_index ].p_module = p_module;
+        p_list[ i_index ].i_score = p_module->i_score + i_shortcut_bonus;
+        p_list[ i_index ].b_force = i_shortcut_bonus && b_strict;
+
+        /* Add it to the modules-to-probe list */
+        if( i_index == 0 )
+        {
+            p_list[ 0 ].p_next = NULL;
+            p_first = p_list;
+        }
+        else
+        {
+            /* Ok, so at school you learned that quicksort is quick, and
+             * bubble sort sucks raw eggs. But that's when dealing with
+             * thousands of items. Here we have barely 50. */
+            module_list_t *p_newlist = p_first;
+
+            if( p_first->i_score < p_list[ i_index ].i_score )
+            {
+                p_list[ i_index ].p_next = p_first;
+                p_first = &p_list[ i_index ];
+            }
+            else
+            {
+                while( p_newlist->p_next != NULL &&
+                    p_newlist->p_next->i_score >= p_list[ i_index ].i_score )
+                {
+                    p_newlist = p_newlist->p_next;
+                }
+
+                p_list[ i_index ].p_next = p_newlist->p_next;
+                p_newlist->p_next = &p_list[ i_index ];
+            }
+        }
+
+        i_index++;
+    }
+
+    msg_Dbg( p_this, "looking for %s module: %i candidate%s", psz_capability,
+                                            i_index, i_index == 1 ? "" : "s" );
+
+    /* Lock all candidate modules */
+    p_tmp = p_first;
+    while( p_tmp != NULL )
+    {
+        vlc_object_yield( p_tmp->p_module );
+        p_tmp = p_tmp->p_next;
+    }
+
+    /* We can release the list, interesting modules were yielded */
+    vlc_list_release( p_all );
+
+    /* Parse the linked list and use the first successful module */
+    p_tmp = p_first;
+    while( p_tmp != NULL )
+    {
+#ifdef HAVE_DYNAMIC_PLUGINS
+        /* Make sure the module is loaded in mem */
+        module_t *p_module = p_tmp->p_module->b_submodule ?
+            (module_t *)p_tmp->p_module->p_parent : p_tmp->p_module;
+        if( !p_module->b_builtin && !p_module->b_loaded )
+        {
+            module_t *p_new_module =
+                AllocatePlugin( p_this, p_module->psz_filename );
+            if( p_new_module )
+            {
+                CacheMerge( p_this, p_module, p_new_module );
+                vlc_object_attach( p_new_module, p_module );
+                DeleteModule( p_new_module );
+            }
+        }
+#endif
+
+        p_this->b_force = p_tmp->b_force;
+        if( p_tmp->p_module->pf_activate
+             && p_tmp->p_module->pf_activate( p_this ) == VLC_SUCCESS )
+        {
+            break;
+        }
+
+        vlc_object_release( p_tmp->p_module );
+        p_tmp = p_tmp->p_next;
+    }
+
+    /* Store the locked module value */
+    if( p_tmp != NULL )
+    {
+        p_module = p_tmp->p_module;
+        p_tmp = p_tmp->p_next;
+    }
+    else
+    {
+        p_module = NULL;
+    }
+
+    /* Unlock the remaining modules */
+    while( p_tmp != NULL )
+    {
+        vlc_object_release( p_tmp->p_module );
+        p_tmp = p_tmp->p_next;
+    }
+
+    free( p_list );
+    p_this->b_force = b_force_backup;
+
+    if( p_module != NULL )
+    {
+        msg_Dbg( p_this, "using %s module \"%s\"",
+                 psz_capability, p_module->psz_object_name );
+    }
+    else if( p_first == NULL )
+    {
+        if( !strcmp( psz_capability, "access_demux" ) )
+        {
+            msg_Warn( p_this, "no %s module matched \"%s\"",
+                 psz_capability, (psz_name && *psz_name) ? psz_name : "any" );
+        }
+        else
+        {
+            msg_Err( p_this, "no %s module matched \"%s\"",
+                 psz_capability, (psz_name && *psz_name) ? psz_name : "any" );
+        }
+    }
+    else if( psz_name != NULL && *psz_name )
+    {
+        msg_Warn( p_this, "no %s module matching \"%s\" could be loaded",
+                  psz_capability, (psz_name && *psz_name) ? psz_name : "any" );
+    }
+
+    if( psz_shortcuts )
+    {
+        free( psz_shortcuts );
+    }
+
+    if( psz_var )
+    {
+        free( psz_var );
+    }
+
+    /* Don't forget that the module is still locked */
+    return p_module;
+}
+
+/*****************************************************************************
+ * module_Unneed: decrease the usage count of a module.
+ *****************************************************************************
+ * This function must be called by the thread that called module_Need, to
+ * decrease the reference count and allow for hiding of modules.
+ *****************************************************************************/
+void __module_Unneed( vlc_object_t * p_this, module_t * p_module )
+{
+    /* Use the close method */
+    if( p_module->pf_deactivate )
+    {
+        p_module->pf_deactivate( p_this );
+    }
+
+    msg_Dbg( p_this, "removing module \"%s\"", p_module->psz_object_name );
+
+    vlc_object_release( p_module );
+
+    return;
+}
+
+/*****************************************************************************
+ * Following functions are local.
+ *****************************************************************************/
+
+#if defined( WIN32 ) || defined( UNDER_CE )
+
+static char * GetPathToSelf() 
+{
+	char sz_selfpath[MAX_PATH] = {0};
+	
+	DWORD len = GetModuleFileNameA(NULL, &sz_selfpath[0], MAX_PATH);
+
+	if( sz_selfpath[0] != NULL )
+  {
+  	DWORD cur = strlen(sz_selfpath) - 1;
+  	
+  	for(; cur > 0; cur--) {
+  	  if(sz_selfpath[cur] == '\\')
+  	  {
+  	    sz_selfpath[cur] = '\0';
+  	    return strdup( sz_selfpath );
+  	  }
+  	}
+  }
+	
+  return NULL;
+}
+
+#endif
+
+/*****************************************************************************
+ * AllocateAllPlugins: load all plugin modules we can find.
+ *****************************************************************************/
+#ifdef HAVE_DYNAMIC_PLUGINS
+static void AllocateAllPlugins( vlc_object_t *p_this )
+{
+    /* Yes, there are two NULLs because we replace one with "plugin-path". */
+#if defined( WIN32 ) || defined( UNDER_CE )
+    char *path[] = { "modules", "", "plugins", 0, 0 };
+#else
+    char *path[] = { "modules", PLUGIN_PATH, "plugins", 0, 0 };
+#endif
+
+    char **ppsz_path = path;
+    char *psz_fullpath;
+
+    /* If the user provided a plugin path, we add it to the list */
+
+#if defined( WIN32 )
+        
+    char *psz_selfpath = GetPathToSelf();
+    if( psz_selfpath )
+    {
+      int i_len = strlen(psz_selfpath) + strlen(SONGBIRD_VLC_PLUGINSDIR_WIN) + 16;
+      
+      char *psz_selfpathmodules = malloc(i_len);
+      ZeroMemory(psz_selfpathmodules, i_len);
+      
+      strcat(psz_selfpathmodules, psz_selfpath);
+      strcat(psz_selfpathmodules, "\\");
+      strcat(psz_selfpathmodules, SONGBIRD_VLC_PLUGINSDIR_WIN);
+      
+      path[ sizeof(path)/sizeof(char*) - 2 ] = psz_selfpathmodules;
+      
+      msg_Dbg(p_this, "current exe path + vlcmodules path is `%s'", psz_selfpathmodules );
+      
+      free(psz_selfpath);
+    }
+    else
+    {
+      path[ sizeof(path)/sizeof(char*) - 2 ] =
+        config_GetPsz( p_this, "plugin-path" );
+    }   
+        
+#else
+
+    path[ sizeof(path)/sizeof(char*) - 2 ] =
+        config_GetPsz( p_this, "plugin-path" );
+        
+#endif
+
+    for( ; *ppsz_path != NULL ; ppsz_path++ )
+    {
+        if( !(*ppsz_path)[0] ) continue;
+
+#if defined( SYS_BEOS ) || defined( __APPLE__ ) || defined( WIN32 )
+
+        /* Handle relative as well as absolute paths */
+#ifdef WIN32
+        if( (*ppsz_path)[0] != '\\' && (*ppsz_path)[0] != '/' &&
+            (*ppsz_path)[1] != ':' )
+#else
+        if( (*ppsz_path)[0] != '/' )
+#endif
+        {
+            int i_dirlen = strlen( *ppsz_path );
+            i_dirlen += strlen( p_this->p_libvlc->psz_vlcpath ) + 2;
+
+            psz_fullpath = malloc( i_dirlen );
+            if( psz_fullpath == NULL )
+            {
+                continue;
+            }
+#ifdef WIN32
+            sprintf( psz_fullpath, "%s\\%s",
+                     p_this->p_libvlc->psz_vlcpath, *ppsz_path );
+#else
+            sprintf( psz_fullpath, "%s/%s",
+                     p_this->p_libvlc->psz_vlcpath, *ppsz_path );
+#endif
+        }
+        else
+#endif
+        {
+            psz_fullpath = strdup( *ppsz_path );
+        }
+
+        msg_Dbg( p_this, "recursively browsing `%s'", psz_fullpath );
+
+        /* Don't go deeper than 5 subdirectories */
+        AllocatePluginDir( p_this, psz_fullpath, 5 );
+
+        free( psz_fullpath );
+    }
+
+    /* Free plugin-path */
+    if( path[ sizeof(path)/sizeof(char*) - 2 ] )
+        free( path[ sizeof(path)/sizeof(char*) - 2 ] );
+    path[ sizeof(path)/sizeof(char*) - 2 ] = NULL;
+}
+
+/*****************************************************************************
+ * AllocatePluginDir: recursively parse a directory to look for plugins
+ *****************************************************************************/
+static void AllocatePluginDir( vlc_object_t *p_this, const char *psz_dir,
+                               int i_maxdepth )
+{
+#if defined( UNDER_CE ) || defined( _MSC_VER )
+#ifdef UNDER_CE
+    wchar_t psz_wpath[MAX_PATH + 256];
+    wchar_t psz_wdir[MAX_PATH];
+#endif
+    char psz_path[MAX_PATH + 256];
+    WIN32_FIND_DATA finddata;
+    HANDLE handle;
+    int rc;
+#else
+    int    i_dirlen;
+    DIR *  dir;
+    struct dirent * file;
+#endif
+    char * psz_file;
+
+    if( p_this->p_vlc->b_die || i_maxdepth < 0 )
+    {
+        return;
+    }
+
+#if defined( UNDER_CE ) || defined( _MSC_VER )
+#ifdef UNDER_CE
+    MultiByteToWideChar( CP_ACP, 0, psz_dir, -1, psz_wdir, MAX_PATH );
+
+    rc = GetFileAttributes( psz_wdir );
+    if( rc<0 || !(rc&FILE_ATTRIBUTE_DIRECTORY) ) return; /* Not a directory */
+
+    /* Parse all files in the directory */
+    swprintf( psz_wpath, L"%ls\\*", psz_wdir );
+#else
+    rc = GetFileAttributes( psz_dir );
+    if( rc<0 || !(rc&FILE_ATTRIBUTE_DIRECTORY) ) return; /* Not a directory */
+#endif
+
+    /* Parse all files in the directory */
+    sprintf( psz_path, "%s\\*", psz_dir );
+
+#ifdef UNDER_CE
+    handle = FindFirstFile( psz_wpath, &finddata );
+#else
+    handle = FindFirstFile( psz_path, &finddata );
+#endif
+    if( handle == INVALID_HANDLE_VALUE )
+    {
+        /* Empty directory */
+        return;
+    }
+
+    /* Parse the directory and try to load all files it contains. */
+    do
+    {
+#ifdef UNDER_CE
+        unsigned int i_len = wcslen( finddata.cFileName );
+        swprintf( psz_wpath, L"%ls\\%ls", psz_wdir, finddata.cFileName );
+        sprintf( psz_path, "%s\\%ls", psz_dir, finddata.cFileName );
+#else
+        unsigned int i_len = strlen( finddata.cFileName );
+        sprintf( psz_path, "%s\\%s", psz_dir, finddata.cFileName );
+#endif
+
+        /* Skip ".", ".." */
+        if( !*finddata.cFileName || !strcmp( finddata.cFileName, "." )
+         || !strcmp( finddata.cFileName, ".." ) )
+        {
+            if( !FindNextFile( handle, &finddata ) ) break;
+            continue;
+        }
+
+#ifdef UNDER_CE
+        if( GetFileAttributes( psz_wpath ) & FILE_ATTRIBUTE_DIRECTORY )
+#else
+        if( GetFileAttributes( psz_path ) & FILE_ATTRIBUTE_DIRECTORY )
+#endif
+        {
+            AllocatePluginDir( p_this, psz_path, i_maxdepth - 1 );
+        }
+        else if( i_len > strlen( LIBEXT )
+                  /* We only load files ending with LIBEXT */
+                  && !strncasecmp( psz_path + strlen( psz_path)
+                                   - strlen( LIBEXT ),
+                                   LIBEXT, strlen( LIBEXT ) ) )
+        {
+            WIN32_FILE_ATTRIBUTE_DATA attrbuf;
+            int64_t i_time = 0, i_size = 0;
+
+#ifdef UNDER_CE
+            if( GetFileAttributesEx( psz_wpath, GetFileExInfoStandard,
+                                     &attrbuf ) )
+#else
+            if( GetFileAttributesEx( psz_path, GetFileExInfoStandard,
+                                     &attrbuf ) )
+#endif
+            {
+                i_time = attrbuf.ftLastWriteTime.dwHighDateTime;
+                i_time <<= 32;
+                i_time |= attrbuf.ftLastWriteTime.dwLowDateTime;
+                i_size = attrbuf.nFileSizeHigh;
+                i_size <<= 32;
+                i_size |= attrbuf.nFileSizeLow;
+            }
+            psz_file = psz_path;
+
+            AllocatePluginFile( p_this, psz_file, i_time, i_size );
+        }
+    }
+    while( !p_this->p_vlc->b_die && FindNextFile( handle, &finddata ) );
+
+    /* Close the directory */
+    FindClose( handle );
+
+#else
+    dir = opendir( psz_dir );
+    if( !dir )
+    {
+        return;
+    }
+
+    i_dirlen = strlen( psz_dir );
+
+    /* Parse the directory and try to load all files it contains. */
+    while( !p_this->p_vlc->b_die && (file = readdir( dir )) )
+    {
+        struct stat statbuf;
+        unsigned int i_len;
+        int i_stat;
+
+        /* Skip ".", ".." */
+        if( !*file->d_name || !strcmp( file->d_name, "." )
+         || !strcmp( file->d_name, ".." ) )
+        {
+            continue;
+        }
+
+        i_len = strlen( file->d_name );
+        psz_file = malloc( i_dirlen + 1 + i_len + 1 );
+#ifdef WIN32
+        sprintf( psz_file, "%s\\%s", psz_dir, file->d_name );
+#else
+        sprintf( psz_file, "%s/%s", psz_dir, file->d_name );
+#endif
+
+        i_stat = stat( psz_file, &statbuf );
+        if( !i_stat && statbuf.st_mode & S_IFDIR )
+        {
+            AllocatePluginDir( p_this, psz_file, i_maxdepth - 1 );
+        }
+        else if( i_len > strlen( LIBEXT )
+                  /* We only load files ending with LIBEXT */
+                  && !strncasecmp( file->d_name + i_len - strlen( LIBEXT ),
+                                   LIBEXT, strlen( LIBEXT ) ) )
+        {
+            int64_t i_time = 0, i_size = 0;
+
+            if( !i_stat )
+            {
+                i_time = statbuf.st_mtime;
+                i_size = statbuf.st_size;
+            }
+
+            AllocatePluginFile( p_this, psz_file, i_time, i_size );
+        }
+
+        free( psz_file );
+    }
+
+    /* Close the directory */
+    closedir( dir );
+
+#endif
+}
+
+/*****************************************************************************
+ * AllocatePluginFile: load a module into memory and initialize it.
+ *****************************************************************************
+ * This function loads a dynamically loadable module and allocates a structure
+ * for its information data. The module can then be handled by module_Need
+ * and module_Unneed. It can be removed by DeleteModule.
+ *****************************************************************************/
+static int AllocatePluginFile( vlc_object_t * p_this, char * psz_file,
+                               int64_t i_file_time, int64_t i_file_size )
+{
+    module_t * p_module;
+    module_cache_t *p_cache_entry = NULL;
+
+    /*
+     * Check our plugins cache first then load plugin if needed
+     */
+    p_cache_entry =
+        CacheFind( p_this, psz_file, i_file_time, i_file_size );
+
+    if( !p_cache_entry )
+    {
+        p_module = AllocatePlugin( p_this, psz_file );
+    }
+    else
+    {
+        /* If junk dll, don't try to load it */
+        if( p_cache_entry->b_junk )
+        {
+            p_module = NULL;
+        }
+        else
+        {
+            module_config_t *p_item;
+
+            p_module = p_cache_entry->p_module;
+            p_module->b_loaded = VLC_FALSE;
+
+            /* For now we force loading if the module's config contains
+             * callbacks or actions.
+             * Could be optimized by adding an API call.*/
+            for( p_item = p_module->p_config;
+                 p_item->i_type != CONFIG_HINT_END; p_item++ )
+            {
+                if( p_item->pf_callback || p_item->i_action )
+                    p_module = AllocatePlugin( p_this, psz_file );
+            }
+        }
+    }
+
+    if( p_module )
+    {
+        /* Everything worked fine !
+         * The module is ready to be added to the list. */
+        p_module->b_builtin = VLC_FALSE;
+
+        /* msg_Dbg( p_this, "plugin \"%s\", %s",
+                    p_module->psz_object_name, p_module->psz_longname ); */
+
+        vlc_object_attach( p_module, p_this->p_libvlc->p_module_bank );
+    }
+
+    if( !p_this->p_libvlc->p_module_bank->b_cache ) return 0;
+
+    /* Add entry to cache */
+#define p_bank p_this->p_libvlc->p_module_bank
+    p_bank->pp_cache =
+        realloc( p_bank->pp_cache, (p_bank->i_cache + 1) * sizeof(void *) );
+    p_bank->pp_cache[p_bank->i_cache] = malloc( sizeof(module_cache_t) );
+    p_bank->pp_cache[p_bank->i_cache]->psz_file = strdup( psz_file );
+    p_bank->pp_cache[p_bank->i_cache]->i_time = i_file_time;
+    p_bank->pp_cache[p_bank->i_cache]->i_size = i_file_size;
+    p_bank->pp_cache[p_bank->i_cache]->b_junk = p_module ? 0 : 1;
+    p_bank->pp_cache[p_bank->i_cache]->p_module = p_module;
+    p_bank->i_cache++;
+
+    return p_module ? 0 : -1;
+}
+
+/*****************************************************************************
+ * AllocatePlugin: load a module into memory and initialize it.
+ *****************************************************************************
+ * This function loads a dynamically loadable module and allocates a structure
+ * for its information data. The module can then be handled by module_Need
+ * and module_Unneed. It can be removed by DeleteModule.
+ *****************************************************************************/
+static module_t * AllocatePlugin( vlc_object_t * p_this, char * psz_file )
+{
+    module_t * p_module;
+    module_handle_t handle;
+
+    if( LoadModule( p_this, psz_file, &handle ) ) return NULL;
+
+    /* Now that we have successfully loaded the module, we can
+     * allocate a structure for it */
+    p_module = vlc_object_create( p_this, VLC_OBJECT_MODULE );
+    if( p_module == NULL )
+    {
+        msg_Err( p_this, "out of memory" );
+        CloseModule( handle );
+        return NULL;
+    }
+
+    /* We need to fill these since they may be needed by CallEntry() */
+    p_module->psz_filename = psz_file;
+    p_module->handle = handle;
+#ifndef HAVE_SHARED_LIBVLC
+    p_module->p_symbols = &p_this->p_libvlc->p_module_bank->symbols;
+#endif
+    p_module->b_loaded = VLC_TRUE;
+
+    /* Initialize the module: fill p_module, default config */
+    if( CallEntry( p_module ) != 0 )
+    {
+        /* We couldn't call module_init() */
+        vlc_object_destroy( p_module );
+        CloseModule( handle );
+        return NULL;
+    }
+
+    DupModule( p_module );
+    p_module->psz_filename = strdup( p_module->psz_filename );
+
+    /* Everything worked fine ! The module is ready to be added to the list. */
+    p_module->b_builtin = VLC_FALSE;
+
+    return p_module;
+}
+
+/*****************************************************************************
+ * DupModule: make a plugin module standalone.
+ *****************************************************************************
+ * This function duplicates all strings in the module, so that the dynamic
+ * object can be unloaded. It acts recursively on submodules.
+ *****************************************************************************/
+static void DupModule( module_t *p_module )
+{
+    char **pp_shortcut;
+    int i_submodule;
+
+    for( pp_shortcut = p_module->pp_shortcuts ; *pp_shortcut ; pp_shortcut++ )
+    {
+        *pp_shortcut = strdup( *pp_shortcut );
+    }
+
+    /* We strdup() these entries so that they are still valid when the
+     * module is unloaded. */
+    p_module->psz_object_name = strdup( p_module->psz_object_name );
+    p_module->psz_capability = strdup( p_module->psz_capability );
+    p_module->psz_shortname = p_module->psz_shortname ?
+                                 strdup( p_module->psz_shortname ) : NULL;
+    p_module->psz_longname = strdup( p_module->psz_longname );
+
+    if( p_module->psz_program != NULL )
+    {
+        p_module->psz_program = strdup( p_module->psz_program );
+    }
+
+    for( i_submodule = 0; i_submodule < p_module->i_children; i_submodule++ )
+    {
+        DupModule( (module_t*)p_module->pp_children[ i_submodule ] );
+    }
+}
+
+/*****************************************************************************
+ * UndupModule: free a duplicated module.
+ *****************************************************************************
+ * This function frees the allocations done in DupModule().
+ *****************************************************************************/
+static void UndupModule( module_t *p_module )
+{
+    char **pp_shortcut;
+    int i_submodule;
+
+    for( i_submodule = 0; i_submodule < p_module->i_children; i_submodule++ )
+    {
+        UndupModule( (module_t*)p_module->pp_children[ i_submodule ] );
+    }
+
+    for( pp_shortcut = p_module->pp_shortcuts ; *pp_shortcut ; pp_shortcut++ )
+    {
+        free( *pp_shortcut );
+    }
+
+    free( p_module->psz_object_name );
+    free( p_module->psz_capability );
+    if( p_module->psz_shortname ) free( p_module->psz_shortname );
+    free( p_module->psz_longname );
+
+    if( p_module->psz_program != NULL )
+    {
+        free( p_module->psz_program );
+    }
+}
+
+#endif /* HAVE_DYNAMIC_PLUGINS */
+
+/*****************************************************************************
+ * AllocateBuiltinModule: initialize a builtin module.
+ *****************************************************************************
+ * This function registers a builtin module and allocates a structure
+ * for its information data. The module can then be handled by module_Need
+ * and module_Unneed. It can be removed by DeleteModule.
+ *****************************************************************************/
+static int AllocateBuiltinModule( vlc_object_t * p_this,
+                                  int ( *pf_entry ) ( module_t * ) )
+{
+    module_t * p_module;
+
+    /* Now that we have successfully loaded the module, we can
+     * allocate a structure for it */
+    p_module = vlc_object_create( p_this, VLC_OBJECT_MODULE );
+    if( p_module == NULL )
+    {
+        msg_Err( p_this, "out of memory" );
+        return -1;
+    }
+
+    /* Initialize the module : fill p_module->psz_object_name, etc. */
+    if( pf_entry( p_module ) != 0 )
+    {
+        /* With a well-written module we shouldn't have to print an
+         * additional error message here, but just make sure. */
+        msg_Err( p_this, "failed calling entry point in builtin module" );
+        vlc_object_destroy( p_module );
+        return -1;
+    }
+
+    /* Everything worked fine ! The module is ready to be added to the list. */
+    p_module->b_builtin = VLC_TRUE;
+
+    /* msg_Dbg( p_this, "builtin \"%s\", %s",
+                p_module->psz_object_name, p_module->psz_longname ); */
+
+    vlc_object_attach( p_module, p_this->p_libvlc->p_module_bank );
+
+    return 0;
+}
+
+/*****************************************************************************
+ * DeleteModule: delete a module and its structure.
+ *****************************************************************************
+ * This function can only be called if the module isn't being used.
+ *****************************************************************************/
+static int DeleteModule( module_t * p_module )
+{
+    vlc_object_detach( p_module );
+
+    /* We free the structures that we strdup()ed in Allocate*Module(). */
+#ifdef HAVE_DYNAMIC_PLUGINS
+    if( !p_module->b_builtin )
+    {
+        if( p_module->b_loaded && p_module->b_unloadable )
+        {
+            CloseModule( p_module->handle );
+        }
+        UndupModule( p_module );
+        free( p_module->psz_filename );
+    }
+#endif
+
+    /* Free and detach the object's children */
+    while( p_module->i_children )
+    {
+        vlc_object_t *p_this = p_module->pp_children[0];
+        vlc_object_detach( p_this );
+        vlc_object_destroy( p_this );
+    }
+
+    config_Free( p_module );
+    vlc_object_destroy( p_module );
+
+    return 0;
+}
+
+#ifdef HAVE_DYNAMIC_PLUGINS
+/*****************************************************************************
+ * CallEntry: call an entry point.
+ *****************************************************************************
+ * This function calls a symbol given its name and a module structure. The
+ * symbol MUST refer to a function returning int and taking a module_t* as
+ * an argument.
+ *****************************************************************************/
+static int CallEntry( module_t * p_module )
+{
+    static char *psz_name = "vlc_entry" MODULE_SUFFIX;
+    int (* pf_symbol) ( module_t * p_module );
+
+    /* Try to resolve the symbol */
+    pf_symbol = (int (*)(module_t *)) GetSymbol( p_module->handle, psz_name );
+
+    if( pf_symbol == NULL )
+    {
+#if defined(HAVE_DL_DYLD) || defined(HAVE_DL_BEOS)
+        msg_Warn( p_module, "cannot find symbol \"%s\" in file `%s'",
+                            psz_name, p_module->psz_filename );
+#elif defined(HAVE_DL_WINDOWS)
+        char *psz_error = GetWindowsError();
+        msg_Warn( p_module, "cannot find symbol \"%s\" in file `%s' (%s)",
+                            psz_name, p_module->psz_filename, psz_error );
+        free( psz_error );
+#elif defined(HAVE_DL_DLOPEN)
+        msg_Warn( p_module, "cannot find symbol \"%s\" in file `%s' (%s)",
+                            psz_name, p_module->psz_filename, dlerror() );
+#elif defined(HAVE_DL_SHL_LOAD)
+        msg_Warn( p_module, "cannot find symbol \"%s\" in file `%s' (%s)",
+                            psz_name, p_module->psz_filename, strerror(errno) );
+#else
+#   error "Something is wrong in modules.c"
+#endif
+        return -1;
+    }
+
+    /* We can now try to call the symbol */
+    if( pf_symbol( p_module ) != 0 )
+    {
+        /* With a well-written module we shouldn't have to print an
+         * additional error message here, but just make sure. */
+        msg_Err( p_module, "Failed to call symbol \"%s\" in file `%s'",
+                           psz_name, p_module->psz_filename );
+        return -1;
+    }
+
+    /* Everything worked fine, we can return */
+    return 0;
+}
+
+/*****************************************************************************
+ * LoadModule: loads a dynamic library
+ *****************************************************************************
+ * This function loads a dynamically linked library using a system dependant
+ * method. Will return 0 on success as well as the module handle.
+ *****************************************************************************/
+static int LoadModule( vlc_object_t *p_this, char *psz_file,
+                       module_handle_t *p_handle )
+{
+    module_handle_t handle;
+
+#if defined(HAVE_DL_DYLD)
+    NSObjectFileImage image;
+    NSObjectFileImageReturnCode ret;
+
+    ret = NSCreateObjectFileImageFromFile( psz_file, &image );
+
+    if( ret != NSObjectFileImageSuccess )
+    {
+        msg_Warn( p_this, "cannot create image from `%s'", psz_file );
+        return -1;
+    }
+
+    /* Open the dynamic module */
+    handle = NSLinkModule( image, psz_file,
+                           NSLINKMODULE_OPTION_RETURN_ON_ERROR );
+
+    if( !handle )
+    {
+        NSLinkEditErrors errors;
+        const char *psz_file, *psz_err;
+        int i_errnum;
+        NSLinkEditError( &errors, &i_errnum, &psz_file, &psz_err );
+        msg_Warn( p_this, "cannot link module `%s' (%s)", psz_file, psz_err );
+        NSDestroyObjectFileImage( image );
+        return -1;
+    }
+
+    /* Destroy our image, we won't need it */
+    NSDestroyObjectFileImage( image );
+
+#elif defined(HAVE_DL_BEOS)
+    handle = load_add_on( psz_file );
+    if( handle < 0 )
+    {
+        msg_Warn( p_this, "cannot load module `%s'", psz_file );
+        return -1;
+    }
+
+#elif defined(HAVE_DL_WINDOWS)
+#ifdef UNDER_CE
+    {
+        wchar_t psz_wfile[MAX_PATH];
+        MultiByteToWideChar( CP_ACP, 0, psz_file, -1, psz_wfile, MAX_PATH );
+        handle = LoadLibrary( psz_wfile );
+    }
+#else
+    handle = LoadLibrary( psz_file );
+#endif
+    if( handle == NULL )
+    {
+        char *psz_err = GetWindowsError();
+        msg_Warn( p_this, "cannot load module `%s' (%s)", psz_file, psz_err );
+        free( psz_err );
+        return -1;
+    }
+
+#elif defined(HAVE_DL_DLOPEN) && defined(RTLD_NOW)
+    /* static is OK, we are called atomically */
+
+#   if defined(SYS_LINUX)
+    /* XXX HACK #1 - we should NOT open modules with RTLD_GLOBAL, or we
+     * are going to get namespace collisions when two modules have common
+     * public symbols, but ALSA is being a pest here. */
+    if( strstr( psz_file, "alsa_plugin" ) )
+    {
+        handle = dlopen( psz_file, RTLD_NOW | RTLD_GLOBAL );
+        if( handle == NULL )
+        {
+            msg_Warn( p_this, "cannot load module `%s' (%s)",
+                              psz_file, dlerror() );
+            return -1;
+        }
+    }
+#   endif
+
+    handle = dlopen( psz_file, RTLD_NOW );
+    if( handle == NULL )
+    {
+        msg_Warn( p_this, "cannot load module `%s' (%s)",
+                          psz_file, dlerror() );
+        return -1;
+    }
+
+#elif defined(HAVE_DL_DLOPEN)
+#   if defined(DL_LAZY)
+    handle = dlopen( psz_file, DL_LAZY );
+#   else
+    handle = dlopen( psz_file, 0 );
+#   endif
+    if( handle == NULL )
+    {
+        msg_Warn( p_this, "cannot load module `%s' (%s)",
+                          psz_file, dlerror() );
+        return -1;
+    }
+
+#elif defined(HAVE_DL_SHL_LOAD)
+    handle = shl_load( psz_file, BIND_IMMEDIATE | BIND_NONFATAL, NULL );
+    if( handle == NULL )
+    {
+        msg_Warn( p_this, "cannot load module `%s' (%s)",
+                          psz_file, strerror(errno) );
+        return -1;
+    }
+
+#else
+#   error "Something is wrong in modules.c"
+
+#endif
+
+    *p_handle = handle;
+    return 0;
+}
+
+/*****************************************************************************
+ * CloseModule: unload a dynamic library
+ *****************************************************************************
+ * This function unloads a previously opened dynamically linked library
+ * using a system dependant method. No return value is taken in consideration,
+ * since some libraries sometimes refuse to close properly.
+ *****************************************************************************/
+static void CloseModule( module_handle_t handle )
+{
+#if defined(HAVE_DL_DYLD)
+    NSUnLinkModule( handle, FALSE );
+
+#elif defined(HAVE_DL_BEOS)
+    unload_add_on( handle );
+
+#elif defined(HAVE_DL_WINDOWS)
+    FreeLibrary( handle );
+
+#elif defined(HAVE_DL_DLOPEN)
+    dlclose( handle );
+
+#elif defined(HAVE_DL_SHL_LOAD)
+    shl_unload( handle );
+
+#endif
+    return;
+}
+
+/*****************************************************************************
+ * GetSymbol: get a symbol from a dynamic library
+ *****************************************************************************
+ * This function queries a loaded library for a symbol specified in a
+ * string, and returns a pointer to it. We don't check for dlerror() or
+ * similar functions, since we want a non-NULL symbol anyway.
+ *****************************************************************************/
+static void * _module_getsymbol( module_handle_t, const char * );
+
+static void * GetSymbol( module_handle_t handle, const char * psz_function )
+{
+    void * p_symbol = _module_getsymbol( handle, psz_function );
+
+    /* MacOS X dl library expects symbols to begin with "_". So do
+     * some other operating systems. That's really lame, but hey, what
+     * can we do ? */
+    if( p_symbol == NULL )
+    {
+        char *psz_call = malloc( strlen( psz_function ) + 2 );
+
+        strcpy( psz_call + 1, psz_function );
+        psz_call[ 0 ] = '_';
+        p_symbol = _module_getsymbol( handle, psz_call );
+        free( psz_call );
+    }
+
+    return p_symbol;
+}
+
+static void * _module_getsymbol( module_handle_t handle,
+                                 const char * psz_function )
+{
+#if defined(HAVE_DL_DYLD)
+    NSSymbol sym = NSLookupSymbolInModule( handle, psz_function );
+    return NSAddressOfSymbol( sym );
+
+#elif defined(HAVE_DL_BEOS)
+    void * p_symbol;
+    if( B_OK == get_image_symbol( handle, psz_function,
+                                  B_SYMBOL_TYPE_TEXT, &p_symbol ) )
+    {
+        return p_symbol;
+    }
+    else
+    {
+        return NULL;
+    }
+
+#elif defined(HAVE_DL_WINDOWS) && defined(UNDER_CE)
+    wchar_t psz_real[256];
+    MultiByteToWideChar( CP_ACP, 0, psz_function, -1, psz_real, 256 );
+
+    return (void *)GetProcAddress( handle, psz_real );
+
+#elif defined(HAVE_DL_WINDOWS) && defined(WIN32)
+    return (void *)GetProcAddress( handle, (char *)psz_function );
+
+#elif defined(HAVE_DL_DLOPEN)
+    return dlsym( handle, psz_function );
+
+#elif defined(HAVE_DL_SHL_LOAD)
+    void *p_sym;
+    shl_findsym( &handle, psz_function, TYPE_UNDEFINED, &p_sym );
+    return p_sym;
+
+#endif
+}
+
+#if defined(HAVE_DL_WINDOWS)
+static char * GetWindowsError( void )
+{
+#if defined(UNDER_CE)
+    wchar_t psz_tmp[MAX_PATH];
+    char * psz_buffer = malloc( MAX_PATH );
+#else
+    char * psz_tmp = malloc( MAX_PATH );
+#endif
+    int i = 0, i_error = GetLastError();
+
+    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
+                   NULL, i_error, MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
+                   (LPTSTR)psz_tmp, MAX_PATH, NULL );
+
+    /* Go to the end of the string */
+    while( psz_tmp[i] && psz_tmp[i] != _T('\r') && psz_tmp[i] != _T('\n') )
+    {
+        i++;
+    }
+
+    if( psz_tmp[i] )
+    {
+#if defined(UNDER_CE)
+        swprintf( psz_tmp + i, L" (error %i)", i_error );
+        psz_tmp[ 255 ] = L'\0';
+#else
+        snprintf( psz_tmp + i, 256 - i, " (error %i)", i_error );
+        psz_tmp[ 255 ] = '\0';
+#endif
+    }
+
+#if defined(UNDER_CE)
+    wcstombs( psz_buffer, psz_tmp, MAX_PATH );
+    return psz_buffer;
+#else
+    return psz_tmp;
+#endif
+}
+#endif /* HAVE_DL_WINDOWS */
+
+/*****************************************************************************
+ * LoadPluginsCache: loads the plugins cache file
+ *****************************************************************************
+ * This function will load the plugin cache if present and valid. This cache
+ * will in turn be queried by AllocateAllPlugins() to see if it needs to
+ * actually load the dynamically loadable module.
+ * This allows us to only fully load plugins when they are actually used.
+ *****************************************************************************/
+static void CacheLoad( vlc_object_t *p_this )
+{
+    char *psz_filename, *psz_homedir;
+    FILE *file;
+    int i, j, i_size, i_read;
+    char p_cachestring[sizeof(PLUGINSCACHE_DIR COPYRIGHT_MESSAGE)];
+    char p_cachelang[6], p_lang[6];
+    int i_cache;
+    module_cache_t **pp_cache = 0;
+    int32_t i_file_size, i_marker;
+
+    psz_homedir = p_this->p_vlc->psz_homedir;
+    if( !psz_homedir )
+    {
+        msg_Err( p_this, "psz_homedir is null" );
+        return;
+    }
+
+    i_size = asprintf( &psz_filename, "%s/%s/%s/%s", psz_homedir, CONFIG_DIR,
+                       PLUGINSCACHE_DIR, CacheName() );
+    if( i_size <= 0 )
+    {
+        msg_Err( p_this, "out of memory" );
+        return;
+    }
+
+    if( p_this->p_libvlc->p_module_bank->b_cache_delete )
+    {
+#if !defined( UNDER_CE )
+        unlink( psz_filename );
+#else
+        wchar_t psz_wf[MAX_PATH];
+        MultiByteToWideChar( CP_ACP, 0, psz_filename, -1, psz_wf, MAX_PATH );
+        DeleteFile( psz_wf );
+#endif
+        msg_Dbg( p_this, "removing plugins cache file %s", psz_filename );
+        free( psz_filename );
+        return;
+    }
+
+    msg_Dbg( p_this, "loading plugins cache file %s", psz_filename );
+
+    file = utf8_fopen( psz_filename, "rb" );
+    if( !file )
+    {
+        msg_Warn( p_this, "could not open plugins cache file %s for reading",
+                  psz_filename );
+        free( psz_filename );
+        return;
+    }
+    free( psz_filename );
+
+    /* Check the file size */
+    i_read = fread( &i_file_size, sizeof(char), sizeof(i_file_size), file );
+    if( i_read != sizeof(i_file_size) )
+    {
+        msg_Warn( p_this, "This doesn't look like a valid plugins cache "
+                  "(too short)" );
+        fclose( file );
+        return;
+    }
+
+    fseek( file, 0, SEEK_END );
+    if( ftell( file ) != i_file_size )
+    {
+        msg_Warn( p_this, "This doesn't look like a valid plugins cache "
+                  "(corrupted size)" );
+        fclose( file );
+        return;
+    }
+    fseek( file, sizeof(i_file_size), SEEK_SET );
+
+    /* Check the file is a plugins cache */
+    i_size = sizeof(PLUGINSCACHE_DIR COPYRIGHT_MESSAGE) - 1;
+    i_read = fread( p_cachestring, sizeof(char), i_size, file );
+    if( i_read != i_size ||
+        memcmp( p_cachestring, PLUGINSCACHE_DIR COPYRIGHT_MESSAGE, i_size ) )
+    {
+        msg_Warn( p_this, "This doesn't look like a valid plugins cache" );
+        fclose( file );
+        return;
+    }
+
+    /* Check Sub-version number */
+    i_read = fread( &i_marker, sizeof(char), sizeof(i_marker), file );
+    if( i_read != sizeof(i_marker) || i_marker != CACHE_SUBVERSION_NUM )
+    {
+        msg_Warn( p_this, "This doesn't look like a valid plugins cache "
+                  "(corrupted header)" );
+        fclose( file );
+        return;
+    }
+
+    /* Check the language hasn't changed */
+    sprintf( p_lang, "%5.5s", _("C") ); i_size = 5;
+    i_read = fread( p_cachelang, sizeof(char), i_size, file );
+    if( i_read != i_size || memcmp( p_cachelang, p_lang, i_size ) )
+    {
+        msg_Warn( p_this, "This doesn't look like a valid plugins cache "
+                  "(language changed)" );
+        fclose( file );
+        return;
+    }
+
+    /* Check header marker */
+    i_read = fread( &i_marker, sizeof(char), sizeof(i_marker), file );
+    if( i_read != sizeof(i_marker) ||
+        i_marker != ftell( file ) - (int)sizeof(i_marker) )
+    {
+        msg_Warn( p_this, "This doesn't look like a valid plugins cache "
+                  "(corrupted header)" );
+        fclose( file );
+        return;
+    }
+
+    p_this->p_libvlc->p_module_bank->i_loaded_cache = 0;
+    fread( &i_cache, sizeof(char), sizeof(i_cache), file );
+    if( i_cache )
+        pp_cache = p_this->p_libvlc->p_module_bank->pp_loaded_cache =
+                   malloc( i_cache * sizeof(void *) );
+
+#define LOAD_IMMEDIATE(a) \
+    if( fread( &a, sizeof(char), sizeof(a), file ) != sizeof(a) ) goto error
+#define LOAD_STRING(a) \
+    { if( fread( &i_size, sizeof(char), sizeof(i_size), file ) \
+          != sizeof(i_size) ) goto error; \
+      if( i_size && i_size < 16384 ) { \
+          a = malloc( i_size ); \
+          if( fread( a, sizeof(char), i_size, file ) != (size_t)i_size ) \
+              goto error; \
+          if( a[i_size-1] ) { \
+              free( a ); a = 0; \
+              goto error; } \
+      } else a = 0; \
+    } while(0)
+
+
+    for( i = 0; i < i_cache; i++ )
+    {
+        uint16_t i_size;
+        int i_submodules;
+
+        pp_cache[i] = malloc( sizeof(module_cache_t) );
+        p_this->p_libvlc->p_module_bank->i_loaded_cache++;
+
+        /* Load common info */
+        LOAD_STRING( pp_cache[i]->psz_file );
+        LOAD_IMMEDIATE( pp_cache[i]->i_time );
+        LOAD_IMMEDIATE( pp_cache[i]->i_size );
+        LOAD_IMMEDIATE( pp_cache[i]->b_junk );
+
+        if( pp_cache[i]->b_junk ) continue;
+
+        pp_cache[i]->p_module = vlc_object_create( p_this, VLC_OBJECT_MODULE );
+
+        /* Load additional infos */
+        LOAD_STRING( pp_cache[i]->p_module->psz_object_name );
+        LOAD_STRING( pp_cache[i]->p_module->psz_shortname );
+        LOAD_STRING( pp_cache[i]->p_module->psz_longname );
+        LOAD_STRING( pp_cache[i]->p_module->psz_program );
+        for( j = 0; j < MODULE_SHORTCUT_MAX; j++ )
+        {
+            LOAD_STRING( pp_cache[i]->p_module->pp_shortcuts[j] ); // FIX
+        }
+        LOAD_STRING( pp_cache[i]->p_module->psz_capability );
+        LOAD_IMMEDIATE( pp_cache[i]->p_module->i_score );
+        LOAD_IMMEDIATE( pp_cache[i]->p_module->i_cpu );
+        LOAD_IMMEDIATE( pp_cache[i]->p_module->b_unloadable );
+        LOAD_IMMEDIATE( pp_cache[i]->p_module->b_reentrant );
+        LOAD_IMMEDIATE( pp_cache[i]->p_module->b_submodule );
+
+        /* Config stuff */
+        if( CacheLoadConfig( pp_cache[i]->p_module, file ) != VLC_SUCCESS )
+            goto error;
+
+        LOAD_STRING( pp_cache[i]->p_module->psz_filename );
+
+        LOAD_IMMEDIATE( i_submodules );
+
+        while( i_submodules-- )
+        {
+            module_t *p_module = vlc_object_create( p_this, VLC_OBJECT_MODULE);
+            vlc_object_attach( p_module, pp_cache[i]->p_module );
+            p_module->b_submodule = VLC_TRUE;
+
+            LOAD_STRING( p_module->psz_object_name );
+            LOAD_STRING( p_module->psz_shortname );
+            LOAD_STRING( p_module->psz_longname );
+            LOAD_STRING( p_module->psz_program );
+            for( j = 0; j < MODULE_SHORTCUT_MAX; j++ )
+            {
+                LOAD_STRING( p_module->pp_shortcuts[j] ); // FIX
+            }
+            LOAD_STRING( p_module->psz_capability );
+            LOAD_IMMEDIATE( p_module->i_score );
+            LOAD_IMMEDIATE( p_module->i_cpu );
+            LOAD_IMMEDIATE( p_module->b_unloadable );
+            LOAD_IMMEDIATE( p_module->b_reentrant );
+        }
+    }
+
+    fclose( file );
+    return;
+
+ error:
+
+    msg_Warn( p_this, "plugins cache not loaded (corrupted)" );
+
+    /* TODO: cleanup */
+    p_this->p_libvlc->p_module_bank->i_loaded_cache = 0;
+
+    fclose( file );
+    return;
+}
+
+int CacheLoadConfig( module_t *p_module, FILE *file )
+{
+    int i, j, i_lines;
+    uint16_t i_size;
+
+    /* Calculate the structure length */
+    LOAD_IMMEDIATE( p_module->i_config_items );
+    LOAD_IMMEDIATE( p_module->i_bool_items );
+
+    LOAD_IMMEDIATE( i_lines );
+
+    /* Allocate memory */
+    p_module->p_config =
+        (module_config_t *)malloc( sizeof(module_config_t) * (i_lines + 1));
+    if( p_module->p_config == NULL )
+    {
+        msg_Err( p_module, "config error: can't duplicate p_config" );
+        return VLC_ENOMEM;
+    }
+
+    /* Do the duplication job */
+    for( i = 0; i < i_lines ; i++ )
+    {
+        LOAD_IMMEDIATE( p_module->p_config[i] );
+
+        LOAD_STRING( p_module->p_config[i].psz_type );
+        LOAD_STRING( p_module->p_config[i].psz_name );
+        LOAD_STRING( p_module->p_config[i].psz_text );
+        LOAD_STRING( p_module->p_config[i].psz_longtext );
+        LOAD_STRING( p_module->p_config[i].psz_current );
+        LOAD_STRING( p_module->p_config[i].psz_value_orig );
+
+        p_module->p_config[i].psz_value =
+            p_module->p_config[i].psz_value_orig ?
+                strdup( p_module->p_config[i].psz_value_orig ) : 0;
+        p_module->p_config[i].i_value = p_module->p_config[i].i_value_orig;
+        p_module->p_config[i].f_value = p_module->p_config[i].f_value_orig;
+        p_module->p_config[i].i_value_saved = p_module->p_config[i].i_value;
+        p_module->p_config[i].f_value_saved = p_module->p_config[i].f_value;
+        p_module->p_config[i].psz_value_saved = 0;
+        p_module->p_config[i].b_dirty = VLC_FALSE;
+
+        p_module->p_config[i].p_lock = &p_module->object_lock;
+
+        if( p_module->p_config[i].i_list )
+        {
+            if( p_module->p_config[i].ppsz_list )
+            {
+                p_module->p_config[i].ppsz_list =
+                    malloc( (p_module->p_config[i].i_list+1) * sizeof(char *));
+                if( p_module->p_config[i].ppsz_list )
+                {
+                    for( j = 0; j < p_module->p_config[i].i_list; j++ )
+                        LOAD_STRING( p_module->p_config[i].ppsz_list[j] );
+                    p_module->p_config[i].ppsz_list[j] = NULL;
+                }
+            }
+            if( p_module->p_config[i].ppsz_list_text )
+            {
+                p_module->p_config[i].ppsz_list_text =
+                    malloc( (p_module->p_config[i].i_list+1) * sizeof(char *));
+                if( p_module->p_config[i].ppsz_list_text )
+                {
+                  for( j = 0; j < p_module->p_config[i].i_list; j++ )
+                      LOAD_STRING( p_module->p_config[i].ppsz_list_text[j] );
+                  p_module->p_config[i].ppsz_list_text[j] = NULL;
+                }
+            }
+            if( p_module->p_config[i].pi_list )
+            {
+                p_module->p_config[i].pi_list =
+                    malloc( (p_module->p_config[i].i_list + 1) * sizeof(int) );
+                if( p_module->p_config[i].pi_list )
+                {
+                    for( j = 0; j < p_module->p_config[i].i_list; j++ )
+                        LOAD_IMMEDIATE( p_module->p_config[i].pi_list[j] );
+                }
+            }
+        }
+
+        if( p_module->p_config[i].i_action )
+        {
+            p_module->p_config[i].ppf_action =
+                malloc( p_module->p_config[i].i_action * sizeof(void *) );
+            p_module->p_config[i].ppsz_action_text =
+                malloc( p_module->p_config[i].i_action * sizeof(char *) );
+
+            for( j = 0; j < p_module->p_config[i].i_action; j++ )
+            {
+                p_module->p_config[i].ppf_action[j] = 0;
+                LOAD_STRING( p_module->p_config[i].ppsz_action_text[j] );
+            }
+        }
+
+        LOAD_IMMEDIATE( p_module->p_config[i].pf_callback );
+    }
+
+    p_module->p_config[i].i_type = CONFIG_HINT_END;
+
+    return VLC_SUCCESS;
+
+ error:
+
+    return VLC_EGENERIC;
+}
+
+/*****************************************************************************
+ * SavePluginsCache: saves the plugins cache to a file
+ *****************************************************************************/
+static void CacheSave( vlc_object_t *p_this )
+{
+    static char const psz_tag[] =
+        "Signature: 8a477f597d28d172789f06886806bc55\r\n"
+        "# This file is a cache directory tag created by VLC.\r\n"
+        "# For information about cache directory tags, see:\r\n"
+        "#   http://www.brynosaurus.com/cachedir/\r\n";
+
+    char *psz_filename, *psz_homedir;
+    FILE *file;
+    int i, j, i_cache;
+    module_cache_t **pp_cache;
+    int32_t i_file_size = 0;
+
+    psz_homedir = p_this->p_vlc->psz_homedir;
+    if( !psz_homedir )
+    {
+        msg_Err( p_this, "psz_homedir is null" );
+        return;
+    }
+    psz_filename =
+       (char *)malloc( sizeof("/" CONFIG_DIR "/" PLUGINSCACHE_DIR "/" ) +
+                       strlen(psz_homedir) + strlen(CacheName()) );
+
+    if( !psz_filename )
+    {
+        msg_Err( p_this, "out of memory" );
+        return;
+    }
+
+    sprintf( psz_filename, "%s/%s", psz_homedir, CONFIG_DIR );
+
+    config_CreateDir( p_this, psz_filename );
+
+    strcat( psz_filename, "/" PLUGINSCACHE_DIR );
+
+    config_CreateDir( p_this, psz_filename );
+
+    strcat( psz_filename, "/CACHEDIR.TAG" );
+
+    file = utf8_fopen( psz_filename, "wb" );
+    if( file )
+    {
+        fwrite( psz_tag, 1, strlen(psz_tag), file );
+        fclose( file );
+    }
+
+    sprintf( psz_filename, "%s/%s/%s/%s", psz_homedir, CONFIG_DIR,
+             PLUGINSCACHE_DIR, CacheName() );
+
+    msg_Dbg( p_this, "saving plugins cache file %s", psz_filename );
+
+    file = utf8_fopen( psz_filename, "wb" );
+    if( !file )
+    {
+        msg_Warn( p_this, "could not open plugins cache file %s for writing",
+                  psz_filename );
+        free( psz_filename );
+        return;
+    }
+    free( psz_filename );
+
+    /* Empty space for file size */
+    fwrite( &i_file_size, sizeof(char), sizeof(i_file_size), file );
+
+    /* Contains version number */
+    fprintf( file, "%s", PLUGINSCACHE_DIR COPYRIGHT_MESSAGE );
+
+    /* Sub-version number (to avoid breakage in the dev version when cache
+     * structure changes) */
+    i_file_size = CACHE_SUBVERSION_NUM;
+    fwrite( &i_file_size, sizeof(char), sizeof(i_file_size), file );
+
+    /* Language */
+    fprintf( file, "%5.5s", _("C") );
+
+    /* Header marker */
+    i_file_size = ftell( file );
+    fwrite( &i_file_size, sizeof(char), sizeof(i_file_size), file );
+
+    i_cache = p_this->p_libvlc->p_module_bank->i_cache;
+    pp_cache = p_this->p_libvlc->p_module_bank->pp_cache;
+
+    fwrite( &i_cache, sizeof(char), sizeof(i_cache), file );
+
+#define SAVE_IMMEDIATE(a) \
+    fwrite( &a, sizeof(char), sizeof(a), file )
+#define SAVE_STRING(a) \
+    { i_size = a ? strlen( a ) + 1 : 0; \
+      fwrite( &i_size, sizeof(char), sizeof(i_size), file ); \
+      if( a ) fwrite( a, sizeof(char), i_size, file ); \
+    } while(0)
+
+    for( i = 0; i < i_cache; i++ )
+    {
+        uint16_t i_size;
+        uint32_t i_submodule;
+
+        /* Save common info */
+        SAVE_STRING( pp_cache[i]->psz_file );
+        SAVE_IMMEDIATE( pp_cache[i]->i_time );
+        SAVE_IMMEDIATE( pp_cache[i]->i_size );
+        SAVE_IMMEDIATE( pp_cache[i]->b_junk );
+
+        if( pp_cache[i]->b_junk ) continue;
+
+        /* Save additional infos */
+        SAVE_STRING( pp_cache[i]->p_module->psz_object_name );
+        SAVE_STRING( pp_cache[i]->p_module->psz_shortname );
+        SAVE_STRING( pp_cache[i]->p_module->psz_longname );
+        SAVE_STRING( pp_cache[i]->p_module->psz_program );
+        for( j = 0; j < MODULE_SHORTCUT_MAX; j++ )
+        {
+            SAVE_STRING( pp_cache[i]->p_module->pp_shortcuts[j] ); // FIX
+        }
+        SAVE_STRING( pp_cache[i]->p_module->psz_capability );
+        SAVE_IMMEDIATE( pp_cache[i]->p_module->i_score );
+        SAVE_IMMEDIATE( pp_cache[i]->p_module->i_cpu );
+        SAVE_IMMEDIATE( pp_cache[i]->p_module->b_unloadable );
+        SAVE_IMMEDIATE( pp_cache[i]->p_module->b_reentrant );
+        SAVE_IMMEDIATE( pp_cache[i]->p_module->b_submodule );
+
+        /* Config stuff */
+        CacheSaveConfig( pp_cache[i]->p_module, file );
+
+        SAVE_STRING( pp_cache[i]->p_module->psz_filename );
+
+        i_submodule = pp_cache[i]->p_module->i_children;
+        SAVE_IMMEDIATE( i_submodule );
+        for( i_submodule = 0; i_submodule < (unsigned)pp_cache[i]->p_module->i_children;
+             i_submodule++ )
+        {
+            module_t *p_module =
+                (module_t *)pp_cache[i]->p_module->pp_children[i_submodule];
+
+            SAVE_STRING( p_module->psz_object_name );
+            SAVE_STRING( p_module->psz_shortname );
+            SAVE_STRING( p_module->psz_longname );
+            SAVE_STRING( p_module->psz_program );
+            for( j = 0; j < MODULE_SHORTCUT_MAX; j++ )
+            {
+                SAVE_STRING( p_module->pp_shortcuts[j] ); // FIX
+            }
+            SAVE_STRING( p_module->psz_capability );
+            SAVE_IMMEDIATE( p_module->i_score );
+            SAVE_IMMEDIATE( p_module->i_cpu );
+            SAVE_IMMEDIATE( p_module->b_unloadable );
+            SAVE_IMMEDIATE( p_module->b_reentrant );
+        }
+    }
+
+    /* Fill-up file size */
+    i_file_size = ftell( file );
+    fseek( file, 0, SEEK_SET );
+    fwrite( &i_file_size, sizeof(char), sizeof(i_file_size), file );
+
+    fclose( file );
+
+    return;
+}
+
+void CacheSaveConfig( module_t *p_module, FILE *file )
+{
+    int i, j, i_lines = 0;
+    module_config_t *p_item;
+    uint16_t i_size;
+
+    SAVE_IMMEDIATE( p_module->i_config_items );
+    SAVE_IMMEDIATE( p_module->i_bool_items );
+
+    for( p_item = p_module->p_config; p_item->i_type != CONFIG_HINT_END;
+         p_item++ ) i_lines++;
+
+    SAVE_IMMEDIATE( i_lines );
+
+    for( i = 0; i < i_lines ; i++ )
+    {
+        SAVE_IMMEDIATE( p_module->p_config[i] );
+
+        SAVE_STRING( p_module->p_config[i].psz_type );
+        SAVE_STRING( p_module->p_config[i].psz_name );
+        SAVE_STRING( p_module->p_config[i].psz_text );
+        SAVE_STRING( p_module->p_config[i].psz_longtext );
+        SAVE_STRING( p_module->p_config[i].psz_current );
+        SAVE_STRING( p_module->p_config[i].psz_value_orig );
+
+        if( p_module->p_config[i].i_list )
+        {
+            if( p_module->p_config[i].ppsz_list )
+            {
+                for( j = 0; j < p_module->p_config[i].i_list; j++ )
+                    SAVE_STRING( p_module->p_config[i].ppsz_list[j] );
+            }
+
+            if( p_module->p_config[i].ppsz_list_text )
+            {
+                for( j = 0; j < p_module->p_config[i].i_list; j++ )
+                    SAVE_STRING( p_module->p_config[i].ppsz_list_text[j] );
+            }
+            if( p_module->p_config[i].pi_list )
+            {
+                for( j = 0; j < p_module->p_config[i].i_list; j++ )
+                    SAVE_IMMEDIATE( p_module->p_config[i].pi_list[j] );
+            }
+        }
+
+        for( j = 0; j < p_module->p_config[i].i_action; j++ )
+            SAVE_STRING( p_module->p_config[i].ppsz_action_text[j] );
+
+        SAVE_IMMEDIATE( p_module->p_config[i].pf_callback );
+    }
+}
+
+/*****************************************************************************
+ * CacheName: Return the cache file name for this platform.
+ *****************************************************************************/
+static char *CacheName( void )
+{
+    static char psz_cachename[32];
+
+    /* Code int size, pointer size and endianness in the filename */
+    int32_t x = 0xbe00001e;
+    sprintf( psz_cachename, "plugins-%.2x%.2x%.2x.dat", sizeof(int),
+             sizeof(void *), (unsigned int)((unsigned char *)&x)[0] );
+    return psz_cachename;
+}
+
+/*****************************************************************************
+ * CacheMerge: Merge a cache module descriptor with a full module descriptor.
+ *****************************************************************************/
+static void CacheMerge( vlc_object_t *p_this, module_t *p_cache,
+                        module_t *p_module )
+{
+    int i_submodule;
+
+    p_cache->pf_activate = p_module->pf_activate;
+    p_cache->pf_deactivate = p_module->pf_deactivate;
+#ifndef HAVE_SHARED_LIBVLC
+    p_cache->p_symbols = p_module->p_symbols;
+#endif
+    p_cache->handle = p_module->handle;
+
+    for( i_submodule = 0; i_submodule < p_module->i_children; i_submodule++ )
+    {
+        module_t *p_child = (module_t*)p_module->pp_children[i_submodule];
+        module_t *p_cchild = (module_t*)p_cache->pp_children[i_submodule];
+        p_cchild->pf_activate = p_child->pf_activate;
+        p_cchild->pf_deactivate = p_child->pf_deactivate;
+#ifndef HAVE_SHARED_LIBVLC
+        p_cchild->p_symbols = p_child->p_symbols;
+#endif
+    }
+
+    p_cache->b_loaded = VLC_TRUE;
+    p_module->b_loaded = VLC_FALSE;
+}
+
+/*****************************************************************************
+ * FindPluginCache: finds the cache entry corresponding to a file
+ *****************************************************************************/
+static module_cache_t *CacheFind( vlc_object_t *p_this, char *psz_file,
+                                  int64_t i_time, int64_t i_size )
+{
+    module_cache_t **pp_cache;
+    int i_cache, i;
+
+    pp_cache = p_this->p_libvlc->p_module_bank->pp_loaded_cache;
+    i_cache = p_this->p_libvlc->p_module_bank->i_loaded_cache;
+
+    for( i = 0; i < i_cache; i++ )
+    {
+        if( !strcmp( pp_cache[i]->psz_file, psz_file ) &&
+            pp_cache[i]->i_time == i_time &&
+            pp_cache[i]->i_size == i_size ) return pp_cache[i];
+    }
+
+    return NULL;
+}
+
+#endif /* HAVE_DYNAMIC_PLUGINS */

Property changes on: src\misc\modules.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\modules_builtin.h.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\mtime.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\objects.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\stats.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\strings.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\threads.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\unicode.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\update.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\variables.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\vlm.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\win32_specific.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\misc\xml.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\network\acl.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\network\error.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\network\getaddrinfo.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\network\httpd.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\network\io.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\network\rootwrap.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\network\tcp.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\network\tls.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\network\udp.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\osd\osd.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\osd\osd_parser.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\osd\osd_text.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\osd\osd_widgets.c
___________________________________________________________________
Name: svn:eol-style
   + LF

Index: src/playlist/item-ext.c
===================================================================
--- src/playlist/item-ext.c	(revision 159)
+++ src/playlist/item-ext.c	(working copy)
@@ -1,931 +1,933 @@
-/*****************************************************************************
- * item-ext.c : Playlist item management functions (act on the playlist)
- *****************************************************************************
- * Copyright (C) 1999-2004 the VideoLAN team
- * $Id: item-ext.c 19645 2007-04-02 22:01:01Z dionoea $
- *
- * Authors: Samuel Hocevar <sam@zoy.org>
- *          Clément Stenac <zorglub@videolan.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-#include <stdlib.h>                                      /* free(), strtol() */
-#include <stdio.h>                                              /* sprintf() */
-#include <string.h>                                            /* strerror() */
-
-#include <vlc/vlc.h>
-#include <vlc/input.h>
-
-#include "vlc_playlist.h"
-
-/***************************************************************************
- * Item creation/addition functions
- ***************************************************************************/
-
-/**
- * Add a MRL into the playlist, duration and options given
- *
- * \param p_playlist the playlist to add into
- * \param psz_uri the mrl to add to the playlist
- * \param psz_name a text giving a name or description of this item
- * \param i_mode the mode used when adding
- * \param i_pos the position in the playlist where to add. If this is
- *        PLAYLIST_END the item will be added at the end of the playlist
- *        regardless of it's size
- * \param i_duration length of the item in milliseconds.
- * \param ppsz_options an array of options
- * \param i_options the number of options
- * \return The id of the playlist item
-*/
-int playlist_AddExt( playlist_t *p_playlist, const char * psz_uri,
-                     const char *psz_name, int i_mode, int i_pos,
-                     mtime_t i_duration, const char **ppsz_options,
-                     int i_options )
-{
-    playlist_item_t *p_item;
-    p_item = playlist_ItemNew( p_playlist , psz_uri, psz_name );
-
-    if( p_item == NULL )
-    {
-        msg_Err( p_playlist, "unable to add item to playlist" );
-        return -1;
-    }
-
-    p_item->input.i_duration = i_duration;
-    p_item->input.i_options = i_options;
-    p_item->input.ppsz_options = NULL;
-
-    for( p_item->input.i_options = 0; p_item->input.i_options < i_options;
-         p_item->input.i_options++ )
-    {
-        if( !p_item->input.i_options )
-        {
-            p_item->input.ppsz_options = malloc( i_options * sizeof(char *) );
-            if( !p_item->input.ppsz_options ) break;
-        }
-
-        p_item->input.ppsz_options[p_item->input.i_options] =
-            strdup( ppsz_options[p_item->input.i_options] );
-    }
-
-    return playlist_AddItem( p_playlist, p_item, i_mode, i_pos );
-}
-
-/**
- * Add a MRL into the playlist.
- *
- * \param p_playlist the playlist to add into
- * \param psz_uri the mrl to add to the playlist
- * \param psz_name a text giving a name or description of this item
- * \param i_mode the mode used when adding
- * \param i_pos the position in the playlist where to add. If this is
- *        PLAYLIST_END the item will be added at the end of the playlist
- *        regardless of it's size
- * \return The id of the playlist item
-*/
-int playlist_Add( playlist_t *p_playlist, const char *psz_uri,
-                  const char *psz_name, int i_mode, int i_pos )
-{
-    return playlist_AddExt( p_playlist, psz_uri, psz_name, i_mode, i_pos,
-                            -1, NULL, 0 );
-}
-
-/**
- * Add a playlist item into a playlist
- *
- * \param p_playlist the playlist to insert into
- * \param p_item the playlist item to insert
- * \param i_mode the mode used when adding
- * \param i_pos the possition in the playlist where to add. If this is
- *        PLAYLIST_END the item will be added at the end of the playlist
- *        regardless of it's size
- * \return The id of the playlist item
- */
-int playlist_AddItem( playlist_t *p_playlist, playlist_item_t *p_item,
-                      int i_mode, int i_pos)
-{
-    vlc_value_t val;
-    vlc_bool_t b_end = VLC_FALSE;
-    playlist_view_t *p_view = NULL;
-
-    playlist_add_t *p_add = (playlist_add_t *)malloc(sizeof( playlist_add_t));
-
-    vlc_mutex_lock( &p_playlist->object_lock );
-
-    /*
-     * CHECK_INSERT : checks if the item is already enqued before
-     * enqueing it
-     */
-
-    /* That should not change */
-    if ( i_mode & PLAYLIST_CHECK_INSERT )
-    {
-         int j;
-
-        if ( p_playlist->pp_items )
-        {
-            for ( j = 0; j < p_playlist->i_size; j++ )
-            {
-                if ( !strcmp( p_playlist->pp_items[j]->input.psz_uri,
-                               p_item->input.psz_uri ) )
-                {
-                    playlist_ItemDelete( p_item );
-                    vlc_mutex_unlock( &p_playlist->object_lock );
-                    return -1;
-                }
-             }
-         }
-         i_mode &= ~PLAYLIST_CHECK_INSERT;
-         i_mode |= PLAYLIST_APPEND;
-    }
-
-    msg_Dbg( p_playlist, "adding playlist item `%s' ( %s )",
-             p_item->input.psz_name, p_item->input.psz_uri );
-
-    p_item->input.i_id = ++p_playlist->i_last_id;
-
-    /* Do a few boundary checks and allocate space for the item */
-    if( i_pos == PLAYLIST_END )
-    {
-        b_end = VLC_TRUE;
-        if( i_mode & PLAYLIST_INSERT )
-        {
-            i_mode &= ~PLAYLIST_INSERT;
-            i_mode |= PLAYLIST_APPEND;
-        }
-
-        i_pos = p_playlist->i_size - 1;
-    }
-
-    if( !(i_mode & PLAYLIST_REPLACE)
-         || i_pos < 0 || i_pos >= p_playlist->i_size )
-    {
-        /* Additional boundary checks */
-        if( i_mode & PLAYLIST_APPEND )
-        {
-            i_pos++;
-        }
-
-        if( i_pos < 0 )
-        {
-            i_pos = 0;
-        }
-        else if( i_pos > p_playlist->i_size )
-        {
-            i_pos = p_playlist->i_size;
-        }
-
-        INSERT_ELEM( p_playlist->pp_items, p_playlist->i_size, i_pos, p_item );
-        INSERT_ELEM( p_playlist->pp_all_items, p_playlist->i_all_size,
-                     p_playlist->i_all_size, p_item );
-        p_playlist->i_enabled ++;
-
-        /* We update the ALL view directly */
-        playlist_ViewUpdate( p_playlist, VIEW_ALL );
-
-        /* Add the item to the General category */
-        if( b_end == VLC_TRUE )
-        {
-            playlist_NodeAppend( p_playlist, VIEW_CATEGORY, p_item,
-                                 p_playlist->p_general );
-            p_add->i_item = p_item->input.i_id;
-            p_add->i_node = p_playlist->p_general->input.i_id;
-            p_add->i_view = VIEW_CATEGORY;
-            val.p_address = p_add;
-            var_Set( p_playlist, "item-append", val );
-        }
-        else
-        {
-            playlist_NodeInsert( p_playlist, VIEW_CATEGORY, p_item,
-                                 p_playlist->p_general, i_pos );
-        }
-
-
-        p_view = playlist_ViewFind( p_playlist, VIEW_ALL );
-        playlist_ItemAddParent( p_item, VIEW_ALL, p_view->p_root );
-
-        /* FIXME : Update sorted views */
-
-        if( p_playlist->i_index >= i_pos )
-        {
-            p_playlist->i_index++;
-        }
-    }
-    else
-    {
-        msg_Err( p_playlist, "Insert mode not implemented" );
-    }
-
-    if( (i_mode & PLAYLIST_GO ) && p_view )
-    {
-        p_playlist->request.b_request = VLC_TRUE;
-        /* FIXME ... */
-        p_playlist->request.i_view = VIEW_CATEGORY;
-        p_playlist->request.p_node = p_view->p_root;
-        p_playlist->request.p_item = p_item;
-
-        if( p_playlist->p_input )
-        {
-            input_StopThread( p_playlist->p_input );
-        }
-        p_playlist->status.i_status = PLAYLIST_RUNNING;
-    }
-
-    if( i_mode & PLAYLIST_PREPARSE &&
-        var_CreateGetBool( p_playlist, "auto-preparse" ) )
-    {
-        playlist_PreparseEnqueue( p_playlist, &p_item->input );
-    }
-
-    vlc_mutex_unlock( &p_playlist->object_lock );
-
-    if( b_end == VLC_FALSE )
-    {
-        val.b_bool = VLC_TRUE;
-        var_Set( p_playlist, "intf-change", val );
-    }
-
-    free( p_add );
-
-    return p_item->input.i_id;
-}
-
-
-/**
- * Add a playlist item to a given node (in the category view )
- *
- * \param p_playlist the playlist to insert into
- * \param p_item the playlist item to insert
- * \param i_view the view for which to add or TODO: ALL_VIEWS
- * \param p_parent the parent node
- * \param i_mode the mode used when adding
- * \param i_pos the possition in the node where to add. If this is
- *        PLAYLIST_END the item will be added at the end of the node
- ** \return The id of the playlist item
- */
-int playlist_NodeAddItem( playlist_t *p_playlist, playlist_item_t *p_item,
-                          int i_view,playlist_item_t *p_parent,
-                          int i_mode, int i_pos)
-{
-    vlc_value_t val;
-    int i_position;
-    playlist_view_t *p_view;
-
-    playlist_add_t *p_add = (playlist_add_t *)malloc(sizeof( playlist_add_t));
-
-    vlc_mutex_lock( &p_playlist->object_lock );
-
-    if ( i_pos == PLAYLIST_END ) i_pos = -1;
-
-    /* Sanity checks */
-    if( !p_parent || p_parent->i_children == -1 )
-    {
-        msg_Err( p_playlist, "invalid node" );
-    }
-
-    /*
-     * CHECK_INSERT : checks if the item is already enqued before
-     * enqueing it
-     */
-    if ( i_mode & PLAYLIST_CHECK_INSERT )
-    {
-         int j;
-
-        if ( p_playlist->pp_items )
-        {
-            for ( j = 0; j < p_playlist->i_size; j++ )
-            {
-                if ( !strcmp( p_playlist->pp_items[j]->input.psz_uri,
-                              p_item->input.psz_uri ) )
-                {
-                    playlist_ItemDelete( p_item );
-                    vlc_mutex_unlock( &p_playlist->object_lock );
-                    free( p_add );
-                    return -1;
-                }
-            }
-        }
-        i_mode &= ~PLAYLIST_CHECK_INSERT;
-        i_mode |= PLAYLIST_APPEND;
-    }
-
-    msg_Dbg( p_playlist, "adding playlist item `%s' ( %s )",
-             p_item->input.psz_name, p_item->input.psz_uri );
-
-    p_item->input.i_id = ++p_playlist->i_last_id;
-
-    /* First, add the item at the right position in the item bank */
-    /* WHY THAT ? */
-     //i_position = p_playlist->i_index == -1 ? 0 : p_playlist->i_index;
-    i_position = p_playlist->i_size ;
-
-    INSERT_ELEM( p_playlist->pp_items,
-                 p_playlist->i_size,
-                 i_position,
-                 p_item );
-    INSERT_ELEM( p_playlist->pp_all_items,
-                 p_playlist->i_all_size,
-                 p_playlist->i_all_size,
-                 p_item );
-    p_playlist->i_enabled ++;
-
-    /* TODO: Handle modes */
-    playlist_NodeInsert( p_playlist, i_view, p_item, p_parent, i_pos );
-
-    p_add->i_item = p_item->input.i_id;
-    p_add->i_node = p_parent->input.i_id;
-    p_add->i_view = i_view;
-    val.p_address = p_add;
-    var_Set( p_playlist, "item-append", val );
-
-    /* We update the ALL view directly */
-    p_view = playlist_ViewFind( p_playlist, VIEW_ALL );
-    playlist_ItemAddParent( p_item, VIEW_ALL, p_view->p_root );
-    playlist_ViewUpdate( p_playlist, VIEW_ALL );
-
-    /* TODO : Update sorted views*/
-
-    if( i_mode & PLAYLIST_GO )
-    {
-        p_playlist->request.b_request = VLC_TRUE;
-        p_playlist->request.i_view = VIEW_CATEGORY;
-        p_playlist->request.p_node = p_parent;
-        p_playlist->request.p_item = p_item;
-        if( p_playlist->p_input )
-        {
-            input_StopThread( p_playlist->p_input );
-        }
-        p_playlist->status.i_status = PLAYLIST_RUNNING;
-    }
-    if( i_mode & PLAYLIST_PREPARSE &&
-        var_CreateGetBool( p_playlist, "auto-preparse" ) )
-    {
-        playlist_PreparseEnqueue( p_playlist, &p_item->input );
-    }
-
-    vlc_mutex_unlock( &p_playlist->object_lock );
-
-    val.b_bool = VLC_TRUE;
-//    var_Set( p_playlist, "intf-change", val );
-//
-    free( p_add );
-
-    return p_item->input.i_id;
-}
-
-/***************************************************************************
- * Item search functions
- ***************************************************************************/
-
-/**
- * Search the position of an item by its id
- * This function must be entered with the playlist lock
- *
- * \param p_playlist the playlist
- * \param i_id the id to find
- * \return the position, or VLC_EGENERIC on failure
- */
-int playlist_GetPositionById( playlist_t * p_playlist , int i_id )
-{
-    int i;
-    for( i =  0 ; i < p_playlist->i_size ; i++ )
-    {
-        if( p_playlist->pp_items[i]->input.i_id == i_id )
-        {
-            return i;
-        }
-    }
-    return VLC_EGENERIC;
-}
-
-
-/**
- * Search an item by its position
- * This function must be entered with the playlist lock
- *
- * \param p_playlist the playlist
- * \param i_pos the position of the item to find
- * \return the item, or NULL on failure
- */
-playlist_item_t * playlist_ItemGetByPos( playlist_t * p_playlist , int i_pos )
-{
-    if( i_pos >= 0 && i_pos < p_playlist->i_size)
-    {
-        return p_playlist->pp_items[i_pos];
-    }
-    else if( p_playlist->i_size > 0)
-    {
-        return p_playlist->pp_items[p_playlist->i_index];
-    }
-    else
-    {
-        return NULL;
-    }
-}
-
-playlist_item_t *playlist_LockItemGetByPos( playlist_t *p_playlist, int i_pos )
-{
-    playlist_item_t *p_ret;
-    vlc_mutex_lock( &p_playlist->object_lock );
-    p_ret = playlist_ItemGetByPos( p_playlist, i_pos );
-    vlc_mutex_unlock( &p_playlist->object_lock );
-    return p_ret;
-}
-
-/**
- * Search an item by its id
- *
- * \param p_playlist the playlist
- * \param i_id the id to find
- * \return the item, or NULL on failure
- */
-playlist_item_t * playlist_ItemGetById( playlist_t * p_playlist , int i_id )
-{
-    int i, i_top, i_bottom;
-    i_bottom = 0; i_top = p_playlist->i_all_size - 1;
-    i = i_top / 2;
-    while( p_playlist->pp_all_items[i]->input.i_id != i_id &&
-           i_top > i_bottom )
-    {
-        if( p_playlist->pp_all_items[i]->input.i_id < i_id )
-        {
-            i_bottom = i + 1;
-        }
-        else
-        {
-            i_top = i - 1;
-        }
-        i = i_bottom + ( i_top - i_bottom ) / 2;
-    }
-    if( p_playlist->pp_all_items[i]->input.i_id == i_id )
-    {
-        return p_playlist->pp_all_items[i];
-    }
-    return NULL;
-}
-
-playlist_item_t *playlist_LockItemGetById( playlist_t *p_playlist, int i_id)
-{
-    playlist_item_t *p_ret;
-    vlc_mutex_lock( &p_playlist->object_lock );
-    p_ret = playlist_ItemGetById( p_playlist, i_id );
-    vlc_mutex_unlock( &p_playlist->object_lock );
-    return p_ret;
-}
-
-/**
- * Search an item by its input_item_t
- *
- * \param p_playlist the playlist
- * \param p_item the input_item_t to find
- * \return the item, or NULL on failure
- */
-playlist_item_t * playlist_ItemGetByInput( playlist_t * p_playlist ,
-                                           input_item_t *p_item )
-{
-    int i;
-    if( &p_playlist->status.p_item->input == p_item )
-    {
-        return p_playlist->status.p_item;
-    }
-
-    for( i =  0 ; i < p_playlist->i_size ; i++ )
-    {
-        if( &p_playlist->pp_items[i]->input == p_item )
-        {
-            return p_playlist->pp_items[i];
-        }
-    }
-    return NULL;
-}
-
-playlist_item_t *playlist_LockItemGetByInput( playlist_t *p_playlist,
-                                               input_item_t *p_item )
-{
-    playlist_item_t *p_ret;
-    vlc_mutex_lock( &p_playlist->object_lock );
-    p_ret = playlist_ItemGetByInput( p_playlist, p_item );
-    vlc_mutex_unlock( &p_playlist->object_lock );
-    return p_ret;
-}
-
-
-/***********************************************************************
- * Misc functions
- ***********************************************************************/
-
-/**
- * Transform an item to a node
- *
- * This function must be entered without the playlist lock
- *
- * \param p_playlist the playlist object
- * \param p_item the item to transform
- * \return nothing
- */
-int playlist_ItemToNode( playlist_t *p_playlist,playlist_item_t *p_item )
-{
-    int i = 0;
-    if( p_item->i_children == -1 )
-    {
-        p_item->i_children = 0;
-    }
-
-    /* Remove it from the array of available items */
-    for( i = 0 ; i < p_playlist->i_size ; i++ )
-    {
-        if( p_item == p_playlist->pp_items[i] )
-        {
-            REMOVE_ELEM( p_playlist->pp_items, p_playlist->i_size, i );
-        }
-    }
-    var_SetInteger( p_playlist, "item-change", p_item->input.i_id );
-
-    return VLC_SUCCESS;
-}
-
-int playlist_LockItemToNode( playlist_t *p_playlist, playlist_item_t *p_item )
-{
-    int i_ret;
-    vlc_mutex_lock( &p_playlist->object_lock );
-    i_ret = playlist_ItemToNode( p_playlist, p_item );
-    vlc_mutex_unlock( &p_playlist->object_lock );
-    return i_ret;
-}
-
-/**
- * Replaces an item with another one
- * This function must be entered without the playlist lock
- *
- * \see playlist_Replace
- */
-int playlist_LockReplace( playlist_t *p_playlist,
-                             playlist_item_t *p_olditem,
-                             input_item_t *p_new )
-{
-    int i_ret;
-    vlc_mutex_lock( &p_playlist->object_lock );
-    i_ret = playlist_Replace( p_playlist, p_olditem, p_new );
-    vlc_mutex_unlock( &p_playlist->object_lock );
-    return i_ret;
-}
-
-/**
- * Replaces an item with another one
- * This function must be entered with the playlist lock:
- *
- * \param p_playlist the playlist
- * \param p_olditem the item to replace
- * \param p_new the new input_item
- * \return VLC_SUCCESS or an error
- */
-int playlist_Replace( playlist_t *p_playlist, playlist_item_t *p_olditem,
-                       input_item_t *p_new )
-{
-    int i;
-    int j;
-
-    if( p_olditem->i_children != -1 )
-    {
-        msg_Err( p_playlist, "playlist_Replace can only be used on leafs");
-        return VLC_EGENERIC;
-    }
-
-    p_olditem->i_nb_played = 0;
-    memcpy( &p_olditem->input, p_new, sizeof( input_item_t ) );
-
-    p_olditem->i_nb_played = 0;
-
-    for( i = 0 ; i< p_olditem->i_parents ; i++ )
-    {
-        playlist_item_t *p_parent = p_olditem->pp_parents[i]->p_parent;
-
-        for( j = 0 ; j< p_parent->i_children ; i++ )
-        {
-            if( p_parent->pp_children[j] == p_olditem )
-            {
-                p_parent->i_serial++;
-            }
-        }
-    }
-    return VLC_SUCCESS;
-}
-
-/**
- * Deletes an item from a playlist.
- *
- * This function must be entered without the playlist lock
- *
- * \param p_playlist the playlist to remove from.
- * \param i_id the identifier of the item to delete
- * \return returns VLC_SUCCESS or an error
- */
-int playlist_Delete( playlist_t * p_playlist, int i_id )
-{
-    int i, i_top, i_bottom;
-    int i_pos;
-    vlc_bool_t b_flag = VLC_FALSE;
-
-    playlist_item_t *p_item = playlist_ItemGetById( p_playlist, i_id );
-
-    if( p_item == NULL )
-    {
-        return VLC_EGENERIC;
-    }
-    if( p_item->i_children > -1 )
-    {
-        return playlist_NodeDelete( p_playlist, p_item, VLC_TRUE, VLC_FALSE );
-    }
-
-    var_SetInteger( p_playlist, "item-deleted", i_id );
-
-    i_bottom = 0; i_top = p_playlist->i_all_size - 1;
-    i = i_top / 2;
-    while( p_playlist->pp_all_items[i]->input.i_id != i_id &&
-           i_top > i_bottom )
-    {
-        if( p_playlist->pp_all_items[i]->input.i_id < i_id )
-        {
-            i_bottom = i + 1;
-        }
-        else
-        {
-            i_top = i - 1;
-        }
-        i = i_bottom + ( i_top - i_bottom ) / 2;
-    }
-    if( p_playlist->pp_all_items[i]->input.i_id == i_id )
-    {
-        REMOVE_ELEM( p_playlist->pp_all_items, p_playlist->i_all_size, i );
-    }
-
-    /* Check if it is the current item */
-    if( p_playlist->status.p_item == p_item )
-    {
-        /* Hack we don't call playlist_Control for lock reasons */
-        p_playlist->status.i_status = PLAYLIST_STOPPED;
-        p_playlist->request.b_request = VLC_TRUE;
-        p_playlist->request.p_item = NULL;
-        msg_Info( p_playlist, "stopping playback" );
-        b_flag = VLC_TRUE;
-    }
-
-    /* Get position and update index if needed */
-    i_pos = playlist_GetPositionById( p_playlist, i_id );
-
-    if( i_pos >= 0 && i_pos <= p_playlist->i_index )
-    {
-        p_playlist->i_index--;
-    }
-
-    msg_Dbg( p_playlist, "deleting playlist item `%s'",
-                          p_item->input.psz_name );
-
-    /* Remove the item from all its parent nodes */
-    for ( i= 0 ; i < p_item->i_parents ; i++ )
-    {
-        playlist_NodeRemoveItem( p_playlist, p_item,
-                                 p_item->pp_parents[i]->p_parent );
-        if( p_item->pp_parents[i]->i_view == VIEW_ALL )
-        {
-            p_playlist->i_size--;
-        }
-    }
-
-    /* TODO : Update views */
-
-    if( b_flag == VLC_FALSE )
-        playlist_ItemDelete( p_item );
-    else
-        p_item->i_flags |= PLAYLIST_REMOVE_FLAG;
-
-    return VLC_SUCCESS;
-}
-
-int playlist_LockDelete( playlist_t * p_playlist, int i_id )
-{
-    int i_ret;
-    vlc_mutex_lock( &p_playlist->object_lock );
-    i_ret = playlist_Delete( p_playlist, i_id );
-    vlc_mutex_unlock( &p_playlist->object_lock );
-    return i_ret;
-}
-
-/**
- * Clear all playlist items
- *
- * \param p_playlist the playlist to be cleared.
- * \return returns 0
- */
-int playlist_Clear( playlist_t * p_playlist )
-{
-    int i;
-    for( i = p_playlist->i_size; i > 0 ; i-- )
-    {
-        playlist_Delete( p_playlist, p_playlist->pp_items[0]->input.i_id );
-    }
-    for( i = 0 ; i< p_playlist->i_views; i++ )
-    {
-        playlist_ViewEmpty( p_playlist, i, VLC_TRUE );
-    }
-    return VLC_SUCCESS;
-}
-
-int playlist_LockClear( playlist_t *p_playlist )
-{
-    int i_ret;
-    vlc_mutex_lock( &p_playlist->object_lock );
-    i_ret = playlist_Clear( p_playlist );
-    vlc_mutex_unlock( &p_playlist->object_lock );
-    return i_ret;
-}
-
-
-/**
- * Disables a playlist item
- *
- * \param p_playlist the playlist to disable from.
- * \param i_pos the position of the item to disable
- * \return returns 0
- */
-int playlist_Disable( playlist_t * p_playlist, playlist_item_t *p_item )
-{
-    if( !p_item ) return VLC_EGENERIC;
-
-    msg_Dbg( p_playlist, "disabling playlist item `%s'",
-                   p_item->input.psz_name );
-
-    if( p_item->i_flags & PLAYLIST_ENA_FLAG )
-    {
-        p_playlist->i_enabled--;
-    }
-    p_item->i_flags &= ~PLAYLIST_ENA_FLAG;
-
-    var_SetInteger( p_playlist, "item-change", p_item->input.i_id );
-    return VLC_SUCCESS;
-}
-
-/**
- * Enables a playlist item
- *
- * \param p_playlist the playlist to enable from.
- * \param i_pos the position of the item to enable
- * \return returns 0
- */
-int playlist_Enable( playlist_t * p_playlist, playlist_item_t *p_item )
-{
-    if( !p_item ) return VLC_EGENERIC;
-
-    msg_Dbg( p_playlist, "enabling playlist item `%s'",
-                   p_item->input.psz_name );
-
-    if( p_item->i_flags & ~PLAYLIST_ENA_FLAG )
-    {
-        p_playlist->i_enabled++;
-    }
-    p_item->i_flags |= PLAYLIST_ENA_FLAG;
-
-    var_SetInteger( p_playlist, "item-change", p_item->input.i_id );
-    return VLC_SUCCESS;
-}
-
-/**
- * Move an item in a playlist
- *
- * This function must be entered without the playlist lock
- *
- * Move the item in the playlist with position i_pos before the current item
- * at position i_newpos.
- * \param p_playlist the playlist to move items in
- * \param i_pos the position of the item to move
- * \param i_newpos the position of the item that will be behind the moved item
- *        after the move
- * \return returns VLC_SUCCESS
- */
-int playlist_Move( playlist_t * p_playlist, int i_pos, int i_newpos )
-{
-    vlc_value_t val;
-    vlc_mutex_lock( &p_playlist->object_lock );
-
-    /* take into account that our own row disappears. */
-    if( i_pos < i_newpos ) i_newpos--;
-
-    if( i_pos >= 0 && i_newpos >=0 && i_pos <= p_playlist->i_size &&
-        i_newpos <= p_playlist->i_size )
-    {
-        playlist_item_t * temp;
-
-        msg_Dbg( p_playlist, "moving playlist item `%s' (%i -> %i)",
-                 p_playlist->pp_items[i_pos]->input.psz_name, i_pos, i_newpos);
-
-        if( i_pos == p_playlist->i_index )
-        {
-            p_playlist->i_index = i_newpos;
-        }
-        else if( i_pos > p_playlist->i_index &&
-                 i_newpos <= p_playlist->i_index )
-        {
-            p_playlist->i_index++;
-        }
-        else if( i_pos < p_playlist->i_index &&
-                 i_newpos >= p_playlist->i_index )
-        {
-            p_playlist->i_index--;
-        }
-
-        if ( i_pos < i_newpos )
-        {
-            temp = p_playlist->pp_items[i_pos];
-            while ( i_pos < i_newpos )
-            {
-                p_playlist->pp_items[i_pos] = p_playlist->pp_items[i_pos+1];
-                i_pos++;
-            }
-            p_playlist->pp_items[i_newpos] = temp;
-        }
-        else if ( i_pos > i_newpos )
-        {
-            temp = p_playlist->pp_items[i_pos];
-            while ( i_pos > i_newpos )
-            {
-                p_playlist->pp_items[i_pos] = p_playlist->pp_items[i_pos-1];
-                i_pos--;
-            }
-            p_playlist->pp_items[i_newpos] = temp;
-        }
-    }
-
-    vlc_mutex_unlock( &p_playlist->object_lock );
-
-    val.b_bool = VLC_TRUE;
-    var_Set( p_playlist, "intf-change", val );
-
-    return VLC_SUCCESS;
-}
-
-/**
- * Moves an item
- *
- * This function must be entered with the playlist lock
- *
- * \param p_playlist the playlist
- * \param p_item the item to move
- * \param p_node the new parent of the item
- * \param i_newpos the new position under this new parent
- * \param i_view the view in which the move must be done or ALL_VIEWS
- * \return VLC_SUCCESS or an error
- */
-int playlist_TreeMove( playlist_t * p_playlist, playlist_item_t *p_item,
-                       playlist_item_t *p_node, int i_newpos, int i_view )
-{
-    int i;
-    playlist_item_t *p_detach = NULL;
-    struct item_parent_t *p_parent;
-
-    if( p_node->i_children == -1 ) return VLC_EGENERIC;
-
-    /* Detach from the parent */
-    for( i = 0 ; i< p_item->i_parents; i++ )
-    {
-        if( p_item->pp_parents[i]->i_view == i_view )
-        {
-            int j;
-            p_detach = p_item->pp_parents[i]->p_parent;
-            for( j = 0; j < p_detach->i_children; j++ )
-            {
-                if( p_detach->pp_children[j] == p_item ) break;
-            }
-            REMOVE_ELEM( p_detach->pp_children, p_detach->i_children, j );
-            p_detach->i_serial++;
-            free( p_item->pp_parents[i] );
-            REMOVE_ELEM( p_item->pp_parents, p_item->i_parents, i );
-            i--;
-        }
-    }
-
-    /* Attach to new parent */
-    INSERT_ELEM( p_node->pp_children, p_node->i_children, i_newpos, p_item );
-
-    p_parent = malloc( sizeof( struct item_parent_t ) );
-    p_parent->p_parent = p_node;
-    p_parent->i_view = i_view;
-
-    INSERT_ELEM( p_item->pp_parents, p_item->i_parents, p_item->i_parents,
-                 p_parent );
-    p_node->i_serial++;
-    p_item->i_serial++;
-
-    return VLC_SUCCESS;
-}
+/*****************************************************************************
+ * item-ext.c : Playlist item management functions (act on the playlist)
+ *****************************************************************************
+ * Copyright (C) 1999-2004 the VideoLAN team
+ * $Id: item-ext.c 19645 2007-04-02 22:01:01Z dionoea $
+ *
+ * Authors: Samuel Hocevar <sam@zoy.org>
+ *          Clément Stenac <zorglub@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#include <stdlib.h>                                      /* free(), strtol() */
+#include <stdio.h>                                              /* sprintf() */
+#include <string.h>                                            /* strerror() */
+
+#include <vlc/vlc.h>
+#include <vlc/input.h>
+
+#include "vlc_playlist.h"
+
+/***************************************************************************
+ * Item creation/addition functions
+ ***************************************************************************/
+
+/**
+ * Add a MRL into the playlist, duration and options given
+ *
+ * \param p_playlist the playlist to add into
+ * \param psz_uri the mrl to add to the playlist
+ * \param psz_name a text giving a name or description of this item
+ * \param i_mode the mode used when adding
+ * \param i_pos the position in the playlist where to add. If this is
+ *        PLAYLIST_END the item will be added at the end of the playlist
+ *        regardless of it's size
+ * \param i_duration length of the item in milliseconds.
+ * \param ppsz_options an array of options
+ * \param i_options the number of options
+ * \return The id of the playlist item
+*/
+int playlist_AddExt( playlist_t *p_playlist, const char * psz_uri,
+                     const char *psz_name, int i_mode, int i_pos,
+                     mtime_t i_duration, const char **ppsz_options,
+                     int i_options )
+{
+    playlist_item_t *p_item;
+    p_item = playlist_ItemNew( p_playlist , psz_uri, psz_name );
+
+    if( p_item == NULL )
+    {
+        msg_Err( p_playlist, "unable to add item to playlist" );
+        return -1;
+    }
+
+    p_item->input.i_duration = i_duration;
+    p_item->input.i_options = i_options;
+    p_item->input.ppsz_options = NULL;
+
+    for( p_item->input.i_options = 0; p_item->input.i_options < i_options;
+         p_item->input.i_options++ )
+    {
+        if( !p_item->input.i_options )
+        {
+            p_item->input.ppsz_options = malloc( i_options * sizeof(char *) );
+            if( !p_item->input.ppsz_options ) break;
+        }
+
+        p_item->input.ppsz_options[p_item->input.i_options] =
+            strdup( ppsz_options[p_item->input.i_options] );
+    }
+
+    return playlist_AddItem( p_playlist, p_item, i_mode, i_pos );
+}
+
+/**
+ * Add a MRL into the playlist.
+ *
+ * \param p_playlist the playlist to add into
+ * \param psz_uri the mrl to add to the playlist
+ * \param psz_name a text giving a name or description of this item
+ * \param i_mode the mode used when adding
+ * \param i_pos the position in the playlist where to add. If this is
+ *        PLAYLIST_END the item will be added at the end of the playlist
+ *        regardless of it's size
+ * \return The id of the playlist item
+*/
+int playlist_Add( playlist_t *p_playlist, const char *psz_uri,
+                  const char *psz_name, int i_mode, int i_pos )
+{
+    return playlist_AddExt( p_playlist, psz_uri, psz_name, i_mode, i_pos,
+                            -1, NULL, 0 );
+}
+
+/**
+ * Add a playlist item into a playlist
+ *
+ * \param p_playlist the playlist to insert into
+ * \param p_item the playlist item to insert
+ * \param i_mode the mode used when adding
+ * \param i_pos the possition in the playlist where to add. If this is
+ *        PLAYLIST_END the item will be added at the end of the playlist
+ *        regardless of it's size
+ * \return The id of the playlist item
+ */
+int playlist_AddItem( playlist_t *p_playlist, playlist_item_t *p_item,
+                      int i_mode, int i_pos)
+{
+    vlc_value_t val;
+    vlc_bool_t b_end = VLC_FALSE;
+    playlist_view_t *p_view = NULL;
+
+    playlist_add_t *p_add = (playlist_add_t *)malloc(sizeof( playlist_add_t));
+
+    vlc_mutex_lock( &p_playlist->object_lock );
+
+    /*
+     * CHECK_INSERT : checks if the item is already enqued before
+     * enqueing it
+     */
+
+    /* That should not change */
+    if ( i_mode & PLAYLIST_CHECK_INSERT )
+    {
+         int j;
+
+        if ( p_playlist->pp_items )
+        {
+            for ( j = 0; j < p_playlist->i_size; j++ )
+            {
+                if ( !strcmp( p_playlist->pp_items[j]->input.psz_uri,
+                               p_item->input.psz_uri ) )
+                {
+                    playlist_ItemDelete( p_item );
+                    vlc_mutex_unlock( &p_playlist->object_lock );
+                    return -1;
+                }
+             }
+         }
+         i_mode &= ~PLAYLIST_CHECK_INSERT;
+         i_mode |= PLAYLIST_APPEND;
+    }
+
+    msg_Dbg( p_playlist, "adding playlist item `%s' ( %s )",
+             p_item->input.psz_name, p_item->input.psz_uri );
+
+    p_item->input.i_id = ++p_playlist->i_last_id;
+
+    /* Do a few boundary checks and allocate space for the item */
+    if( i_pos == PLAYLIST_END )
+    {
+        b_end = VLC_TRUE;
+        if( i_mode & PLAYLIST_INSERT )
+        {
+            i_mode &= ~PLAYLIST_INSERT;
+            i_mode |= PLAYLIST_APPEND;
+        }
+
+        i_pos = p_playlist->i_size - 1;
+    }
+
+    if( !(i_mode & PLAYLIST_REPLACE)
+         || i_pos < 0 || i_pos >= p_playlist->i_size )
+    {
+        /* Additional boundary checks */
+        if( i_mode & PLAYLIST_APPEND )
+        {
+            i_pos++;
+        }
+
+        if( i_pos < 0 )
+        {
+            i_pos = 0;
+        }
+        else if( i_pos > p_playlist->i_size )
+        {
+            i_pos = p_playlist->i_size;
+        }
+
+        INSERT_ELEM( p_playlist->pp_items, p_playlist->i_size, i_pos, p_item );
+        INSERT_ELEM( p_playlist->pp_all_items, p_playlist->i_all_size,
+                     p_playlist->i_all_size, p_item );
+        p_playlist->i_enabled ++;
+
+        /* We update the ALL view directly */
+        playlist_ViewUpdate( p_playlist, VIEW_ALL );
+
+        /* Add the item to the General category */
+        if( b_end == VLC_TRUE )
+        {
+            playlist_NodeAppend( p_playlist, VIEW_CATEGORY, p_item,
+                                 p_playlist->p_general );
+            p_add->i_item = p_item->input.i_id;
+            p_add->i_node = p_playlist->p_general->input.i_id;
+            p_add->i_view = VIEW_CATEGORY;
+            val.p_address = p_add;
+            var_Set( p_playlist, "item-append", val );
+        }
+        else
+        {
+            playlist_NodeInsert( p_playlist, VIEW_CATEGORY, p_item,
+                                 p_playlist->p_general, i_pos );
+        }
+
+
+        p_view = playlist_ViewFind( p_playlist, VIEW_ALL );
+        playlist_ItemAddParent( p_item, VIEW_ALL, p_view->p_root );
+
+        /* FIXME : Update sorted views */
+
+        if( p_playlist->i_index >= i_pos )
+        {
+            p_playlist->i_index++;
+        }
+    }
+    else
+    {
+        msg_Err( p_playlist, "Insert mode not implemented" );
+    }
+
+    if( (i_mode & PLAYLIST_GO ) && p_view )
+    {
+        p_playlist->request.b_request = VLC_TRUE;
+        /* FIXME ... */
+        p_playlist->request.i_view = VIEW_CATEGORY;
+        p_playlist->request.p_node = p_view->p_root;
+        p_playlist->request.p_item = p_item;
+
+        if( p_playlist->p_input )
+        {
+            input_StopThread( p_playlist->p_input );
+        }
+        p_playlist->status.i_status = PLAYLIST_RUNNING;
+    }
+
+    if( i_mode & PLAYLIST_PREPARSE &&
+        var_CreateGetBool( p_playlist, "auto-preparse" ) )
+    {
+        playlist_PreparseEnqueue( p_playlist, &p_item->input );
+    }
+
+    vlc_mutex_unlock( &p_playlist->object_lock );
+
+    if( b_end == VLC_FALSE )
+    {
+        val.b_bool = VLC_TRUE;
+        var_Set( p_playlist, "intf-change", val );
+    }
+
+    free( p_add );
+
+    return p_item->input.i_id;
+}
+
+
+/**
+ * Add a playlist item to a given node (in the category view )
+ *
+ * \param p_playlist the playlist to insert into
+ * \param p_item the playlist item to insert
+ * \param i_view the view for which to add or TODO: ALL_VIEWS
+ * \param p_parent the parent node
+ * \param i_mode the mode used when adding
+ * \param i_pos the possition in the node where to add. If this is
+ *        PLAYLIST_END the item will be added at the end of the node
+ ** \return The id of the playlist item
+ */
+int playlist_NodeAddItem( playlist_t *p_playlist, playlist_item_t *p_item,
+                          int i_view,playlist_item_t *p_parent,
+                          int i_mode, int i_pos)
+{
+    vlc_value_t val;
+    int i_position;
+    playlist_view_t *p_view;
+
+    playlist_add_t *p_add = (playlist_add_t *)malloc(sizeof( playlist_add_t));
+
+    vlc_mutex_lock( &p_playlist->object_lock );
+
+    if ( i_pos == PLAYLIST_END ) i_pos = -1;
+
+    /* Sanity checks */
+    if( !p_parent || p_parent->i_children == -1 )
+    {
+        msg_Err( p_playlist, "invalid node" );
+    }
+
+    /*
+     * CHECK_INSERT : checks if the item is already enqued before
+     * enqueing it
+     */
+    if ( i_mode & PLAYLIST_CHECK_INSERT )
+    {
+         int j;
+
+        if ( p_playlist->pp_items )
+        {
+            for ( j = 0; j < p_playlist->i_size; j++ )
+            {
+                if ( !strcmp( p_playlist->pp_items[j]->input.psz_uri,
+                              p_item->input.psz_uri ) )
+                {
+                    playlist_ItemDelete( p_item );
+                    vlc_mutex_unlock( &p_playlist->object_lock );
+                    free( p_add );
+                    return -1;
+                }
+            }
+        }
+        i_mode &= ~PLAYLIST_CHECK_INSERT;
+        i_mode |= PLAYLIST_APPEND;
+    }
+
+    msg_Dbg( p_playlist, "adding playlist item `%s' ( %s )",
+             p_item->input.psz_name, p_item->input.psz_uri );
+
+    p_item->input.i_id = ++p_playlist->i_last_id;
+
+    /* First, add the item at the right position in the item bank */
+    /* WHY THAT ? */
+     //i_position = p_playlist->i_index == -1 ? 0 : p_playlist->i_index;
+    i_position = p_playlist->i_size ;
+
+    INSERT_ELEM( p_playlist->pp_items,
+                 p_playlist->i_size,
+                 i_position,
+                 p_item );
+    INSERT_ELEM( p_playlist->pp_all_items,
+                 p_playlist->i_all_size,
+                 p_playlist->i_all_size,
+                 p_item );
+    p_playlist->i_enabled ++;
+
+    /* TODO: Handle modes */
+    playlist_NodeInsert( p_playlist, i_view, p_item, p_parent, i_pos );
+
+    p_add->i_item = p_item->input.i_id;
+    p_add->i_node = p_parent->input.i_id;
+    p_add->i_view = i_view;
+    val.p_address = p_add;
+    var_Set( p_playlist, "item-append", val );
+
+    /* We update the ALL view directly */
+    p_view = playlist_ViewFind( p_playlist, VIEW_ALL );
+    playlist_ItemAddParent( p_item, VIEW_ALL, p_view->p_root );
+    playlist_ViewUpdate( p_playlist, VIEW_ALL );
+
+    /* TODO : Update sorted views*/
+
+    if( i_mode & PLAYLIST_GO )
+    {
+        p_playlist->request.b_request = VLC_TRUE;
+        p_playlist->request.i_view = VIEW_CATEGORY;
+        p_playlist->request.p_node = p_parent;
+        p_playlist->request.p_item = p_item;
+        if( p_playlist->p_input )
+        {
+            input_StopThread( p_playlist->p_input );
+        }
+        p_playlist->status.i_status = PLAYLIST_RUNNING;
+    }
+    if( i_mode & PLAYLIST_PREPARSE &&
+        var_CreateGetBool( p_playlist, "auto-preparse" ) )
+    {
+        playlist_PreparseEnqueue( p_playlist, &p_item->input );
+    }
+
+    vlc_mutex_unlock( &p_playlist->object_lock );
+
+    val.b_bool = VLC_TRUE;
+//    var_Set( p_playlist, "intf-change", val );
+//
+    free( p_add );
+
+    return p_item->input.i_id;
+}
+
+/***************************************************************************
+ * Item search functions
+ ***************************************************************************/
+
+/**
+ * Search the position of an item by its id
+ * This function must be entered with the playlist lock
+ *
+ * \param p_playlist the playlist
+ * \param i_id the id to find
+ * \return the position, or VLC_EGENERIC on failure
+ */
+int playlist_GetPositionById( playlist_t * p_playlist , int i_id )
+{
+    int i;
+    for( i =  0 ; i < p_playlist->i_size ; i++ )
+    {
+        if( p_playlist->pp_items[i]->input.i_id == i_id )
+        {
+            return i;
+        }
+    }
+    return VLC_EGENERIC;
+}
+
+
+/**
+ * Search an item by its position
+ * This function must be entered with the playlist lock
+ *
+ * \param p_playlist the playlist
+ * \param i_pos the position of the item to find
+ * \return the item, or NULL on failure
+ */
+playlist_item_t * playlist_ItemGetByPos( playlist_t * p_playlist , int i_pos )
+{
+    if( i_pos >= 0 && i_pos < p_playlist->i_size)
+    {
+        return p_playlist->pp_items[i_pos];
+    }
+    else if( p_playlist->i_size > 0 && 
+             p_playlist->i_index >= 0 && 
+             p_playlist->i_index <= p_playlist->i_size )
+    {
+        return p_playlist->pp_items[p_playlist->i_index];
+    }
+    else
+    {
+        return NULL;
+    }
+}
+
+playlist_item_t *playlist_LockItemGetByPos( playlist_t *p_playlist, int i_pos )
+{
+    playlist_item_t *p_ret;
+    vlc_mutex_lock( &p_playlist->object_lock );
+    p_ret = playlist_ItemGetByPos( p_playlist, i_pos );
+    vlc_mutex_unlock( &p_playlist->object_lock );
+    return p_ret;
+}
+
+/**
+ * Search an item by its id
+ *
+ * \param p_playlist the playlist
+ * \param i_id the id to find
+ * \return the item, or NULL on failure
+ */
+playlist_item_t * playlist_ItemGetById( playlist_t * p_playlist , int i_id )
+{
+    int i, i_top, i_bottom;
+    i_bottom = 0; i_top = p_playlist->i_all_size - 1;
+    i = i_top / 2;
+    while( p_playlist->pp_all_items[i]->input.i_id != i_id &&
+           i_top > i_bottom )
+    {
+        if( p_playlist->pp_all_items[i]->input.i_id < i_id )
+        {
+            i_bottom = i + 1;
+        }
+        else
+        {
+            i_top = i - 1;
+        }
+        i = i_bottom + ( i_top - i_bottom ) / 2;
+    }
+    if( p_playlist->pp_all_items[i]->input.i_id == i_id )
+    {
+        return p_playlist->pp_all_items[i];
+    }
+    return NULL;
+}
+
+playlist_item_t *playlist_LockItemGetById( playlist_t *p_playlist, int i_id)
+{
+    playlist_item_t *p_ret;
+    vlc_mutex_lock( &p_playlist->object_lock );
+    p_ret = playlist_ItemGetById( p_playlist, i_id );
+    vlc_mutex_unlock( &p_playlist->object_lock );
+    return p_ret;
+}
+
+/**
+ * Search an item by its input_item_t
+ *
+ * \param p_playlist the playlist
+ * \param p_item the input_item_t to find
+ * \return the item, or NULL on failure
+ */
+playlist_item_t * playlist_ItemGetByInput( playlist_t * p_playlist ,
+                                           input_item_t *p_item )
+{
+    int i;
+    if( &p_playlist->status.p_item->input == p_item )
+    {
+        return p_playlist->status.p_item;
+    }
+
+    for( i =  0 ; i < p_playlist->i_size ; i++ )
+    {
+        if( &p_playlist->pp_items[i]->input == p_item )
+        {
+            return p_playlist->pp_items[i];
+        }
+    }
+    return NULL;
+}
+
+playlist_item_t *playlist_LockItemGetByInput( playlist_t *p_playlist,
+                                               input_item_t *p_item )
+{
+    playlist_item_t *p_ret;
+    vlc_mutex_lock( &p_playlist->object_lock );
+    p_ret = playlist_ItemGetByInput( p_playlist, p_item );
+    vlc_mutex_unlock( &p_playlist->object_lock );
+    return p_ret;
+}
+
+
+/***********************************************************************
+ * Misc functions
+ ***********************************************************************/
+
+/**
+ * Transform an item to a node
+ *
+ * This function must be entered without the playlist lock
+ *
+ * \param p_playlist the playlist object
+ * \param p_item the item to transform
+ * \return nothing
+ */
+int playlist_ItemToNode( playlist_t *p_playlist,playlist_item_t *p_item )
+{
+    int i = 0;
+    if( p_item->i_children == -1 )
+    {
+        p_item->i_children = 0;
+    }
+
+    /* Remove it from the array of available items */
+    for( i = 0 ; i < p_playlist->i_size ; i++ )
+    {
+        if( p_item == p_playlist->pp_items[i] )
+        {
+            REMOVE_ELEM( p_playlist->pp_items, p_playlist->i_size, i );
+        }
+    }
+    var_SetInteger( p_playlist, "item-change", p_item->input.i_id );
+
+    return VLC_SUCCESS;
+}
+
+int playlist_LockItemToNode( playlist_t *p_playlist, playlist_item_t *p_item )
+{
+    int i_ret;
+    vlc_mutex_lock( &p_playlist->object_lock );
+    i_ret = playlist_ItemToNode( p_playlist, p_item );
+    vlc_mutex_unlock( &p_playlist->object_lock );
+    return i_ret;
+}
+
+/**
+ * Replaces an item with another one
+ * This function must be entered without the playlist lock
+ *
+ * \see playlist_Replace
+ */
+int playlist_LockReplace( playlist_t *p_playlist,
+                             playlist_item_t *p_olditem,
+                             input_item_t *p_new )
+{
+    int i_ret;
+    vlc_mutex_lock( &p_playlist->object_lock );
+    i_ret = playlist_Replace( p_playlist, p_olditem, p_new );
+    vlc_mutex_unlock( &p_playlist->object_lock );
+    return i_ret;
+}
+
+/**
+ * Replaces an item with another one
+ * This function must be entered with the playlist lock:
+ *
+ * \param p_playlist the playlist
+ * \param p_olditem the item to replace
+ * \param p_new the new input_item
+ * \return VLC_SUCCESS or an error
+ */
+int playlist_Replace( playlist_t *p_playlist, playlist_item_t *p_olditem,
+                       input_item_t *p_new )
+{
+    int i;
+    int j;
+
+    if( p_olditem->i_children != -1 )
+    {
+        msg_Err( p_playlist, "playlist_Replace can only be used on leafs");
+        return VLC_EGENERIC;
+    }
+
+    p_olditem->i_nb_played = 0;
+    memcpy( &p_olditem->input, p_new, sizeof( input_item_t ) );
+
+    p_olditem->i_nb_played = 0;
+
+    for( i = 0 ; i< p_olditem->i_parents ; i++ )
+    {
+        playlist_item_t *p_parent = p_olditem->pp_parents[i]->p_parent;
+
+        for( j = 0 ; j< p_parent->i_children ; i++ )
+        {
+            if( p_parent->pp_children[j] == p_olditem )
+            {
+                p_parent->i_serial++;
+            }
+        }
+    }
+    return VLC_SUCCESS;
+}
+
+/**
+ * Deletes an item from a playlist.
+ *
+ * This function must be entered without the playlist lock
+ *
+ * \param p_playlist the playlist to remove from.
+ * \param i_id the identifier of the item to delete
+ * \return returns VLC_SUCCESS or an error
+ */
+int playlist_Delete( playlist_t * p_playlist, int i_id )
+{
+    int i, i_top, i_bottom;
+    int i_pos;
+    vlc_bool_t b_flag = VLC_FALSE;
+
+    playlist_item_t *p_item = playlist_ItemGetById( p_playlist, i_id );
+
+    if( p_item == NULL )
+    {
+        return VLC_EGENERIC;
+    }
+    if( p_item->i_children > -1 )
+    {
+        return playlist_NodeDelete( p_playlist, p_item, VLC_TRUE, VLC_FALSE );
+    }
+
+    var_SetInteger( p_playlist, "item-deleted", i_id );
+
+    i_bottom = 0; i_top = p_playlist->i_all_size - 1;
+    i = i_top / 2;
+    while( p_playlist->pp_all_items[i]->input.i_id != i_id &&
+           i_top > i_bottom )
+    {
+        if( p_playlist->pp_all_items[i]->input.i_id < i_id )
+        {
+            i_bottom = i + 1;
+        }
+        else
+        {
+            i_top = i - 1;
+        }
+        i = i_bottom + ( i_top - i_bottom ) / 2;
+    }
+    if( p_playlist->pp_all_items[i]->input.i_id == i_id )
+    {
+        REMOVE_ELEM( p_playlist->pp_all_items, p_playlist->i_all_size, i );
+    }
+
+    /* Check if it is the current item */
+    if( p_playlist->status.p_item == p_item )
+    {
+        /* Hack we don't call playlist_Control for lock reasons */
+        p_playlist->status.i_status = PLAYLIST_STOPPED;
+        p_playlist->request.b_request = VLC_TRUE;
+        p_playlist->request.p_item = NULL;
+        msg_Info( p_playlist, "stopping playback" );
+        b_flag = VLC_TRUE;
+    }
+
+    /* Get position and update index if needed */
+    i_pos = playlist_GetPositionById( p_playlist, i_id );
+
+    if( i_pos >= 0 && i_pos <= p_playlist->i_index )
+    {
+        p_playlist->i_index--;
+    }
+
+    msg_Dbg( p_playlist, "deleting playlist item `%s'",
+                          p_item->input.psz_name );
+
+    /* Remove the item from all its parent nodes */
+    for ( i= 0 ; i < p_item->i_parents ; i++ )
+    {
+        playlist_NodeRemoveItem( p_playlist, p_item,
+                                 p_item->pp_parents[i]->p_parent );
+        if( p_item->pp_parents[i]->i_view == VIEW_ALL )
+        {
+            p_playlist->i_size--;
+        }
+    }
+
+    /* TODO : Update views */
+
+    if( b_flag == VLC_FALSE )
+        playlist_ItemDelete( p_item );
+    else
+        p_item->i_flags |= PLAYLIST_REMOVE_FLAG;
+
+    return VLC_SUCCESS;
+}
+
+int playlist_LockDelete( playlist_t * p_playlist, int i_id )
+{
+    int i_ret;
+    vlc_mutex_lock( &p_playlist->object_lock );
+    i_ret = playlist_Delete( p_playlist, i_id );
+    vlc_mutex_unlock( &p_playlist->object_lock );
+    return i_ret;
+}
+
+/**
+ * Clear all playlist items
+ *
+ * \param p_playlist the playlist to be cleared.
+ * \return returns 0
+ */
+int playlist_Clear( playlist_t * p_playlist )
+{
+    int i;
+    for( i = p_playlist->i_size; i > 0 ; i-- )
+    {
+        playlist_Delete( p_playlist, p_playlist->pp_items[0]->input.i_id );
+    }
+    for( i = 0 ; i< p_playlist->i_views; i++ )
+    {
+        playlist_ViewEmpty( p_playlist, i, VLC_TRUE );
+    }
+    return VLC_SUCCESS;
+}
+
+int playlist_LockClear( playlist_t *p_playlist )
+{
+    int i_ret;
+    vlc_mutex_lock( &p_playlist->object_lock );
+    i_ret = playlist_Clear( p_playlist );
+    vlc_mutex_unlock( &p_playlist->object_lock );
+    return i_ret;
+}
+
+
+/**
+ * Disables a playlist item
+ *
+ * \param p_playlist the playlist to disable from.
+ * \param i_pos the position of the item to disable
+ * \return returns 0
+ */
+int playlist_Disable( playlist_t * p_playlist, playlist_item_t *p_item )
+{
+    if( !p_item ) return VLC_EGENERIC;
+
+    msg_Dbg( p_playlist, "disabling playlist item `%s'",
+                   p_item->input.psz_name );
+
+    if( p_item->i_flags & PLAYLIST_ENA_FLAG )
+    {
+        p_playlist->i_enabled--;
+    }
+    p_item->i_flags &= ~PLAYLIST_ENA_FLAG;
+
+    var_SetInteger( p_playlist, "item-change", p_item->input.i_id );
+    return VLC_SUCCESS;
+}
+
+/**
+ * Enables a playlist item
+ *
+ * \param p_playlist the playlist to enable from.
+ * \param i_pos the position of the item to enable
+ * \return returns 0
+ */
+int playlist_Enable( playlist_t * p_playlist, playlist_item_t *p_item )
+{
+    if( !p_item ) return VLC_EGENERIC;
+
+    msg_Dbg( p_playlist, "enabling playlist item `%s'",
+                   p_item->input.psz_name );
+
+    if( p_item->i_flags & ~PLAYLIST_ENA_FLAG )
+    {
+        p_playlist->i_enabled++;
+    }
+    p_item->i_flags |= PLAYLIST_ENA_FLAG;
+
+    var_SetInteger( p_playlist, "item-change", p_item->input.i_id );
+    return VLC_SUCCESS;
+}
+
+/**
+ * Move an item in a playlist
+ *
+ * This function must be entered without the playlist lock
+ *
+ * Move the item in the playlist with position i_pos before the current item
+ * at position i_newpos.
+ * \param p_playlist the playlist to move items in
+ * \param i_pos the position of the item to move
+ * \param i_newpos the position of the item that will be behind the moved item
+ *        after the move
+ * \return returns VLC_SUCCESS
+ */
+int playlist_Move( playlist_t * p_playlist, int i_pos, int i_newpos )
+{
+    vlc_value_t val;
+    vlc_mutex_lock( &p_playlist->object_lock );
+
+    /* take into account that our own row disappears. */
+    if( i_pos < i_newpos ) i_newpos--;
+
+    if( i_pos >= 0 && i_newpos >=0 && i_pos <= p_playlist->i_size &&
+        i_newpos <= p_playlist->i_size )
+    {
+        playlist_item_t * temp;
+
+        msg_Dbg( p_playlist, "moving playlist item `%s' (%i -> %i)",
+                 p_playlist->pp_items[i_pos]->input.psz_name, i_pos, i_newpos);
+
+        if( i_pos == p_playlist->i_index )
+        {
+            p_playlist->i_index = i_newpos;
+        }
+        else if( i_pos > p_playlist->i_index &&
+                 i_newpos <= p_playlist->i_index )
+        {
+            p_playlist->i_index++;
+        }
+        else if( i_pos < p_playlist->i_index &&
+                 i_newpos >= p_playlist->i_index )
+        {
+            p_playlist->i_index--;
+        }
+
+        if ( i_pos < i_newpos )
+        {
+            temp = p_playlist->pp_items[i_pos];
+            while ( i_pos < i_newpos )
+            {
+                p_playlist->pp_items[i_pos] = p_playlist->pp_items[i_pos+1];
+                i_pos++;
+            }
+            p_playlist->pp_items[i_newpos] = temp;
+        }
+        else if ( i_pos > i_newpos )
+        {
+            temp = p_playlist->pp_items[i_pos];
+            while ( i_pos > i_newpos )
+            {
+                p_playlist->pp_items[i_pos] = p_playlist->pp_items[i_pos-1];
+                i_pos--;
+            }
+            p_playlist->pp_items[i_newpos] = temp;
+        }
+    }
+
+    vlc_mutex_unlock( &p_playlist->object_lock );
+
+    val.b_bool = VLC_TRUE;
+    var_Set( p_playlist, "intf-change", val );
+
+    return VLC_SUCCESS;
+}
+
+/**
+ * Moves an item
+ *
+ * This function must be entered with the playlist lock
+ *
+ * \param p_playlist the playlist
+ * \param p_item the item to move
+ * \param p_node the new parent of the item
+ * \param i_newpos the new position under this new parent
+ * \param i_view the view in which the move must be done or ALL_VIEWS
+ * \return VLC_SUCCESS or an error
+ */
+int playlist_TreeMove( playlist_t * p_playlist, playlist_item_t *p_item,
+                       playlist_item_t *p_node, int i_newpos, int i_view )
+{
+    int i;
+    playlist_item_t *p_detach = NULL;
+    struct item_parent_t *p_parent;
+
+    if( p_node->i_children == -1 ) return VLC_EGENERIC;
+
+    /* Detach from the parent */
+    for( i = 0 ; i< p_item->i_parents; i++ )
+    {
+        if( p_item->pp_parents[i]->i_view == i_view )
+        {
+            int j;
+            p_detach = p_item->pp_parents[i]->p_parent;
+            for( j = 0; j < p_detach->i_children; j++ )
+            {
+                if( p_detach->pp_children[j] == p_item ) break;
+            }
+            REMOVE_ELEM( p_detach->pp_children, p_detach->i_children, j );
+            p_detach->i_serial++;
+            free( p_item->pp_parents[i] );
+            REMOVE_ELEM( p_item->pp_parents, p_item->i_parents, i );
+            i--;
+        }
+    }
+
+    /* Attach to new parent */
+    INSERT_ELEM( p_node->pp_children, p_node->i_children, i_newpos, p_item );
+
+    p_parent = malloc( sizeof( struct item_parent_t ) );
+    p_parent->p_parent = p_node;
+    p_parent->i_view = i_view;
+
+    INSERT_ELEM( p_item->pp_parents, p_item->i_parents, p_item->i_parents,
+                 p_parent );
+    p_node->i_serial++;
+    p_item->i_serial++;
+
+    return VLC_SUCCESS;
+}

Property changes on: src\playlist\item-ext.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\playlist\item.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\playlist\loadsave.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\playlist\playlist.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\playlist\services_discovery.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\playlist\sort.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\playlist\view.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\stream_output\announce.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\stream_output\sap.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\stream_output\stream_output.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\test\i18n_atof.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\test\url.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\video_output\video_output.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\video_output\video_text.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\video_output\video_widgets.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\video_output\vout_intf.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\video_output\vout_pictures.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\video_output\vout_pictures.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\video_output\vout_subpictures.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\video_output\vout_synchro.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: src\vlc.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\libvlc_sample.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\mangle\mangle.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\mangle\VLCUtil.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\native\libvlc.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\native\stats.c
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\NativeLibvlcTest.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\NativeStatsTest.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\PyMediaControlBaseTest.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\PyMediaControlPlaylistTest.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\PyMediaControlVariablesTest.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\pyunit.h
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\setup.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\test.py
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\test.sh
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: test\TODO
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: THANKS
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: vlc-api.pl
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: vlc-config.in.in
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: vlc.exe.manifest
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: vlc.roku
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: vlc.spec
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: vlc.spec.mdk
___________________________________________________________________
Name: svn:eol-style
   + LF


Property changes on: vlc.win32.nsi.in
___________________________________________________________________
Name: svn:eol-style
   + LF

