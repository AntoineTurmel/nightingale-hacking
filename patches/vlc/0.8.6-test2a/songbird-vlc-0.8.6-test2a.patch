
Property changes on: toolbox
___________________________________________________________________
Name: svn:executable
   + *
Name: eol-style
   + LF

Index: src/control/playlist.c
===================================================================
--- src/control/playlist.c	(.../0.8.6)	(revision 108)
+++ src/control/playlist.c	(.../0.8.6-songbird)	(revision 108)
@@ -173,3 +173,68 @@
 
     return p_input;
 }
+
+void libvlc_playlist_get_metadata( libvlc_instance_t *p_instance, vlc_meta_t **pp_meta, libvlc_exception_t *p_e )
+{
+  if( p_instance->p_playlist == NULL )
+  {
+      libvlc_exception_raise( p_e, "No playlist" );
+      return;
+  }
+
+  if( p_instance->p_playlist->status.i_status != PLAYLIST_RUNNING)
+  {
+      libvlc_exception_raise( p_e, "Playlist not running" );
+      return;
+  }
+
+  vlc_mutex_lock( &p_instance->p_playlist->object_lock );
+  //playlist_ItemGetByPos( p_instance->p_playlist, p_instance->p_playlist->i_index );
+  playlist_item_t *p_item = p_instance->p_playlist->status.p_item;
+
+  if( p_item == NULL )
+  {
+      libvlc_exception_raise( p_e, "Playlist has no currently playlist item" );
+      vlc_mutex_unlock( &p_instance->p_playlist->object_lock );
+      return;
+  }
+  
+  vlc_mutex_lock( &p_item->input.lock );
+    
+  *pp_meta = vlc_meta_New();
+  vlc_meta_t *p_meta = *pp_meta;
+  
+  vlc_meta_Add(p_meta, "Root", "Root Metadata Node");
+  
+  int i = 0;
+  for( ; i < p_item->input.i_categories; i++ )
+  {
+    p_meta->track = (vlc_meta_t**)realloc( p_meta->track, sizeof( vlc_meta_t* ) * (p_meta->i_track+1) );
+    p_meta->track[p_meta->i_track] = vlc_meta_New();
+    vlc_meta_Add(p_meta->track[p_meta->i_track], "Category", p_item->input.pp_categories[i]->psz_name);
+
+    p_meta->track[i]->track = (vlc_meta_t**)realloc( p_meta->track[i]->track, sizeof( vlc_meta_t* ) * (p_meta->track[i]->i_track+1) );
+    p_meta->track[i]->track[p_meta->track[i]->i_track] = vlc_meta_New();    
+       
+    int j = 0;
+    for( ; j < p_item->input.pp_categories[i]->i_infos; j++ )
+    {
+      if( p_item->input.pp_categories[i]->pp_infos[j]->psz_name[0] != 0 &&
+          p_item->input.pp_categories[i]->pp_infos[j]->psz_value[0] != 0 )
+      {
+        vlc_meta_Add(p_meta->track[i]->track[p_meta->track[i]->i_track], 
+                     p_item->input.pp_categories[i]->pp_infos[j]->psz_name,
+                     p_item->input.pp_categories[i]->pp_infos[j]->psz_value);
+        
+      }
+    }
+    
+    p_meta->track[i]->i_track++;    
+    p_meta->i_track++;
+  }
+  
+  vlc_mutex_unlock( &p_item->input.lock );
+  vlc_mutex_unlock( &p_instance->p_playlist->object_lock );
+  
+  return;
+}
Index: src/audio_output/output.c
===================================================================
--- src/audio_output/output.c	(.../0.8.6)	(revision 108)
+++ src/audio_output/output.c	(.../0.8.6-songbird)	(revision 108)
@@ -32,6 +32,8 @@
 #include "audio_output.h"
 #include "aout_internal.h"
 
+//#define DEBUG_AOUT_DEFAULT_STEREO
+
 /*****************************************************************************
  * aout_OutputNew : allocate a new output and rework the filter pipeline
  *****************************************************************************
@@ -43,6 +45,11 @@
     /* Retrieve user defaults. */
     int i_rate = config_GetInt( p_aout, "aout-rate" );
     vlc_value_t val, text;
+
+    int i_hasSetOut = 0;
+    int i_preferred = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT;
+    int i_preferredVar = AOUT_VAR_CHAN_STEREO;
+
     /* kludge to avoid a fpu error when rate is 0... */
     if( i_rate == 0 ) i_rate = -1;
 
@@ -65,6 +72,8 @@
     if ( var_Type( p_aout, "audio-channels" ) ==
              (VLC_VAR_INTEGER | VLC_VAR_HASCHOICE) )
     {
+        i_hasSetOut = 1;
+        
         /* The user may have selected a different channels configuration. */
         var_Get( p_aout, "audio-channels", &val );
 
@@ -96,6 +105,12 @@
               && (p_aout->output.output.i_original_channels
                    & AOUT_CHAN_PHYSMASK) == (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT) )
     {
+#if defined(DEBUG_AOUT_DEFAULT_STEREO)      
+        printf("vlc: output.c: aout_OutputNew: AOUT_CHAN_CENTER -- MONO!\n");
+#endif
+        int i_preferred = AOUT_CHAN_LEFT;
+        int i_preferredVar = AOUT_VAR_CHAN_LEFT;
+  
         /* Mono - create the audio-channels variable. */
         var_Create( p_aout, "audio-channels",
                     VLC_VAR_INTEGER | VLC_VAR_HASCHOICE );
@@ -110,9 +125,16 @@
         var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
         if ( p_aout->output.output.i_original_channels & AOUT_CHAN_DUALMONO )
         {
+            i_hasSetOut = 1;
+            
             /* Go directly to the left channel. */
             p_aout->output.output.i_original_channels = AOUT_CHAN_LEFT;
             val.i_int = AOUT_VAR_CHAN_LEFT;
+
+#if defined(DEBUG_AOUT_DEFAULT_STEREO)      
+        printf("vlc: output.c: aout_OutputNew: MONO BUT USING LEFT CHANNEL ONLY!\n");
+#endif
+            
             var_Set( p_aout, "audio-channels", val );
         }
         var_AddCallback( p_aout, "audio-channels", aout_ChannelsRestart,
@@ -123,6 +145,10 @@
                 && (p_aout->output.output.i_original_channels &
                      (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT)) )
     {
+#if defined(DEBUG_AOUT_DEFAULT_STEREO)      
+        printf("vlc: output.c: aout_OutputNew: AOUT_CHAN_CENTER -- STEREO!\n");
+#endif
+
         /* Stereo - create the audio-channels variable. */
         var_Create( p_aout, "audio-channels",
                     VLC_VAR_INTEGER | VLC_VAR_HASCHOICE );
@@ -131,11 +157,17 @@
 
         if ( p_aout->output.output.i_original_channels & AOUT_CHAN_DOLBYSTEREO )
         {
+            i_preferred = AOUT_CHAN_DOLBYSTEREO;
+            i_preferredVar = AOUT_VAR_CHAN_DOLBYS;
+            
             val.i_int = AOUT_VAR_CHAN_DOLBYS;
             text.psz_string = _("Dolby Surround");
         }
         else
         {
+            i_preferred = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT;
+            i_preferredVar = AOUT_VAR_CHAN_STEREO;
+            
             val.i_int = AOUT_VAR_CHAN_STEREO;
             text.psz_string = _("Stereo");
         }
@@ -148,14 +180,34 @@
         var_Change( p_aout, "audio-channels", VLC_VAR_ADDCHOICE, &val, &text );
         if ( p_aout->output.output.i_original_channels & AOUT_CHAN_DUALMONO )
         {
+            i_hasSetOut = 1;
+            
             /* Go directly to the left channel. */
-            p_aout->output.output.i_original_channels = AOUT_CHAN_LEFT;
-            val.i_int = AOUT_VAR_CHAN_LEFT;
+            p_aout->output.output.i_original_channels = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT;
+            val.i_int = AOUT_VAR_CHAN_STEREO;
+            
+#if defined(DEBUG_AOUT_DEFAULT_STEREO)      
+            printf("vlc: output.c: aout_OutputNew: DUAL MONO BUT USING STEREO CHANNEL ONLY!\n");
+#endif
+
             var_Set( p_aout, "audio-channels", val );
         }
+   
         var_AddCallback( p_aout, "audio-channels", aout_ChannelsRestart,
                          NULL );
     }
+
+    if(i_hasSetOut == 0)
+    {
+#if defined(DEBUG_AOUT_DEFAULT_STEREO)      
+        printf("vlc: output.c: aout_OutputNew: STEREO -- DEFAULT TO PREFERRED: %d!\n", i_preferred);
+#endif
+        p_aout->output.output.i_original_channels = i_preferred;
+        val.i_int = i_preferredVar;
+
+        var_Change( p_aout, "audio-channels", VLC_VAR_SETVALUE, &val, NULL );
+    }
+
     val.b_bool = VLC_TRUE;
     var_Set( p_aout, "intf-change", val );
 
Index: src/misc/configuration.c
===================================================================
--- src/misc/configuration.c	(.../0.8.6)	(revision 108)
+++ src/misc/configuration.c	(.../0.8.6-songbird)	(revision 108)
@@ -60,6 +60,11 @@
 #   if !defined( UNDER_CE )
 #       include <direct.h>
 #   endif
+/* BEGIN SONGBIRD EDIT */
+#   if !defined(CSIDL_COMMON_APPDATA)
+#      define CSIDL_COMMON_APPDATA (0x0023)
+#   endif
+/* END SONGBIRD EDIT */
 #include <tchar.h>
 #endif
 
@@ -1753,13 +1758,25 @@
         {
             char psz_ACPhome[MAX_PATH];
 
-            /* get the "Application Data" folder for the current user */
+/*BEGIN SONGBIRD EDIT*/
+/* Original unmodified code block */
+/*
+            // get the "Application Data" folder for the current user
             if( S_OK == SHGetFolderPath( NULL,
                                          (b_appdata ? CSIDL_APPDATA :
                                            CSIDL_PROFILE) | CSIDL_FLAG_CREATE,
                                          NULL, SHGFP_TYPE_CURRENT,
                                          psz_ACPhome ) )
             {
+*/
+            /* get the "Application Data" folder for the all users */
+            if( S_OK == SHGetFolderPath( NULL,
+                                         (b_appdata ? CSIDL_COMMON_APPDATA :
+                                           CSIDL_PROFILE) | CSIDL_FLAG_CREATE,
+                                         NULL, SHGFP_TYPE_CURRENT,
+                                         psz_ACPhome ) )
+            {
+/*END SONGBIRD EDIT*/
                 FreeLibrary( shfolder_dll );
                 return FromLocaleDup( psz_ACPhome );
             }
Index: src/libvlc.c
===================================================================
--- src/libvlc.c	(.../0.8.6)	(revision 108)
+++ src/libvlc.c	(.../0.8.6-songbird)	(revision 108)
@@ -1788,6 +1788,85 @@
     return i_err;
 }
 
+/* BEGIN SONGBIRD EDIT */
+/** 
+ * Get Item Metadata. 
+ * 
+ * \param i_object
+ * \param i_index
+ * \param pp_meta
+ * \return 
+ */
+int VLC_PlaylistGetItemMetadata( int i_object, int i_index, vlc_meta_t ** pp_meta)
+{
+  playlist_t *p_playlist = NULL;
+  vlc_t *p_vlc = vlc_current_object( i_object );
+
+  /* Check that the handle is valid */
+  if( !p_vlc )
+  {
+    return VLC_ENOOBJ;
+  }
+  
+  p_playlist = vlc_object_find( p_vlc, VLC_OBJECT_PLAYLIST, FIND_CHILD );
+  
+  if( !p_playlist )
+  {
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_ENOOBJ;
+  }
+ 
+  playlist_item_t *p_item = playlist_ItemGetByPos( p_playlist, i_index );
+  
+  if( !p_item )
+  {
+    vlc_object_release( p_playlist );
+    if( i_object ) vlc_object_release( p_vlc );
+    return VLC_ENOOBJ;
+  }
+  
+  vlc_mutex_lock( &p_item->input.lock );
+  
+  *pp_meta = vlc_meta_New();
+  vlc_meta_t *p_meta = *pp_meta;
+  
+  vlc_meta_Add(p_meta, "Root", "Root Metadata Node");
+  
+  int i = 0;
+  for( ; i < p_item->input.i_categories; i++ )
+  {
+    p_meta->track = (vlc_meta_t**)realloc( p_meta->track, sizeof( vlc_meta_t* ) * (p_meta->i_track+1) );
+    p_meta->track[p_meta->i_track] = vlc_meta_New();
+    vlc_meta_Add(p_meta->track[p_meta->i_track], "Category", p_item->input.pp_categories[i]->psz_name);
+
+    p_meta->track[i]->track = (vlc_meta_t**)realloc( p_meta->track[i]->track, sizeof( vlc_meta_t* ) * (p_meta->track[i]->i_track+1) );
+    p_meta->track[i]->track[p_meta->track[i]->i_track] = vlc_meta_New();    
+       
+    int j = 0;
+    for( ; j < p_item->input.pp_categories[i]->i_infos; j++ )
+    {
+      if( p_item->input.pp_categories[i]->pp_infos[j]->psz_name[0] != 0 &&
+          p_item->input.pp_categories[i]->pp_infos[j]->psz_value[0] != 0 )
+      {
+        vlc_meta_Add(p_meta->track[i]->track[p_meta->track[i]->i_track], 
+                     p_item->input.pp_categories[i]->pp_infos[j]->psz_name,
+                     p_item->input.pp_categories[i]->pp_infos[j]->psz_value);
+        
+      }
+    }
+    
+    p_meta->track[i]->i_track++;    
+    p_meta->i_track++;
+  }
+  
+  vlc_mutex_unlock( &p_item->input.lock );
+  vlc_object_release( p_playlist );
+  
+  if( i_object ) vlc_object_release( p_vlc );
+  
+  return VLC_SUCCESS;
+}
+
 /**
  * Change the volume
  *
Index: src/playlist/item-ext.c
===================================================================
--- src/playlist/item-ext.c	(.../0.8.6)	(revision 108)
+++ src/playlist/item-ext.c	(.../0.8.6-songbird)	(revision 108)
@@ -425,7 +425,9 @@
     {
         return p_playlist->pp_items[i_pos];
     }
-    else if( p_playlist->i_size > 0)
+    else if( p_playlist->i_size > 0 && 
+             p_playlist->i_index >= 0 && 
+             p_playlist->i_index <= p_playlist->i_size )
     {
         return p_playlist->pp_items[p_playlist->i_index];
     }
Index: bindings/java/org/videolan/jvlc/SWTVideoWidget.java
===================================================================
--- bindings/java/org/videolan/jvlc/SWTVideoWidget.java	(.../0.8.6)	(revision 108)
+++ bindings/java/org/videolan/jvlc/SWTVideoWidget.java	(.../0.8.6-songbird)	(revision 108)
@@ -1,61 +0,0 @@
-/*****************************************************************************
- * SWTVideoWidget.java: A component usable in SWT Application, embeds JVLC
- *****************************************************************************
- * Copyright (C) 1998-2006 the VideoLAN team
- *
- * $Id: SWTVideoWidget.java 15086 2006-04-03 18:05:47Z littlejohn $
- *
- * Authors: Filippo Carone <filippo@carone.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-package org.videolan.jvlc;
-
-
-import org.eclipse.swt.awt.SWT_AWT;
-import org.eclipse.swt.widgets.Composite;
-
-import java.awt.Frame;
-
-public class SWTVideoWidget {
-    /*
-     * This class implements an SWTCanvas containing VLC Video Output
-     */
-
-    /*
-     * The root SWT Frame we embed JVLCCanvas in
-     */
-    public Frame rootFrame;
-    private JVLCCanvas jvlcCanvas;
-    
-    /*
-     * This class 'installs' the VLC video output window
-     * in a Composite container such as a canvas. 
-     */
-    public SWTVideoWidget( Composite parent ) {
-    	// allocate the new AWT Frame to embed in the Composite
-    	rootFrame = SWT_AWT.new_Frame( parent );
-
-    	// add the JVLCCanvas to the Frame
-    	jvlcCanvas = new JVLCCanvas();
-    	rootFrame.add( jvlcCanvas );
-    }
-    
-    
-	public JVLC getJVLC() {
-		return jvlcCanvas.getJVLC();
-	}
-}
Index: bindings/java/vlc-libvlc-jni.cc
===================================================================
--- bindings/java/vlc-libvlc-jni.cc	(.../0.8.6)	(revision 108)
+++ bindings/java/vlc-libvlc-jni.cc	(.../0.8.6-songbird)	(revision 108)
@@ -1,477 +0,0 @@
-/*****************************************************************************
- * JVLC.java: JNI interface for vlc Java Bindings
- *****************************************************************************
- * Copyright (C) 1998-2006 the VideoLAN team
- *
- * Authors: Filippo Carone <filippo@carone.org>
- *
- * $Id$
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
- *****************************************************************************/
-
-/* These are a must*/
-#include <jni.h>
-#include <vlc/libvlc.h>
-
-#include <stdio.h>  // for printf
-#include <stdlib.h> // for calloc
-#include <string.h> // for strcmp
-
-
-/* JVLC internal imports, generated by gcjh */
-#include "org_videolan_jvlc_JVLC.h"
-#include "org_videolan_jvlc_Playlist.h"
-
-jlong getClassInstance (JNIEnv *env, jobject _this);
-jlong getPlaylistInstance (JNIEnv *env, jobject _this);
-
-JNIEXPORT jlong JNICALL Java_org_videolan_jvlc_JVLC_createInstance__ (JNIEnv *env, jobject _this) {
-
-    // res is the pointer to libvlc_instance_t
-    long res;
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-    res = ( long ) libvlc_new( 0, NULL, exception );
-
-    if ( libvlc_exception_raised( exception )) 
-    {
-        ///\TODO: raise java exception
-        printf("%s\n", libvlc_exception_get_message( exception ));
-    }
-
-    free( exception );
-
-    return res;
-}
-
-JNIEXPORT jlong JNICALL Java_org_videolan_jvlc_JVLC_createInstance___3Ljava_lang_String_2 (JNIEnv *env, jobject _this, jobjectArray args) {
-
-    long res;
-    int argc;
-    const char **argv;
-
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ) );
-
-    libvlc_exception_init( exception );
-  
-    argc = (int) env->GetArrayLength((jarray) args);
-    argv = (const char **) malloc(argc * sizeof(char*));
-    for (int i = 0; i < argc; i++) {
-        argv[i] = env->GetStringUTFChars((jstring) env->GetObjectArrayElement(args, i),
-                                         0
-        );
-    }
-
-    res = (long) libvlc_new(argc, (char**) argv, exception );
-
-    free( exception );
-    free( argv );
-
-    return res;
-
-}
-
-/*
- * Audio native functions
- */
-
-JNIEXPORT jboolean JNICALL Java_org_videolan_jvlc_JVLC__1getMute (JNIEnv *env, jobject _this) 
-{
-    // res is the final result
-    jboolean res;
-    long instance = 0;
-    
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-
-    instance = getPlaylistInstance( env, _this );
-   
-    res = (jboolean) libvlc_audio_get_mute( ( libvlc_instance_t * ) instance, exception );
-    
-    if ( libvlc_exception_raised( exception )) 
-    {
-        ///\TODO: raise java exception
-        printf("%s\n", libvlc_exception_get_message( exception ));
-    }
-
-    free( exception );
-
-    return res;
-    
-}
-
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_JVLC__1setMute (JNIEnv *env, jobject _this, jboolean value) 
-{
-    long instance = 0;
-    
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-
-    instance = getPlaylistInstance( env, _this );
-
-    libvlc_audio_set_mute( ( libvlc_instance_t * ) instance, value, exception );
-    
-    if ( libvlc_exception_raised( exception )) 
-    {
-        ///\TODO: raise java exception
-        printf("%s\n", libvlc_exception_get_message( exception ));
-    }
-
-    free( exception );
-}
-
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_JVLC__1toggleMute (JNIEnv *env, jobject _this) 
-{
-
-    long instance = 0;
-    
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-
-    instance = getPlaylistInstance( env, _this );
-
-    ///\TODO: NO, this is not what we want.
-    libvlc_audio_get_mute( ( libvlc_instance_t * ) instance, exception );
-    
-    if ( libvlc_exception_raised( exception )) 
-    {
-        ///\TODO: raise java exception
-        printf("%s\n", libvlc_exception_get_message( exception ));
-    }
-
-    free( exception );
-}
-
-JNIEXPORT jint JNICALL Java_org_videolan_jvlc_JVLC__1getVolume (JNIEnv *env, jobject _this)
-{
-
-    // res is the final result
-    jboolean res;
-    long instance = 0;
-    
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-
-    instance = getPlaylistInstance( env, _this );
-
-    
-    res = (jboolean) libvlc_audio_get_mute( ( libvlc_instance_t * ) instance, exception );
-    
-    if ( libvlc_exception_raised( exception )) 
-    {
-        ///\TODO: raise java exception
-        printf("%s\n", libvlc_exception_get_message( exception ));
-    }
-
-    free( exception );
-
-    return res;
-    
-}
-
-JNIEXPORT jint JNICALL Java_org_videolan_jvlc_JVLC__1getVolume (JNIEnv *env, jobject _this, jboolean value) 
-{
-    jint res = 0;
-    long instance = 0;
-    
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-
-    instance = getPlaylistInstance( env, _this );
-
-    res = libvlc_audio_get_volume( ( libvlc_instance_t * ) instance, exception );
-    
-    if ( libvlc_exception_raised( exception )) 
-    {
-        ///\TODO: raise java exception
-        printf("%s\n", libvlc_exception_get_message( exception ));
-    }
-
-    free( exception );
-
-    return res;
-}
-
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_JVLC__1setVolume (JNIEnv *env, jobject _this, jint volume) 
-{
-    long instance = 0;
-    
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-
-    instance = getPlaylistInstance( env, _this );
-
-    libvlc_audio_set_volume( ( libvlc_instance_t * ) instance, volume, exception );
-    
-    if ( libvlc_exception_raised( exception )) 
-    {
-        ///\TODO: raise java exception
-        printf("%s\n", libvlc_exception_get_message( exception ));
-    }
-
-    free( exception );
-}
-
-
-
-/*
- * Video native functions
- */
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_JVLC__1toggleFullscreen (JNIEnv *env, jobject _this) 
-{
-    long instance = 0;
-    libvlc_input_t *input;
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-
-    instance = getPlaylistInstance( env, _this );
-
-    input = libvlc_playlist_get_input( ( libvlc_instance_t *) instance, exception );
-
-    
-    libvlc_toggle_fullscreen( input, exception );
-    
-    if ( libvlc_exception_raised( exception )) 
-    {
-        ///\TODO: raise java exception
-        printf("%s\n", libvlc_exception_get_message( exception ));
-    }
-
-    free( exception );
-}
-
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_JVLC__1setFullscreen (JNIEnv *env, jobject _this, jboolean value)
-{
-    long instance = 0;
-    libvlc_input_t *input;
-    
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-
-    instance = getPlaylistInstance( env, _this );
-
-    input = libvlc_playlist_get_input( ( libvlc_instance_t *) instance, exception );
-    libvlc_set_fullscreen( input, value, exception );
-    
-    if ( libvlc_exception_raised( exception )) 
-    {
-        ///\TODO: raise java exception
-        printf("%s\n", libvlc_exception_get_message( exception ));
-    }
-
-    free( exception );
-}
-
-JNIEXPORT jboolean JNICALL Java_org_videolan_jvlc_JVLC__1getFullscreen (JNIEnv *env, jobject _this)
-{
-    int res = 0;
-    libvlc_input_t *input;
-    long instance = 0;
-    
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-
-    instance = getPlaylistInstance( env, _this );
-    input = libvlc_playlist_get_input( ( libvlc_instance_t *) instance, exception );
-
-    res = libvlc_get_fullscreen( input, exception );
-    
-    if ( libvlc_exception_raised( exception )) 
-    {
-        ///\TODO: raise java exception
-        printf("%s\n", libvlc_exception_get_message( exception ));
-    }
-
-    free( exception );
-
-    return res;
-}
-
-
-
-
-/*
- * Playlist native functions
- */
-
-JNIEXPORT jint JNICALL Java_org_videolan_jvlc_Playlist__1playlist_1add (JNIEnv *env, jobject _this, jstring uri, jstring name) {
-    long instance = 0;
-    int res = 0;
-    const char* psz_uri  = env->GetStringUTFChars( uri, 0 );
-    const char* psz_name = env->GetStringUTFChars( name, 0 );
-    libvlc_exception_t *exception = (libvlc_exception_t *) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-
-    instance = getPlaylistInstance( env, _this );
-
-    res = libvlc_playlist_add( (libvlc_instance_t*) instance, psz_uri, psz_name, exception );
-  
-    /// \todo check exceptions
-
-    /* free resources */
-    free(exception);
-    if (psz_uri != NULL) {
-        env->ReleaseStringUTFChars( uri, psz_uri );
-    }
-
-    if (psz_name != NULL) {
-        env->ReleaseStringUTFChars( name, psz_name );
-    }
-
-    return res;
-}
-
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_Playlist__1play (JNIEnv *env, jobject _this, jint id, jobjectArray options) {
-
-    long instance = 0;
-    int i_options = 0;
-    char** ppsz_options = NULL;
-    instance = getPlaylistInstance( env, _this );
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-
-    if ( options != NULL ) ;
-    /// \TODO: parse options 
-
-    libvlc_playlist_play( ( libvlc_instance_t* ) instance, id, i_options, ppsz_options, exception );
-
-    free( exception );
-    return;
-}
-
-
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_Playlist__1pause (JNIEnv *env, jobject _this) {
-    long instance = 0;
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ) );
-
-    libvlc_exception_init( exception );
-    instance = getPlaylistInstance( env, _this );
-  
-    libvlc_playlist_pause( ( libvlc_instance_t* ) instance, exception );
-
-    free( exception );
-    return;
-}
-
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_Playlist__1stop (JNIEnv *env, jobject _this) {
-    long instance = 0;
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ) );
-
-    libvlc_exception_init( exception );
-    instance = getPlaylistInstance( env, _this );
-    libvlc_playlist_stop( ( libvlc_instance_t* ) instance, exception );
-
-    free( exception );
-    return;
-  
-}
-
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_Playlist__1next (JNIEnv *env, jobject _this) {
-    long instance = 0;
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ) );
-
-    libvlc_exception_init( exception );
-    instance = getPlaylistInstance( env, _this );
-    libvlc_playlist_next( ( libvlc_instance_t* ) instance, exception );
-
-    free( exception );
-    return;
-
-}
-
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_Playlist__1prev (JNIEnv *env, jobject _this) {
-    long instance = 0;
-    libvlc_exception_t *exception = ( libvlc_exception_t * ) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-    instance = getPlaylistInstance( env, _this );
-    libvlc_playlist_prev( (libvlc_instance_t*) instance, exception );
-
-    free( exception );
-    return;
-}
-
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_Playlist__1clear (JNIEnv *env, jobject _this) {
-    long instance = 0;
-    libvlc_exception_t *exception = (libvlc_exception_t *) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-    instance = getPlaylistInstance( env, _this );
-    libvlc_playlist_clear( (libvlc_instance_t*) instance, exception );
-
-    free( exception );
-    return;
-}
-
-JNIEXPORT jint JNICALL Java_org_videolan_jvlc_Playlist__1itemsCount (JNIEnv *env, jobject _this) {
-    long instance = 0;
-    int res = 0;
-    libvlc_exception_t *exception = (libvlc_exception_t *) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-    instance = getPlaylistInstance( env, _this );
-    res = libvlc_playlist_items_count( (libvlc_instance_t*) instance, exception );
-
-    free( exception );
-    return res;
-
-}
-
-JNIEXPORT jint JNICALL Java_org_videolan_jvlc_Playlist__1isPlaying (JNIEnv *env, jobject _this) {
-    long instance = 0;
-    int res = 0;
-    libvlc_exception_t *exception = (libvlc_exception_t *) malloc( sizeof( libvlc_exception_t ));
-
-    libvlc_exception_init( exception );
-    instance = getPlaylistInstance( env, _this );
-    res = libvlc_playlist_isplaying( (libvlc_instance_t*) instance, exception );
-
-    free( exception );
-    return res;
-
-}
-
-
-/*
- * Utility functions
- */
-jlong getClassInstance (JNIEnv *env, jobject _this) {
-    /* get the id field of object */
-    jclass    cls   = env->GetObjectClass(_this);
-    jmethodID mid   = env->GetMethodID(cls, "getInstance", "()J");
-    jlong     field = env->CallLongMethod(_this, mid);
-    return field;
-}
-
-jlong getPlaylistInstance (JNIEnv *env, jobject _this) {
-    /* get the instance field of object */
-    jclass    cls   = env->GetObjectClass(_this);
-    jmethodID mid   = env->GetMethodID(cls, "getInstance", "()J");
-    jlong     field = env->CallLongMethod(_this, mid);
-    return field;
-}
Index: bindings/java/vlc-graphics-jni.cc
===================================================================
--- bindings/java/vlc-graphics-jni.cc	(.../0.8.6)	(revision 108)
+++ bindings/java/vlc-graphics-jni.cc	(.../0.8.6-songbird)	(revision 108)
@@ -1,103 +0,0 @@
-/*****************************************************************************
- * JVLC.java: JNI interface for vlc Java Bindings
- *****************************************************************************
- * Copyright (C) 1998-2005 the VideoLAN team
- *
- * Authors: Filippo Carone <filippo@carone.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/* These are a must*/
-#include <jni.h>
-#include <vlc/vlc.h>
-#include <jawt.h>
-#include <jawt_md.h>
-
-#include <X11/Xlib.h> // for Xlibs graphics functions
-
-/* JVLC internal imports, generated by gcjh */
-#include "org_videolan_jvlc_JVLCCanvas.h"
-
-/*
- * This will only work on X11 at the moment
- */
-
-JNIEXPORT void JNICALL Java_org_videolan_jvlc_JVLCCanvas_paint (JNIEnv *env, jobject canvas, jobject graphics) {
-
-  JAWT awt;
-  JAWT_DrawingSurface* ds;
-  JAWT_DrawingSurfaceInfo* dsi;
-  JAWT_X11DrawingSurfaceInfo* dsi_x11;
-  jboolean result;
-  jint lock;
-  GC gc;
-    
-  vlc_value_t value;
-  short i;
-
-  /* Get the AWT */
-  awt.version = JAWT_VERSION_1_3;
-  if (JAWT_GetAWT(env, &awt) == JNI_FALSE) {
-    printf("AWT Not found\n");
-    return;
-  }
-
-  /* Get the drawing surface */
-  ds = awt.GetDrawingSurface(env, canvas);
-  if (ds == NULL) {
-    printf("NULL drawing surface\n");
-    return;
-  }
-
-  /* Lock the drawing surface */
-  lock = ds->Lock(ds);
-  if((lock & JAWT_LOCK_ERROR) != 0) {
-    printf("Error locking surface\n");
-    awt.FreeDrawingSurface(ds);
-    return;
-  }
-
-  /* Get the drawing surface info */
-  dsi = ds->GetDrawingSurfaceInfo(ds);
-  if (dsi == NULL) {
-    printf("Error getting surface info\n");
-    ds->Unlock(ds);
-    awt.FreeDrawingSurface(ds);
-    return;
-  }
-
-  /* Get the platform-specific drawing info */
-  dsi_x11 = (JAWT_X11DrawingSurfaceInfo*)dsi->platformInfo;
-
-
-  /* Now paint */
-  gc = XCreateGC(dsi_x11->display, dsi_x11->drawable, 0, 0);
-  XSetBackground(dsi_x11->display, gc, 0);
-
-  value.i_int = dsi_x11->drawable;
-  VLC_VariableSet( 0, "drawable", value );
-
-  XFreeGC(dsi_x11->display, gc);
-
-  /* Free the drawing surface info */
-  ds->FreeDrawingSurfaceInfo(dsi);
-
-  /* Unlock the drawing surface */
-  ds->Unlock(ds);
-
-  /* Free the drawing surface */
-  awt.FreeDrawingSurface(ds);
-}
Index: bindings/java/SWTUglyPlayer.java
===================================================================
--- bindings/java/SWTUglyPlayer.java	(.../0.8.6)	(revision 108)
+++ bindings/java/SWTUglyPlayer.java	(.../0.8.6-songbird)	(revision 108)
@@ -1,118 +0,0 @@
-/*****************************************************************************
- * JVLC.java: global class for vlc Java Bindings
- *****************************************************************************
- * Copyright (C) 1998-2006 the VideoLAN team
- *
- * $Id$
- *
- * Authors: Filippo Carone <filippo@carone.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-import java.awt.Dialog;
-
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.widgets.Display;
-import org.eclipse.swt.widgets.Shell;
-import org.eclipse.swt.widgets.Canvas;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Text;
-
-import org.videolan.jvlc.*;
-
-
-public class SWTUglyPlayer {
-
-	private Shell sShell = null;  //  @jve:decl-index=0:visual-constraint="230,12"
-	private Canvas canvas = null;
-	private SWTVideoWidget vlc = null;
-	private Button button = null;
-	private Text text = null;
-	private Button button1 = null;
-	private Button button2 = null;
-	private Display display = new Display(); 
-	/**
-	 * This method initializes sShell
-	 */
-	private void createSShell() {
-		sShell = new Shell(display);
-		sShell.setText("Shell");
-		createCanvas();
-		sShell.setSize(new org.eclipse.swt.graphics.Point(339,303));
-		button = new Button(sShell, SWT.NONE);
-		button.setText("Play");
-		button.setSize(new org.eclipse.swt.graphics.Point(70,30));
-		button.setLocation(new org.eclipse.swt.graphics.Point(26,185));
-		button.addMouseListener(new org.eclipse.swt.events.MouseAdapter() {
-			public void mouseDown(org.eclipse.swt.events.MouseEvent e) {
-				vlc.getJVLC().playlist.add(text.getText(), text.getText());
-				vlc.getJVLC().playlist.play(-1, null);
-			}
-		});
-		text = new Text(sShell, SWT.BORDER);
-		text.setBounds(new org.eclipse.swt.graphics.Rectangle(26,222,200,25));
-		text.setText("~/a.avi");
-		button1 = new Button(sShell, SWT.NONE);
-		button1.setLocation(new org.eclipse.swt.graphics.Point(120,186));
-		button1.setText("Pause");
-		button1.setSize(new org.eclipse.swt.graphics.Point(70,30));
-		button1.addMouseListener(new org.eclipse.swt.events.MouseAdapter() {
-			public void mouseDown(org.eclipse.swt.events.MouseEvent e) {
-				vlc.getJVLC().playlist.pause();
-			}
-		});
-		button2 = new Button(sShell, SWT.NONE);
-		button2.setText("Stop");
-		button2.setSize(new org.eclipse.swt.graphics.Point(70,30));
-		button2.setLocation(new org.eclipse.swt.graphics.Point(221,188));
-		button2.addSelectionListener(new org.eclipse.swt.events.SelectionAdapter() {
-			public void widgetSelected(org.eclipse.swt.events.SelectionEvent e) {
-				vlc.getJVLC().playlist.stop();
-			}
-		});
-	}
-
-	/**
-	 * This method initializes canvas	
-	 *
-	 */
-	private void createCanvas() {
-		canvas = new Canvas(sShell, SWT.EMBEDDED);
-		canvas.setBounds(new org.eclipse.swt.graphics.Rectangle(22,15,248,145));
-		vlc = new SWTVideoWidget( canvas );
-	}
-
-	public Canvas getCanvas() {
-		return canvas;
-	}
-	
-	public SWTUglyPlayer( ) {
-		createSShell();
-		sShell.open();
-		while( !sShell.isDisposed())
-	    {
-	      if(!display.readAndDispatch()) 
-	      display.sleep();
-	    }
-		display.dispose();
-	}
-	
-	static public void main( String[] args ) {
-		SWTUglyPlayer swt = new SWTUglyPlayer();
-	}
-
-}

Property changes on: extras/contrib/bootstrap
___________________________________________________________________
Name: svn:executable
   + *
Name: eol-style
   + LF


Property changes on: extras/MacOSX/Resources/shuffle_embedded.png
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: extras/MacOSX/Resources/shuffle_embedded_blue.png
___________________________________________________________________
Name: svn:executable
   - *

Index: modules/demux/mp4/drms.c
===================================================================
--- modules/demux/mp4/drms.c	(.../0.8.6)	(revision 108)
+++ modules/demux/mp4/drms.c	(.../0.8.6-songbird)	(revision 108)
@@ -24,6 +24,12 @@
 
 #include <stdlib.h>                                      /* malloc(), free() */
 
+/* BEGIN SONGBIRD EDIT */
+
+#define DISABLE_DRMS_PLAYBACK
+
+/* END SONGBIRD EDIT */
+
 #ifdef WIN32
 #   include <io.h>
 #else
@@ -252,6 +258,11 @@
  *****************************************************************************/
 void drms_decrypt( void *_p_drms, uint32_t *p_buffer, uint32_t i_bytes )
 {
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return;
+#else  
+  
     struct drms_s *p_drms = (struct drms_s *)_p_drms;
     uint32_t p_key[ 4 ];
     unsigned int i_blocks;
@@ -281,6 +292,9 @@
 
         p_buffer += 4;
     }
+    
+#endif
+/* END SONGBIRD EDIT */    
 }
 
 /*****************************************************************************
@@ -298,6 +312,12 @@
 int drms_init( void *_p_drms, uint32_t i_type,
                uint8_t *p_info, uint32_t i_len )
 {
+  
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+
     struct drms_s *p_drms = (struct drms_s *)_p_drms;
     int i_ret = 0;
 
@@ -396,6 +416,9 @@
     }
 
     return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */    
 }
 
 /* The following functions are local */
@@ -1506,6 +1529,12 @@
  *****************************************************************************/
 static int GetSystemKey( uint32_t *p_sys_key, vlc_bool_t b_ipod )
 {
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+
     static char const p_secret5[ 8 ] = "YuaFlafu";
     static char const p_secret6[ 8 ] = "zPif98ga";
     struct md5_s md5;
@@ -1544,6 +1573,9 @@
     memcpy( p_sys_key, md5.p_digest, 16 );
 
     return 0;
+    
+#endif
+/* END SONGBIRD EDIT */    
 }
 
 #ifdef WIN32
@@ -1560,6 +1592,13 @@
  *****************************************************************************/
 static int WriteUserKey( void *_p_drms, uint32_t *p_user_key )
 {
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+/* BEGIN SONGBIRD EDIT */
+
     struct drms_s *p_drms = (struct drms_s *)_p_drms;
     FILE *file;
     int i_ret = -1;
@@ -1591,6 +1630,9 @@
     }
 
     return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */
 }
 
 /*****************************************************************************
@@ -1600,6 +1642,13 @@
  *****************************************************************************/
 static int ReadUserKey( void *_p_drms, uint32_t *p_user_key )
 {
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+/* BEGIN SONGBIRD EDIT */
+
     struct drms_s *p_drms = (struct drms_s *)_p_drms;
     FILE *file;
     int i_ret = -1;
@@ -1618,6 +1667,9 @@
     }
 
     return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */
 }
 
 /*****************************************************************************
@@ -1629,6 +1681,12 @@
  *****************************************************************************/
 static int GetUserKey( void *_p_drms, uint32_t *p_user_key )
 {
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+
     static char const p_secret7[] = "mUfnpognadfgf873";
     struct drms_s *p_drms = (struct drms_s *)_p_drms;
     struct aes_s aes;
@@ -1761,6 +1819,10 @@
     free( p_sci_data );
 
     return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */
+
 }
 
 /*****************************************************************************
@@ -1771,6 +1833,12 @@
 static int GetSCIData( char *psz_ipod, uint32_t **pp_sci,
                        uint32_t *pi_sci_size )
 {
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+
     FILE *file;
     char *psz_path = NULL;
     char p_tmp[ 4 * PATH_MAX ];
@@ -1860,6 +1928,10 @@
     }
 
     return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */
+
 }
 
 /*****************************************************************************
@@ -1957,6 +2029,12 @@
  *****************************************************************************/
 static int GetiPodID( int64_t *p_ipod_id )
 {
+
+/* BEGIN SONGBIRD EDIT */
+#if defined(DISABLE_DRMS_PLAYBACK)
+    return -1;
+#else  
+
     int i_ret = -1;
 
 #define PROD_NAME   "iPod"
@@ -2073,6 +2151,9 @@
 #endif
 
     return i_ret;
+
+#endif
+/* END SONGBIRD EDIT */    
 }
 
 #else /* !defined( UNDER_CE ) */

Property changes on: bootstrap
___________________________________________________________________
Name: svn:executable
   + *
Name: eol-style
   + LF

Index: include/vlc_meta.h
===================================================================
--- include/vlc_meta.h	(.../0.8.6)	(revision 108)
+++ include/vlc_meta.h	(.../0.8.6-songbird)	(revision 108)
@@ -68,6 +68,11 @@
 #define VLC_META_CODEC_NAME         N_("Codec Name")
 #define VLC_META_CODEC_DESCRIPTION  N_("Codec Description")
 
+/* BEGIN SONGBIRD CHANGES */
+#include <stdlib.h>
+#include <string.h>
+/* END SONGBIRD CHANGES */
+
 struct vlc_meta_t
 {
     /* meta name/value pairs */
Index: include/vlc/libvlc.h
===================================================================
--- include/vlc/libvlc.h	(.../0.8.6)	(revision 108)
+++ include/vlc/libvlc.h	(.../0.8.6-songbird)	(revision 108)
@@ -34,6 +34,10 @@
 
 #include <vlc/vlc.h>
 
+/* BEGIN SONGBIRD EDIT */
+#include <vlc_meta.h>
+/* END SONGBIRD EDIT */
+
 # ifdef __cplusplus
 extern "C" {
 # endif
@@ -247,6 +251,20 @@
 libvlc_input_t *libvlc_playlist_get_input( libvlc_instance_t *,
                                            libvlc_exception_t * );
 
+
+/* BEGIN SONGBIRD EDIT */
+
+/** 
+ * Get metadata for currently playing input.
+ * 
+ * \param p_instance the instance
+ * \param pp_meta a pointer to the metadata container.
+ * \param p_exception an initialized exception.
+ */
+void libvlc_playlist_get_metadata( libvlc_instance_t *, vlc_meta_t **, libvlc_exception_t * );
+
+/* END SONGBIRD EDIT */
+
 /** @}*/
 
 /*****************************************************************************
Index: include/vlc/vlc.h
===================================================================
--- include/vlc/vlc.h	(.../0.8.6)	(revision 108)
+++ include/vlc/vlc.h	(.../0.8.6-songbird)	(revision 108)
@@ -153,6 +153,10 @@
 #   include "vlc_common.h"
 #endif
 
+/* BEGIN SONGBIRD EDIT */
+#include "vlc_meta.h"
+/* END SONGBIRD EDIT */
+
 /*****************************************************************************
  * Exported libvlc API
  *****************************************************************************/
@@ -569,7 +573,19 @@
  */
 int             VLC_FullScreen( int );
 
+/* BEGIN SONGBIRD EDIT */
 
+/**
+ * Get Playlist Item MetaData.
+ *
+ * \param i_object a vlc object id.
+ * \param i_item an item index.
+ * \return VLC_SUCCESS on success
+ */
+int             VLC_PlaylistGetItemMetadata( int, int, vlc_meta_t ** );
+
+/* END SONGBIRD EDIT */
+
 # ifdef __cplusplus
 }
 # endif
Index: include/vlc_config.h
===================================================================
--- include/vlc_config.h	(.../0.8.6)	(revision 108)
+++ include/vlc_config.h	(.../0.8.6-songbird)	(revision 108)
@@ -44,7 +44,11 @@
  * outputting an error message (in second) */
 #define THREAD_COND_TIMEOUT             1
 
-/* The configuration file and directory */
+/*BEGIN SONGBIRD EDIT*/
+
+/* Unmodified code block below */
+/*
+// The configuration file and directory 
 #ifdef SYS_BEOS
 #  define CONFIG_DIR                    "config/settings/VideoLAN Client"
 #elif __APPLE__
@@ -56,7 +60,23 @@
 #endif
 #define CONFIG_FILE                     "vlcrc"
 #define PLUGINSCACHE_DIR                "cache"
+*/
 
+/* The configuration file and directory */
+#ifdef SYS_BEOS
+#  define CONFIG_DIR                    "config/settings/Songbird VLC"
+#elif __APPLE__
+#  define CONFIG_DIR                    "Library/Preferences/SongbirdVLC"
+#elif defined( WIN32 ) || defined( UNDER_CE )
+#  define CONFIG_DIR                    "SongbirdVLC"
+#else
+#  define CONFIG_DIR                    ".songbird_vlc"
+#endif
+#define CONFIG_FILE                     "songbirdvlcrc"
+#define PLUGINSCACHE_DIR                "cache"
+
+/*END SONGBIRD EDIT*/
+
 /*****************************************************************************
  * Interface configuration
  *****************************************************************************/
Index: mozilla/control/nporuntime.cpp
===================================================================
--- mozilla/control/nporuntime.cpp	(.../0.8.6)	(revision 108)
+++ mozilla/control/nporuntime.cpp	(.../0.8.6-songbird)	(revision 108)
@@ -56,6 +56,28 @@
     return s;
 }
 
+void RuntimeNPObject::copyStringToNPVariant(const NPUTF8* val, NPVariant &result)
+{
+    NPUTF8* retval = NULL;
+    NPUTF8 *p = NULL;
+    NPUTF8 *defaultVal = "";
+
+    int len = 0;
+   
+    p = (val == NULL) ? defaultVal : (NPUTF8 *)val;
+    len = strlen(p);
+
+    retval = (NPUTF8*)NPN_MemAlloc((len + 1) * sizeof(NPUTF8));
+   
+    if(retval)
+    {
+        memset(retval, 0, len + 1);
+        memcpy(retval, p, len);
+        
+        STRINGN_TO_NPVARIANT(retval, len, result);
+    }
+}
+
 RuntimeNPObject::InvokeResult RuntimeNPObject::getProperty(int index, NPVariant &result)
 {
     /* default behaviour */
Index: mozilla/control/nporuntime.h
===================================================================
--- mozilla/control/nporuntime.h	(.../0.8.6)	(revision 108)
+++ mozilla/control/nporuntime.h	(.../0.8.6-songbird)	(revision 108)
@@ -68,6 +68,9 @@
     static char* stringValue(const NPString &v);
     static char* stringValue(const NPVariant &v);
 
+    static void copyStringToNPVariant(const NPUTF8* val, NPVariant &result);
+    virtual void ReleaseChildren() { };
+
 protected:
 
     RuntimeNPObject(NPP instance, const NPClass *aClass) :
Index: mozilla/control/npolibvlc.cpp
===================================================================
--- mozilla/control/npolibvlc.cpp	(.../0.8.6)	(revision 108)
+++ mozilla/control/npolibvlc.cpp	(.../0.8.6-songbird)	(revision 108)
@@ -1,1770 +1,2192 @@
-/*****************************************************************************
- * npolibvlc.cpp: official Javascript APIs
- *****************************************************************************
- * Copyright (C) 2002-2006 the VideoLAN team
- *
- * Authors: Damien Fouilleul <Damien.Fouilleul@laposte.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-#include "config.h"
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-
-/* Mozilla stuff */
-#ifdef HAVE_MOZILLA_CONFIG_H
-#   include <mozilla-config.h>
-#endif
-
-#include "npolibvlc.h"
-#include "vlcplugin.h"
-
-/*
-** implementation of libvlc root object
-*/
-
-LibvlcRootNPObject::LibvlcRootNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass)
-{
-    audioObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcAudioNPObject>::getClass());
-    inputObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcInputNPObject>::getClass());
-    logObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcLogNPObject>::getClass());
-    playlistObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcPlaylistNPObject>::getClass());
-    videoObj = NPN_CreateObject(instance,RuntimeNPClass<LibvlcVideoNPObject>::getClass());
-}
-
-LibvlcRootNPObject::~LibvlcRootNPObject()
-{
-    NPN_ReleaseObject(audioObj);
-    NPN_ReleaseObject(inputObj);
-    NPN_ReleaseObject(logObj);
-    NPN_ReleaseObject(playlistObj);
-    NPN_ReleaseObject(videoObj);
-}
-
-const NPUTF8 * const LibvlcRootNPObject::propertyNames[] = 
-{
-    "audio",
-    "input",
-    "log",
-    "playlist",
-    "video",
-    "VersionInfo",
-};
-
-const int LibvlcRootNPObject::propertyCount = sizeof(LibvlcRootNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcRootNPObjectPropertyIds
-{
-    ID_audio = 0,
-    ID_input,
-    ID_log,
-    ID_playlist,
-    ID_video,
-    ID_VersionInfo,
-};
-
-RuntimeNPObject::InvokeResult LibvlcRootNPObject::getProperty(int index, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        switch( index )
-        {
-            case ID_audio:
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(audioObj), result);
-                return INVOKERESULT_NO_ERROR;
-            case ID_input:
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(inputObj), result);
-                return INVOKERESULT_NO_ERROR;
-            case ID_log:
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(logObj), result);
-                return INVOKERESULT_NO_ERROR;
-            case ID_playlist:
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(playlistObj), result);
-                return INVOKERESULT_NO_ERROR;
-            case ID_video:
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(videoObj), result);
-                return INVOKERESULT_NO_ERROR;
-            case ID_VersionInfo:
-            {
-                int len = strlen(VLC_Version());
-                NPUTF8 *retval =(NPUTF8*)NPN_MemAlloc(len);
-                if( retval )
-                {
-                    memcpy(retval, VLC_Version(), len);
-                    STRINGN_TO_NPVARIANT(retval, len, result);
-                }
-                else
-                {
-                    NULL_TO_NPVARIANT(result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcRootNPObject::methodNames[] =
-{
-    "versionInfo",
-};
-
-const int LibvlcRootNPObject::methodCount = sizeof(LibvlcRootNPObject::methodNames)/sizeof(NPUTF8 *);
-
-enum LibvlcRootNPObjectMethodIds
-{
-    ID_version,
-};
-
-RuntimeNPObject::InvokeResult LibvlcRootNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_version:
-                if( argCount == 0 )
-                {
-                    NPUTF8 *versionStr = NULL;
-
-                    versionStr = strdup( VLC_Version() );
-                    if (!versionStr)
-                        return INVOKERESULT_GENERIC_ERROR;
-
-                    STRINGZ_TO_NPVARIANT(versionStr, result);
-                    return INVOKERESULT_NO_ERROR;
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-/*
-** implementation of libvlc audio object
-*/
-
-const NPUTF8 * const LibvlcAudioNPObject::propertyNames[] = 
-{
-    "mute",
-    "volume",
-};
-
-const int LibvlcAudioNPObject::propertyCount = sizeof(LibvlcAudioNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcAudioNPObjectPropertyIds
-{
-    ID_mute,
-    ID_volume,
-};
-
-RuntimeNPObject::InvokeResult LibvlcAudioNPObject::getProperty(int index, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_mute:
-            {
-                vlc_bool_t muted = libvlc_audio_get_mute(p_plugin->getVLC(), &ex);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                BOOLEAN_TO_NPVARIANT(muted, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_volume:
-            {
-                int volume = libvlc_audio_get_volume(p_plugin->getVLC(), &ex);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                INT32_TO_NPVARIANT(volume, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-RuntimeNPObject::InvokeResult LibvlcAudioNPObject::setProperty(int index, const NPVariant &value)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_mute:
-                if( NPVARIANT_IS_BOOLEAN(value) )
-                {
-                    libvlc_audio_set_mute(p_plugin->getVLC(),
-                                          NPVARIANT_TO_BOOLEAN(value), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    return INVOKERESULT_NO_ERROR;
-                }
-                return INVOKERESULT_INVALID_VALUE;
-            case ID_volume:
-                if( isNumberValue(value) )
-                {
-                    libvlc_audio_set_volume(p_plugin->getVLC(),
-                                            numberValue(value), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    return INVOKERESULT_NO_ERROR;
-                }
-                return INVOKERESULT_INVALID_VALUE;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcAudioNPObject::methodNames[] =
-{
-    "toggleMute",
-};
-
-const int LibvlcAudioNPObject::methodCount = sizeof(LibvlcAudioNPObject::methodNames)/sizeof(NPUTF8 *);
-
-enum LibvlcAudioNPObjectMethodIds
-{
-    ID_togglemute,
-};
-
-RuntimeNPObject::InvokeResult LibvlcAudioNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_togglemute:
-                if( argCount == 0 )
-                {
-                    libvlc_audio_toggle_mute(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-/*
-** implementation of libvlc input object
-*/
-
-const NPUTF8 * const LibvlcInputNPObject::propertyNames[] = 
-{
-    "length",
-    "position",
-    "time",
-    "state",
-    "rate",
-    "fps",
-    "hasVout",
-};
-
-const int LibvlcInputNPObject::propertyCount = sizeof(LibvlcInputNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcInputNPObjectPropertyIds
-{
-    ID_length,
-    ID_position,
-    ID_time,
-    ID_state,
-    ID_rate,
-    ID_fps,
-    ID_hasvout,
-};
-
-RuntimeNPObject::InvokeResult LibvlcInputNPObject::getProperty(int index, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
-        if( libvlc_exception_raised(&ex) )
-        {
-            if( index != ID_state )
-            {
-                NPN_SetException(this, libvlc_exception_get_message(&ex));
-                libvlc_exception_clear(&ex);
-                return INVOKERESULT_GENERIC_ERROR;
-            }
-            else
-            {
-                /* for input state, return CLOSED rather than an exception */
-                INT32_TO_NPVARIANT(0, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-        }
-
-        switch( index )
-        {
-            case ID_length:
-            {
-                double val = (double)libvlc_input_get_length(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                DOUBLE_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_position:
-            {
-                double val = libvlc_input_get_position(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                DOUBLE_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_time:
-            {
-                double val = (double)libvlc_input_get_time(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                DOUBLE_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_state:
-            {
-                int val = libvlc_input_get_state(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                INT32_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_rate:
-            {
-                float val = libvlc_input_get_rate(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                DOUBLE_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_fps:
-            {
-                double val = libvlc_input_get_fps(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                DOUBLE_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_hasvout:
-            {
-                vlc_bool_t val = libvlc_input_has_vout(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                BOOLEAN_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-        libvlc_input_free(p_input);
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-RuntimeNPObject::InvokeResult LibvlcInputNPObject::setProperty(int index, const NPVariant &value)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
-        if( libvlc_exception_raised(&ex) )
-        {
-            NPN_SetException(this, libvlc_exception_get_message(&ex));
-            libvlc_exception_clear(&ex);
-            return INVOKERESULT_GENERIC_ERROR;
-        }
-
-        switch( index )
-        {
-            case ID_position:
-            {
-                if( ! NPVARIANT_IS_DOUBLE(value) )
-                {
-                    libvlc_input_free(p_input);
-                    return INVOKERESULT_INVALID_VALUE;
-                }
-
-                float val = (float)NPVARIANT_TO_DOUBLE(value);
-                libvlc_input_set_position(p_input, val, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_time:
-            {
-                vlc_int64_t val;
-                if( NPVARIANT_IS_INT32(value) )
-                    val = (vlc_int64_t)NPVARIANT_TO_INT32(value);
-                else if( NPVARIANT_IS_DOUBLE(value) )
-                    val = (vlc_int64_t)NPVARIANT_TO_DOUBLE(value);
-                else
-                {
-                    libvlc_input_free(p_input);
-                    return INVOKERESULT_INVALID_VALUE;
-                }
-
-                libvlc_input_set_time(p_input, val, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_rate:
-            {
-                float val;
-                if( NPVARIANT_IS_INT32(value) )
-                    val = (float)NPVARIANT_TO_INT32(value);
-                else if( NPVARIANT_IS_DOUBLE(value) )
-                    val = (float)NPVARIANT_TO_DOUBLE(value);
-                else
-                {
-                    libvlc_input_free(p_input);
-                    return INVOKERESULT_INVALID_VALUE;
-                }
-
-                libvlc_input_set_rate(p_input, val, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-        libvlc_input_free(p_input);
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcInputNPObject::methodNames[] =
-{
-    /* no methods */
-};
-
-const int LibvlcInputNPObject::methodCount = sizeof(LibvlcInputNPObject::methodNames)/sizeof(NPUTF8 *);
-
-/*
-** implementation of libvlc message object
-*/
-
-const NPUTF8 * const LibvlcMessageNPObject::propertyNames[] = 
-{
-    "severity",
-    "type",
-    "name",
-    "header",
-    "message",
-};
-
-const int LibvlcMessageNPObject::propertyCount = sizeof(LibvlcMessageNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcMessageNPObjectPropertyIds
-{
-    ID_severity,
-    ID_type,
-    ID_name,
-    ID_header,
-    ID_message,
-};
-
-RuntimeNPObject::InvokeResult LibvlcMessageNPObject::getProperty(int index, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        switch( index )
-        {
-            case ID_severity:
-            {
-                INT32_TO_NPVARIANT(_msg.i_severity, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_type:
-            {
-                if( _msg.psz_type )
-                {
-                    int len = strlen(_msg.psz_type);
-                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
-                    if( retval )
-                    {
-                        memcpy(retval, _msg.psz_type, len);
-                        STRINGN_TO_NPVARIANT(retval, len, result);
-                    }
-                }
-                else
-                {
-                    NULL_TO_NPVARIANT(result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_name:
-            {
-                if( _msg.psz_name )
-                {
-                    int len = strlen(_msg.psz_name);
-                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
-                    if( retval )
-                    {
-                        memcpy(retval, _msg.psz_name, len);
-                        STRINGN_TO_NPVARIANT(retval, len, result);
-                    }
-                }
-                else
-                {
-                    NULL_TO_NPVARIANT(result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_header:
-            {
-                if( _msg.psz_header )
-                {
-                    int len = strlen(_msg.psz_header);
-                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
-                    if( retval )
-                    {
-                        memcpy(retval, _msg.psz_header, len);
-                        STRINGN_TO_NPVARIANT(retval, len, result);
-                    }
-                }
-                else
-                {
-                    NULL_TO_NPVARIANT(result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_message:
-            {
-                if( _msg.psz_message )
-                {
-                    int len = strlen(_msg.psz_message);
-                    NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
-                    if( retval )
-                    {
-                        memcpy(retval, _msg.psz_message, len);
-                        STRINGN_TO_NPVARIANT(retval, len, result);
-                    }
-                }
-                else
-                {
-                    NULL_TO_NPVARIANT(result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcMessageNPObject::methodNames[] =
-{
-    /* no methods */
-};
-
-const int LibvlcMessageNPObject::methodCount = sizeof(LibvlcMessageNPObject::methodNames)/sizeof(NPUTF8 *);
-
-/*
-** implementation of libvlc message iterator object
-*/
-
-LibvlcMessageIteratorNPObject::LibvlcMessageIteratorNPObject(NPP instance, const NPClass *aClass) :
-    RuntimeNPObject(instance, aClass),
-    _p_iter(NULL)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_log_t *p_log = p_plugin->getLog();
-        if( p_log )
-        {
-            _p_iter = libvlc_log_get_iterator(p_log, NULL);
-        }
-    }
-};
-
-LibvlcMessageIteratorNPObject::~LibvlcMessageIteratorNPObject()
-{
-    if( _p_iter )
-        libvlc_log_iterator_free(_p_iter, NULL);
-}
-
-const NPUTF8 * const LibvlcMessageIteratorNPObject::propertyNames[] = 
-{
-    "hasNext",
-};
-
-const int LibvlcMessageIteratorNPObject::propertyCount = sizeof(LibvlcMessageIteratorNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcMessageIteratorNPObjectPropertyIds
-{
-    ID_hasNext,
-};
-
-RuntimeNPObject::InvokeResult LibvlcMessageIteratorNPObject::getProperty(int index, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        switch( index )
-        {
-            case ID_hasNext:
-            {
-                if( _p_iter && p_plugin->getLog() )
-                {
-                    libvlc_exception_t ex;
-                    libvlc_exception_init(&ex);
-
-                    BOOLEAN_TO_NPVARIANT(libvlc_log_iterator_has_next(_p_iter, &ex), result);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                }
-                else
-                {
-                    BOOLEAN_TO_NPVARIANT(0, result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcMessageIteratorNPObject::methodNames[] =
-{
-    "next",
-};
-
-const int LibvlcMessageIteratorNPObject::methodCount = sizeof(LibvlcMessageIteratorNPObject::methodNames)/sizeof(NPUTF8 *);
-
-enum LibvlcMessageIteratorNPObjectMethodIds
-{
-    ID_messageiterator_next,
-};
-
-RuntimeNPObject::InvokeResult LibvlcMessageIteratorNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_messageiterator_next:
-                if( argCount == 0 )
-                {
-                    if( _p_iter && p_plugin->getLog() )
-                    {
-                        struct libvlc_log_message_t buffer;
-
-                        buffer.sizeof_msg = sizeof(buffer);
-
-                        libvlc_log_iterator_next(_p_iter, &buffer, &ex);
-                        if( libvlc_exception_raised(&ex) )
-                        {
-                            NPN_SetException(this, libvlc_exception_get_message(&ex));
-                            libvlc_exception_clear(&ex);
-                            return INVOKERESULT_GENERIC_ERROR;
-                        }
-                        else
-                        {
-                            LibvlcMessageNPObject* message =
-                                static_cast<LibvlcMessageNPObject*>(NPN_CreateObject(_instance, RuntimeNPClass<LibvlcMessageNPObject>::getClass()));
-                            if( message )
-                            {
-                                message->setMessage(buffer);
-                                OBJECT_TO_NPVARIANT(message, result);
-                                return INVOKERESULT_NO_ERROR;
-                            }
-                            return INVOKERESULT_OUT_OF_MEMORY;
-                        }
-                    }
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
- 
-/*
-** implementation of libvlc message object
-*/
-
-const NPUTF8 * const LibvlcMessagesNPObject::propertyNames[] = 
-{
-    "count",
-};
-
-const int LibvlcMessagesNPObject::propertyCount = sizeof(LibvlcMessagesNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcMessagesNPObjectPropertyIds
-{
-    ID_count,
-};
-
-RuntimeNPObject::InvokeResult LibvlcMessagesNPObject::getProperty(int index, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        switch( index )
-        {
-            case ID_count:
-            {
-                libvlc_log_t *p_log = p_plugin->getLog();
-                if( p_log )
-                {
-                    libvlc_exception_t ex;
-                    libvlc_exception_init(&ex);
-
-                    INT32_TO_NPVARIANT(libvlc_log_count(p_log, &ex), result);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                }
-                else
-                {
-                    INT32_TO_NPVARIANT(0, result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcMessagesNPObject::methodNames[] =
-{
-    "clear",
-    "iterator",
-};
-
-const int LibvlcMessagesNPObject::methodCount = sizeof(LibvlcMessagesNPObject::methodNames)/sizeof(NPUTF8 *);
-
-enum LibvlcMessagesNPObjectMethodIds
-{
-    ID_messages_clear,
-    ID_iterator,
-};
-
-RuntimeNPObject::InvokeResult LibvlcMessagesNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_messages_clear:
-                if( argCount == 0 )
-                {
-                    libvlc_log_t *p_log = p_plugin->getLog();
-                    if( p_log )
-                    {
-                        libvlc_log_clear(p_log, &ex);
-                        if( libvlc_exception_raised(&ex) )
-                        {
-                            NPN_SetException(this, libvlc_exception_get_message(&ex));
-                            libvlc_exception_clear(&ex);
-                            return INVOKERESULT_GENERIC_ERROR;
-                        }
-                    }
-                    return INVOKERESULT_NO_ERROR;
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-
-            case ID_iterator:
-                if( argCount == 0 )
-                {
-                    LibvlcMessageIteratorNPObject* iter =
-                        static_cast<LibvlcMessageIteratorNPObject*>(NPN_CreateObject(_instance, RuntimeNPClass<LibvlcMessageIteratorNPObject>::getClass()));
-                    if( iter )
-                    {
-                        OBJECT_TO_NPVARIANT(iter, result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                    return INVOKERESULT_OUT_OF_MEMORY;
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
- 
-/*
-** implementation of libvlc message object
-*/
-
-LibvlcLogNPObject::LibvlcLogNPObject(NPP instance, const NPClass *aClass) :
-    RuntimeNPObject(instance, aClass)
-{
-    _p_vlcmessages = static_cast<LibvlcMessagesNPObject*>(NPN_CreateObject(instance, RuntimeNPClass<LibvlcMessagesNPObject>::getClass()));
-};
-    
-LibvlcLogNPObject::~LibvlcLogNPObject()
-{
-    NPN_ReleaseObject(_p_vlcmessages);
-};
-
-const NPUTF8 * const LibvlcLogNPObject::propertyNames[] = 
-{
-    "messages",
-    "verbosity",
-};
-
-const int LibvlcLogNPObject::propertyCount = sizeof(LibvlcLogNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcLogNPObjectPropertyIds
-{
-    ID_messages,
-    ID_verbosity,
-};
-
-RuntimeNPObject::InvokeResult LibvlcLogNPObject::getProperty(int index, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_messages:
-            {
-                OBJECT_TO_NPVARIANT(NPN_RetainObject(_p_vlcmessages), result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_verbosity:
-            {
-                if( p_plugin->getLog() )
-                {
-                    INT32_TO_NPVARIANT(libvlc_get_log_verbosity(p_plugin->getVLC(),
-                                                                    &ex), result);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                }
-                else
-                {
-                    /* log is not enabled, return -1 */
-                    DOUBLE_TO_NPVARIANT(-1.0, result);
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-RuntimeNPObject::InvokeResult LibvlcLogNPObject::setProperty(int index, const NPVariant &value)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_verbosity:
-                if( isNumberValue(value) )
-                {
-                    libvlc_instance_t* p_libvlc = p_plugin->getVLC();
-                    libvlc_log_t *p_log = p_plugin->getLog();
-                    int verbosity = numberValue(value);
-                    if( verbosity >= 0 )
-                    {
-                        if( ! p_log )
-                        {
-                            p_log = libvlc_log_open(p_libvlc, &ex);
-                            if( libvlc_exception_raised(&ex) )
-                            {
-                                NPN_SetException(this, libvlc_exception_get_message(&ex));
-                                libvlc_exception_clear(&ex);
-                                return INVOKERESULT_GENERIC_ERROR;
-                            }
-                            p_plugin->setLog(p_log);
-                        }
-                        libvlc_set_log_verbosity(p_libvlc, (unsigned)verbosity, &ex);
-                        if( libvlc_exception_raised(&ex) )
-                        {
-                            NPN_SetException(this, libvlc_exception_get_message(&ex));
-                            libvlc_exception_clear(&ex);
-                            return INVOKERESULT_GENERIC_ERROR;
-                        }
-                    }
-                    else if( p_log )
-                    {
-                        /* close log  when verbosity is set to -1 */
-                        p_plugin->setLog(NULL);
-                        libvlc_log_close(p_log, &ex);
-                        if( libvlc_exception_raised(&ex) )
-                        {
-                            NPN_SetException(this, libvlc_exception_get_message(&ex));
-                            libvlc_exception_clear(&ex);
-                            return INVOKERESULT_GENERIC_ERROR;
-                        }
-                    }
-                    return INVOKERESULT_NO_ERROR;
-                }
-                return INVOKERESULT_INVALID_VALUE;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcLogNPObject::methodNames[] =
-{
-    /* no methods */
-};
-
-const int LibvlcLogNPObject::methodCount = sizeof(LibvlcLogNPObject::methodNames)/sizeof(NPUTF8 *);
-
-/*
-** implementation of libvlc playlist object
-*/
-
-
-const NPUTF8 * const LibvlcPlaylistNPObject::propertyNames[] = 
-{
-    "itemCount",
-    "isPlaying",
-};
-
-const int LibvlcPlaylistNPObject::propertyCount = sizeof(LibvlcPlaylistNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-enum LibvlcPlaylistNPObjectPropertyIds
-{
-    ID_itemcount,
-    ID_isplaying,
-};
-
-RuntimeNPObject::InvokeResult LibvlcPlaylistNPObject::getProperty(int index, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_itemcount:
-            {
-                int val = libvlc_playlist_items_count(p_plugin->getVLC(), &ex);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                INT32_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_isplaying:
-            {
-                int val = libvlc_playlist_isplaying(p_plugin->getVLC(), &ex);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                BOOLEAN_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcPlaylistNPObject::methodNames[] =
-{
-    "add",
-    "play",
-    "playItem",
-    "togglePause",
-    "stop",
-    "next",
-    "prev",
-    "clear",
-    "removeItem"
-};
-
-const int LibvlcPlaylistNPObject::methodCount = sizeof(LibvlcPlaylistNPObject::methodNames)/sizeof(NPUTF8 *);
-
-enum LibvlcPlaylistNPObjectMethodIds
-{
-    ID_add,
-    ID_play,
-    ID_playItem,
-    ID_togglepause,
-    ID_stop,
-    ID_next,
-    ID_prev,
-    ID_clear,
-    ID_removeitem
-};
-
-RuntimeNPObject::InvokeResult LibvlcPlaylistNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        switch( index )
-        {
-            case ID_add:
-            {
-                if( (argCount < 1) || (argCount > 3) )
-                    return INVOKERESULT_NO_SUCH_METHOD;
-
-                char *url = NULL;
-
-                // grab URL
-                if( NPVARIANT_IS_STRING(args[0]) )
-                {
-                    char *s = stringValue(NPVARIANT_TO_STRING(args[0]));
-                    if( s )
-                    {
-                        url = p_plugin->getAbsoluteURL(s);
-                        delete s;
-                        if( ! url )
-                            // what happened ?
-                            return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                        return INVOKERESULT_OUT_OF_MEMORY;
-                }
-                else
-                    return INVOKERESULT_NO_SUCH_METHOD;
-
-                char *name = NULL;
-
-                // grab name if available
-                if( argCount > 1 )
-                {
-                    if( NPVARIANT_IS_NULL(args[1]) )
-                    {
-                        // do nothing
-                    }
-                    else if( NPVARIANT_IS_STRING(args[1]) )
-                    {
-                        name = stringValue(NPVARIANT_TO_STRING(args[0]));
-                    }
-                    else
-                        return INVOKERESULT_NO_SUCH_METHOD;
-                }
-
-                int i_options = 0;
-                char** ppsz_options = NULL;
-
-                // grab options if available
-                if( argCount > 2 )
-                {
-                    if( NPVARIANT_IS_NULL(args[2]) )
-                    {
-                        // do nothing
-                    }
-                    else if( NPVARIANT_IS_STRING(args[2]) )
-                    {
-                        parseOptions(NPVARIANT_TO_STRING(args[2]), &i_options, &ppsz_options);
-
-                    }
-                    else if( NPVARIANT_IS_OBJECT(args[2]) )
-                    {
-                        parseOptions(NPVARIANT_TO_OBJECT(args[2]), &i_options, &ppsz_options);
-                    }
-                }
-
-                int item = libvlc_playlist_add_extended(p_plugin->getVLC(),
-                                                        url,
-                                                        name,
-                                                        i_options,
-                                                        const_cast<const char **>(ppsz_options),
-                                                        &ex);
-                delete url;
-                delete name;
-                for( int i=0; i< i_options; ++i )
-                {
-                    if( ppsz_options[i] )
-                        free(ppsz_options[i]);
-                }
-                if( ppsz_options )
-                    free(ppsz_options);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                else
-                {
-                    INT32_TO_NPVARIANT(item, result);
-                    return INVOKERESULT_NO_ERROR;
-                }
-            }
-            case ID_play:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_play(p_plugin->getVLC(), -1, 0, NULL, &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_playItem:
-                if( (argCount == 1) && isNumberValue(args[0]) )
-                {
-                    libvlc_playlist_play(p_plugin->getVLC(), numberValue(args[0]), 0, NULL, &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_togglepause:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_pause(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_stop:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_stop(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_next:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_next(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_prev:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_prev(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_clear:
-                if( argCount == 0 )
-                {
-                    libvlc_playlist_clear(p_plugin->getVLC(), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            case ID_removeitem:
-                if( (argCount == 1) && isNumberValue(args[0]) )
-                {
-                    libvlc_playlist_delete_item(p_plugin->getVLC(), numberValue(args[0]), &ex);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            default:
-                ;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-void LibvlcPlaylistNPObject::parseOptions(const NPString &s, int *i_options, char*** ppsz_options)
-{
-    if( s.utf8length )
-    {
-        char *val = stringValue(s);
-        if( val )
-        {
-            long capacity = 16;
-            char **options = (char **)malloc(capacity*sizeof(char *));
-            if( options )
-            {
-                int nOptions = 0;
-
-                char *end = val + s.utf8length;
-                while( val < end )
-                {
-                    // skip leading blanks
-                    while( (val < end)
-                        && ((*val == ' ' ) || (*val == '\t')) )
-                        ++val;
-
-                    char *start = val;
-                    // skip till we get a blank character
-                    while( (val < end)
-                        && (*val != ' ' )
-                        && (*val != '\t') )
-                    {
-                        char c = *(val++);
-                        if( ('\'' == c) || ('"' == c) )
-                        {
-                            // skip till end of string
-                            while( (val < end) && (*(val++) != c ) );
-                        }
-                    }
-
-                    if( val > start )
-                    {
-                        if( nOptions == capacity )
-                        {
-                            capacity += 16;
-                            char **moreOptions = (char **)realloc(options, capacity*sizeof(char*)); 
-                            if( ! moreOptions )
-                            {
-                                /* failed to allocate more memory */
-                                delete val;
-                                /* return what we got so far */
-                                *i_options = nOptions;
-                                *ppsz_options = options;
-                                break;
-                            }
-                            options = moreOptions;
-                        }
-                        *(val++) = '\0';
-                        options[nOptions++] = strdup(start);
-                    }
-                    else
-                        // must be end of string
-                        break;
-                }
-                *i_options = nOptions;
-                *ppsz_options = options;
-            }
-            delete val;
-        }
-    }
-}
-
-void LibvlcPlaylistNPObject::parseOptions(NPObject *obj, int *i_options, char*** ppsz_options)
-{
-    /* WARNING: Safari does not implement NPN_HasProperty/NPN_HasMethod */
-
-    NPVariant value;
-
-    /* we are expecting to have a Javascript Array object */
-    NPIdentifier propId = NPN_GetStringIdentifier("length");
-    if( NPN_GetProperty(_instance, obj, propId, &value) )
-    {
-        int count = numberValue(value);
-        NPN_ReleaseVariantValue(&value);
-
-        if( count )
-        {
-            long capacity = 16;
-            char **options = (char **)malloc(capacity*sizeof(char *));
-            if( options )
-            {
-                int nOptions = 0;
-
-                while( nOptions < count )
-                {
-                    propId = NPN_GetIntIdentifier(nOptions);
-                    if( ! NPN_GetProperty(_instance, obj, propId, &value) )
-                        /* return what we got so far */
-                        break;
-
-                    if( ! NPVARIANT_IS_STRING(value) )
-                    {
-                        /* return what we got so far */
-                        NPN_ReleaseVariantValue(&value);
-                        break;
-                    }
-
-                    if( nOptions == capacity )
-                    {
-                        capacity += 16;
-                        char **moreOptions = (char **)realloc(options, capacity*sizeof(char*)); 
-                        if( ! moreOptions )
-                        {
-                            /* failed to allocate more memory */
-                            NPN_ReleaseVariantValue(&value);
-                            /* return what we got so far */
-                            *i_options = nOptions;
-                            *ppsz_options = options;
-                            break;
-                        }
-                        options = moreOptions;
-                    }
-
-                    options[nOptions++] = stringValue(value);
-                }
-                *i_options = nOptions;
-                *ppsz_options = options;
-            }
-        }
-    }
-}
-
-/*
-** implementation of libvlc video object
-*/
-
-const NPUTF8 * const LibvlcVideoNPObject::propertyNames[] = 
-{
-    "fullscreen",
-    "height",
-    "width",
-    "aspectRatio"
-};
-
-enum LibvlcVideoNPObjectPropertyIds
-{
-    ID_fullscreen,
-    ID_height,
-    ID_width,
-    ID_aspectratio
-};
-
-const int LibvlcVideoNPObject::propertyCount = sizeof(LibvlcVideoNPObject::propertyNames)/sizeof(NPUTF8 *);
-
-RuntimeNPObject::InvokeResult LibvlcVideoNPObject::getProperty(int index, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
-        if( libvlc_exception_raised(&ex) )
-        {
-            NPN_SetException(this, libvlc_exception_get_message(&ex));
-            libvlc_exception_clear(&ex);
-            return INVOKERESULT_GENERIC_ERROR;
-        }
-
-        switch( index )
-        {
-            case ID_fullscreen:
-            {
-                int val = libvlc_get_fullscreen(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                BOOLEAN_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_height:
-            {
-                int val = libvlc_video_get_height(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                INT32_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_width:
-            {
-                int val = libvlc_video_get_width(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                INT32_TO_NPVARIANT(val, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_aspectratio:
-            {
-                NPUTF8 *psz_aspect = libvlc_video_get_aspect_ratio(p_input, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                if( !psz_aspect )
-                    return INVOKERESULT_GENERIC_ERROR;
-
-                STRINGZ_TO_NPVARIANT(psz_aspect, result);
-                return INVOKERESULT_NO_ERROR;
-            }
-        }
-        libvlc_input_free(p_input);
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-RuntimeNPObject::InvokeResult LibvlcVideoNPObject::setProperty(int index, const NPVariant &value)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
-        if( libvlc_exception_raised(&ex) )
-        {
-            NPN_SetException(this, libvlc_exception_get_message(&ex));
-            libvlc_exception_clear(&ex);
-            return INVOKERESULT_GENERIC_ERROR;
-        }
-
-        switch( index )
-        {
-            case ID_fullscreen:
-            {
-                if( ! NPVARIANT_IS_BOOLEAN(value) )
-                {
-                    libvlc_input_free(p_input);
-                    return INVOKERESULT_INVALID_VALUE;
-                }
-
-                int val = NPVARIANT_TO_BOOLEAN(value);
-                libvlc_set_fullscreen(p_input, val, &ex);
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-            case ID_aspectratio:
-            {
-                char *psz_aspect = NULL;
-
-                if( ! NPVARIANT_IS_STRING(value) )
-                {
-                    libvlc_input_free(p_input);
-                    return INVOKERESULT_INVALID_VALUE;
-                }
-
-                psz_aspect = stringValue(NPVARIANT_TO_STRING(value));
-                if( !psz_aspect )
-                    return INVOKERESULT_GENERIC_ERROR;
-
-                libvlc_video_set_aspect_ratio(p_input, psz_aspect, &ex);
-                if( psz_aspect )
-                    free(psz_aspect );
-
-                libvlc_input_free(p_input);
-                if( libvlc_exception_raised(&ex) )
-                {
-                    NPN_SetException(this, libvlc_exception_get_message(&ex));
-                    libvlc_exception_clear(&ex);
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_ERROR;
-            }
-        }
-        libvlc_input_free(p_input);
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
-const NPUTF8 * const LibvlcVideoNPObject::methodNames[] =
-{
-    "toggleFullscreen",
-};
-
-enum LibvlcVideoNPObjectMethodIds
-{
-    ID_togglefullscreen,
-};
-
-const int LibvlcVideoNPObject::methodCount = sizeof(LibvlcVideoNPObject::methodNames)/sizeof(NPUTF8 *);
-
-RuntimeNPObject::InvokeResult LibvlcVideoNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
-{
-    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
-    if( p_plugin )
-    {
-        libvlc_exception_t ex;
-        libvlc_exception_init(&ex);
-
-        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
-        if( libvlc_exception_raised(&ex) )
-        {
-            NPN_SetException(this, libvlc_exception_get_message(&ex));
-            libvlc_exception_clear(&ex);
-            return INVOKERESULT_GENERIC_ERROR;
-        }
-
-        switch( index )
-        {
-            case ID_togglefullscreen:
-                if( argCount == 0 )
-                {
-                    libvlc_toggle_fullscreen(p_input, &ex);
-                    libvlc_input_free(p_input);
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                        return INVOKERESULT_GENERIC_ERROR;
-                    }
-                    else
-                    {
-                        VOID_TO_NPVARIANT(result);
-                        return INVOKERESULT_NO_ERROR;
-                    }
-                }
-                else
-                {
-                    /* cannot get input, probably not playing */
-                    if( libvlc_exception_raised(&ex) )
-                    {
-                        NPN_SetException(this, libvlc_exception_get_message(&ex));
-                        libvlc_exception_clear(&ex);
-                    }
-                    return INVOKERESULT_GENERIC_ERROR;
-                }
-                return INVOKERESULT_NO_SUCH_METHOD;
-            default:
-                return INVOKERESULT_NO_SUCH_METHOD;
-        }
-    }
-    return INVOKERESULT_GENERIC_ERROR;
-}
-
+/*****************************************************************************
+ * npolibvlc.cpp: official Javascript APIs
+ *****************************************************************************
+ * Copyright (C) 2002-2006 the VideoLAN team
+ *
+ * Authors: Damien Fouilleul <Damien.Fouilleul@laposte.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include "config.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+/* Mozilla stuff */
+#ifdef HAVE_MOZILLA_CONFIG_H
+#   include <mozilla-config.h>
+#endif
+
+#include "npolibvlc.h"
+#include "vlcplugin.h"
+
+//#define DEBUG_METADATA_OBJECT
+
+#define JS_EVAL_BUFFER_SIZE 16384
+namespace VLCUtils 
+{
+
+void GetMetadata(libvlc_instance_t *instance, vlc_meta_t **metadata, libvlc_exception_t* ex)
+{
+  if(!instance)
+    return;
+  
+  libvlc_playlist_get_metadata(instance, metadata, ex);
+ 
+  return;
+}
+
+char *GetMetadataString( libvlc_instance_t *instance, const char *category, const char *key, libvlc_exception_t* ex)
+{
+  char *metadataStr = NULL;
+  vlc_meta_t *metadata = NULL;
+
+  if(!instance ||
+     !category ||
+     !key)
+    return metadataStr;
+
+  GetMetadata(instance, &metadata, ex);
+  if( libvlc_exception_raised(ex) ) 
+    return metadataStr;
+
+  metadataStr = GetMetadataString(metadata, category, key);
+  vlc_meta_Delete(metadata);
+
+  return metadataStr;
+}
+
+char *GetMetadataString(vlc_meta_t *metadata, const char *category, const char *key)
+{
+  char *metadataStr = NULL;
+  
+  if(!metadata ||
+     !category ||
+     !key)
+    return metadataStr;
+
+  for(int i = 0; i < metadata->i_track; i++)
+  {
+    if(!strcmp(category, metadata->track[i]->value[0]))
+    {
+      for( int j = 0; j < metadata->track[i]->track[0]->i_meta; j++ )
+      {
+        if( !strcmp( metadata->track[i]->track[0]->name[j], key ) )
+        {
+#if defined(DEBUG_METADATA_OBJECT)
+          printf("\nGetMetadataString found %s:%s => %s\n", category, key, metadata->track[i]->track[0]->value[j]);
+#endif
+          if( metadata->track[i]->track[0]->value[j] ) 
+            metadataStr = strdup( metadata->track[i]->track[0]->value[j] );
+            
+          break;
+        }
+      }
+    }
+  }
+  
+  return metadataStr;
+}
+
+int GetMetadataCategoryCount(libvlc_instance_t *instance,  libvlc_exception_t* ex)
+{
+  int count = 0;
+  vlc_meta_t *metadata = NULL;
+
+  if(!instance)
+    return count;
+
+  GetMetadata(instance, &metadata, ex);
+  if( libvlc_exception_raised(ex) ) 
+    return count;
+
+  count = metadata->i_track;
+  
+  vlc_meta_Delete(metadata);
+  
+  return count;
+}
+
+int GetMetadataCategoryCount(vlc_meta_t *metadata)
+{
+  return metadata->i_track;
+}
+
+char *GetMetadataCategoryString(libvlc_instance_t *instance, int index, libvlc_exception_t* ex)
+{
+  char *category = NULL;
+  vlc_meta_t *metadata = NULL;
+
+  if(!instance ||
+     index < 0)
+    return category;
+
+  GetMetadata(instance, &metadata, ex);
+  if( libvlc_exception_raised(ex) ) 
+    return category;
+
+  category = GetMetadataCategoryString(metadata, index);
+  
+  vlc_meta_Delete(metadata);
+  
+  return category;
+}
+
+char *GetMetadataCategoryString(vlc_meta_t *metadata, int index)
+{
+  if(!metadata || 
+     index >= metadata->i_track) 
+    return NULL;
+    
+  return strdup(metadata->track[index]->value[0]);
+}
+
+int GetMetadataKeyCount(libvlc_instance_t * instance, const char *category, libvlc_exception_t* ex)
+{
+  int count = 0;
+  
+  if(!instance ||
+     !category)
+    return count;
+    
+  vlc_meta_t *metadata = NULL;
+  GetMetadata(instance, &metadata, ex);
+  if( libvlc_exception_raised(ex) ) 
+    return count;
+
+  count = GetMetadataKeyCount(metadata, category);
+
+  vlc_meta_Delete(metadata);
+    
+  return count;
+}
+
+int GetMetadataKeyCount(vlc_meta_t *metadata, const char *category)
+{
+  int count = 0;
+  
+  if(!metadata ||
+     !category)
+    return count;
+    
+  for(int i = 0; i < metadata->i_track; i++)
+  {
+    if(!strcmp(category, metadata->track[i]->value[0]))
+    {
+      count = metadata->track[i]->track[0]->i_meta;
+      break;
+    }
+  }
+
+  return count;
+}
+
+char *GetMetadataKeyString(libvlc_instance_t *instance, const char *category, int index, libvlc_exception_t* ex)
+{
+  char *key = NULL;
+  
+  if(!instance ||
+     !category ||
+     index < 0)
+    return key;
+    
+  vlc_meta_t *metadata = NULL;
+  GetMetadata(instance, &metadata, ex);
+  if( libvlc_exception_raised(ex) ) 
+    return key;
+
+  key = GetMetadataKeyString(metadata, category, index);
+    
+  return key;
+}
+
+char *GetMetadataKeyString(vlc_meta_t *metadata, const char *category, int index)
+{
+  char *key = NULL;
+  
+  if(!metadata ||
+     !category ||
+     index < 0)
+    return key;
+    
+  for(int i = 0; i < metadata->i_track; i++)
+  {
+    if(!strcmp(category, metadata->track[i]->value[0]) &&
+       index < metadata->track[i]->track[0]->i_meta)
+    {
+      key = strdup(metadata->track[i]->track[0]->name[index]);
+      break;
+    }
+  }
+  
+  return key;
+}
+
+} //namespace VLCUtils
+
+/*
+** implementation of libvlc root object
+*/
+
+LibvlcRootNPObject::LibvlcRootNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass)
+{
+    audioObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcAudioNPObject>::getClass());
+    inputObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcInputNPObject>::getClass());
+    logObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcLogNPObject>::getClass());
+    playlistObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcPlaylistNPObject>::getClass());
+    videoObj = NPN_CreateObject(instance,RuntimeNPClass<LibvlcVideoNPObject>::getClass());
+    metadataObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcMetadataNPObject>::getClass());
+}
+
+LibvlcRootNPObject::~LibvlcRootNPObject()
+{
+}
+
+void LibvlcRootNPObject::ReleaseChildren()
+{
+    if (audioObj) {
+	  RuntimeNPObject* object = (RuntimeNPObject*)audioObj;
+      object->ReleaseChildren();
+      NPN_ReleaseObject(object);
+    }
+    if (inputObj) {
+	  RuntimeNPObject* object = (RuntimeNPObject*)inputObj;
+      object->ReleaseChildren();
+      NPN_ReleaseObject(object);
+    }
+    if (logObj) {
+	  RuntimeNPObject* object = (RuntimeNPObject*)logObj;
+      object->ReleaseChildren();
+      NPN_ReleaseObject(object);
+    }
+    if (playlistObj) {
+	  RuntimeNPObject* object = (RuntimeNPObject*)playlistObj;
+      object->ReleaseChildren();
+      NPN_ReleaseObject(object);
+    }
+    if (videoObj) {
+	  RuntimeNPObject* object = (RuntimeNPObject*)videoObj;
+      object->ReleaseChildren();
+      NPN_ReleaseObject(object);
+    }
+    if (metadataObj) {
+	  RuntimeNPObject* object = (RuntimeNPObject*)metadataObj;
+      object->ReleaseChildren();
+      NPN_ReleaseObject(object);
+    }
+}
+
+const NPUTF8 * const LibvlcRootNPObject::propertyNames[] = 
+{
+    "audio",
+    "input",
+    "log",
+    "playlist",
+    "video",
+    "metadata",
+    "VersionInfo",
+};
+
+const int LibvlcRootNPObject::propertyCount = sizeof(LibvlcRootNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcRootNPObjectPropertyIds
+{
+    ID_audio = 0,
+    ID_input,
+    ID_log,
+    ID_playlist,
+    ID_video,
+    ID_metadata,
+    ID_VersionInfo,
+};
+
+RuntimeNPObject::InvokeResult LibvlcRootNPObject::getProperty(int index, NPVariant &result)
+{
+    switch( index )
+    {
+        case ID_audio:
+            OBJECT_TO_NPVARIANT(NPN_RetainObject(audioObj), result);
+            return INVOKERESULT_NO_ERROR;
+        case ID_input:
+            OBJECT_TO_NPVARIANT(NPN_RetainObject(inputObj), result);
+            return INVOKERESULT_NO_ERROR;
+        case ID_log:
+            OBJECT_TO_NPVARIANT(NPN_RetainObject(logObj), result);
+            return INVOKERESULT_NO_ERROR;
+        case ID_playlist:
+            OBJECT_TO_NPVARIANT(NPN_RetainObject(playlistObj), result);
+            return INVOKERESULT_NO_ERROR;
+        case ID_video:
+            OBJECT_TO_NPVARIANT(NPN_RetainObject(videoObj), result);
+            return INVOKERESULT_NO_ERROR;
+        case ID_metadata:
+            OBJECT_TO_NPVARIANT(NPN_RetainObject(metadataObj), result);
+            return INVOKERESULT_NO_ERROR;
+        case ID_VersionInfo:
+            NPUTF8 *versionStr = NULL;
+
+            versionStr = strdup( VLC_Version() );
+            if (!versionStr)
+                return INVOKERESULT_GENERIC_ERROR;
+
+            STRINGZ_TO_NPVARIANT(versionStr, result);
+            return INVOKERESULT_NO_ERROR;
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcRootNPObject::methodNames[] =
+{
+    "versionInfo",
+};
+
+const int LibvlcRootNPObject::methodCount = sizeof(LibvlcRootNPObject::methodNames)/sizeof(NPUTF8 *);
+
+enum LibvlcRootNPObjectMethodIds
+{
+    ID_version,
+};
+
+RuntimeNPObject::InvokeResult LibvlcRootNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_version:
+                if( argCount == 0 )
+                {
+                    NPUTF8 *versionStr = NULL;
+
+                    versionStr = strdup( VLC_Version() );
+                    if (!versionStr)
+                        return INVOKERESULT_GENERIC_ERROR;
+
+                    STRINGZ_TO_NPVARIANT(versionStr, result);
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                return INVOKERESULT_NO_SUCH_METHOD;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+/*
+** implementation of libvlc audio object
+*/
+
+const NPUTF8 * const LibvlcAudioNPObject::propertyNames[] = 
+{
+    "mute",
+    "volume",
+};
+
+const int LibvlcAudioNPObject::propertyCount = sizeof(LibvlcAudioNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcAudioNPObjectPropertyIds
+{
+    ID_mute,
+    ID_volume,
+};
+
+RuntimeNPObject::InvokeResult LibvlcAudioNPObject::getProperty(int index, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_mute:
+            {
+                vlc_bool_t muted = libvlc_audio_get_mute(p_plugin->getVLC(), &ex);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                BOOLEAN_TO_NPVARIANT(muted, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_volume:
+            {
+                int volume = libvlc_audio_get_volume(p_plugin->getVLC(), &ex);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                INT32_TO_NPVARIANT(volume, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+RuntimeNPObject::InvokeResult LibvlcAudioNPObject::setProperty(int index, const NPVariant &value)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_mute:
+                if( NPVARIANT_IS_BOOLEAN(value) )
+                {
+                    libvlc_audio_set_mute(p_plugin->getVLC(),
+                                          NPVARIANT_TO_BOOLEAN(value), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_INVALID_VALUE;
+            case ID_volume:
+                if( isNumberValue(value) )
+                {
+                    libvlc_audio_set_volume(p_plugin->getVLC(),
+                                            numberValue(value), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_INVALID_VALUE;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcAudioNPObject::methodNames[] =
+{
+    "toggleMute",
+};
+
+const int LibvlcAudioNPObject::methodCount = sizeof(LibvlcAudioNPObject::methodNames)/sizeof(NPUTF8 *);
+
+enum LibvlcAudioNPObjectMethodIds
+{
+    ID_togglemute,
+};
+
+RuntimeNPObject::InvokeResult LibvlcAudioNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_togglemute:
+                if( argCount == 0 )
+                {
+                    libvlc_audio_toggle_mute(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                return INVOKERESULT_NO_SUCH_METHOD;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+/*
+** implementation of libvlc input object
+*/
+
+const NPUTF8 * const LibvlcInputNPObject::propertyNames[] = 
+{
+    "length",
+    "position",
+    "time",
+    "state",
+    "rate",
+    "fps",
+    "hasVout",
+};
+
+const int LibvlcInputNPObject::propertyCount = sizeof(LibvlcInputNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcInputNPObjectPropertyIds
+{
+    ID_length,
+    ID_position,
+    ID_time,
+    ID_state,
+    ID_rate,
+    ID_fps,
+    ID_hasvout,
+};
+
+RuntimeNPObject::InvokeResult LibvlcInputNPObject::getProperty(int index, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
+        if( libvlc_exception_raised(&ex) )
+        {
+            if( index != ID_state )
+            {
+                NPN_SetException(this, libvlc_exception_get_message(&ex));
+                libvlc_exception_clear(&ex);
+                return INVOKERESULT_GENERIC_ERROR;
+            }
+            else
+            {
+                /* for input state, return CLOSED rather than an exception */
+                INT32_TO_NPVARIANT(0, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+
+        switch( index )
+        {
+            case ID_length:
+            {
+                double val = (double)libvlc_input_get_length(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                DOUBLE_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_position:
+            {
+                double val = libvlc_input_get_position(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                DOUBLE_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_time:
+            {
+                double val = (double)libvlc_input_get_time(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                DOUBLE_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_state:
+            {
+                int val = libvlc_input_get_state(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                INT32_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_rate:
+            {
+                float val = libvlc_input_get_rate(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                DOUBLE_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_fps:
+            {
+                double val = libvlc_input_get_fps(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                DOUBLE_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_hasvout:
+            {
+                vlc_bool_t val = libvlc_input_has_vout(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    libvlc_exception_clear(&ex);
+                }
+                BOOLEAN_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+        libvlc_input_free(p_input);
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+RuntimeNPObject::InvokeResult LibvlcInputNPObject::setProperty(int index, const NPVariant &value)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
+        if( libvlc_exception_raised(&ex) )
+        {
+            NPN_SetException(this, libvlc_exception_get_message(&ex));
+            libvlc_exception_clear(&ex);
+            return INVOKERESULT_GENERIC_ERROR;
+        }
+
+        switch( index )
+        {
+            case ID_position:
+            {
+                if( ! NPVARIANT_IS_DOUBLE(value) )
+                {
+                    libvlc_input_free(p_input);
+                    return INVOKERESULT_INVALID_VALUE;
+                }
+
+                float val = (float)NPVARIANT_TO_DOUBLE(value);
+                libvlc_input_set_position(p_input, val, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_time:
+            {
+                vlc_int64_t val;
+                if( NPVARIANT_IS_INT32(value) )
+                    val = (vlc_int64_t)NPVARIANT_TO_INT32(value);
+                else if( NPVARIANT_IS_DOUBLE(value) )
+                    val = (vlc_int64_t)NPVARIANT_TO_DOUBLE(value);
+                else
+                {
+                    libvlc_input_free(p_input);
+                    return INVOKERESULT_INVALID_VALUE;
+                }
+
+                libvlc_input_set_time(p_input, val, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_rate:
+            {
+                float val;
+                if( NPVARIANT_IS_INT32(value) )
+                    val = (float)NPVARIANT_TO_INT32(value);
+                else if( NPVARIANT_IS_DOUBLE(value) )
+                    val = (float)NPVARIANT_TO_DOUBLE(value);
+                else
+                {
+                    libvlc_input_free(p_input);
+                    return INVOKERESULT_INVALID_VALUE;
+                }
+
+                libvlc_input_set_rate(p_input, val, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+        libvlc_input_free(p_input);
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcInputNPObject::methodNames[] =
+{
+    /* no methods */
+};
+
+const int LibvlcInputNPObject::methodCount = sizeof(LibvlcInputNPObject::methodNames)/sizeof(NPUTF8 *);
+
+/*
+** implementation of libvlc message object
+*/
+
+const NPUTF8 * const LibvlcMessageNPObject::propertyNames[] = 
+{
+    "severity",
+    "type",
+    "name",
+    "header",
+    "message",
+};
+
+const int LibvlcMessageNPObject::propertyCount = sizeof(LibvlcMessageNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMessageNPObjectPropertyIds
+{
+    ID_severity,
+    ID_type,
+    ID_name,
+    ID_header,
+    ID_message,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMessageNPObject::getProperty(int index, NPVariant &result)
+{
+    switch( index )
+    {
+        case ID_severity:
+        {
+            INT32_TO_NPVARIANT(_msg.i_severity, result);
+            return INVOKERESULT_NO_ERROR;
+        }
+        case ID_type:
+        {
+            if( _msg.psz_type )
+            {
+                int len = strlen(_msg.psz_type);
+                NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
+                if( retval )
+                {
+                    memcpy(retval, _msg.psz_type, len);
+                    STRINGN_TO_NPVARIANT(retval, len, result);
+                }
+            }
+            else
+            {
+                NULL_TO_NPVARIANT(result);
+            }
+            return INVOKERESULT_NO_ERROR;
+        }
+        case ID_name:
+        {
+            if( _msg.psz_name )
+            {
+                int len = strlen(_msg.psz_name);
+                NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
+                if( retval )
+                {
+                    memcpy(retval, _msg.psz_name, len);
+                    STRINGN_TO_NPVARIANT(retval, len, result);
+                }
+            }
+            else
+            {
+                NULL_TO_NPVARIANT(result);
+            }
+            return INVOKERESULT_NO_ERROR;
+        }
+        case ID_header:
+        {
+            if( _msg.psz_header )
+            {
+                int len = strlen(_msg.psz_header);
+                NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
+                if( retval )
+                {
+                    memcpy(retval, _msg.psz_header, len);
+                    STRINGN_TO_NPVARIANT(retval, len, result);
+                }
+            }
+            else
+            {
+                NULL_TO_NPVARIANT(result);
+            }
+            return INVOKERESULT_NO_ERROR;
+        }
+        case ID_message:
+        {
+            if( _msg.psz_message )
+            {
+                int len = strlen(_msg.psz_message);
+                NPUTF8* retval = (NPUTF8*)NPN_MemAlloc(len);
+                if( retval )
+                {
+                    memcpy(retval, _msg.psz_message, len);
+                    STRINGN_TO_NPVARIANT(retval, len, result);
+                }
+            }
+            else
+            {
+                NULL_TO_NPVARIANT(result);
+            }
+            return INVOKERESULT_NO_ERROR;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcMessageNPObject::methodNames[] =
+{
+    /* no methods */
+};
+
+const int LibvlcMessageNPObject::methodCount = sizeof(LibvlcMessageNPObject::methodNames)/sizeof(NPUTF8 *);
+
+/*
+** implementation of libvlc message iterator object
+*/
+
+void LibvlcMessageIteratorNPObject::setLog(LibvlcLogNPObject* p_vlclog)
+{
+    _p_vlclog = p_vlclog;
+    if( p_vlclog->_p_log )
+    {
+        _p_iter = libvlc_log_get_iterator(p_vlclog->_p_log, NULL);
+    }
+    else
+        _p_iter = NULL;
+};
+
+const NPUTF8 * const LibvlcMessageIteratorNPObject::propertyNames[] = 
+{
+    "hasNext",
+};
+
+const int LibvlcMessageIteratorNPObject::propertyCount = sizeof(LibvlcMessageIteratorNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMessageIteratorNPObjectPropertyIds
+{
+    ID_hasNext,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMessageIteratorNPObject::getProperty(int index, NPVariant &result)
+{
+    switch( index )
+    {
+        case ID_hasNext:
+        {
+            if( _p_iter &&  _p_vlclog->_p_log )
+            {
+                libvlc_exception_t ex;
+                libvlc_exception_init(&ex);
+
+                BOOLEAN_TO_NPVARIANT(libvlc_log_iterator_has_next(_p_iter, &ex), result);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+            }
+            else
+            {
+                BOOLEAN_TO_NPVARIANT(0, result);
+            }
+            return INVOKERESULT_NO_ERROR;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcMessageIteratorNPObject::methodNames[] =
+{
+    "next",
+};
+
+const int LibvlcMessageIteratorNPObject::methodCount = sizeof(LibvlcMessageIteratorNPObject::methodNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMessageIteratorNPObjectMethodIds
+{
+    ID_messageiterator_next,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMessageIteratorNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    if( _p_iter &&  _p_vlclog->_p_log )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_messageiterator_next:
+                if( argCount == 0 )
+                {
+                    struct libvlc_log_message_t buffer;
+
+                    buffer.sizeof_msg = sizeof(buffer);
+
+                    libvlc_log_iterator_next(_p_iter, &buffer, &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        LibvlcMessageNPObject* message =
+                            static_cast<LibvlcMessageNPObject*>(NPN_CreateObject(_instance, RuntimeNPClass<LibvlcMessageNPObject>::getClass()));
+                        if( message )
+                        {
+                            message->setMessage(buffer);
+                            OBJECT_TO_NPVARIANT(message, result);
+                            return INVOKERESULT_NO_ERROR;
+                        }
+                        return INVOKERESULT_OUT_OF_MEMORY;
+                    }
+                }
+            default:
+                return INVOKERESULT_NO_SUCH_METHOD;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+ 
+/*
+** implementation of libvlc message object
+*/
+
+const NPUTF8 * const LibvlcMessagesNPObject::propertyNames[] = 
+{
+    "count",
+};
+
+const int LibvlcMessagesNPObject::propertyCount = sizeof(LibvlcMessagesNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMessagesNPObjectPropertyIds
+{
+    ID_count,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMessagesNPObject::getProperty(int index, NPVariant &result)
+{
+    switch( index )
+    {
+        case ID_count:
+        {
+            libvlc_log_t *p_log = _p_vlclog->_p_log;
+            if( p_log )
+            {
+                libvlc_exception_t ex;
+                libvlc_exception_init(&ex);
+
+                INT32_TO_NPVARIANT(libvlc_log_count(p_log, &ex), result);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+            }
+            else
+            {
+                INT32_TO_NPVARIANT(0, result);
+            }
+            return INVOKERESULT_NO_ERROR;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcMessagesNPObject::methodNames[] =
+{
+    "clear",
+    "iterator",
+};
+
+const int LibvlcMessagesNPObject::methodCount = sizeof(LibvlcMessagesNPObject::methodNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMessagesNPObjectMethodIds
+{
+    ID_messages_clear,
+    ID_iterator,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMessagesNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    libvlc_exception_t ex;
+    libvlc_exception_init(&ex);
+
+    switch( index )
+    {
+        case ID_messages_clear:
+            if( argCount == 0 )
+            {
+                libvlc_log_t *p_log = _p_vlclog->_p_log;
+                if( p_log )
+                {
+                    libvlc_log_clear(p_log, &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            return INVOKERESULT_NO_SUCH_METHOD;
+
+        case ID_iterator:
+            if( argCount == 0 )
+            {
+                LibvlcMessageIteratorNPObject* iter =
+                    static_cast<LibvlcMessageIteratorNPObject*>(NPN_CreateObject(_instance, RuntimeNPClass<LibvlcMessageIteratorNPObject>::getClass()));
+                if( iter )
+                {
+                    iter->setLog(_p_vlclog);
+                    OBJECT_TO_NPVARIANT(iter, result);
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_OUT_OF_MEMORY;
+            }
+            return INVOKERESULT_NO_SUCH_METHOD;
+
+        default:
+            return INVOKERESULT_NO_SUCH_METHOD;
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+ 
+/*
+** implementation of libvlc message object
+*/
+
+const NPUTF8 * const LibvlcLogNPObject::propertyNames[] = 
+{
+    "messages",
+    "verbosity",
+};
+
+const int LibvlcLogNPObject::propertyCount = sizeof(LibvlcLogNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcLogNPObjectPropertyIds
+{
+    ID_messages,
+    ID_verbosity,
+};
+
+RuntimeNPObject::InvokeResult LibvlcLogNPObject::getProperty(int index, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_messages:
+            {
+                OBJECT_TO_NPVARIANT(NPN_RetainObject(_p_vlcmessages), result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_verbosity:
+            {
+                if( _p_log )
+                {
+                    INT32_TO_NPVARIANT(libvlc_get_log_verbosity(p_plugin->getVLC(),
+                                                                    &ex), result);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                }
+                else
+                {
+                    /* log is not enabled, return -1 */
+                    DOUBLE_TO_NPVARIANT(-1.0, result);
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+RuntimeNPObject::InvokeResult LibvlcLogNPObject::setProperty(int index, const NPVariant &value)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_verbosity:
+                if( isNumberValue(value) )
+                {
+                    libvlc_instance_t* p_libvlc = p_plugin->getVLC();
+                    int verbosity = numberValue(value);
+                    if( verbosity >= 0 )
+                    {
+                        if( ! _p_log )
+                        {
+                            _p_log = libvlc_log_open(p_libvlc, &ex);
+                            if( libvlc_exception_raised(&ex) )
+                            {
+                                NPN_SetException(this, libvlc_exception_get_message(&ex));
+                                libvlc_exception_clear(&ex);
+                                return INVOKERESULT_GENERIC_ERROR;
+                            }
+                        }
+                        libvlc_set_log_verbosity(p_libvlc, (unsigned)verbosity, &ex);
+                        if( libvlc_exception_raised(&ex) )
+                        {
+                            NPN_SetException(this, libvlc_exception_get_message(&ex));
+                            libvlc_exception_clear(&ex);
+                            return INVOKERESULT_GENERIC_ERROR;
+                        }
+                    }
+                    else if( _p_log )
+                    {
+                        /* close log  when verbosity is set to -1 */
+                        libvlc_log_close(_p_log, &ex);
+                        _p_log = NULL;
+                        if( libvlc_exception_raised(&ex) )
+                        {
+                            NPN_SetException(this, libvlc_exception_get_message(&ex));
+                            libvlc_exception_clear(&ex);
+                            return INVOKERESULT_GENERIC_ERROR;
+                        }
+                    }
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_INVALID_VALUE;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcLogNPObject::methodNames[] =
+{
+    /* no methods */
+};
+
+const int LibvlcLogNPObject::methodCount = sizeof(LibvlcLogNPObject::methodNames)/sizeof(NPUTF8 *);
+
+/*
+** implementation of libvlc playlist object
+*/
+
+
+const NPUTF8 * const LibvlcPlaylistNPObject::propertyNames[] = 
+{
+    "itemCount",
+    "isPlaying",
+};
+
+const int LibvlcPlaylistNPObject::propertyCount = sizeof(LibvlcPlaylistNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcPlaylistNPObjectPropertyIds
+{
+    ID_itemcount,
+    ID_isplaying,
+};
+
+RuntimeNPObject::InvokeResult LibvlcPlaylistNPObject::getProperty(int index, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_itemcount:
+            {
+                int val = libvlc_playlist_items_count(p_plugin->getVLC(), &ex);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                INT32_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_isplaying:
+            {
+                int val = libvlc_playlist_isplaying(p_plugin->getVLC(), &ex);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                BOOLEAN_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcPlaylistNPObject::methodNames[] =
+{
+    "add",
+    "play",
+    "playItem",
+    "togglePause",
+    "stop",
+    "next",
+    "prev",
+    "clear",
+    "removeItem"
+};
+
+const int LibvlcPlaylistNPObject::methodCount = sizeof(LibvlcPlaylistNPObject::methodNames)/sizeof(NPUTF8 *);
+
+enum LibvlcPlaylistNPObjectMethodIds
+{
+    ID_add,
+    ID_play,
+    ID_playItem,
+    ID_togglepause,
+    ID_stop,
+    ID_next,
+    ID_prev,
+    ID_clear,
+    ID_removeitem
+};
+
+RuntimeNPObject::InvokeResult LibvlcPlaylistNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_add:
+            {
+                if( (argCount < 1) || (argCount > 3) )
+                    return INVOKERESULT_NO_SUCH_METHOD;
+
+                char *url = NULL;
+
+                // grab URL
+                if( NPVARIANT_IS_STRING(args[0]) )
+                {
+                    char *s = stringValue(NPVARIANT_TO_STRING(args[0]));
+                    if( s )
+                    {
+                        url = p_plugin->getAbsoluteURL(s);
+                        delete s;
+                        if( ! url )
+                            // what happened ?
+                            return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                        return INVOKERESULT_OUT_OF_MEMORY;
+                }
+                else
+                    return INVOKERESULT_NO_SUCH_METHOD;
+
+                char *name = NULL;
+
+                // grab name if available
+                if( argCount > 1 )
+                {
+                    if( NPVARIANT_IS_NULL(args[1]) )
+                    {
+                        // do nothing
+                    }
+                    else if( NPVARIANT_IS_STRING(args[1]) )
+                    {
+                        name = stringValue(NPVARIANT_TO_STRING(args[0]));
+                    }
+                    else
+                        return INVOKERESULT_NO_SUCH_METHOD;
+                }
+
+                int i_options = 0;
+                char** ppsz_options = NULL;
+
+                // grab options if available
+                if( argCount > 2 )
+                {
+                    if( NPVARIANT_IS_NULL(args[2]) )
+                    {
+                        // do nothing
+                    }
+                    else if( NPVARIANT_IS_STRING(args[2]) )
+                    {
+                        parseOptions(NPVARIANT_TO_STRING(args[2]), &i_options, &ppsz_options);
+
+                    }
+                    else if( NPVARIANT_IS_OBJECT(args[2]) )
+                    {
+                        parseOptions(NPVARIANT_TO_OBJECT(args[2]), &i_options, &ppsz_options);
+                    }
+                }
+
+                int item = libvlc_playlist_add_extended(p_plugin->getVLC(),
+                                                        url,
+                                                        name,
+                                                        i_options,
+                                                        const_cast<const char **>(ppsz_options),
+                                                        &ex);
+                delete url;
+                delete name;
+                for( int i=0; i< i_options; ++i )
+                {
+                    if( ppsz_options[i] )
+                        free(ppsz_options[i]);
+                }
+                if( ppsz_options )
+                    free(ppsz_options);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                else
+                {
+                    INT32_TO_NPVARIANT(item, result);
+                    return INVOKERESULT_NO_ERROR;
+                }
+            }
+            case ID_play:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_play(p_plugin->getVLC(), -1, 0, NULL, &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_playItem:
+                if( (argCount == 1) && isNumberValue(args[0]) )
+                {
+                    libvlc_playlist_play(p_plugin->getVLC(), numberValue(args[0]), 0, NULL, &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_togglepause:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_pause(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_stop:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_stop(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_next:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_next(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_prev:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_prev(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_clear:
+                if( argCount == 0 )
+                {
+                    libvlc_playlist_clear(p_plugin->getVLC(), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            case ID_removeitem:
+                if( (argCount == 1) && isNumberValue(args[0]) )
+                {
+                    libvlc_playlist_delete_item(p_plugin->getVLC(), numberValue(args[0]), &ex);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                return INVOKERESULT_NO_SUCH_METHOD;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+void LibvlcPlaylistNPObject::parseOptions(const NPString &s, int *i_options, char*** ppsz_options)
+{
+    if( s.utf8length )
+    {
+        char *val = stringValue(s);
+        if( val )
+        {
+            long capacity = 16;
+            char **options = (char **)malloc(capacity*sizeof(char *));
+            if( options )
+            {
+                int nOptions = 0;
+
+                char *end = val + s.utf8length;
+                while( val < end )
+                {
+                    // skip leading blanks
+                    while( (val < end)
+                        && ((*val == ' ' ) || (*val == '\t')) )
+                        ++val;
+
+                    char *start = val;
+                    // skip till we get a blank character
+                    while( (val < end)
+                        && (*val != ' ' )
+                        && (*val != '\t') )
+                    {
+                        char c = *(val++);
+                        if( ('\'' == c) || ('"' == c) )
+                        {
+                            // skip till end of string
+                            while( (val < end) && (*(val++) != c ) );
+                        }
+                    }
+
+                    if( val > start )
+                    {
+                        if( nOptions == capacity )
+                        {
+                            capacity += 16;
+                            char **moreOptions = (char **)realloc(options, capacity*sizeof(char*)); 
+                            if( ! moreOptions )
+                            {
+                                /* failed to allocate more memory */
+                                delete val;
+                                /* return what we got so far */
+                                *i_options = nOptions;
+                                *ppsz_options = options;
+                                break;
+                            }
+                            options = moreOptions;
+                        }
+                        *(val++) = '\0';
+                        options[nOptions++] = strdup(start);
+                    }
+                    else
+                        // must be end of string
+                        break;
+                }
+                *i_options = nOptions;
+                *ppsz_options = options;
+            }
+            delete val;
+        }
+    }
+}
+
+void LibvlcPlaylistNPObject::parseOptions(NPObject *obj, int *i_options, char*** ppsz_options)
+{
+    /* WARNING: Safari does not implement NPN_HasProperty/NPN_HasMethod */
+
+    NPVariant value;
+
+    /* we are expecting to have a Javascript Array object */
+    NPIdentifier propId = NPN_GetStringIdentifier("length");
+    if( NPN_GetProperty(_instance, obj, propId, &value) )
+    {
+        int count = numberValue(value);
+        NPN_ReleaseVariantValue(&value);
+
+        if( count )
+        {
+            long capacity = 16;
+            char **options = (char **)malloc(capacity*sizeof(char *));
+            if( options )
+            {
+                int nOptions = 0;
+
+                while( nOptions < count )
+                {
+                    propId = NPN_GetIntIdentifier(nOptions);
+                    if( ! NPN_GetProperty(_instance, obj, propId, &value) )
+                        /* return what we got so far */
+                        break;
+
+                    if( ! NPVARIANT_IS_STRING(value) )
+                    {
+                        /* return what we got so far */
+                        NPN_ReleaseVariantValue(&value);
+                        break;
+                    }
+
+                    if( nOptions == capacity )
+                    {
+                        capacity += 16;
+                        char **moreOptions = (char **)realloc(options, capacity*sizeof(char*)); 
+                        if( ! moreOptions )
+                        {
+                            /* failed to allocate more memory */
+                            NPN_ReleaseVariantValue(&value);
+                            /* return what we got so far */
+                            *i_options = nOptions;
+                            *ppsz_options = options;
+                            break;
+                        }
+                        options = moreOptions;
+                    }
+
+                    options[nOptions++] = stringValue(value);
+                }
+                *i_options = nOptions;
+                *ppsz_options = options;
+            }
+        }
+    }
+}
+
+/*
+** implementation of libvlc video object
+*/
+
+const NPUTF8 * const LibvlcVideoNPObject::propertyNames[] = 
+{
+    "fullscreen",
+    "height",
+    "width",
+    "aspectRatio"
+};
+
+enum LibvlcVideoNPObjectPropertyIds
+{
+    ID_fullscreen,
+    ID_height,
+    ID_width,
+    ID_aspectratio
+};
+
+const int LibvlcVideoNPObject::propertyCount = sizeof(LibvlcVideoNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+RuntimeNPObject::InvokeResult LibvlcVideoNPObject::getProperty(int index, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
+        if( libvlc_exception_raised(&ex) )
+        {
+            NPN_SetException(this, libvlc_exception_get_message(&ex));
+            libvlc_exception_clear(&ex);
+            return INVOKERESULT_GENERIC_ERROR;
+        }
+
+        switch( index )
+        {
+            case ID_fullscreen:
+            {
+                int val = libvlc_get_fullscreen(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                BOOLEAN_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_height:
+            {
+                int val = libvlc_video_get_height(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                INT32_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_width:
+            {
+                int val = libvlc_video_get_width(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                INT32_TO_NPVARIANT(val, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_aspectratio:
+            {
+                NPUTF8 *psz_aspect = libvlc_video_get_aspect_ratio(p_input, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                if( !psz_aspect )
+                    return INVOKERESULT_GENERIC_ERROR;
+
+                // XXXMATT does this make a difference?  
+                copyStringToNPVariant(psz_aspect, result);
+                delete psz_aspect;
+                //STRINGZ_TO_NPVARIANT(psz_aspect, result);
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+        libvlc_input_free(p_input);
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+RuntimeNPObject::InvokeResult LibvlcVideoNPObject::setProperty(int index, const NPVariant &value)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
+        if( libvlc_exception_raised(&ex) )
+        {
+            NPN_SetException(this, libvlc_exception_get_message(&ex));
+            libvlc_exception_clear(&ex);
+            return INVOKERESULT_GENERIC_ERROR;
+        }
+
+        switch( index )
+        {
+            case ID_fullscreen:
+            {
+                if( ! NPVARIANT_IS_BOOLEAN(value) )
+                {
+                    libvlc_input_free(p_input);
+                    return INVOKERESULT_INVALID_VALUE;
+                }
+
+                int val = NPVARIANT_TO_BOOLEAN(value);
+                libvlc_set_fullscreen(p_input, val, &ex);
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+            case ID_aspectratio:
+            {
+                char *psz_aspect = NULL;
+
+                if( ! NPVARIANT_IS_STRING(value) )
+                {
+                    libvlc_input_free(p_input);
+                    return INVOKERESULT_INVALID_VALUE;
+                }
+
+                psz_aspect = stringValue(NPVARIANT_TO_STRING(value));
+                if( !psz_aspect )
+                    return INVOKERESULT_GENERIC_ERROR;
+
+                libvlc_video_set_aspect_ratio(p_input, psz_aspect, &ex);
+                if( psz_aspect )
+                    free(psz_aspect );
+
+                libvlc_input_free(p_input);
+                if( libvlc_exception_raised(&ex) )
+                {
+                    NPN_SetException(this, libvlc_exception_get_message(&ex));
+                    libvlc_exception_clear(&ex);
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+        libvlc_input_free(p_input);
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+const NPUTF8 * const LibvlcVideoNPObject::methodNames[] =
+{
+    "toggleFullscreen",
+};
+
+enum LibvlcVideoNPObjectMethodIds
+{
+    ID_togglefullscreen,
+};
+
+const int LibvlcVideoNPObject::methodCount = sizeof(LibvlcVideoNPObject::methodNames)/sizeof(NPUTF8 *);
+
+RuntimeNPObject::InvokeResult LibvlcVideoNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        libvlc_input_t *p_input = libvlc_playlist_get_input(p_plugin->getVLC(), &ex);
+        if( libvlc_exception_raised(&ex) )
+        {
+            NPN_SetException(this, libvlc_exception_get_message(&ex));
+            libvlc_exception_clear(&ex);
+            return INVOKERESULT_GENERIC_ERROR;
+        }
+
+        switch( index )
+        {
+            case ID_togglefullscreen:
+                if( argCount == 0 )
+                {
+                    libvlc_toggle_fullscreen(p_input, &ex);
+                    libvlc_input_free(p_input);
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                        return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    else
+                    {
+                        VOID_TO_NPVARIANT(result);
+                        return INVOKERESULT_NO_ERROR;
+                    }
+                }
+                else
+                {
+                    /* cannot get input, probably not playing */
+                    if( libvlc_exception_raised(&ex) )
+                    {
+                        NPN_SetException(this, libvlc_exception_get_message(&ex));
+                        libvlc_exception_clear(&ex);
+                    }
+                    return INVOKERESULT_GENERIC_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                return INVOKERESULT_NO_SUCH_METHOD;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+
+
+/*
+** implementation of libvlc metadata object
+*
+*  Current usage:
+*   ["meta-information", "general"] = vlc.metadata.categories 
+*   ["artist", "album"] = vlc.metadata.getCategoryKeys("meta-information") 
+*   "metadata" = vlc.metadata.get("meta-information","album")
+*/
+
+const NPUTF8 * const LibvlcMetadataNPObject::propertyNames[] = 
+{
+    "categories",
+};
+
+const int LibvlcMetadataNPObject::propertyCount = sizeof(LibvlcMetadataNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMetadataNPObjectPropertyIds
+{
+    ID_categories,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMetadataNPObject::getProperty(int index, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_categories:
+            {
+                NPP browser = p_plugin->getBrowser();
+                NPObject *plugin;
+
+                if( NPERR_NO_ERROR == NPN_GetValue(browser, NPNVWindowNPObject, &plugin) )
+                {
+                    char buffer[JS_EVAL_BUFFER_SIZE] = "['";
+
+                    vlc_meta_t *metadata = NULL;
+
+                    VLCUtils::GetMetadata(p_plugin->getVLC(), &metadata, &ex);
+                    if( libvlc_exception_raised(&ex) ) 
+                        return INVOKERESULT_GENERIC_ERROR;
+
+                    int count = VLCUtils::GetMetadataCategoryCount(metadata);
+
+#if defined(DEBUG_METADATA_OBJECT)
+                    printf("GetMetadataCategoryCount: %d\n", count);
+#endif
+                    
+                    for(int i = 0; i < count; i++)
+                    {
+                        char *category = VLCUtils::GetMetadataCategoryString(metadata, i);
+
+                        strncat(buffer, category, JS_EVAL_BUFFER_SIZE - 1);
+                        strncat(buffer, "'", JS_EVAL_BUFFER_SIZE - 1);
+                      
+                        if(i + 1 < count)
+                          strncat(buffer, ",'", JS_EVAL_BUFFER_SIZE - 1);
+                      
+                        free(category);
+                    }
+
+                    vlc_meta_Delete(metadata);
+                    
+                    strncat(buffer, "]", JS_EVAL_BUFFER_SIZE - 1);
+
+#if defined(DEBUG_METADATA_OBJECT)
+                    printf("vlc.metadata.categories = %s", buffer);
+#endif
+                    
+                    NPString script;
+                    script.utf8characters = buffer;
+                    script.utf8length = strlen(buffer);
+
+                    if( NPN_Evaluate(browser, plugin, &script, &result) )
+                    {
+                        if( !NPVARIANT_IS_OBJECT(result) )
+                        {
+                            NPN_ReleaseObject(plugin);
+                            return INVOKERESULT_GENERIC_ERROR;
+                        }
+                        // NPN_RetainObject(NPVARIANT_TO_OBJECT(result));
+                        // NPN_ReleaseVariantValue(&result);
+                    } else {
+                       NPN_ReleaseObject(plugin);
+                       return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    NPN_ReleaseObject(plugin);
+                }
+
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+RuntimeNPObject::InvokeResult LibvlcMetadataNPObject::setProperty(int index, const NPVariant &value)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+       // TODO Should anything be writeable? Nope.
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+
+const NPUTF8 * const LibvlcMetadataNPObject::methodNames[] =
+{
+    "getCategoryKeys",
+    "get",
+};
+
+enum LibvlcMetadataNPObjectMethodIds
+{
+    ID_getcategorykeys,
+    ID_get,
+};
+
+const int LibvlcMetadataNPObject::methodCount = sizeof(LibvlcMetadataNPObject::methodNames)/sizeof(NPUTF8 *);
+
+RuntimeNPObject::InvokeResult LibvlcMetadataNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_getcategorykeys:
+                if( argCount == 1 )
+                {
+                    if( NPVARIANT_IS_STRING(args[0]) )
+                    {
+                        char *s = stringValue(NPVARIANT_TO_STRING(args[0]));
+
+#if defined(DEBUG_METADATA_OBJECT)
+                        printf("\nvlc.metadata.getCategoryKeys(%s)\n", s);
+#endif
+                       
+                        NPP browser = p_plugin->getBrowser();
+                        NPObject *plugin;
+
+                        if( NPERR_NO_ERROR == NPN_GetValue(browser, NPNVWindowNPObject, &plugin) )
+                        {
+                            char buffer[JS_EVAL_BUFFER_SIZE] = "['";
+                            vlc_meta_t *metadata = NULL;
+
+                            VLCUtils::GetMetadata(p_plugin->getVLC(), &metadata, &ex);
+                            if( libvlc_exception_raised(&ex) ) 
+                                return INVOKERESULT_GENERIC_ERROR;
+
+                            int count = VLCUtils::GetMetadataKeyCount(metadata, s);
+
+                            for(int i = 0; i < count; i++)
+                            {
+                                char *key = VLCUtils::GetMetadataKeyString(metadata, s, i);
+
+                                strncat(buffer, key, JS_EVAL_BUFFER_SIZE - 1);
+                                strncat(buffer, "'", JS_EVAL_BUFFER_SIZE - 1);
+                              
+                                if(i + 1 < count)
+                                    strncat(buffer, ",'", JS_EVAL_BUFFER_SIZE - 1);
+                              
+                                free(key);
+                            }
+
+                            vlc_meta_Delete(metadata);
+                            free(s);
+
+                            strncat(buffer, "]", JS_EVAL_BUFFER_SIZE - 1);
+                            
+#if defined(DEBUG_METADATA_OBJECT)
+                            printf("vlc.metadata.categoryKeys = %s\n", buffer);
+#endif
+                            
+                            NPString script;
+                            script.utf8characters = buffer;
+                            script.utf8length = strlen(buffer);
+
+                            if( NPN_Evaluate(browser, plugin, &script, &result) )
+                            {
+                                if( !NPVARIANT_IS_OBJECT(result) )
+                                {
+                                    NPN_ReleaseObject(plugin);
+                                    return INVOKERESULT_GENERIC_ERROR;
+                                }
+                                // NPN_RetainObject(NPVARIANT_TO_OBJECT(result));
+                                // NPN_ReleaseVariantValue(&result);
+                            } else {
+                               NPN_ReleaseObject(plugin);
+                               return INVOKERESULT_GENERIC_ERROR;
+                            }
+                            
+                            NPN_ReleaseObject(plugin);
+                        }
+
+                    }
+                    else
+                        return INVOKERESULT_NO_SUCH_METHOD;                    
+
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+
+            case ID_get:
+                if( argCount == 2 )
+                {
+                    if( NPVARIANT_IS_STRING(args[0]) && NPVARIANT_IS_STRING(args[1]))
+                    {
+                        char *category = stringValue(NPVARIANT_TO_STRING(args[0]));
+                        char *key = stringValue(NPVARIANT_TO_STRING(args[1]));
+                        NPUTF8 *metadata = NULL;
+                        
+                        metadata = VLCUtils::GetMetadataString(p_plugin->getVLC(), category, key, &ex);
+
+                        if (category) 
+                            free(category);
+
+                        if (key) 
+                            free(key);
+
+                        if( libvlc_exception_raised(&ex) ) 
+                            return INVOKERESULT_GENERIC_ERROR;
+
+#if defined(DEBUG_METADATA_OBJECT)
+                        printf("vlc.metadata.get = %s\n", metadata);
+#endif
+                        
+                        copyStringToNPVariant(metadata, result);
+
+                        free(metadata);
+                    }
+                    else
+                        return INVOKERESULT_NO_SUCH_METHOD;                    
+
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                return INVOKERESULT_NO_SUCH_METHOD;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+
Index: mozilla/control/npolibvlc.h
===================================================================
--- mozilla/control/npolibvlc.h	(.../0.8.6)	(revision 108)
+++ mozilla/control/npolibvlc.h	(.../0.8.6-songbird)	(revision 108)
@@ -1,233 +1,308 @@
-/*****************************************************************************
- * npolibvlc.h: official Javascript APIs
- *****************************************************************************
- * Copyright (C) 2002-2006 the VideoLAN team
- *
- * Authors: Damien Fouilleul <damien.fouilleul@laposte.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-/*
-** defined runtime script objects
-*/
-#include <vlc/libvlc.h>
-
-#include "nporuntime.h"
-
-class LibvlcRootNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcRootNPObject>;
-
-    LibvlcRootNPObject(NPP instance, const NPClass *aClass);
-    virtual ~LibvlcRootNPObject();
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-
-    NPObject *audioObj;
-    NPObject *inputObj;
-    NPObject *logObj;
-    NPObject *playlistObj;
-    NPObject *videoObj;
-};
-
-class LibvlcAudioNPObject: public RuntimeNPObject
-{
-protected:
-    LibvlcAudioNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-    virtual ~LibvlcAudioNPObject() {};
-
-    friend class RuntimeNPClass<LibvlcAudioNPObject>;
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-    InvokeResult setProperty(int index, const NPVariant &value);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-};
-
-class LibvlcInputNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcInputNPObject>;
-
-    LibvlcInputNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-        
-    virtual ~LibvlcInputNPObject() {};
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-    InvokeResult setProperty(int index, const NPVariant &value);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-};
-
-class LibvlcMessageNPObject: public RuntimeNPObject
-{
-public:
-    void setMessage(struct libvlc_log_message_t &msg)
-    {
-        _msg = msg;
-    };
-
-protected:
-    friend class RuntimeNPClass<LibvlcMessageNPObject>;
-
-    LibvlcMessageNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-        
-    virtual ~LibvlcMessageNPObject() {};
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-private:
-    struct libvlc_log_message_t _msg;
-};
-
-class LibvlcLogNPObject;
-
-class LibvlcMessageIteratorNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcMessageIteratorNPObject>;
-
-    LibvlcMessageIteratorNPObject(NPP instance, const NPClass *aClass);
-    virtual ~LibvlcMessageIteratorNPObject();
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-
-private:
-    libvlc_log_iterator_t*  _p_iter;
-};
-
-class LibvlcMessagesNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcMessagesNPObject>;
-
-    LibvlcMessagesNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-        
-    virtual ~LibvlcMessagesNPObject() {};
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-};
-
-class LibvlcLogNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcLogNPObject>;
-
-    LibvlcLogNPObject(NPP instance, const NPClass *aClass);
-    virtual ~LibvlcLogNPObject();
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-    InvokeResult setProperty(int index, const NPVariant &value);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-private:
-    LibvlcMessagesNPObject* _p_vlcmessages;
-};
-
-class LibvlcPlaylistNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcPlaylistNPObject>;
-
-    LibvlcPlaylistNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-    virtual ~LibvlcPlaylistNPObject() {};
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-
-    void parseOptions(const NPString &s, int *i_options, char*** ppsz_options);
-    void parseOptions(NPObject *obj, int *i_options, char*** ppsz_options);
-};
-
-class LibvlcVideoNPObject: public RuntimeNPObject
-{
-protected:
-    friend class RuntimeNPClass<LibvlcVideoNPObject>;
-
-    LibvlcVideoNPObject(NPP instance, const NPClass *aClass) :
-        RuntimeNPObject(instance, aClass) {};
-    virtual ~LibvlcVideoNPObject() {};
-
-    static const int propertyCount;
-    static const NPUTF8 * const propertyNames[];
-
-    InvokeResult getProperty(int index, NPVariant &result);
-    InvokeResult setProperty(int index, const NPVariant &value);
-
-    static const int methodCount;
-    static const NPUTF8 * const methodNames[];
-
-    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
-};
-
+/*****************************************************************************
+ * npolibvlc.h: official Javascript APIs
+ *****************************************************************************
+ * Copyright (C) 2002-2006 the VideoLAN team
+ *
+ * Authors: Damien Fouilleul <damien.fouilleul@laposte.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*
+** defined runtime script objects
+*/
+#include <vlc/libvlc.h>
+#include <vlc_meta.h>
+
+#include "nporuntime.h"
+
+namespace VLCUtils 
+{
+  void GetMetadata(libvlc_instance_t *instance, vlc_meta_t **, libvlc_exception_t* ex);
+  
+  char *GetMetadataString(libvlc_instance_t *instance, const char *category, const char *key, libvlc_exception_t* ex);
+  char *GetMetadataString(vlc_meta_t *metadata, const char *category, const char *key);
+  
+  int GetMetadataCategoryCount(libvlc_instance_t *instance, libvlc_exception_t* ex);
+  int GetMetadataCategoryCount(vlc_meta_t *metadata);
+  
+  char *GetMetadataCategoryString(libvlc_instance_t *instance, int index, libvlc_exception_t* ex);
+  char *GetMetadataCategoryString(vlc_meta_t *metadata, int index);
+  
+  int GetMetadataKeyCount(libvlc_instance_t * instance, const char *category, libvlc_exception_t* ex);
+  int GetMetadataKeyCount(vlc_meta_t *metadata, const char *category);
+  
+  char *GetMetadataKeyString(libvlc_instance_t *instance, const char *category, int index, libvlc_exception_t* ex);
+  char *GetMetadataKeyString(vlc_meta_t *metadata, const char *category, int index);
+}
+
+class LibvlcRootNPObject: public RuntimeNPObject
+{
+public:
+    virtual void ReleaseChildren();
+
+protected:
+    friend class RuntimeNPClass<LibvlcRootNPObject>;
+
+    LibvlcRootNPObject(NPP instance, const NPClass *aClass);
+    virtual ~LibvlcRootNPObject();
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+
+    NPObject *audioObj;
+    NPObject *inputObj;
+    NPObject *logObj;
+    NPObject *playlistObj;
+    NPObject *videoObj;
+    NPObject *metadataObj;
+};
+
+class LibvlcAudioNPObject: public RuntimeNPObject
+{
+protected:
+    LibvlcAudioNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+    virtual ~LibvlcAudioNPObject() {};
+
+    friend class RuntimeNPClass<LibvlcAudioNPObject>;
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+    InvokeResult setProperty(int index, const NPVariant &value);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+};
+
+class LibvlcInputNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcInputNPObject>;
+
+    LibvlcInputNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+        
+    virtual ~LibvlcInputNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+    InvokeResult setProperty(int index, const NPVariant &value);
+ 
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+};
+
+class LibvlcMessageNPObject: public RuntimeNPObject
+{
+public:
+    void setMessage(struct libvlc_log_message_t &msg)
+    {
+        _msg = msg;
+    };
+
+protected:
+    friend class RuntimeNPClass<LibvlcMessageNPObject>;
+
+    LibvlcMessageNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+        
+    virtual ~LibvlcMessageNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+private:
+    struct libvlc_log_message_t _msg;
+};
+
+class LibvlcLogNPObject;
+
+class LibvlcMessageIteratorNPObject: public RuntimeNPObject
+{
+public:
+    void setLog(LibvlcLogNPObject* p_vlclog);
+
+protected:
+    friend class RuntimeNPClass<LibvlcMessageIteratorNPObject>;
+
+    LibvlcMessageIteratorNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+        
+    virtual ~LibvlcMessageIteratorNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+
+private:
+    LibvlcLogNPObject*      _p_vlclog;
+    libvlc_log_iterator_t*  _p_iter;
+};
+
+class LibvlcMessagesNPObject: public RuntimeNPObject
+{
+public:
+    void setLog(LibvlcLogNPObject *p_log)
+    {
+        _p_vlclog = p_log;
+    }
+    
+protected:
+    friend class RuntimeNPClass<LibvlcMessagesNPObject>;
+
+    LibvlcMessagesNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass),
+        _p_vlclog(NULL) {};
+        
+    virtual ~LibvlcMessagesNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+
+private:
+    LibvlcLogNPObject* _p_vlclog;
+};
+
+class LibvlcLogNPObject: public RuntimeNPObject
+{
+public:
+    virtual void ReleaseChildren() { NPN_ReleaseObject(_p_vlcmessages); }
+
+protected:
+    friend class RuntimeNPClass<LibvlcLogNPObject>;
+    friend class LibvlcMessagesNPObject;
+    friend class LibvlcMessageIteratorNPObject;
+
+    libvlc_log_t    *_p_log;
+
+    LibvlcLogNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass),
+        _p_log(NULL)
+    {
+        _p_vlcmessages = static_cast<LibvlcMessagesNPObject*>(NPN_CreateObject(instance, RuntimeNPClass<LibvlcMessagesNPObject>::getClass()));
+        _p_vlcmessages->setLog(this);
+    };
+        
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+    InvokeResult setProperty(int index, const NPVariant &value);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+private:
+    LibvlcMessagesNPObject* _p_vlcmessages;
+};
+
+class LibvlcPlaylistNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcPlaylistNPObject>;
+
+    LibvlcPlaylistNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+    virtual ~LibvlcPlaylistNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+
+    void parseOptions(const NPString &s, int *i_options, char*** ppsz_options);
+    void parseOptions(NPObject *obj, int *i_options, char*** ppsz_options);
+};
+
+class LibvlcVideoNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcVideoNPObject>;
+
+    LibvlcVideoNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+    virtual ~LibvlcVideoNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+    InvokeResult setProperty(int index, const NPVariant &value);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+};
+
+
+class LibvlcMetadataNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcMetadataNPObject>;
+
+    LibvlcMetadataNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+
+    virtual ~LibvlcMetadataNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+    InvokeResult setProperty(int index, const NPVariant &value);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+};
Index: mozilla/vlc.r
===================================================================
--- mozilla/vlc.r	(.../0.8.6)	(revision 108)
+++ mozilla/vlc.r	(.../0.8.6-songbird)	(revision 108)
@@ -13,9 +13,9 @@
 resource 'STR#' (126)
 {
     {
-        "Version 0.8.6, Copyright 2006, The VideoLAN Team"
-        "<BR><A HREF='http://www.videolan.org'>http://www.videolan.org</A>",
-        "VLC Multimedia Plugin"
+        "Songbird VLC Version 0.8.6, Copyright 2006, The VideoLAN Team"
+        "<BR><A HREF='http://www.videolan.org'>http://www.videolan.org</A>, <A HREF='http://www.songbirdnest.com'>http://www.songbirdnest.com</A>",
+        "Songbird VLC Multimedia Plugin"
     };
 };
 
@@ -37,7 +37,7 @@
 /*        "QuickTime video", */
         "Ogg stream",
         "Ogg stream",
-        "VLC plugin",
+        "Songbird VLC plugin",
         "ASF stream",
         "ASF stream",
         "",
@@ -52,6 +52,7 @@
 resource 'STR#' (128,"MIME Type")
 {
     {
+/*
         "audio/mpeg", "mp2,mp3,mpga,mpega",
         "audio/x-mpeg", "mp2,mp3,mpga,mpega",
         "video/mpeg", "mpg,mpeg,mpe",
@@ -63,10 +64,11 @@
         "application/mpeg4-iod", "mp4,mpg4",
         "application/mpeg4-muxcodetable", "mp4,mpg4",
         "video/x-msvideo", "avi",
+*/
 /*        "video/quicktime", "mov, qt", */
+/*
         "application/ogg", "ogg",
         "application/x-ogg", "ogg",
-        "application/x-vlc-plugin", "vlc",
         "video/x-ms-asf-plugin", "",
         "video/x-ms-asf", "",
         "application/x-mplayer2", "",
@@ -74,6 +76,8 @@
         "video/x-google-vlc-plugin", "",
         "audio/wav", "wav",
         "audio/x-wav", "wav",
+*/
+        "application/x-songbird-vlc-plugin", "",
     };
 };
 
Index: mozilla/vlcplugin.cpp
===================================================================
--- mozilla/vlcplugin.cpp	(.../0.8.6)	(revision 108)
+++ mozilla/vlcplugin.cpp	(.../0.8.6-songbird)	(revision 108)
@@ -2,7 +2,7 @@
  * vlcplugin.cpp: a VLC plugin for Mozilla
  *****************************************************************************
  * Copyright (C) 2002-2005 the VideoLAN team
- * $Id: vlcplugin.cpp 17899 2006-11-20 23:14:43Z damienf $
+ * $Id: vlcplugin.cpp 17415 2006-11-02 01:23:40Z damienf $
  *
  * Authors: Samuel Hocevar <sam@zoy.org>
  *          Damien Fouilleul <damienf.fouilleul@laposte.net>
@@ -44,9 +44,7 @@
     b_autoplay(1),
     psz_target(NULL),
     libvlc_instance(NULL),
-    libvlc_log(NULL),
-    p_scriptClass(NULL),
-    p_scriptObject(NULL),
+    scriptObject(NULL),
     p_browser(instance),
     psz_baseURL(NULL)
 #if XP_WIN
@@ -60,7 +58,7 @@
     memset(&npwindow, 0, sizeof(NPWindow));
 }
 
-static bool boolValue(const char *value) {
+static int boolValue(const char *value) {
     return ( !strcmp(value, "1") || 
              !strcasecmp(value, "true") ||
              !strcasecmp(value, "yes") );
@@ -75,8 +73,40 @@
     /* locate VLC module path */
 #ifdef XP_MACOSX
     ppsz_argv[ppsz_argc++] = "--plugin-path";
-    ppsz_argv[ppsz_argc++] = "/Library/Internet Plug-Ins/VLC Plugin.plugin/"
-                             "Contents/MacOS/modules";
+
+    // Dig through the os x bundle API to figure out the module path
+    CFBundleRef appBundle = CFBundleGetMainBundle();
+    if (appBundle == NULL) { 
+      printf("\nVlcPlugin::init - Could not get bundle ref\n");
+      return NPERR_GENERIC_ERROR;
+    }
+    CFURLRef bundleURL = CFBundleCopyBundleURL(appBundle);
+    if (bundleURL == NULL) {
+      printf("\nVlcPlugin::init - Could not get bundle URL\n");
+      return NPERR_GENERIC_ERROR;
+    }
+    CFStringRef myString = CFURLCopyFileSystemPath(bundleURL, kCFURLPOSIXPathStyle);
+
+    // ppsz_argv needs a CString path, so convert down.
+    // What happens if the user runs the app from some unicode URL?
+    const CFIndex PATH_BUFFER = PATH_MAX + 1;
+    char bundlePath[PATH_BUFFER];
+    CFStringGetCString(myString, bundlePath, PATH_BUFFER, kCFStringEncodingASCII);
+    if (bundlePath == NULL) {
+        printf("\nVlcPlugin::init - Could not get path string\n");
+        CFRelease(bundleURL);
+        return NPERR_GENERIC_ERROR;
+    }
+
+    // Add the known plugin path to the bundle path
+    strcat(bundlePath, "/Contents/Resources/plugins/VLC Plugin.plugin/Contents/MacOS/modules" );
+    printf("\nVlcPlugin::init - Using path %s\n", bundlePath);
+    ppsz_argv[ppsz_argc++] = bundlePath;
+
+    CFRelease(bundleURL);
+
+    //ppsz_argv[ppsz_argc++] = "/Library/Internet Plug-Ins/VLC Plugin.plugin/"
+    //                         "Contents/MacOS/modules";
 #elif defined(XP_WIN)
     HKEY h_key;
     DWORD i_type, i_data = MAX_PATH + 1;
@@ -124,7 +154,7 @@
     ppsz_argv[ppsz_argc++] = "--intf";
     ppsz_argv[ppsz_argc++] = "dummy";
 
-    const char *progid = NULL;
+    const char *version = NULL;
 
     /* parse plugin arguments */
     for( int i = 0; i < argc ; i++ )
@@ -173,10 +203,9 @@
                 ppsz_argv[ppsz_argc++] = "--no-loop";
             }
         }
-        else if( !strcmp( argn[i], "version")
-              || !strcmp( argn[i], "progid") )
+        else if( !strcmp( argn[i], "version") )
         {
-            progid = argv[i];
+            version = argv[i];
         }
     }
 
@@ -230,15 +259,15 @@
     }
 
     /* assign plugin script root class */
-    if( (NULL != progid) && (!strcmp(progid, "VideoLAN.VLCPlugin.2")) )
+    if( (NULL != version) && (!strcmp(version, "VideoLAN.VLCPlugin.2")) )
     {
         /* new APIs */
-        p_scriptClass = RuntimeNPClass<LibvlcRootNPObject>::getClass();
+        scriptObject = NPN_CreateObject(p_browser, RuntimeNPClass<LibvlcRootNPObject>::getClass());
     }
     else
     {
         /* legacy APIs */
-        p_scriptClass = RuntimeNPClass<VlcNPObject>::getClass();
+        scriptObject = NPN_CreateObject(p_browser, RuntimeNPClass<VlcNPObject>::getClass());
     }
 
     return NPERR_NO_ERROR;
@@ -281,10 +310,13 @@
 {
     delete psz_baseURL;
     delete psz_target;
-    if( p_scriptObject )
-        NPN_ReleaseObject(p_scriptObject);
-    if( libvlc_log )
-        libvlc_log_close(libvlc_log, NULL);
+
+    if (scriptObject) {
+	    RuntimeNPObject* object = (RuntimeNPObject*)scriptObject;
+        object->ReleaseChildren();
+        NPN_ReleaseObject(object);
+    }
+
     if( libvlc_instance )
         libvlc_destroy(libvlc_instance);
 }
@@ -403,15 +435,6 @@
     return NULL;
 }
 
-NPObject* VlcPlugin::getScriptObject()
-{
-    if( NULL == p_scriptObject )
-    {
-        p_scriptObject = NPN_CreateObject(p_browser, p_scriptClass);
-    }
-    return NPN_RetainObject(p_scriptObject);
-}
-
 #if XP_UNIX
 int  VlcPlugin::setSize(unsigned width, unsigned height)
 {
@@ -425,3 +448,4 @@
 }
 #endif
 
+
Index: mozilla/npvlc_rc.rc
===================================================================
--- mozilla/npvlc_rc.rc	(.../0.8.6)	(revision 108)
+++ mozilla/npvlc_rc.rc	(.../0.8.6-songbird)	(revision 108)
@@ -31,17 +31,17 @@
     BEGIN
         BLOCK "040904e4"
         BEGIN
-            VALUE "ProductName", "VLC multimedia plugin\0"
+            VALUE "ProductName", "Songbird VLC multimedia plugin\0"
             VALUE "ProductVersion", STRINGIFY( VERSION )
             VALUE "OriginalFilename", "npvlc.dll\0"
             VALUE "FileVersion", STRINGIFY( VERSION )
-            VALUE "FileDescription", "VLC multimedia plugin Version "STRINGIFY( VERSION )"<br><br>VideoLAN WWW: <a href=""http://www.videolan.org/"">http://www.videolan.org/</a>\0"
+            VALUE "FileDescription", "Songbird VLC multimedia plugin Version "STRINGIFY( VERSION )"<br><br>VideoLAN WWW: <a href=""http://www.videolan.org/"">http://www.videolan.org/</a><br>Songbird WWW: <a href=""http://www.songbirdnest.com/"">http://www.songbirdnest.com/</a>\0"
             VALUE "InternalName", "npvlc\0"
             VALUE "CompanyName", "VideoLAN Team\0"
             VALUE "LegalCopyright", "Copyright VideoLAN \251 1996-2006\0"
-            VALUE "MIMEType", "audio/mpeg|audio/x-mpeg|video/mpeg|video/x-mpeg|video/mpeg-system|video/x-mpeg-system|video/mpeg4|audio/mpeg4|application/mpeg4-iod|application/mpeg4-muxcodetable|video/x-msvideo|video/quicktime|application/x-ogg|application/ogg|application/x-vlc-plugin|video/x-ms-asf-plugin|video/x-ms-asf|application/x-mplayer2|video/x-ms-wmv|application/x-google-vlc-plugin|audio/wav|audio/x-wav\0"
-            VALUE "FileExtents", "mp2,mp3,mpga,mpega|mp2,mp3,mpga,mpega|mpg,mpeg,mpe|mpg,mpeg,mpe|mpg,mpeg,vob|mpg,mpeg,vob|mp4,mpg4|mp4,mpg4|mp4,mpg4|mp4,mpg4|avi|mov,qt|ogg|ogg|vlc||||wmv||wav|wav\0"
-            VALUE "FileOpenName", "MPEG audio|MPEG audio|MPEG video|MPEG video|MPEG video|MPEG video|MPEG-4 video|MPEG-4 audio|MPEG-4 video|MPEG-4 video|AVI video|QuickTime video|Ogg stream|Ogg stream|VLC plugin|||||Google VLC plugin|WAV audio|WAV audio\0"
+            VALUE "MIMEType", "application/x-songbird-vlc-plugin\0"
+            VALUE "FileExtents", "sbvlc\0"
+            VALUE "FileOpenName", "Songbird VLC plugin\0"
         END
     END
     BLOCK "VarFileInfo"
Index: mozilla/vlcplugin.h
===================================================================
--- mozilla/vlcplugin.h	(.../0.8.6)	(revision 108)
+++ mozilla/vlcplugin.h	(.../0.8.6-songbird)	(revision 108)
@@ -2,7 +2,7 @@
  * vlcplugin.h: a VLC plugin for Mozilla
  *****************************************************************************
  * Copyright (C) 2002-2006 the VideoLAN team
- * $Id: vlcplugin.h 17899 2006-11-20 23:14:43Z damienf $
+ * $Id: vlcplugin.h 16931 2006-10-03 09:04:50Z damienf $
  *
  * Authors: Samuel Hocevar <sam@zoy.org>
             Damien Fouilleul <damienf@videolan.org>
@@ -71,12 +71,9 @@
     void                setWindow(const NPWindow *window)
                             { npwindow = *window; };
 
-    NPObject*           getScriptObject();
+    NPObject*            getScriptObject()
+                            { return scriptObject; };
 
-    void                setLog(libvlc_log_t *log)
-                            { libvlc_log = log; };
-    libvlc_log_t*       getLog()
-                            { return libvlc_log; };
 #if XP_WIN
     WNDPROC             getWindowProc()
                             { return pf_wndproc; };
@@ -97,10 +94,8 @@
 
 private:
     /* VLC reference */
-    libvlc_instance_t   *libvlc_instance;
-    libvlc_log_t        *libvlc_log;
-    NPClass             *p_scriptClass;
-    NPObject            *p_scriptObject;
+    libvlc_instance_t *libvlc_instance;
+    NPObject           *scriptObject;
 
     /* browser reference */
     NPP     p_browser;
@@ -119,44 +114,20 @@
 /*******************************************************************************
  * Plugin properties.
  ******************************************************************************/
-#define PLUGIN_NAME         "VLC multimedia plugin"
+/* BEGIN SONGBIRD EDIT */
+#define PLUGIN_NAME         "VLC multimedia plugin - Songbird Version"
 #define PLUGIN_DESCRIPTION \
-    "VLC multimedia plugin <br>" \
+    "VLC multimedia plugin - Songbird Version<br>" \
     " <br>" \
     "version %s <br>" \
-    "VideoLAN WWW: <a href=\"http://www.videolan.org/\">http://www.videolan.org/</a>"
+    "VideoLAN WWW: <a href=\"http://www.videolan.org/\">http://www.videolan.org/</a>" \
+    "Songbird WWW: <a href=\"http://www.songbirdnest.com/\">http://www.songbirdnest.com/</a>"
 
 #define PLUGIN_MIMETYPES \
-    /* MPEG-1 and MPEG-2 */ \
-    "audio/mpeg:mp2,mp3,mpga,mpega:MPEG audio;" \
-    "audio/x-mpeg:mp2,mp3,mpga,mpega:MPEG audio;" \
-    "video/mpeg:mpg,mpeg,mpe:MPEG video;" \
-    "video/x-mpeg:mpg,mpeg,mpe:MPEG video;" \
-    "video/mpeg-system:mpg,mpeg,mpe,vob:MPEG video;" \
-    "video/x-mpeg-system:mpg,mpeg,mpe,vob:MPEG video;" \
-    /* MPEG-4 */ \
-    "video/mpeg4:mp4,mpg4:MPEG-4 video;" \
-    "audio/mpeg4:mp4,mpg4:MPEG-4 audio;" \
-    "application/mpeg4-iod:mp4,mpg4:MPEG-4 video;" \
-    "application/mpeg4-muxcodetable:mp4,mpg4:MPEG-4 video;" \
-    /* AVI */ \
-    "video/x-msvideo:avi:AVI video;" \
-    /* QuickTime */ \
-    "video/quicktime:mov,qt:QuickTime video;" \
-    /* Ogg */ \
-    "application/x-ogg:ogg:Ogg stream;" \
-    "application/ogg:ogg:Ogg stream;" \
     /* explicit plugin call */ \
-    "application/x-vlc-plugin::VLC plugin;" \
-    /* windows media */ \
-    "video/x-ms-asf-plugin:asf,asx:Windows Media Video;" \
-    "video/x-ms-asf:asf,asx:Windows Media Video;" \
-    "application/x-mplayer2::Windows Media;" \
-    "video/x-ms-wmv:wmv:Windows Media;" \
+    "application/x-songbird-vlc-plugin::Songbird VLC plugin;" \
     /* Google VLC mime */ \
     "application/x-google-vlc-plugin::Google VLC plugin" \
-    /* Misc */ \
-    "audio/wav::WAV audio" \
-    "audio/x-wav::WAV audio" \
 
 #endif
+/* END SONGBIRD EDIT */
Index: mozilla/Makefile.am
===================================================================
--- mozilla/Makefile.am	(.../0.8.6)	(revision 108)
+++ mozilla/Makefile.am	(.../0.8.6-songbird)	(revision 108)
@@ -90,7 +90,7 @@
 	awk -v libdylib="$$dylib" ' \
 	/@executable_path/ { \
 	    newpath=$$1 ; \
-	    sub("@executable_path","/Library/Internet Plug-Ins/VLC Plugin.plugin/Contents/MacOS",newpath) ; \
+	    sub("@executable_path","@executable_path/../Resources/plugins/VLC Plugin.plugin/Contents/MacOS",newpath) ; \
 	    print "install_name_tool -change \""$$1"\" \""newpath"\" \""libdylib"\"" ; \
 	}' | sh -x
 endef
Index: mozilla/support/npwin.cpp
===================================================================
--- mozilla/support/npwin.cpp	(.../0.8.6)	(revision 108)
+++ mozilla/support/npwin.cpp	(.../0.8.6-songbird)	(revision 108)
@@ -180,6 +180,7 @@
 {
     NPP_Shutdown();
     g_pNavigatorFuncs = NULL;
+    g_pluginFuncs = NULL;
     return NPERR_NO_ERROR;
 }
 
Index: mozilla/vlcshell.cpp
===================================================================
--- mozilla/vlcshell.cpp	(.../0.8.6)	(revision 108)
+++ mozilla/vlcshell.cpp	(.../0.8.6-songbird)	(revision 108)
@@ -2,7 +2,7 @@
  * vlcshell.cpp: a VLC plugin for Mozilla
  *****************************************************************************
  * Copyright (C) 2002-2005 the VideoLAN team
- * $Id: vlcshell.cpp 17899 2006-11-20 23:14:43Z damienf $
+ * $Id: vlcshell.cpp 17413 2006-11-01 23:09:50Z damienf $
  *
  * Authors: Samuel Hocevar <sam@zoy.org>
  *
@@ -45,7 +45,7 @@
 /* Enable/disable debugging printf's for X11 resizing */
 #undef X11_RESIZE_DEBUG
 
-#define WINDOW_TEXT "(no video)"
+#define WINDOW_TEXT "Songbird Web Player"
 
 /*****************************************************************************
  * Unix-only declarations
@@ -120,11 +120,14 @@
     {
         case NPPVpluginScriptableNPObject:
             /* create an instance and return it */
-            *(NPObject**)value = p_plugin->getScriptObject();
-            if( NULL == *(NPObject**)value )
+            NPObject* scriptObject = p_plugin->getScriptObject();
+            if( !scriptObject )
             {
                 return NPERR_OUT_OF_MEMORY_ERROR;
             }
+            NPN_RetainObject(scriptObject);
+            *((NPObject **)value) = scriptObject;
+
             break;
 
         default:
@@ -155,6 +158,9 @@
             break;
         case mouseDown:
         {
+            // XXXMATT: Disabling doubleclick until fullscreen is fixed
+            return true;
+
             if( (myEvent->when - lastMouseUp) < GetDblTime() )
             {
                 /* double click */
@@ -261,7 +267,7 @@
 
 void NPP_Shutdown( void )
 {
-    ;
+    return;
 }
 
 NPError NPP_New( NPMIMEType pluginType, NPP instance, uint16 mode, int16 argc,
@@ -292,15 +298,13 @@
 
 NPError NPP_Destroy( NPP instance, NPSavedData** save )
 {
-    if( NULL == instance )
+    if( instance == NULL )
+    {
         return NPERR_INVALID_INSTANCE_ERROR;
+    }
 
     VlcPlugin* p_plugin = reinterpret_cast<VlcPlugin*>(instance->pdata);
-    if( NULL == p_plugin )
-        return NPERR_NO_ERROR;
 
-    instance->pdata = NULL;
-
 #if XP_WIN
     HWND win = (HWND)p_plugin->getWindow()->window;
     WNDPROC winproc = p_plugin->getWindowProc();
@@ -314,6 +318,8 @@
     if( p_plugin )
         delete p_plugin;
 
+    instance->pdata = NULL;
+
     return NPERR_NO_ERROR;
 }
 
@@ -766,3 +772,4 @@
 
 #endif /* XP_UNIX */
 
+
