Index: mozilla/control/npolibvlc.cpp
===================================================================
--- mozilla/control/npolibvlc.cpp	(revision 17424)
+++ mozilla/control/npolibvlc.cpp	(working copy)
@@ -46,6 +46,7 @@
     logObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcLogNPObject>::getClass());
     playlistObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcPlaylistNPObject>::getClass());
     videoObj = NPN_CreateObject(instance,RuntimeNPClass<LibvlcVideoNPObject>::getClass());
+    metadataObj = NPN_CreateObject(instance, RuntimeNPClass<LibvlcMetadataNPObject>::getClass());
 }
 
 LibvlcRootNPObject::~LibvlcRootNPObject()
@@ -55,6 +56,7 @@
     NPN_ReleaseObject(logObj);
     NPN_ReleaseObject(playlistObj);
     NPN_ReleaseObject(videoObj);
+    NPN_ReleaseObject(metadataObj);
 }
 
 const NPUTF8 * const LibvlcRootNPObject::propertyNames[] = 
@@ -63,6 +65,7 @@
     "input",
     "playlist",
     "video",
+    "metadata",
     "VersionInfo",
 };
 
@@ -74,6 +77,7 @@
     ID_input,
     ID_playlist,
     ID_video,
+    ID_metadata,
     ID_VersionInfo,
 };
 
@@ -93,6 +97,9 @@
         case ID_video:
             OBJECT_TO_NPVARIANT(NPN_RetainObject(videoObj), result);
             return INVOKERESULT_NO_ERROR;
+        case ID_metadata:
+            OBJECT_TO_NPVARIANT(NPN_RetainObject(metadataObj), result);
+            return INVOKERESULT_NO_ERROR;
         case ID_VersionInfo:
             NPUTF8 *versionStr = NULL;
 
@@ -1687,3 +1694,189 @@
     return INVOKERESULT_GENERIC_ERROR;
 }
 
+
+
+/*
+** implementation of libvlc metadata object
+*
+*  Current usage:
+*   ["meta-information", "general"] = vlc.metadata.categories 
+*   ["artist", "album"] = vlc.metadata.getCategoryKeys("meta-information") 
+*   "metadata" = vlc.metadata.get("meta-information","album")
+*/
+
+const NPUTF8 * const LibvlcMetadataNPObject::propertyNames[] = 
+{
+    "categories",
+};
+
+const int LibvlcMetadataNPObject::propertyCount = sizeof(LibvlcMetadataNPObject::propertyNames)/sizeof(NPUTF8 *);
+
+enum LibvlcMetadataNPObjectPropertyIds
+{
+    ID_categories,
+};
+
+RuntimeNPObject::InvokeResult LibvlcMetadataNPObject::getProperty(int index, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_categories:
+            {
+                NPP browser = p_plugin->getBrowser();
+                NPObject *plugin;
+
+                if( NPERR_NO_ERROR == NPN_GetValue(browser, NPNVWindowNPObject, &plugin) )
+                {
+
+                    // TODO call request all available metadata categories form libvlc
+                    // and then build a javascript array
+
+                    static const char rawScript[] = "['meta-information','general']";
+                    NPString script;
+                    script.utf8characters = rawScript;
+                    script.utf8length = sizeof(rawScript)-1;
+
+                    if( NPN_Evaluate(browser, plugin, &script, &result) )
+                    {
+                        if( !NPVARIANT_IS_OBJECT(result) )
+                        {
+                            NPN_ReleaseObject(plugin);
+                            return INVOKERESULT_GENERIC_ERROR;
+                        }
+                        // NPN_RetainObject(NPVARIANT_TO_OBJECT(result));
+                        // NPN_ReleaseVariantValue(&result);
+                    } else {
+                       NPN_ReleaseObject(plugin);
+                       return INVOKERESULT_GENERIC_ERROR;
+                    }
+                    NPN_ReleaseObject(plugin);
+                }
+
+                printf("\nvlc.metadata.categories = ['artist','album']\n");
+                return INVOKERESULT_NO_ERROR;
+            }
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+RuntimeNPObject::InvokeResult LibvlcMetadataNPObject::setProperty(int index, const NPVariant &value)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+       // TODO Should anything be writeable? 
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
+
+const NPUTF8 * const LibvlcMetadataNPObject::methodNames[] =
+{
+    "getCategoryKeys",
+    "get",
+};
+
+enum LibvlcMetadataNPObjectMethodIds
+{
+    ID_getcategorykeys,
+    ID_get,
+};
+
+const int LibvlcMetadataNPObject::methodCount = sizeof(LibvlcMetadataNPObject::methodNames)/sizeof(NPUTF8 *);
+
+RuntimeNPObject::InvokeResult LibvlcMetadataNPObject::invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result)
+{
+    VlcPlugin *p_plugin = reinterpret_cast<VlcPlugin *>(_instance->pdata);
+    if( p_plugin )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        switch( index )
+        {
+            case ID_getcategorykeys:
+                if( argCount == 1 )
+                {
+                    if( NPVARIANT_IS_STRING(args[0]) )
+                    {
+                        char *s = stringValue(NPVARIANT_TO_STRING(args[0]));
+                        printf("\nvlc.metadata.getCategoryKeys(%s)\n", s);
+                       
+                        // TODO get the metadata corresponding to s from libvlc
+
+                        NPP browser = p_plugin->getBrowser();
+                        NPObject *plugin;
+
+                        if( NPERR_NO_ERROR == NPN_GetValue(browser, NPNVWindowNPObject, &plugin) )
+                        {
+
+                            // TODO call request all available metadata category keys form libvlc
+                            // and then build a javascript array
+
+                            static const char rawScript[] = "['artist','album']";
+                            NPString script;
+                            script.utf8characters = rawScript;
+                            script.utf8length = sizeof(rawScript)-1;
+
+                            if( NPN_Evaluate(browser, plugin, &script, &result) )
+                            {
+                                if( !NPVARIANT_IS_OBJECT(result) )
+                                {
+                                    NPN_ReleaseObject(plugin);
+                                    return INVOKERESULT_GENERIC_ERROR;
+                                }
+                                // NPN_RetainObject(NPVARIANT_TO_OBJECT(result));
+                                // NPN_ReleaseVariantValue(&result);
+                            } else {
+                               NPN_ReleaseObject(plugin);
+                               return INVOKERESULT_GENERIC_ERROR;
+                            }
+                            NPN_ReleaseObject(plugin);
+                        }
+
+                        printf("\nvlc.metadata.categories = ['artist','album']\n");
+                    }
+                    else
+                        return INVOKERESULT_NO_SUCH_METHOD;                    
+
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+
+            case ID_get:
+                if( argCount == 2 )
+                {
+                    if( NPVARIANT_IS_STRING(args[0]) && NPVARIANT_IS_STRING(args[1]))
+                    {
+                        char *category = stringValue(NPVARIANT_TO_STRING(args[0]));
+                        char *key = stringValue(NPVARIANT_TO_STRING(args[1]));
+                        printf("\nvlc.metadata.get(%s, %s)\n", category, key);
+
+                        // TODO get the metadata corresponding to s from libvlc
+
+                        STRINGZ_TO_NPVARIANT(strdup("metadata"), result);
+                    }
+                    else
+                        return INVOKERESULT_NO_SUCH_METHOD;                    
+
+                    return INVOKERESULT_NO_ERROR;
+                }
+                return INVOKERESULT_NO_SUCH_METHOD;
+            default:
+                return INVOKERESULT_NO_SUCH_METHOD;
+        }
+    }
+    return INVOKERESULT_GENERIC_ERROR;
+}
+
Index: mozilla/control/npolibvlc.h
===================================================================
--- mozilla/control/npolibvlc.h	(revision 17424)
+++ mozilla/control/npolibvlc.h	(working copy)
@@ -50,6 +50,7 @@
     NPObject *logObj;
     NPObject *playlistObj;
     NPObject *videoObj;
+    NPObject *metadataObj;
 };
 
 class LibvlcAudioNPObject: public RuntimeNPObject
@@ -261,3 +262,25 @@
     InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
 };
 
+
+class LibvlcMetadataNPObject: public RuntimeNPObject
+{
+protected:
+    friend class RuntimeNPClass<LibvlcMetadataNPObject>;
+
+    LibvlcMetadataNPObject(NPP instance, const NPClass *aClass) :
+        RuntimeNPObject(instance, aClass) {};
+
+    virtual ~LibvlcMetadataNPObject() {};
+
+    static const int propertyCount;
+    static const NPUTF8 * const propertyNames[];
+
+    InvokeResult getProperty(int index, NPVariant &result);
+    InvokeResult setProperty(int index, const NPVariant &value);
+
+    static const int methodCount;
+    static const NPUTF8 * const methodNames[];
+
+    InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+};
Index: mozilla/vlcplugin.cpp
===================================================================
--- mozilla/vlcplugin.cpp	(revision 17424)
+++ mozilla/vlcplugin.cpp	(working copy)
@@ -73,8 +73,40 @@
     /* locate VLC module path */
 #ifdef XP_MACOSX
     ppsz_argv[ppsz_argc++] = "--plugin-path";
-    ppsz_argv[ppsz_argc++] = "/Library/Internet Plug-Ins/VLC Plugin.plugin/"
-                             "Contents/MacOS/modules";
+
+    // Dig through the os x bundle API to figure out the module path
+    CFBundleRef appBundle = CFBundleGetMainBundle();
+    if (appBundle == NULL) { 
+      printf("\nVlcPlugin::init - Could not get bundle ref\n");
+      return NPERR_GENERIC_ERROR;
+    }
+    CFURLRef bundleURL = CFBundleCopyBundleURL(appBundle);
+    if (bundleURL == NULL) {
+      printf("\nVlcPlugin::init - Could not get bundle URL\n");
+      return NPERR_GENERIC_ERROR;
+    }
+    CFStringRef myString = CFURLCopyFileSystemPath(bundleURL, kCFURLPOSIXPathStyle);
+
+    // ppsz_argv needs a CString path, so convert down.
+    // What happens if the user runs the app from some unicode URL?
+    const CFIndex PATH_BUFFER = PATH_MAX + 1;
+    char bundlePath[PATH_BUFFER];
+    CFStringGetCString(myString, bundlePath, PATH_BUFFER, kCFStringEncodingASCII);
+    if (bundlePath == NULL) {
+        printf("\nVlcPlugin::init - Could not get path string\n");
+        CFRelease(bundleURL);
+        return NPERR_GENERIC_ERROR;
+    }
+
+    // Add the known plugin path to the bundle path
+    strcat(bundlePath, "/Contents/Frameworks/XUL.framework/plugins/VLC Plugin.plugin/Contents/MacOS/modules" );
+    printf("\nVlcPlugin::init - Using path %s\n", bundlePath);
+    ppsz_argv[ppsz_argc++] = bundlePath;
+
+    CFRelease(bundleURL);
+
+    //ppsz_argv[ppsz_argc++] = "/Library/Internet Plug-Ins/VLC Plugin.plugin/"
+    //                         "Contents/MacOS/modules";
 #elif defined(XP_WIN)
     HKEY h_key;
     DWORD i_type, i_data = MAX_PATH + 1;
Index: mozilla/Makefile.am
===================================================================
--- mozilla/Makefile.am	(revision 17424)
+++ mozilla/Makefile.am	(working copy)
@@ -90,7 +90,7 @@
 	awk -v libdylib="$$dylib" ' \
 	/@executable_path/ { \
 	    newpath=$$1 ; \
-	    sub("@executable_path","/Library/Internet Plug-Ins/VLC Plugin.plugin/Contents/MacOS",newpath) ; \
+	    sub("@executable_path","@executable_path/plugins/VLC Plugin.plugin/Contents/MacOS",newpath) ; \
 	    print "install_name_tool -change \""$$1"\" \""newpath"\" \""libdylib"\"" ; \
 	}' | sh -x
 endef
