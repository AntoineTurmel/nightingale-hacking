Index: widget/src/cocoa/nsCocoaWindow.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsCocoaWindow.h,v
retrieving revision 1.48
diff -u -p -r1.48 nsCocoaWindow.h
--- widget/src/cocoa/nsCocoaWindow.h	27 Mar 2008 03:42:57 -0000	1.48
+++ widget/src/cocoa/nsCocoaWindow.h	2 Apr 2008 19:15:02 -0000
@@ -94,7 +94,11 @@ typedef struct _nsCocoaWindowList {
 
 - (BOOL)canBecomeKeyWindow;
 - (BOOL)canBecomeMainWindow;
+@end
+
 
+@interface SongbirdWindow : BorderlessWindow 
+{}
 @end
 
 
Index: widget/src/cocoa/nsCocoaWindow.mm
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsCocoaWindow.mm,v
retrieving revision 1.141
diff -u -p -r1.141 nsCocoaWindow.mm
--- widget/src/cocoa/nsCocoaWindow.mm	27 Mar 2008 03:42:57 -0000	1.141
+++ widget/src/cocoa/nsCocoaWindow.mm	2 Apr 2008 19:15:02 -0000
@@ -348,10 +348,24 @@ nsresult nsCocoaWindow::StandardCreate(n
     // If we're a popup window we need to use the PopupWindow class.
     else if (mWindowType == eWindowType_popup)
       windowClass = [PopupWindow class];
-    // If we're a non-popup borderless window we need to use the
-    // BorderlessWindow class.
-    else if (features == NSBorderlessWindowMask)
-      windowClass = [BorderlessWindow class];
+
+    // XXXmatt: If we use a borderless window the OS makes
+    // assumptions about what the window should be able to do.
+    // What we really want is a normal window in which
+    // the XUL takes responsibility for drawing the titlebar
+    // and resizer.
+    else if (features == NSBorderlessWindowMask) {
+      windowClass = [SongbirdWindow class];
+      features |= NSClosableWindowMask;
+      features |= NSTitledWindowMask;
+      features |= NSMiniaturizableWindowMask;
+      
+      // If the window was opened with resizable=yes, then 
+      // enable to OS resizer.
+      if (aInitData->mBorderStyle & eBorderStyle_resizeh) {
+        features |= NSResizableWindowMask;
+      }
+    }
 
     // Create the window
     mWindow = [[windowClass alloc] initWithContentRect:rect styleMask:features 
@@ -380,7 +394,11 @@ nsresult nsCocoaWindow::StandardCreate(n
     }
 
     [mWindow setBackgroundColor:[NSColor whiteColor]];
-    [mWindow setContentMinSize:NSMakeSize(60, 60)];
+    
+    // XXXmatt: Modifying the arbitrary min size so that it 
+    // doesn't interfere with the Songbird miniplayer.
+    [mWindow setContentMinSize:NSMakeSize(60, 20)];
+    
     [mWindow setReleasedWhenClosed:NO];
 
     // setup our notification delegate. Note that setDelegate: does NOT retain.
@@ -2341,3 +2359,231 @@ already_AddRefed<nsIDOMElement> GetFocus
 }
 
 @end
+
+/*************************************************************************
+ * BEGIN SONGBIRD HACK
+ *
+ * If you want to draw your own window decorations like iPhoto or
+ * Aperature, you have to use the unsupported NSThemeFrame view.
+ *
+ * See http://andymatuschak.org/articles/2006/01/11/ for gory details.
+ *
+ * In Songbird we like to draw all window decorations using XUL, so we
+ * subclass NSThemeFrame and make the content area 100% of the window. 
+ * BorderlessWindow would work, but causes the OS to make assumptions
+ * about things like resizing and zooming.
+ *
+ *************************************************************************/
+
+@class NSDocumentDragButton, NSButton, NSCell, NSImage, NSString;
+
+@interface NSFrameView : NSView
+{
+  unsigned int styleMask;
+  NSString *_title;
+  NSCell *titleCell;
+  NSButton *closeButton;
+  NSButton *zoomButton;
+  NSButton *minimizeButton;
+  char resizeByIncrement;
+  char frameNeedsDisplay;
+  unsigned char tabViewCount;
+  struct _NSSize resizeParameter;
+  int shadowState; 
+}
+
+- (id)initWithFrame:(struct _NSRect)fp8 styleMask:(unsigned int)fp24 owner:(id)fp28;
+- (id)initWithFrame:(struct _NSRect)fp8;
+
+@end
+
+@interface NSTitledFrame : NSFrameView
+{
+  int resizeFlags;
+  id fileButton;    
+  struct _NSSize titleCellSize;
+}
+
+- (id)initWithFrame:(struct _NSRect)fp8 styleMask:(unsigned int)fp24 owner:(id)fp28;
+- (float)_titlebarHeight;
++ (float)_titlebarHeight:(unsigned int)fp8;
+- (int)_numberOfTitlebarLines;
++ (float)_windowTitlebarTitleMinHeight:(unsigned int)fp8;
+- (float)_windowTitlebarTitleMinHeight;
+
+@end
+
+@interface NSThemeFrame : NSTitledFrame
+{
+  NSButton *toolbarButton;
+  int toolbarVisibleStatus;
+  NSImage *showToolbarTransitionImage;
+  struct _NSSize showToolbarPreWindowSize;
+  NSButton *modeButton;
+  int leftGroupTrackingTagNum;
+  int rightGroupTrackingTagNum;
+  char mouseInsideLeftGroup;
+  char mouseInsideRightGroup;
+  int widgetState;
+  NSString *displayName; 
+}
+
+- (id)initWithFrame:(struct _NSRect)fp8 styleMask:(unsigned int)fp24 owner:(id)fp28;
+- (float)_titlebarHeight;
++ (float)_titlebarHeight:(unsigned int)fp8;
+- (float)_windowTitlebarTitleMinHeight;
++ (float)_windowTitlebarTitleMinHeight:(unsigned int)fp8;
+
+@end
+
+
+// A ThemeFrame with no titlebar or resize indicator,
+
+@interface SongbirdThemeFrame : NSThemeFrame {}
+@end
+
+@implementation SongbirdThemeFrame
+
+- initWithFrame:(NSRect)frame styleMask:(int)sm owner:owner
+{
+  self = [super initWithFrame:frame styleMask:sm owner:owner];
+
+  if (self) {
+    NSWindow *window = [self window];
+    
+    // Turn off the standard window controls
+    [[window standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];
+    [[window standardWindowButton:NSWindowZoomButton] setHidden:YES];
+    [[window standardWindowButton:NSWindowCloseButton] setHidden:YES];
+
+    // Let the window paint its own resize indicator.
+    // Note that we are suppressing the graphic, and
+    // the resizer may still be functional.
+    [window setShowsResizeIndicator:NO];
+
+    [window setHasShadow:YES];
+  }
+  return self;
+}
+
+// Crush the titlebar, since the window will paint its own
+
++ (float)_windowTitlebarTitleMinHeight:(unsigned int)fp8 
+{
+  return 0;
+}
+
+- (int)titlebarHeight
+{
+  return 0;
+}
+
+- (float)_titlebarHeight
+{
+  return 0.0;
+}
+
+- (int)_numberOfTitlebarLines 
+{
+  return 0;
+}
+
+@end
+
+
+// Create a window that uses our special frame
+
+@interface NSWindow (Private)
++ (Class)frameViewClassForStyleMask:(unsigned int)mask;
+@end
+
+@implementation SongbirdWindow
+
++ (Class)frameViewClassForStyleMask:(unsigned int)styleMask
+{
+  return [SongbirdThemeFrame class];
+}
+
+- (id)initWithContentRect:(NSRect)contentRect 
+                styleMask:(unsigned int)aStyle 
+                  backing:(NSBackingStoreType)bufferingType 
+                    defer:(BOOL)flag
+{
+  if ((self = [super initWithContentRect:contentRect 
+                               styleMask:aStyle 
+                                 backing:bufferingType 
+                                   defer:flag])) 
+  {
+    [[NSNotificationCenter defaultCenter] addObserver:self 
+                                             selector:@selector(windowDidMove:)
+                                                 name:NSWindowDidMoveNotification 
+                                               object:self];
+    [[NSNotificationCenter defaultCenter] addObserver:self 
+                                             selector:@selector(windowDidMove:)
+                                                 name:NSWindowDidBecomeMainNotification 
+                                               object:self];
+    [[NSNotificationCenter defaultCenter] addObserver:self 
+                                             selector:@selector(windowDidMove:)
+                                                 name:NSWindowDidResignMainNotification 
+                                               object:self];
+  }
+  
+  return self;
+}
+
+- (void)dealloc
+{
+  [[NSNotificationCenter defaultCenter] removeObserver:self
+                                                  name:NSWindowDidMoveNotification
+                                                object:self];
+  [[NSNotificationCenter defaultCenter] removeObserver:self
+                                                  name:NSWindowDidBecomeMainNotification
+                                                object:self];
+  [[NSNotificationCenter defaultCenter] removeObserver:self
+                                                  name:NSWindowDidResignMainNotification
+                                                object:self];
+  [super dealloc];
+}
+
+- (void)windowDidMove:(NSNotification *)notification
+{
+  NSRect newFrame = [self frame];
+  NSRect screenFrame = [[NSScreen mainScreen] visibleFrame];
+  
+  // Prevent the window from going under the menubar:
+  if ((newFrame.origin.y + newFrame.size.height) > 
+      (screenFrame.origin.y + screenFrame.size.height))
+  {
+    newFrame.origin.y = 
+      screenFrame.origin.y + (screenFrame.size.height - newFrame.size.height);
+    [self setFrameOrigin:newFrame.origin];
+  }
+}
+
+// This is the un-documented function that enables any window to display the 
+// normal drop shadow to it. All borderless-windows (like |SongbirdWindow|) 
+// will never return |YES| here unless we override it.
+- (BOOL)_hasDarkShadow
+{
+  return YES;
+}
+
+- (void)windowDidBecomeMain:(NSNotification *)notification
+{
+  // since we are a borderless window - we need to send this event ourselves
+  // so that our shadow is updated correctly.
+  [self display];
+}
+ 
+- (void)windowDidResignMain:(NSNotification *)notification
+{
+  // since we are a borderless window - we need to send this event ourselves
+  // so that our shadow is updated correctly.
+  [self display];
+}
+
+@end
+
+/*************************************************************************
+ * END SONGBIRD HACK
+ ************************************************************************/
