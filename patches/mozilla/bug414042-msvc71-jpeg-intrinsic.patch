Index: jdapimin.c
===================================================================
RCS file: /cvsroot/mozilla/jpeg/jdapimin.c,v
retrieving revision 3.9
diff -u -8 -p -r3.9 jdapimin.c
--- jdapimin.c	25 Jan 2008 07:15:32 -0000	3.9
+++ jdapimin.c	25 Jan 2008 23:03:02 -0000
@@ -16,17 +16,16 @@
  * case.
  */
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
 #include "jpeglib.h"
 
 #ifdef HAVE_MMX_INTEL_MNEMONICS
-#include "intrin.h"
 int MMXAvailable;
 static int mmxsupport();
 #endif
 
 #ifdef HAVE_SSE2_INTRINSICS
 int SSE2Available = 0;
 #ifdef HAVE_SSE2_INTEL_MNEMONICS
 static int sse2support();
@@ -439,36 +438,78 @@ jpeg_finish_decompress (j_decompress_ptr
   jpeg_abort((j_common_ptr) cinfo);
   return TRUE;
 }
 
 
 #ifdef HAVE_MMX_INTEL_MNEMONICS
 static int mmxsupport()
 {
-  int CPUInfo[4];
+	int mmx_supported = 0;
+
+	_asm {
+		pushfd					//Save Eflag to stack
+		pop eax					//Get Eflag from stack into eax
+		mov ecx, eax			//Make another copy of Eflag in ecx
+		xor eax, 0x200000		//Toggle ID bit in Eflag [i.e. bit(21)] 
+		push eax				//Save modified Eflag back to stack
+
+		popfd					//Restored modified value back to Eflag reg 
+		pushfd					//Save Eflag to stack
+		pop eax					//Get Eflag from stack
+		xor eax, ecx			//Compare the new Eflag with the original Eflag
+		jz NOT_SUPPORTED		//If the same, CPUID instruction is not supported,
+								//skip following instructions and jump to
+								//NOT_SUPPORTED label
+
+		xor eax, eax			//Set eax to zero
+					
+		cpuid
+		
+		cmp eax, 1				//make sure eax return non-zero value
+		jl NOT_SUPPORTED		//If eax is zero, mmx not supported
+
+		xor eax, eax			//set eax to zero
+		inc eax					//Now increment eax to 1.  This instruction is 
+								//faster than the instruction "mov eax, 1"
+		
+		cpuid
+
+		and edx, 0x00800000		//mask out all bits but mmx bit(24)
+		cmp edx, 0				// 0 = mmx not supported
+		jz	NOT_SUPPORTED		// non-zero = Yes, mmx IS supported
+
+		mov	mmx_supported, 1	//set return value to 1
+
+NOT_SUPPORTED:
+		mov	eax, mmx_supported	//move return value to eax	
+
+	}
+
+	return mmx_supported;		
 
-  __cpuid(CPUInfo, 1);
-  if (CPUInfo[3] & (0x1 << 23))
-    return 1;
-  else
-    return 0;
 }
 #endif
 
 #ifdef HAVE_SSE2_INTEL_MNEMONICS
 static int sse2support()
 {
-  int CPUInfo[4];
+        int sse2available = 0;
+        int my_edx;
+        _asm
+        {
+                mov eax, 01                       
+                cpuid                                    
+                mov my_edx, edx    
+        }
+        if (my_edx & (0x1 << 26)) 
+                sse2available = 1; 
+        else sse2available = 2;
 
-  __cpuid(CPUInfo, 1);
-  if (CPUInfo[3] & (0x1 << 26))
-    return 1;
-  else
-    return 2;
+        return sse2available;
 }
 #else
 #ifdef HAVE_SSE2_INTRINSICS
 static int sse2supportGCC()
 {
 
   /* Mac Intel started with Core Duo chips which have SSE2 Support */
 
