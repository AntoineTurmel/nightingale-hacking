Index: widget/src/cocoa/nsChildView.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsChildView.h,v
retrieving revision 1.75
diff -u -p -r1.75 nsChildView.h
--- widget/src/cocoa/nsChildView.h	9 Oct 2007 18:46:31 -0000	1.75
+++ widget/src/cocoa/nsChildView.h	26 Oct 2007 02:30:39 -0000
@@ -111,6 +111,10 @@ union nsPluginPort;
   NSMutableArray* mPendingDirtyRects;
   BOOL mPendingFullDisplay;
 
+  // All views are always opaque (non-transparent). The only exception is when we're
+  // the content view in a transparent XUL window.
+  BOOL isTransparent;
+
   // Holds our drag service across multiple drag calls. The reference to the
   // service is obtained when the mouse enters the view and is released when
   // the mouse exits or there is a drop. This prevents us from having to
@@ -127,6 +131,7 @@ union nsPluginPort;
 
 // Stop NSView hierarchy being changed during [ChildView drawRect:]
 - (void)delayedTearDown;
+- (void)setTransparent:(BOOL)transparent;
 @end
 
 
@@ -293,12 +298,16 @@ public:
   NS_IMETHOD        StartDrawPlugin();
   NS_IMETHOD        EndDrawPlugin();
   
+  // translucency
+  NS_IMETHOD        GetWindowTranslucency(PRBool& aTranslucent);
+  NS_IMETHOD        SetWindowTranslucency(PRBool aTranslucent);
+  
   // Mac specific methods
   virtual PRBool    PointInWidget(Point aThePoint);
   
   virtual PRBool    DispatchWindowEvent(nsGUIEvent& event);
-  virtual void      AcceptFocusOnClick(PRBool aBool) { mAcceptFocusOnClick = aBool;};
-  PRBool            AcceptFocusOnClick() { return mAcceptFocusOnClick;};
+  virtual void      AcceptFocusOnClick(PRBool aBool) { mAcceptFocusOnClick = aBool; }
+  PRBool            AcceptFocusOnClick() { return mAcceptFocusOnClick; }
   
   void              LiveResizeStarted();
   void              LiveResizeEnded();
Index: widget/src/cocoa/nsChildView.mm
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsChildView.mm,v
retrieving revision 1.267
diff -u -p -r1.267 nsChildView.mm
--- widget/src/cocoa/nsChildView.mm	15 Oct 2007 12:35:57 -0000	1.267
+++ widget/src/cocoa/nsChildView.mm	26 Oct 2007 02:30:40 -0000
@@ -46,7 +46,6 @@
 
 #include "nsCOMPtr.h"
 #include "nsToolkit.h"
-#include "prmem.h"
 #include "nsCRT.h"
 #include "nsplugindefs.h"
 #include "nsThreadUtils.h"
@@ -149,8 +148,6 @@ nsIWidget         * gRollupWidget   = ns
 
 - (BOOL)childViewHasPlugin;
 
-- (BOOL)isRectObscuredBySubview:(NSRect)inRect;
-
 - (void)processPendingRedraws;
 
 - (BOOL)maybeRerouteMouseEventToRollupWidget:(NSEvent *)anEvent;
@@ -656,8 +653,34 @@ void* nsChildView::GetNativeData(PRUint3
 
 #pragma mark -
 
+NS_IMETHODIMP nsChildView::GetWindowTranslucency(PRBool& aTranslucent)
+{
+  aTranslucent = ![mView isOpaque];
+  return NS_OK;
+}
+
+// This is called by nsContainerFrame on the root widget for all window types
+// except popup windows (which nsCocoaWindow::SetWindowTranslucency is used instead)
+NS_IMETHODIMP nsChildView::SetWindowTranslucency(PRBool aTranslucent)
+{
+  BOOL currentTranslucency = ![[mView nativeWindow] isOpaque];
+  nsresult rv = NS_OK;
+  if (aTranslucent != currentTranslucency) {
+    // Find out if this is a window we created by seeing if the delegate is WindowDelegate. If it is,
+    // let the nsCocoaWindow take care of changing the window's translucency.
+    id windowDelegate = [[mView nativeWindow] delegate];
+    if (windowDelegate && [windowDelegate isKindOfClass:[WindowDelegate class]]) {
+      nsCocoaWindow *widget = [(WindowDelegate *)windowDelegate geckoWidget];
+      if (widget) {
+        widget->MakeWindowTranslucent(aTranslucent);
+        [mView setTransparent:aTranslucent];
+      }
+    }
+  }
+  return rv;
+}
+
 
-// Return PR_TRUE if the whether the component is visible, PR_FALSE otherwise
 NS_IMETHODIMP nsChildView::IsVisible(PRBool& outState)
 {
   if (!mVisible) {
@@ -2034,10 +2057,17 @@ NSEvent* gLastDragEvent = nil;
 }
 
 
+- (void)setTransparent:(BOOL)transparent
+{
+  if (isTransparent != transparent) {
+    isTransparent = transparent;
+  }
+}
+
+
 - (BOOL)isOpaque
 {
-  // this will be NO when we can do transparent windows/views
-  return YES;
+  return !isTransparent;
 }
 
 
@@ -2163,11 +2193,6 @@ NSEvent* gLastDragEvent = nil;
   PRBool isVisible;
   if (!mGeckoChild || NS_FAILED(mGeckoChild->IsVisible(isVisible)) || !isVisible)
     return;
-  
-  // Workaround for the fact that NSQuickDrawViews can't be opaque; see if the rect
-  // being drawn is covered by a subview, and, if so, just bail.
-  if ([self isRectObscuredBySubview:aRect])
-    return;
 
   CGContextRef cgContext = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
 
@@ -2254,19 +2279,6 @@ NSEvent* gLastDragEvent = nil;
 }
 
 
-- (BOOL)isRectObscuredBySubview:(NSRect)inRect
-{
-  unsigned int numSubviews = [[self subviews] count];
-  for (unsigned int i = 0; i < numSubviews; i++) {
-    NSRect subviewFrame = [[[self subviews] objectAtIndex:i] frame];
-    if (NSContainsRect(subviewFrame, inRect))
-      return YES;
-  }
-  
-  return NO;
-}
-
-
 // Allows us to turn off setting up the clip region
 // before each drawRect. We already clip within gecko.
 - (BOOL)wantsDefaultClipping
@@ -2589,7 +2601,7 @@ static nsEventStatus SendGeckoMouseEnter
 
 
 - (void)mouseMoved:(NSEvent*)theEvent
-{
+{ 
   NSPoint windowEventLocation = [theEvent locationInWindow];
   NSPoint screenEventLocation = [mWindow convertBaseToScreen:windowEventLocation];
   NSPoint viewEventLocation = [self convertPoint:windowEventLocation fromView:nil];
Index: widget/src/cocoa/nsCocoaWindow.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsCocoaWindow.h,v
retrieving revision 1.42
diff -u -p -r1.42 nsCocoaWindow.h
--- widget/src/cocoa/nsCocoaWindow.h	19 Oct 2007 15:47:58 -0000	1.42
+++ widget/src/cocoa/nsCocoaWindow.h	26 Oct 2007 02:30:40 -0000
@@ -199,6 +199,8 @@ public:
     NS_IMETHOD DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus) ;
     NS_IMETHOD CaptureRollupEvents(nsIRollupListener * aListener, PRBool aDoCapture, PRBool aConsumeRollupEvent);
     NS_IMETHOD GetAttention(PRInt32 aCycleCount);
+    NS_IMETHOD GetWindowTranslucency(PRBool& aTranslucent);
+    NS_IMETHOD SetWindowTranslucency(PRBool aTranslucent);
 
     virtual gfxASurface* GetThebesSurface();
 
@@ -212,6 +214,8 @@ public:
     
     // nsIKBStateControl interface
     NS_IMETHOD ResetInputState();
+    
+    void MakeWindowTranslucent(PRBool aTranslucency);
 
     NS_IMETHOD BeginSecureKeyboardInput();
     NS_IMETHOD EndSecureKeyboardInput();
Index: widget/src/cocoa/nsCocoaWindow.mm
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsCocoaWindow.mm,v
retrieving revision 1.110
diff -u -p -r1.110 nsCocoaWindow.mm
--- widget/src/cocoa/nsCocoaWindow.mm	19 Oct 2007 15:47:58 -0000	1.110
+++ widget/src/cocoa/nsCocoaWindow.mm	26 Oct 2007 02:30:40 -0000
@@ -1,4 +1,4 @@
-/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* -*- Mode: Objective-C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
@@ -64,6 +64,8 @@ extern BOOL                gSomeMenuBarP
 
 #define NS_APPSHELLSERVICE_CONTRACTID "@mozilla.org/appshell/appShellService;1"
 
+#define POPUP_DEFAULT_TRANSPARENCY 0.95
+
 NS_IMPL_ISUPPORTS_INHERITED1(nsCocoaWindow, Inherited, nsPIWidgetCocoa)
 
 
@@ -311,6 +313,7 @@ nsresult nsCocoaWindow::StandardCreate(n
 
     rect.origin.y -= (newWindowFrame.size.height - rect.size.height);
     
+    // XXXhakan: this should only be done on the screen showing the menubar
     if (mWindowType != eWindowType_popup)
       rect.origin.y -= ::GetMBarHeight();
 
@@ -334,7 +337,7 @@ nsresult nsCocoaWindow::StandardCreate(n
                                    backing:NSBackingStoreBuffered defer:NO];
     
     if (mWindowType == eWindowType_popup) {
-      [mWindow setAlphaValue:0.95];
+      [mWindow setAlphaValue:POPUP_DEFAULT_TRANSPARENCY];
       [mWindow setLevel:NSPopUpMenuWindowLevel];
       [mWindow setHasShadow:YES];
 
@@ -641,6 +644,44 @@ NS_IMETHODIMP nsCocoaWindow::Show(PRBool
   return NS_OK;
 }
 
+void nsCocoaWindow::MakeWindowTranslucent(PRBool aTranslucent)
+{
+  BOOL currentTranslucency = ![mWindow isOpaque];
+  if (aTranslucent != currentTranslucency) {
+    // Popups have an alpha value we need to toggle.
+    if (mWindowType == eWindowType_popup) {
+      [mWindow setAlphaValue:(aTranslucent ? 1.0 : POPUP_DEFAULT_TRANSPARENCY)];
+    }
+    [mWindow setBackgroundColor:(aTranslucent ? [NSColor clearColor] : [NSColor whiteColor])];
+    [mWindow setHasShadow:!aTranslucent];
+    [mWindow setOpaque:!aTranslucent];
+  }
+}
+
+NS_IMETHODIMP nsCocoaWindow::GetWindowTranslucency(PRBool& aTranslucent)
+{
+  aTranslucent = ![mWindow isOpaque];   
+  return NS_OK;
+}
+
+// This is called from nsMenuPopupFrame when making a popup translucent.
+// For other window types, nsChildView::SetWindowTranslucency is used.
+NS_IMETHODIMP nsCocoaWindow::SetWindowTranslucency(PRBool aTranslucent)
+{
+  BOOL currentTranslucency = ![mWindow isOpaque];
+  if (aTranslucent != currentTranslucency) {
+    // Take care of window translucency
+    MakeWindowTranslucent(aTranslucent);
+    // Make sure our content view is also translucent
+    if (mPopupContentView) {
+      ChildView *childView = (ChildView*)mPopupContentView->GetNativeData(NS_NATIVE_WIDGET);
+      if (childView) {
+        [childView setTransparent:aTranslucent];
+      }
+    }
+  }
+  return NS_OK;
+}
 
 NS_METHOD nsCocoaWindow::AddMouseListener(nsIMouseListener * aListener)
 {
