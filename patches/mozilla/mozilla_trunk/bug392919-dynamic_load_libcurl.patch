Index: toolkit/crashreporter/client/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/client/Makefile.in,v
retrieving revision 1.12
diff -u -8 -p -r1.12 Makefile.in
--- toolkit/crashreporter/client/Makefile.in	8 Aug 2007 15:19:59 -0000	1.12
+++ toolkit/crashreporter/client/Makefile.in	2 Oct 2007 04:22:43 -0000
@@ -81,17 +81,17 @@ endif
 
 ifeq ($(OS_ARCH),Linux)
 CPPSRCS += crashreporter_linux.cpp
 LIBS += \
   $(DEPTH)/toolkit/crashreporter/google-breakpad/src/common/linux/$(LIB_PREFIX)breakpad_linux_common_s.$(LIB_SUFFIX) \
   $(NULL)
 LOCAL_INCLUDES += -I$(srcdir)
 OS_CXXFLAGS += $(MOZ_GTK2_CFLAGS)
-OS_LIBS += $(MOZ_GTK2_LIBS) -lcurl
+OS_LIBS += $(MOZ_GTK2_LIBS)
 CPPSRCS += http_upload.cc
 FORCE_USE_PIC=1
 endif
 
 include $(topsrcdir)/config/rules.mk
 
 ifeq ($(OS_ARCH),Darwin)
 libs::
Index: toolkit/crashreporter/google-breakpad/src/common/linux/http_upload.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/linux/http_upload.cc,v
retrieving revision 1.1
diff -u -8 -p -r1.1 http_upload.cc
--- toolkit/crashreporter/google-breakpad/src/common/linux/http_upload.cc	25 Jul 2007 01:06:12 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/common/linux/http_upload.cc	2 Oct 2007 04:22:44 -0000
@@ -23,16 +23,17 @@
 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <cassert>
+#include <dlfcn.h>
 #include <curl/curl.h>
 #include <curl/easy.h>
 #include <curl/types.h>
 
 #include "common/linux/http_upload.h"
 
 namespace {
 
@@ -60,75 +61,106 @@ bool HTTPUpload::SendRequest(const strin
                              const string &upload_file,
                              const string &file_part_name,
                              const string &proxy,
                              const string &proxy_user_pwd,
                              string *response_body) {
   if (!CheckParameters(parameters))
     return false;
 
-  CURL *curl = curl_easy_init();
-  CURLcode err_code = CURLE_OK;
+  void *curlLib = dlopen("libcurl.so.4", RTLD_NOW);
+  if (!curlLib) {
+    curlLib = dlopen("libcurl.so.3", RTLD_NOW);
+  }
+  if (!curlLib) {
+    return false;
+  }
 
-  if (curl) {
-    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
-    curl_easy_setopt(curl, CURLOPT_USERAGENT, kUserAgent);
-    // Set proxy information if necessary.
-    if (!proxy.empty())
-      curl_easy_setopt(curl, CURLOPT_PROXY, proxy.c_str());
-    if (!proxy_user_pwd.empty())
-      curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, proxy_user_pwd.c_str());
-
-    struct curl_httppost *formpost = NULL;
-    struct curl_httppost *lastptr = NULL;
-    // Add form data.
-    map<string, string>::const_iterator iter = parameters.begin();
-    for (; iter != parameters.end(); ++iter)
-      curl_formadd(&formpost, &lastptr,
-                   CURLFORM_COPYNAME, iter->first.c_str(),
-                   CURLFORM_COPYCONTENTS, iter->second.c_str(),
-                   CURLFORM_END);
-
-    // Add form file.
-    curl_formadd(&formpost, &lastptr,
-                 CURLFORM_COPYNAME, file_part_name.c_str(),
-                 CURLFORM_FILE, upload_file.c_str(),
-                 CURLFORM_END);
+  CURL* (*curl_easy_init)(void);
+  *(void**) (&curl_easy_init) = dlsym(curlLib, "curl_easy_init");
+  CURL *curl = (*curl_easy_init)();
 
-    curl_easy_setopt(curl, CURLOPT_HTTPPOST, formpost);
+  if (!curl) {
+    dlclose(curlLib);
+    return false;
+  }
 
-    // Disable 100-continue header.
-    struct curl_slist *headerlist = NULL;
-    char buf[] = "Expect:";
-    headerlist = curl_slist_append(headerlist, buf);
-    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist);
-
-    if (response_body != NULL) {
-      curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
-      curl_easy_setopt(curl, CURLOPT_WRITEDATA,
-                       reinterpret_cast<void *>(response_body));
-    }
+  CURLcode err_code = CURLE_OK;
+  CURLcode (*curl_easy_setopt)(CURL *, CURLoption, ...);
+  *(void**) (&curl_easy_setopt) = dlsym(curlLib, "curl_easy_setopt");
+  (*curl_easy_setopt)(curl, CURLOPT_URL, url.c_str());
+  (*curl_easy_setopt)(curl, CURLOPT_USERAGENT, kUserAgent);
+  // Set proxy information if necessary.
+  if (!proxy.empty())
+    (*curl_easy_setopt)(curl, CURLOPT_PROXY, proxy.c_str());
+  if (!proxy_user_pwd.empty())
+    (*curl_easy_setopt)(curl, CURLOPT_PROXYUSERPWD, proxy_user_pwd.c_str());
+
+  struct curl_httppost *formpost = NULL;
+  struct curl_httppost *lastptr = NULL;
+  // Add form data.
+  CURLFORMcode (*curl_formadd)(struct curl_httppost **, struct curl_httppost **, ...);
+  *(void**) (&curl_formadd) = dlsym(curlLib, "curl_formadd");
+  dlerror();
+  map<string, string>::const_iterator iter = parameters.begin();
+  for (; iter != parameters.end(); ++iter)
+    (*curl_formadd)(&formpost, &lastptr,
+                 CURLFORM_COPYNAME, iter->first.c_str(),
+                 CURLFORM_COPYCONTENTS, iter->second.c_str(),
+                 CURLFORM_END);
 
-    err_code = curl_easy_perform(curl);
+  // Add form file.
+  (*curl_formadd)(&formpost, &lastptr,
+               CURLFORM_COPYNAME, file_part_name.c_str(),
+               CURLFORM_FILE, upload_file.c_str(),
+               CURLFORM_END);
+
+  (*curl_easy_setopt)(curl, CURLOPT_HTTPPOST, formpost);
+
+  // Disable 100-continue header.
+  struct curl_slist *headerlist = NULL;
+  char buf[] = "Expect:";
+  struct curl_slist* (*curl_slist_append)(struct curl_slist *, const char *);
+  *(void**) (&curl_slist_append) = dlsym(curlLib, "curl_slist_append");
+  headerlist = (*curl_slist_append)(headerlist, buf);
+  (*curl_easy_setopt)(curl, CURLOPT_HTTPHEADER, headerlist);
+
+  if (response_body != NULL) {
+    (*curl_easy_setopt)(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
+    (*curl_easy_setopt)(curl, CURLOPT_WRITEDATA,
+                     reinterpret_cast<void *>(response_body));
+  }
+
+  CURLcode (*curl_easy_perform)(CURL *);
+  *(void**) (&curl_easy_perform) = dlsym(curlLib, "curl_easy_perform");
+  err_code = (*curl_easy_perform)(curl);
 #ifndef NDEBUG
-    if (err_code != CURLE_OK)
-      fprintf(stderr, "Failed to send http request to %s, error: %s\n",
-              url.c_str(),
-              curl_easy_strerror(err_code));
+  const char* (*curl_easy_strerror)(CURLcode);
+  *(void**) (&curl_easy_strerror) = dlsym(curlLib, "curl_easy_strerror");
+  if (err_code != CURLE_OK)
+    fprintf(stderr, "Failed to send http request to %s, error: %s\n",
+            url.c_str(),
+            (*curl_easy_strerror)(err_code));
 #endif
 
-    if (curl != NULL)
-      curl_easy_cleanup(curl);
-    if (formpost != NULL)
-      curl_formfree(formpost);
-    if (headerlist != NULL)
-      curl_slist_free_all(headerlist);
-    return err_code == CURLE_OK;
+  void (*curl_easy_cleanup)(CURL *);
+  *(void**) (&curl_easy_cleanup) = dlsym(curlLib, "curl_easy_cleanup");
+  (*curl_easy_cleanup)(curl);
+  if (formpost != NULL) {
+    void (*curl_formfree)(struct curl_httppost *);
+    *(void**) (&curl_formfree) = dlsym(curlLib, "curl_formfree");
+    (*curl_formfree)(formpost);
+  }
+  if (headerlist != NULL) {
+    void (*curl_slist_free_all)(struct curl_slist *);
+    *(void**) (&curl_slist_free_all) = dlsym(curlLib, "curl_slist_free_all");
+    (*curl_slist_free_all)(headerlist);
   }
-  return false;
+  dlclose(curlLib);
+  return err_code == CURLE_OK;
 }
 
 // static
 bool HTTPUpload::CheckParameters(const map<string, string> &parameters) {
   for (map<string, string>::const_iterator pos = parameters.begin();
        pos != parameters.end(); ++pos) {
     const string &str = pos->first;
     if (str.size() == 0)
