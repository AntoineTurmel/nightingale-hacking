Index: js/src/xpconnect/idl/nsIXPConnect.idl
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/idl/nsIXPConnect.idl,v
retrieving revision 1.55
diff -u -p -r1.55 nsIXPConnect.idl
--- js/src/xpconnect/idl/nsIXPConnect.idl	31 Aug 2007 00:52:58 -0000	1.55
+++ js/src/xpconnect/idl/nsIXPConnect.idl	14 Sep 2007 17:02:18 -0000
@@ -675,6 +675,17 @@ interface nsIXPConnect : nsISupports
     void flagSystemFilenamePrefix(in string aFilenamePrefix);
 
     /**
+     * Get a native pointer of type aIID from aJSObject if the object
+     * is a wrapped native or a wrapped JS object, but never create a
+     * new wrapper, only use existing ones.
+     */
+    void
+    getNativeOfJSObject(in JSContextPtr aJSContext,
+                        in JSObjectPtr  aJSObj,
+                        in nsIIDRef     aIID,
+                        [iid_is(aIID),retval] out nsQIResult result);
+
+    /**
      * Restore an old prototype for wrapped natives of type
      * aClassInfo. This should be used only when restoring an old
      * scope into a state close to where it was prior to
Index: js/src/xpconnect/src/XPCDispConvert.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/XPCDispConvert.cpp,v
retrieving revision 1.17
diff -u -p -r1.17 XPCDispConvert.cpp
--- js/src/xpconnect/src/XPCDispConvert.cpp	31 Aug 2007 00:52:58 -0000	1.17
+++ js/src/xpconnect/src/XPCDispConvert.cpp	14 Sep 2007 17:02:18 -0000
@@ -331,6 +331,7 @@ JSBool XPCDispConvert::JSToCOM(XPCCallCo
                 obj, 
                 &NSID_IDISPATCH,
                 nsnull, 
+                PR_TRUE, 
                 &err))
             {
                 // Avoid cleaning up garbage
Index: js/src/xpconnect/src/nsXPConnect.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/nsXPConnect.cpp,v
retrieving revision 1.130
diff -u -p -r1.130 nsXPConnect.cpp
--- js/src/xpconnect/src/nsXPConnect.cpp	31 Aug 2007 00:52:58 -0000	1.130
+++ js/src/xpconnect/src/nsXPConnect.cpp	14 Sep 2007 17:02:18 -0000
@@ -1112,7 +1112,7 @@ nsXPConnect::WrapJS(JSContext * aJSConte
 
     nsresult rv;
     if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
-                                             &aIID, nsnull, &rv))
+                                             &aIID, nsnull, PR_TRUE, &rv))
         return rv;
     return NS_OK;
 }
@@ -1138,7 +1138,7 @@ nsXPConnect::WrapJSAggregatedToNative(ns
 
     nsresult rv;
     if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
-                                             &aIID, aOuter, &rv))
+                                             &aIID, aOuter, PR_TRUE, &rv))
         return rv;
     return NS_OK;
 }
@@ -2097,6 +2097,30 @@ nsXPConnect::OnDispatchedEvent(nsIThread
     return NS_ERROR_UNEXPECTED;
 }
 
+/* void getNativeOfJSObject(in JSContextPtr aJSContext, in JSObjectPtr aJSObj, in nsIIDRef aIID, [iid_is(aIID),retval] out nsQIResult result); */
+NS_IMETHODIMP
+nsXPConnect::GetNativeOfJSObject(JSContext * aJSContext,
+                                 JSObject * aJSObj,
+                                 const nsIID & aIID,
+                                 void * *result)
+{
+    NS_ASSERTION(aJSContext, "bad param");
+    NS_ASSERTION(aJSObj, "bad param");
+    NS_ASSERTION(result, "bad param");
+
+    *result = nsnull;
+
+    XPCCallContext ccx(NATIVE_CALLER, aJSContext);
+    if(!ccx.IsValid())
+        return UnexpectedFailure(NS_ERROR_FAILURE);
+
+    nsresult rv;
+    if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
+                                             &aIID, nsnull, PR_FALSE, &rv))
+        return rv;
+    return NS_OK;
+}
+
 #ifdef DEBUG
 /* These are here to be callable from a debugger */
 JS_BEGIN_EXTERN_C
Index: js/src/xpconnect/src/xpcconvert.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcconvert.cpp,v
retrieving revision 1.115
diff -u -p -r1.115 xpcconvert.cpp
--- js/src/xpconnect/src/xpcconvert.cpp	31 Aug 2007 00:52:58 -0000	1.115
+++ js/src/xpconnect/src/xpcconvert.cpp	14 Sep 2007 17:02:18 -0000
@@ -1030,7 +1030,7 @@ XPCConvert::JSData2Native(XPCCallContext
             }
 
             return JSObject2NativeInterface(ccx, (void**)d, obj, iid,
-                                            nsnull, pErr);
+                                            nsnull, PR_TRUE, pErr);
         }
         default:
             NS_ASSERTION(0, "bad type");
@@ -1230,6 +1230,7 @@ XPCConvert::JSObject2NativeInterface(XPC
                                      void** dest, JSObject* src,
                                      const nsID* iid,
                                      nsISupports* aOuter,
+                                     PRBool createNew,
                                      nsresult* pErr)
 {
     NS_ASSERTION(dest, "bad param");
@@ -1239,7 +1240,7 @@ XPCConvert::JSObject2NativeInterface(XPC
     JSContext* cx = ccx.GetJSContext();
 
     *dest = nsnull;
-     if(pErr)
+    if(pErr)
         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS;
 
     nsISupports* iface;
@@ -1288,8 +1289,15 @@ XPCConvert::JSObject2NativeInterface(XPC
 
     // else...
 
+    nsresult rv;
+
     nsXPCWrappedJS* wrapper;
-    nsresult rv = nsXPCWrappedJS::GetNewOrUsed(ccx, src, *iid, aOuter, &wrapper);
+    if (createNew) {
+        rv = nsXPCWrappedJS::GetNewOrUsed(ccx, src, *iid, aOuter, &wrapper);
+    } else {
+        rv = nsXPCWrappedJS::GetUsedOnly(ccx, src, *iid, aOuter, &wrapper);
+    }
+
     if(pErr)
         *pErr = rv;
     if(NS_SUCCEEDED(rv) && wrapper)
Index: js/src/xpconnect/src/xpcprivate.h
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcprivate.h,v
retrieving revision 1.231
diff -u -p -r1.231 xpcprivate.h
--- js/src/xpconnect/src/xpcprivate.h	31 Aug 2007 00:52:58 -0000	1.231
+++ js/src/xpconnect/src/xpcprivate.h	14 Sep 2007 17:02:18 -0000
@@ -2356,6 +2356,12 @@ public:
                  REFNSIID aIID,
                  nsISupports* aOuter,
                  nsXPCWrappedJS** wrapper);
+    static nsresult
+    GetUsedOnly(XPCCallContext& ccx,
+                JSObject* aJSObj,
+                REFNSIID aIID,
+                nsISupports* aOuter,
+                nsXPCWrappedJS** wrapperResult);
 
     nsISomeInterface* GetXPTCStub() { return mXPTCStub; }
     JSObject* GetJSObject() const {return mJSObj;}
@@ -2531,6 +2537,7 @@ public:
                                            void** dest, JSObject* src,
                                            const nsID* iid,
                                            nsISupports* aOuter,
+                                           PRBool createNew,
                                            nsresult* pErr);
 
     /**
Index: js/src/xpconnect/src/xpcwrappedjs.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcwrappedjs.cpp,v
retrieving revision 1.59
diff -u -p -r1.59 xpcwrappedjs.cpp
--- js/src/xpconnect/src/xpcwrappedjs.cpp	31 Aug 2007 00:52:58 -0000	1.59
+++ js/src/xpconnect/src/xpcwrappedjs.cpp	14 Sep 2007 17:02:18 -0000
@@ -417,6 +417,68 @@ return_wrapper:
     return NS_OK;
 }
 
+// static
+nsresult
+nsXPCWrappedJS::GetUsedOnly(XPCCallContext& ccx,
+                            JSObject* aJSObj,
+                            REFNSIID aIID,
+                            nsISupports* aOuter,
+                            nsXPCWrappedJS** wrapperResult)
+{
+    JSObject2WrappedJSMap* map;
+    JSBool hasProp;
+    JSObject* rootJSObj;
+    nsXPCWrappedJS* root;
+    nsXPCWrappedJS* wrapper = nsnull;
+    nsXPCWrappedJSClass *clazz = nsnull;
+    XPCJSRuntime* rt = ccx.GetRuntime();
+
+    map = rt->GetWrappedJSMap();
+    if(!map)
+    {
+        NS_ASSERTION(map,"bad map");
+        return NS_ERROR_FAILURE;
+    }
+
+    nsXPCWrappedJSClass::GetNewOrUsed(ccx, aIID, &clazz);
+    if(!clazz)
+        return NS_ERROR_FAILURE;
+
+    // GetRootJSObject will attempt to call a QueryInterface function on
+    // aJSObj. If QueryInterface doesn't exist on the object then a strict
+    // warning will be emitted, so check to make sure that the QueryInterface
+    // function exists before proceeding.
+    if(JS_HasProperty(ccx.GetJSContext(), aJSObj,
+                      rt->GetStringName(XPCJSRuntime::IDX_QUERY_INTERFACE),
+                      &hasProp) && hasProp)
+        rootJSObj = clazz->GetRootJSObject(ccx, aJSObj);
+    else
+        rootJSObj = aJSObj;
+
+    NS_RELEASE(clazz);
+
+    if(!rootJSObj)
+        return NS_ERROR_FAILURE;
+
+    // look for the root wrapper
+    {   // scoped lock
+        XPCAutoLock lock(rt->GetMapLock());
+        root = map->Find(rootJSObj);
+    }
+
+    if(root)
+    {
+        if((nsnull != (wrapper = root->Find(aIID))) ||
+           (nsnull != (wrapper = root->FindInherited(aIID))))
+        {
+            NS_ADDREF(wrapper);
+        }
+    }
+
+    *wrapperResult = wrapper;
+    return NS_OK;
+}
+
 nsXPCWrappedJS::nsXPCWrappedJS(XPCCallContext& ccx,
                                JSObject* aJSObj,
                                nsXPCWrappedJSClass* aClass,
Index: caps/src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.323
diff -u -p -r1.323 nsScriptSecurityManager.cpp
--- caps/src/nsScriptSecurityManager.cpp	6 Sep 2007 07:02:57 -0000	1.323
+++ caps/src/nsScriptSecurityManager.cpp	14 Sep 2007 17:02:18 -0000
@@ -565,6 +565,12 @@ nsScriptSecurityManager::CheckObjectAcce
     if (!ssm)
         return JS_FALSE;
 
+    nsCOMPtr<nsISupports> native;
+    nsresult rv =
+        sXPConnect->GetNativeOfJSObject(cx, obj,
+                                        NS_GET_IID(nsISupports),
+                                        getter_AddRefs(native));
+
     // Get the object being accessed.  We protect these cases:
     // 1. The Function.prototype.caller property's value, which might lead
     //    an attacker up a call-stack to a function or another object from
@@ -577,11 +583,13 @@ nsScriptSecurityManager::CheckObjectAcce
 
     // Do the same-origin check -- this sets a JS exception if the check fails.
     // Pass the parent object's class name, as we have no class-info for it.
-    nsresult rv =
-        ssm->CheckPropertyAccess(cx, target, JS_GetClass(cx, obj)->name, id,
-                                 (mode & JSACC_WRITE) ?
-                                 nsIXPCSecurityManager::ACCESS_SET_PROPERTY :
-                                 nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
+    rv = ssm->CheckPropertyAccessImpl(( (mode & JSACC_WRITE) ?
+                                        nsIXPCSecurityManager::ACCESS_SET_PROPERTY :
+                                        nsIXPCSecurityManager::ACCESS_GET_PROPERTY ),
+                                      nsnull, cx, target, native, nsnull,
+                                      nsnull, JS_GET_CLASS(cx, obj)->name, id,
+                                      nsnull);
+
 
     if (NS_FAILED(rv))
         return JS_FALSE; // Security check failed (XXX was an error reported?)
@@ -843,14 +851,24 @@ nsScriptSecurityManager::CheckPropertyAc
     nsXPIDLCString objectSecurityLevel;
     if (checkedComponent)
     {
-        nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
-        nsCOMPtr<nsIInterfaceInfo> interfaceInfo;
-        const nsIID* objIID;
-        rv = aCallContext->GetCalleeWrapper(getter_AddRefs(wrapper));
-        if (NS_SUCCEEDED(rv))
-            rv = wrapper->FindInterfaceWithMember(aProperty, getter_AddRefs(interfaceInfo));
-        if (NS_SUCCEEDED(rv))
-            rv = interfaceInfo->GetIIDShared(&objIID);
+        const nsIID* objIID = nsnull;
+        if (aCallContext) {
+            // If we have a call context, find the wrapper and the IID
+            // with the member in question to pass to
+            // nsISecurityCheckedComponent, if not, pass a null IID
+            // and it's up to the implementation to decide if it wants
+            // to permit access or not.
+            nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
+            nsCOMPtr<nsIInterfaceInfo> interfaceInfo;
+            rv = aCallContext->GetCalleeWrapper(getter_AddRefs(wrapper));
+            if (NS_SUCCEEDED(rv))
+                rv = wrapper->FindInterfaceWithMember(aProperty, getter_AddRefs(interfaceInfo));
+            if (NS_SUCCEEDED(rv))
+                rv = interfaceInfo->GetIIDShared(&objIID);
+        } else {
+            rv = NS_OK;
+        }
+
         if (NS_SUCCEEDED(rv))
         {
             switch (aAction)
