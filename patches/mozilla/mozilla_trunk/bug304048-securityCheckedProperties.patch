? js/src/xpconnect/src/sanity.diff
Index: js/src/xpconnect/idl/nsIXPConnect.idl
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/idl/nsIXPConnect.idl,v
retrieving revision 1.50
diff -u -8 -p -r1.50 nsIXPConnect.idl
--- js/src/xpconnect/idl/nsIXPConnect.idl	2 May 2007 20:20:21 -0000	1.50
+++ js/src/xpconnect/idl/nsIXPConnect.idl	28 Jun 2007 22:02:59 -0000
@@ -670,16 +670,27 @@ interface nsIXPConnect : nsISupports
      * automatically wrapped with an XPCNativeWrapper.
      *
      * @param aFilenamePrefix the UTF-8 filename prefix to match, which
      *                        should end with a slash (/) character
      */
     void flagSystemFilenamePrefix(in string aFilenamePrefix);
 
     /**
+     * Get a native pointer of type aIID from aJSObject if the object
+     * is a wrapped native or a wrapped JS object, but never create a
+     * new wrapper, only use existing ones.
+     */
+    void
+    getNativeOfJSObject(in JSContextPtr aJSContext,
+                        in JSObjectPtr  aJSObj,
+                        in nsIIDRef     aIID,
+                        [iid_is(aIID),retval] out nsQIResult result);
+
+    /**
      * Restore an old prototype for wrapped natives of type
      * aClassInfo. This should be used only when restoring an old
      * scope into a state close to where it was prior to
      * being reinitialized.
      */
     void restoreWrappedNativePrototype(in JSContextPtr aJSContext,
                                        in JSObjectPtr  aScope,
                                        in nsIClassInfo aClassInfo,
Index: js/src/xpconnect/src/XPCDispConvert.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/XPCDispConvert.cpp,v
retrieving revision 1.14
diff -u -8 -p -r1.14 XPCDispConvert.cpp
--- js/src/xpconnect/src/XPCDispConvert.cpp	5 Apr 2006 21:34:16 -0000	1.14
+++ js/src/xpconnect/src/XPCDispConvert.cpp	28 Jun 2007 22:02:59 -0000
@@ -326,16 +326,17 @@ JSBool XPCDispConvert::JSToCOM(XPCCallCo
             JSObject * obj = JSVAL_TO_OBJECT(src);
             IUnknown * pUnknown = nsnull;
             if(!XPCConvert::JSObject2NativeInterface(
                 ccx, 
                 (void**)&pUnknown, 
                 obj, 
                 &NSID_IDISPATCH,
                 nsnull, 
+                PR_TRUE, 
                 &err))
             {
                 // Avoid cleaning up garbage
                 varDest->vt = VT_EMPTY;
                 return JS_FALSE;
             }
             varDest->vt = VT_DISPATCH;
             pUnknown->QueryInterface(IID_IDispatch, 
Index: js/src/xpconnect/src/nsXPConnect.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/nsXPConnect.cpp,v
retrieving revision 1.112
diff -u -8 -p -r1.112 nsXPConnect.cpp
--- js/src/xpconnect/src/nsXPConnect.cpp	4 Jun 2007 10:01:34 -0000	1.112
+++ js/src/xpconnect/src/nsXPConnect.cpp	28 Jun 2007 22:02:59 -0000
@@ -1049,17 +1049,17 @@ nsXPConnect::WrapJS(JSContext * aJSConte
     *result = nsnull;
 
     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     if(!ccx.IsValid())
         return UnexpectedFailure(NS_ERROR_FAILURE);
 
     nsresult rv;
     if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
-                                             &aIID, nsnull, &rv))
+                                             &aIID, nsnull, PR_TRUE, &rv))
         return rv;
     return NS_OK;
 }
 
 /* void wrapJSAggregatedToNative (in nsISupports aOuter, in JSContextPtr aJSContext, in JSObjectPtr aJSObj, in nsIIDRef aIID, [iid_is (aIID), retval] out nsQIResult result); */
 NS_IMETHODIMP
 nsXPConnect::WrapJSAggregatedToNative(nsISupports *aOuter,
                                       JSContext * aJSContext,
@@ -1075,17 +1075,17 @@ nsXPConnect::WrapJSAggregatedToNative(ns
     *result = nsnull;
 
     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     if(!ccx.IsValid())
         return UnexpectedFailure(NS_ERROR_FAILURE);
 
     nsresult rv;
     if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
-                                             &aIID, aOuter, &rv))
+                                             &aIID, aOuter, PR_TRUE, &rv))
         return rv;
     return NS_OK;
 }
 
 /* nsIXPConnectWrappedNative getWrappedNativeOfJSObject (in JSContextPtr aJSContext, in JSObjectPtr aJSObj); */
 NS_IMETHODIMP
 nsXPConnect::GetWrappedNativeOfJSObject(JSContext * aJSContext,
                                         JSObject * aJSObj,
@@ -1996,16 +1996,40 @@ nsXPConnect::FlagSystemFilenamePrefix(co
     if(NS_FAILED(rv))
         return rv;
 
     if(!JS_FlagScriptFilenamePrefix(rt, aFilenamePrefix, JSFILENAME_SYSTEM))
         return NS_ERROR_OUT_OF_MEMORY;
     return NS_OK;
 }
 
+/* void getNativeOfJSObject(in JSContextPtr aJSContext, in JSObjectPtr aJSObj, in nsIIDRef aIID, [iid_is(aIID),retval] out nsQIResult result); */
+NS_IMETHODIMP
+nsXPConnect::GetNativeOfJSObject(JSContext * aJSContext,
+                                 JSObject * aJSObj,
+                                 const nsIID & aIID,
+                                 void * *result)
+{
+    NS_ASSERTION(aJSContext, "bad param");
+    NS_ASSERTION(aJSObj, "bad param");
+    NS_ASSERTION(result, "bad param");
+
+    *result = nsnull;
+
+    XPCCallContext ccx(NATIVE_CALLER, aJSContext);
+    if(!ccx.IsValid())
+        return UnexpectedFailure(NS_ERROR_FAILURE);
+
+    nsresult rv;
+    if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
+                                             &aIID, nsnull, PR_FALSE, &rv))
+        return rv;
+    return NS_OK;
+}
+
 #ifdef DEBUG
 /* These are here to be callable from a debugger */
 JS_BEGIN_EXTERN_C
 void DumpJSStack()
 {
     nsresult rv;
     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
     if(NS_SUCCEEDED(rv) && xpc)
Index: js/src/xpconnect/src/xpcconvert.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcconvert.cpp,v
retrieving revision 1.111
diff -u -8 -p -r1.111 xpcconvert.cpp
--- js/src/xpconnect/src/xpcconvert.cpp	28 Feb 2007 02:33:05 -0000	1.111
+++ js/src/xpconnect/src/xpcconvert.cpp	28 Jun 2007 22:03:00 -0000
@@ -1024,17 +1024,17 @@ XPCConvert::JSData2Native(XPCCallContext
             if(!JSVAL_IS_OBJECT(s) || !(obj = JSVAL_TO_OBJECT(s)))
             {
                 if(pErr && JSVAL_IS_INT(s) && 0 == JSVAL_TO_INT(s))
                     *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL;
                 return JS_FALSE;
             }
 
             return JSObject2NativeInterface(ccx, (void**)d, obj, iid,
-                                            nsnull, pErr);
+                                            nsnull, PR_TRUE, pErr);
         }
         default:
             NS_ASSERTION(0, "bad type");
             return JS_FALSE;
         }
     }
     return JS_TRUE;
 }
@@ -1202,26 +1202,27 @@ XPCConvert::NativeInterface2JSObject(XPC
 /***************************************************************************/
 
 // static
 JSBool
 XPCConvert::JSObject2NativeInterface(XPCCallContext& ccx,
                                      void** dest, JSObject* src,
                                      const nsID* iid,
                                      nsISupports* aOuter,
+                                     PRBool createNew,
                                      nsresult* pErr)
 {
     NS_ASSERTION(dest, "bad param");
     NS_ASSERTION(src, "bad param");
     NS_ASSERTION(iid, "bad param");
 
     JSContext* cx = ccx.GetJSContext();
 
     *dest = nsnull;
-     if(pErr)
+    if(pErr)
         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS;
 
     nsISupports* iface;
 
     if(!aOuter)
     {
         // Note that if we have a non-null aOuter then it means that we are
         // forcing the creation of a wrapper even if the object *is* a 
@@ -1260,18 +1261,25 @@ XPCConvert::JSObject2NativeInterface(XPC
                 return NS_SUCCEEDED(iface->QueryInterface(*iid, dest));
 
             return JS_FALSE;
         }
     }
 
     // else...
 
+    nsresult rv;
+
     nsXPCWrappedJS* wrapper;
-    nsresult rv = nsXPCWrappedJS::GetNewOrUsed(ccx, src, *iid, aOuter, &wrapper);
+    if (createNew) {
+        rv = nsXPCWrappedJS::GetNewOrUsed(ccx, src, *iid, aOuter, &wrapper);
+    } else {
+        rv = nsXPCWrappedJS::GetUsedOnly(ccx, src, *iid, aOuter, &wrapper);
+    }
+
     if(pErr)
         *pErr = rv;
     if(NS_SUCCEEDED(rv) && wrapper)
     {
         // We need to go through the QueryInterface logic to make this return
         // the right thing for the various 'special' interfaces; e.g. 
         // nsIPropertyBag. We must use AggregatedQueryInterface in cases where 
         // there is an outer to avoid nasty recursion.
Index: js/src/xpconnect/src/xpcprivate.h
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcprivate.h,v
retrieving revision 1.215
diff -u -8 -p -r1.215 xpcprivate.h
--- js/src/xpconnect/src/xpcprivate.h	2 Jun 2007 15:11:52 -0000	1.215
+++ js/src/xpconnect/src/xpcprivate.h	28 Jun 2007 22:03:00 -0000
@@ -2330,16 +2330,22 @@ public:
     */
 
     static nsresult
     GetNewOrUsed(XPCCallContext& ccx,
                  JSObject* aJSObj,
                  REFNSIID aIID,
                  nsISupports* aOuter,
                  nsXPCWrappedJS** wrapper);
+    static nsresult
+    GetUsedOnly(XPCCallContext& ccx,
+                JSObject* aJSObj,
+                REFNSIID aIID,
+                nsISupports* aOuter,
+                nsXPCWrappedJS** wrapperResult);
 
     nsISomeInterface* GetXPTCStub() { return mXPTCStub; }
     JSObject* GetJSObject() const {return mJSObj;}
     nsXPCWrappedJSClass*  GetClass() const {return mClass;}
     REFNSIID GetIID() const {return GetClass()->GetIID();}
     nsXPCWrappedJS* GetRootWrapper() const {return mRoot;}
     nsXPCWrappedJS* GetNextWrapper() const {return mNext;}
 
@@ -2505,16 +2511,17 @@ public:
     static JSBool GetNativeInterfaceFromJSObject(XPCCallContext& ccx,
                                                  void** dest, JSObject* src,
                                                  const nsID* iid, 
                                                  nsresult* pErr);
     static JSBool JSObject2NativeInterface(XPCCallContext& ccx,
                                            void** dest, JSObject* src,
                                            const nsID* iid,
                                            nsISupports* aOuter,
+                                           PRBool createNew,
                                            nsresult* pErr);
 
     /**
      * Convert a native array into a jsval.
      *
      * @param ccx the context for the whole procedure
      * @param d [out] the resulting jsval
      * @param s the native array we're working with
Index: js/src/xpconnect/src/xpcwrappedjs.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcwrappedjs.cpp,v
retrieving revision 1.55
diff -u -8 -p -r1.55 xpcwrappedjs.cpp
--- js/src/xpconnect/src/xpcwrappedjs.cpp	2 Jun 2007 15:11:52 -0000	1.55
+++ js/src/xpconnect/src/xpcwrappedjs.cpp	28 Jun 2007 22:03:00 -0000
@@ -412,16 +412,78 @@ return_wrapper:
 
     if(!wrapper)
         return NS_ERROR_FAILURE;
 
     *wrapperResult = wrapper;
     return NS_OK;
 }
 
+// static
+nsresult
+nsXPCWrappedJS::GetUsedOnly(XPCCallContext& ccx,
+                            JSObject* aJSObj,
+                            REFNSIID aIID,
+                            nsISupports* aOuter,
+                            nsXPCWrappedJS** wrapperResult)
+{
+    JSObject2WrappedJSMap* map;
+    JSBool hasProp;
+    JSObject* rootJSObj;
+    nsXPCWrappedJS* root;
+    nsXPCWrappedJS* wrapper = nsnull;
+    nsXPCWrappedJSClass *clazz = nsnull;
+    XPCJSRuntime* rt = ccx.GetRuntime();
+
+    map = rt->GetWrappedJSMap();
+    if(!map)
+    {
+        NS_ASSERTION(map,"bad map");
+        return NS_ERROR_FAILURE;
+    }
+
+    nsXPCWrappedJSClass::GetNewOrUsed(ccx, aIID, &clazz);
+    if(!clazz)
+        return NS_ERROR_FAILURE;
+
+    // GetRootJSObject will attempt to call a QueryInterface function on
+    // aJSObj. If QueryInterface doesn't exist on the object then a strict
+    // warning will be emitted, so check to make sure that the QueryInterface
+    // function exists before proceeding.
+    if(JS_HasProperty(ccx.GetJSContext(), aJSObj,
+                      rt->GetStringName(XPCJSRuntime::IDX_QUERY_INTERFACE),
+                      &hasProp) && hasProp)
+        rootJSObj = clazz->GetRootJSObject(ccx, aJSObj);
+    else
+        rootJSObj = aJSObj;
+
+    NS_RELEASE(clazz);
+
+    if(!rootJSObj)
+        return NS_ERROR_FAILURE;
+
+    // look for the root wrapper
+    {   // scoped lock
+        XPCAutoLock lock(rt->GetMapLock());
+        root = map->Find(rootJSObj);
+    }
+
+    if(root)
+    {
+        if((nsnull != (wrapper = root->Find(aIID))) ||
+           (nsnull != (wrapper = root->FindInherited(aIID))))
+        {
+            NS_ADDREF(wrapper);
+        }
+    }
+
+    *wrapperResult = wrapper;
+    return NS_OK;
+}
+
 nsXPCWrappedJS::nsXPCWrappedJS(XPCCallContext& ccx,
                                JSObject* aJSObj,
                                nsXPCWrappedJSClass* aClass,
                                nsXPCWrappedJS* root,
                                nsISupports* aOuter)
     : mJSObj(aJSObj),
       mClass(aClass),
       mRoot(root ? root : this),
Index: caps/src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.318
diff -u -8 -p -r1.318 nsScriptSecurityManager.cpp
--- caps/src/nsScriptSecurityManager.cpp	18 Jun 2007 15:12:09 -0000	1.318
+++ caps/src/nsScriptSecurityManager.cpp	28 Jun 2007 22:03:01 -0000
@@ -488,33 +488,41 @@ nsScriptSecurityManager::CheckObjectAcce
     // Get the security manager
     nsScriptSecurityManager *ssm =
         nsScriptSecurityManager::GetScriptSecurityManager();
 
     NS_ASSERTION(ssm, "Failed to get security manager service");
     if (!ssm)
         return JS_FALSE;
 
+    nsCOMPtr<nsISupports> native;
+    nsresult rv =
+        sXPConnect->GetNativeOfJSObject(cx, obj,
+                                        NS_GET_IID(nsISupports),
+                                        getter_AddRefs(native));
+
     // Get the object being accessed.  We protect these cases:
     // 1. The Function.prototype.caller property's value, which might lead
     //    an attacker up a call-stack to a function or another object from
     //    a different trust domain.
     // 2. A user-defined getter or setter function accessible on another
     //    trust domain's window or document object.
     // *vp can be a primitive, in that case, we use obj as the target
     // object.
     JSObject* target = JSVAL_IS_PRIMITIVE(*vp) ? obj : JSVAL_TO_OBJECT(*vp);
 
     // Do the same-origin check -- this sets a JS exception if the check fails.
     // Pass the parent object's class name, as we have no class-info for it.
-    nsresult rv =
-        ssm->CheckPropertyAccess(cx, target, JS_GetClass(cx, obj)->name, id,
-                                 (mode & JSACC_WRITE) ?
-                                 nsIXPCSecurityManager::ACCESS_SET_PROPERTY :
-                                 nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
+    rv = ssm->CheckPropertyAccessImpl(( (mode & JSACC_WRITE) ?
+                                        nsIXPCSecurityManager::ACCESS_SET_PROPERTY :
+                                        nsIXPCSecurityManager::ACCESS_GET_PROPERTY ),
+                                      nsnull, cx, target, native, nsnull,
+                                      nsnull, JS_GET_CLASS(cx, obj)->name, id,
+                                      nsnull);
+
 
     if (NS_FAILED(rv))
         return JS_FALSE; // Security check failed (XXX was an error reported?)
 
     return JS_TRUE;
 }
 
 NS_IMETHODIMP
@@ -766,24 +774,34 @@ nsScriptSecurityManager::CheckPropertyAc
     //--See if the object advertises a non-default level of access
     //  using nsISecurityCheckedComponent
     nsCOMPtr<nsISecurityCheckedComponent> checkedComponent =
         do_QueryInterface(aObj);
 
     nsXPIDLCString objectSecurityLevel;
     if (checkedComponent)
     {
-        nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
-        nsCOMPtr<nsIInterfaceInfo> interfaceInfo;
-        const nsIID* objIID;
-        rv = aCallContext->GetCalleeWrapper(getter_AddRefs(wrapper));
-        if (NS_SUCCEEDED(rv))
-            rv = wrapper->FindInterfaceWithMember(aProperty, getter_AddRefs(interfaceInfo));
-        if (NS_SUCCEEDED(rv))
-            rv = interfaceInfo->GetIIDShared(&objIID);
+        const nsIID* objIID = nsnull;
+        if (aCallContext) {
+            // If we have a call context, find the wrapper and the IID
+            // with the member in question to pass to
+            // nsISecurityCheckedComponent, if not, pass a null IID
+            // and it's up to the implementation to decide if it wants
+            // to permit access or not.
+            nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
+            nsCOMPtr<nsIInterfaceInfo> interfaceInfo;
+            rv = aCallContext->GetCalleeWrapper(getter_AddRefs(wrapper));
+            if (NS_SUCCEEDED(rv))
+                rv = wrapper->FindInterfaceWithMember(aProperty, getter_AddRefs(interfaceInfo));
+            if (NS_SUCCEEDED(rv))
+                rv = interfaceInfo->GetIIDShared(&objIID);
+        } else {
+            rv = NS_OK;
+        }
+
         if (NS_SUCCEEDED(rv))
         {
             switch (aAction)
             {
             case nsIXPCSecurityManager::ACCESS_GET_PROPERTY:
                 checkedComponent->CanGetProperty(objIID,
                                                  JSValIDToString(cx, aProperty),
                                                  getter_Copies(objectSecurityLevel));
