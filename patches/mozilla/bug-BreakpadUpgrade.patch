Index: toolkit/crashreporter/nsExceptionHandler.cpp
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/nsExceptionHandler.cpp,v
retrieving revision 1.28
retrieving revision 1.29
diff -u -r1.28 -r1.29
--- toolkit/crashreporter/nsExceptionHandler.cpp	26 Sep 2007 18:35:21 -0000	1.28
+++ toolkit/crashreporter/nsExceptionHandler.cpp	25 Oct 2007 00:37:18 -0000	1.29
@@ -672,6 +672,12 @@
     delete crashReporterAPIData_Hash;
     crashReporterAPIData_Hash = nsnull;
   }
+
+  if (crashReporterAPIData) {
+    delete crashReporterAPIData;
+    crashReporterAPIData = nsnull;
+  }
+
   if (crashReporterPath) {
     NS_Free(crashReporterPath);
     crashReporterPath = nsnull;
Index: toolkit/crashreporter/client/crashreporter_linux.cpp
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/client/crashreporter_linux.cpp,v
retrieving revision 1.9
retrieving revision 1.10
diff -u -r1.9 -r1.10
--- toolkit/crashreporter/client/crashreporter_linux.cpp	26 Sep 2007 18:35:22 -0000	1.9
+++ toolkit/crashreporter/client/crashreporter_linux.cpp	24 Oct 2007 09:38:31 -0000	1.10
@@ -50,22 +50,7 @@
 
 #include <signal.h>
 
-#include <gtk/gtkhbbox.h>
-#include <gtk/gtkcheckbutton.h>
-#include <gtk/gtkcontainer.h>
-#include <gtk/gtkdialog.h>
-#include <gtk/gtkentry.h>
-#include <gtk/gtkexpander.h>
-#include <gtk/gtkhbox.h>
-#include <gtk/gtklabel.h>
-#include <gtk/gtkmain.h>
-#include <gtk/gtkmessagedialog.h>
-#include <gtk/gtkscrolledwindow.h>
-#include <gtk/gtktextview.h>
-#include <gtk/gtktextbuffer.h>
-#include <gtk/gtktogglebutton.h>
-#include <gtk/gtkvbox.h>
-#include <gtk/gtkwindow.h>
+#include <gtk/gtk.h>
 
 #include "common/linux/http_upload.h"
 
Index: toolkit/crashreporter/google-breakpad/Makefile.am
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/Makefile.am,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- toolkit/crashreporter/google-breakpad/Makefile.am	25 Jul 2007 01:06:11 -0000	1.5
+++ toolkit/crashreporter/google-breakpad/Makefile.am	21 Oct 2007 15:36:00 -0000	1.6
@@ -61,20 +61,21 @@
 	src/google_breakpad/processor/minidump.h \
 	src/google_breakpad/processor/minidump_processor.h \
 	src/google_breakpad/processor/process_state.h \
+	src/google_breakpad/processor/source_line_resolver_interface.h \
 	src/google_breakpad/processor/stack_frame.h \
 	src/google_breakpad/processor/stack_frame_cpu.h \
 	src/google_breakpad/processor/stackwalker.h \
 	src/google_breakpad/processor/symbol_supplier.h \
 	src/google_breakpad/processor/system_info.h \
-	src/processor/address_map.h \
 	src/processor/address_map-inl.h \
+	src/processor/address_map.h \
 	src/processor/basic_code_module.h \
 	src/processor/basic_code_modules.cc \
 	src/processor/basic_code_modules.h \
 	src/processor/basic_source_line_resolver.cc \
 	src/processor/call_stack.cc \
-	src/processor/contained_range_map.h \
 	src/processor/contained_range_map-inl.h \
+	src/processor/contained_range_map.h \
 	src/processor/linked_ptr.h \
 	src/processor/logging.h \
 	src/processor/logging.cc \
@@ -82,11 +83,11 @@
 	src/processor/minidump_processor.cc \
 	src/processor/pathname_stripper.cc \
 	src/processor/pathname_stripper.h \
-	src/processor/postfix_evaluator.h \
 	src/processor/postfix_evaluator-inl.h \
+	src/processor/postfix_evaluator.h \
 	src/processor/process_state.cc \
-	src/processor/range_map.h \
 	src/processor/range_map-inl.h \
+	src/processor/range_map.h \
 	src/processor/scoped_ptr.h \
 	src/processor/simple_symbol_supplier.cc \
 	src/processor/simple_symbol_supplier.h \
@@ -94,6 +95,8 @@
 	src/processor/stackwalker.cc \
 	src/processor/stackwalker_ppc.cc \
 	src/processor/stackwalker_ppc.h \
+	src/processor/stackwalker_sparc.cc \
+	src/processor/stackwalker_sparc.h \
 	src/processor/stackwalker_x86.cc \
 	src/processor/stackwalker_x86.h
 
@@ -159,6 +162,7 @@
 	src/processor/process_state.lo \
 	src/processor/stackwalker.lo \
 	src/processor/stackwalker_ppc.lo \
+	src/processor/stackwalker_sparc.lo \
 	src/processor/stackwalker_x86.lo
 
 src_processor_pathname_stripper_unittest_SOURCES = \
@@ -189,6 +193,7 @@
 	src/processor/pathname_stripper.lo \
 	src/processor/stackwalker.lo \
 	src/processor/stackwalker_ppc.lo \
+	src/processor/stackwalker_sparc.lo \
 	src/processor/stackwalker_x86.lo
 
 ## Non-installables
@@ -217,15 +222,30 @@
 	src/processor/simple_symbol_supplier.lo \
 	src/processor/stackwalker.lo \
 	src/processor/stackwalker_ppc.lo \
+	src/processor/stackwalker_sparc.lo \
 	src/processor/stackwalker_x86.lo
 
 
 ## Additional files to be included in a source distribution
 ##
 ## find src/client src/common src/processor/testdata src/tools \
-##     -type f \! -path '*/.svn/*' -print | sort
+##     -type f \! -path '*/.svn/*' -print | sort | \
+##     sed -e s/'^\(.*\)$'/'\t\1 \\'/
 EXTRA_DIST = \
 	$(SCRIPTS) \
+	src/processor/stackwalk_selftest_sol.s \
+	src/client/linux/handler/Makefile \
+	src/client/linux/handler/exception_handler.cc \
+	src/client/linux/handler/exception_handler.h \
+	src/client/linux/handler/exception_handler_test.cc \
+	src/client/linux/handler/linux_thread.cc \
+	src/client/linux/handler/linux_thread.h \
+	src/client/linux/handler/linux_thread_test.cc \
+	src/client/linux/handler/minidump_generator.cc \
+	src/client/linux/handler/minidump_generator.h \
+	src/client/linux/handler/minidump_test.cc \
+	src/client/mac/handler/dynamic_images.cc \
+	src/client/mac/handler/dynamic_images.h \
 	src/client/mac/handler/exception_handler.cc \
 	src/client/mac/handler/exception_handler.h \
 	src/client/mac/handler/exception_handler_test.cc \
@@ -233,10 +253,21 @@
 	src/client/mac/handler/minidump_generator.h \
 	src/client/mac/handler/minidump_generator_test.cc \
 	src/client/mac/handler/minidump_test.xcodeproj/project.pbxproj \
+	src/client/mac/handler/protected_memory_allocator.cc \
+	src/client/mac/handler/protected_memory_allocator.h \
+	src/client/minidump_file_writer-inl.h \
 	src/client/minidump_file_writer.cc \
 	src/client/minidump_file_writer.h \
-	src/client/minidump_file_writer-inl.h \
 	src/client/minidump_file_writer_unittest.cc \
+	src/client/solaris/handler/Makefile \
+	src/client/solaris/handler/exception_handler.cc \
+	src/client/solaris/handler/exception_handler.h \
+	src/client/solaris/handler/exception_handler_test.cc \
+	src/client/solaris/handler/minidump_generator.cc \
+	src/client/solaris/handler/minidump_generator.h \
+	src/client/solaris/handler/minidump_test.cc \
+	src/client/solaris/handler/solaris_lwp.cc \
+	src/client/solaris/handler/solaris_lwp.h \
 	src/client/windows/breakpad_client.sln \
 	src/client/windows/handler/exception_handler.cc \
 	src/client/windows/handler/exception_handler.h \
@@ -246,6 +277,14 @@
 	src/client/windows/sender/crash_report_sender.vcproj \
 	src/common/convert_UTF.c \
 	src/common/convert_UTF.h \
+	src/common/linux/dump_symbols.cc \
+	src/common/linux/dump_symbols.h \
+	src/common/linux/file_id.cc \
+	src/common/linux/file_id.h \
+	src/common/linux/guid_creator.cc \
+	src/common/linux/guid_creator.h \
+	src/common/linux/http_upload.cc \
+	src/common/linux/http_upload.h \
 	src/common/mac/HTTPMultipartUpload.h \
 	src/common/mac/HTTPMultipartUpload.m \
 	src/common/mac/dump_syms.h \
@@ -254,10 +293,21 @@
 	src/common/mac/file_id.h \
 	src/common/mac/macho_id.cc \
 	src/common/mac/macho_id.h \
+	src/common/mac/macho_utilities.cc \
+	src/common/mac/macho_utilities.h \
 	src/common/mac/macho_walker.cc \
 	src/common/mac/macho_walker.h \
 	src/common/mac/string_utilities.cc \
 	src/common/mac/string_utilities.h \
+	src/common/md5.c \
+	src/common/md5.h \
+	src/common/solaris/dump_symbols.cc \
+	src/common/solaris/dump_symbols.h \
+	src/common/solaris/file_id.cc \
+	src/common/solaris/file_id.h \
+	src/common/solaris/guid_creator.cc \
+	src/common/solaris/guid_creator.h \
+	src/common/solaris/message_output.h \
 	src/common/string_conversion.cc \
 	src/common/string_conversion.h \
 	src/common/windows/guid_string.cc \
@@ -275,9 +325,15 @@
 	src/processor/testdata/module1.out \
 	src/processor/testdata/module2.out \
 	src/processor/testdata/module3_bad.out \
+	src/processor/testdata/module4_bad.out \
 	src/processor/testdata/symbols/kernel32.pdb/BCE8785C57B44245A669896B6A19B9542/kernel32.sym \
 	src/processor/testdata/symbols/test_app.pdb/5A9832E5287241C1838ED98914E9B7FF1/test_app.sym \
 	src/processor/testdata/test_app.cc \
+	src/tools/linux/dump_syms/Makefile \
+	src/tools/linux/dump_syms/dump_syms.cc \
+	src/tools/linux/symupload/Makefile \
+	src/tools/linux/symupload/minidump_upload.cc \
+	src/tools/linux/symupload/sym_upload.cc \
 	src/tools/mac/crash_report/crash_report.mm \
 	src/tools/mac/crash_report/crash_report.xcodeproj/project.pbxproj \
 	src/tools/mac/crash_report/on_demand_symbol_supplier.h \
@@ -287,6 +343,13 @@
 	src/tools/mac/symupload/minidump_upload.m \
 	src/tools/mac/symupload/symupload.m \
 	src/tools/mac/symupload/symupload.xcodeproj/project.pbxproj \
+	src/tools/solaris/dump_syms/Makefile \
+	src/tools/solaris/dump_syms/dump_syms.cc \
+	src/tools/solaris/dump_syms/run_regtest.sh \
+	src/tools/solaris/dump_syms/testdata/dump_syms_regtest.cc \
+	src/tools/solaris/dump_syms/testdata/dump_syms_regtest.o \
+	src/tools/solaris/dump_syms/testdata/dump_syms_regtest.stabs \
+	src/tools/solaris/dump_syms/testdata/dump_syms_regtest.sym \
 	src/tools/windows/converter/ms_symbol_server_converter.cc \
 	src/tools/windows/converter/ms_symbol_server_converter.h \
 	src/tools/windows/converter/ms_symbol_server_converter.vcproj \
Index: toolkit/crashreporter/google-breakpad/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/Makefile.in,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- toolkit/crashreporter/google-breakpad/Makefile.in	25 Jul 2007 01:06:11 -0000	1.5
+++ toolkit/crashreporter/google-breakpad/Makefile.in	21 Oct 2007 15:36:00 -0000	1.6
@@ -113,6 +113,7 @@
 	src/processor/process_state.lo \
 	src/processor/simple_symbol_supplier.lo \
 	src/processor/stackwalker.lo src/processor/stackwalker_ppc.lo \
+	src/processor/stackwalker_sparc.lo \
 	src/processor/stackwalker_x86.lo
 src_libbreakpad_la_OBJECTS = $(am_src_libbreakpad_la_OBJECTS)
 binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
@@ -156,6 +157,7 @@
 	src/processor/pathname_stripper.lo \
 	src/processor/process_state.lo src/processor/stackwalker.lo \
 	src/processor/stackwalker_ppc.lo \
+	src/processor/stackwalker_sparc.lo \
 	src/processor/stackwalker_x86.lo
 am_src_processor_minidump_stackwalk_OBJECTS =  \
 	src/processor/minidump_stackwalk.$(OBJEXT)
@@ -170,6 +172,7 @@
 	src/processor/process_state.lo \
 	src/processor/simple_symbol_supplier.lo \
 	src/processor/stackwalker.lo src/processor/stackwalker_ppc.lo \
+	src/processor/stackwalker_sparc.lo \
 	src/processor/stackwalker_x86.lo
 am_src_processor_pathname_stripper_unittest_OBJECTS =  \
 	src/processor/pathname_stripper_unittest.$(OBJEXT)
@@ -199,6 +202,7 @@
 	src/processor/call_stack.lo src/processor/logging.lo \
 	src/processor/minidump.lo src/processor/pathname_stripper.lo \
 	src/processor/stackwalker.lo src/processor/stackwalker_ppc.lo \
+	src/processor/stackwalker_sparc.lo \
 	src/processor/stackwalker_x86.lo
 SCRIPTS = $(noinst_SCRIPTS)
 DEFAULT_INCLUDES = -I. -I$(top_builddir)/src@am__isrc@
@@ -389,20 +393,21 @@
 	src/google_breakpad/processor/minidump.h \
 	src/google_breakpad/processor/minidump_processor.h \
 	src/google_breakpad/processor/process_state.h \
+	src/google_breakpad/processor/source_line_resolver_interface.h \
 	src/google_breakpad/processor/stack_frame.h \
 	src/google_breakpad/processor/stack_frame_cpu.h \
 	src/google_breakpad/processor/stackwalker.h \
 	src/google_breakpad/processor/symbol_supplier.h \
 	src/google_breakpad/processor/system_info.h \
-	src/processor/address_map.h \
 	src/processor/address_map-inl.h \
+	src/processor/address_map.h \
 	src/processor/basic_code_module.h \
 	src/processor/basic_code_modules.cc \
 	src/processor/basic_code_modules.h \
 	src/processor/basic_source_line_resolver.cc \
 	src/processor/call_stack.cc \
-	src/processor/contained_range_map.h \
 	src/processor/contained_range_map-inl.h \
+	src/processor/contained_range_map.h \
 	src/processor/linked_ptr.h \
 	src/processor/logging.h \
 	src/processor/logging.cc \
@@ -410,11 +415,11 @@
 	src/processor/minidump_processor.cc \
 	src/processor/pathname_stripper.cc \
 	src/processor/pathname_stripper.h \
-	src/processor/postfix_evaluator.h \
 	src/processor/postfix_evaluator-inl.h \
+	src/processor/postfix_evaluator.h \
 	src/processor/process_state.cc \
-	src/processor/range_map.h \
 	src/processor/range_map-inl.h \
+	src/processor/range_map.h \
 	src/processor/scoped_ptr.h \
 	src/processor/simple_symbol_supplier.cc \
 	src/processor/simple_symbol_supplier.h \
@@ -422,6 +427,8 @@
 	src/processor/stackwalker.cc \
 	src/processor/stackwalker_ppc.cc \
 	src/processor/stackwalker_ppc.h \
+	src/processor/stackwalker_sparc.cc \
+	src/processor/stackwalker_sparc.h \
 	src/processor/stackwalker_x86.cc \
 	src/processor/stackwalker_x86.h
 
@@ -468,6 +475,7 @@
 	src/processor/process_state.lo \
 	src/processor/stackwalker.lo \
 	src/processor/stackwalker_ppc.lo \
+	src/processor/stackwalker_sparc.lo \
 	src/processor/stackwalker_x86.lo
 
 src_processor_pathname_stripper_unittest_SOURCES = \
@@ -502,6 +510,7 @@
 	src/processor/pathname_stripper.lo \
 	src/processor/stackwalker.lo \
 	src/processor/stackwalker_ppc.lo \
+	src/processor/stackwalker_sparc.lo \
 	src/processor/stackwalker_x86.lo
 
 noinst_SCRIPTS = $(check_SCRIPTS)
@@ -529,10 +538,24 @@
 	src/processor/simple_symbol_supplier.lo \
 	src/processor/stackwalker.lo \
 	src/processor/stackwalker_ppc.lo \
+	src/processor/stackwalker_sparc.lo \
 	src/processor/stackwalker_x86.lo
 
 EXTRA_DIST = \
 	$(SCRIPTS) \
+	src/processor/stackwalk_selftest_sol.s \
+	src/client/linux/handler/Makefile \
+	src/client/linux/handler/exception_handler.cc \
+	src/client/linux/handler/exception_handler.h \
+	src/client/linux/handler/exception_handler_test.cc \
+	src/client/linux/handler/linux_thread.cc \
+	src/client/linux/handler/linux_thread.h \
+	src/client/linux/handler/linux_thread_test.cc \
+	src/client/linux/handler/minidump_generator.cc \
+	src/client/linux/handler/minidump_generator.h \
+	src/client/linux/handler/minidump_test.cc \
+	src/client/mac/handler/dynamic_images.cc \
+	src/client/mac/handler/dynamic_images.h \
 	src/client/mac/handler/exception_handler.cc \
 	src/client/mac/handler/exception_handler.h \
 	src/client/mac/handler/exception_handler_test.cc \
@@ -540,10 +563,21 @@
 	src/client/mac/handler/minidump_generator.h \
 	src/client/mac/handler/minidump_generator_test.cc \
 	src/client/mac/handler/minidump_test.xcodeproj/project.pbxproj \
+	src/client/mac/handler/protected_memory_allocator.cc \
+	src/client/mac/handler/protected_memory_allocator.h \
+	src/client/minidump_file_writer-inl.h \
 	src/client/minidump_file_writer.cc \
 	src/client/minidump_file_writer.h \
-	src/client/minidump_file_writer-inl.h \
 	src/client/minidump_file_writer_unittest.cc \
+	src/client/solaris/handler/Makefile \
+	src/client/solaris/handler/exception_handler.cc \
+	src/client/solaris/handler/exception_handler.h \
+	src/client/solaris/handler/exception_handler_test.cc \
+	src/client/solaris/handler/minidump_generator.cc \
+	src/client/solaris/handler/minidump_generator.h \
+	src/client/solaris/handler/minidump_test.cc \
+	src/client/solaris/handler/solaris_lwp.cc \
+	src/client/solaris/handler/solaris_lwp.h \
 	src/client/windows/breakpad_client.sln \
 	src/client/windows/handler/exception_handler.cc \
 	src/client/windows/handler/exception_handler.h \
@@ -553,6 +587,14 @@
 	src/client/windows/sender/crash_report_sender.vcproj \
 	src/common/convert_UTF.c \
 	src/common/convert_UTF.h \
+	src/common/linux/dump_symbols.cc \
+	src/common/linux/dump_symbols.h \
+	src/common/linux/file_id.cc \
+	src/common/linux/file_id.h \
+	src/common/linux/guid_creator.cc \
+	src/common/linux/guid_creator.h \
+	src/common/linux/http_upload.cc \
+	src/common/linux/http_upload.h \
 	src/common/mac/HTTPMultipartUpload.h \
 	src/common/mac/HTTPMultipartUpload.m \
 	src/common/mac/dump_syms.h \
@@ -561,10 +603,21 @@
 	src/common/mac/file_id.h \
 	src/common/mac/macho_id.cc \
 	src/common/mac/macho_id.h \
+	src/common/mac/macho_utilities.cc \
+	src/common/mac/macho_utilities.h \
 	src/common/mac/macho_walker.cc \
 	src/common/mac/macho_walker.h \
 	src/common/mac/string_utilities.cc \
 	src/common/mac/string_utilities.h \
+	src/common/md5.c \
+	src/common/md5.h \
+	src/common/solaris/dump_symbols.cc \
+	src/common/solaris/dump_symbols.h \
+	src/common/solaris/file_id.cc \
+	src/common/solaris/file_id.h \
+	src/common/solaris/guid_creator.cc \
+	src/common/solaris/guid_creator.h \
+	src/common/solaris/message_output.h \
 	src/common/string_conversion.cc \
 	src/common/string_conversion.h \
 	src/common/windows/guid_string.cc \
@@ -582,9 +635,15 @@
 	src/processor/testdata/module1.out \
 	src/processor/testdata/module2.out \
 	src/processor/testdata/module3_bad.out \
+	src/processor/testdata/module4_bad.out \
 	src/processor/testdata/symbols/kernel32.pdb/BCE8785C57B44245A669896B6A19B9542/kernel32.sym \
 	src/processor/testdata/symbols/test_app.pdb/5A9832E5287241C1838ED98914E9B7FF1/test_app.sym \
 	src/processor/testdata/test_app.cc \
+	src/tools/linux/dump_syms/Makefile \
+	src/tools/linux/dump_syms/dump_syms.cc \
+	src/tools/linux/symupload/Makefile \
+	src/tools/linux/symupload/minidump_upload.cc \
+	src/tools/linux/symupload/sym_upload.cc \
 	src/tools/mac/crash_report/crash_report.mm \
 	src/tools/mac/crash_report/crash_report.xcodeproj/project.pbxproj \
 	src/tools/mac/crash_report/on_demand_symbol_supplier.h \
@@ -594,6 +653,13 @@
 	src/tools/mac/symupload/minidump_upload.m \
 	src/tools/mac/symupload/symupload.m \
 	src/tools/mac/symupload/symupload.xcodeproj/project.pbxproj \
+	src/tools/solaris/dump_syms/Makefile \
+	src/tools/solaris/dump_syms/dump_syms.cc \
+	src/tools/solaris/dump_syms/run_regtest.sh \
+	src/tools/solaris/dump_syms/testdata/dump_syms_regtest.cc \
+	src/tools/solaris/dump_syms/testdata/dump_syms_regtest.o \
+	src/tools/solaris/dump_syms/testdata/dump_syms_regtest.stabs \
+	src/tools/solaris/dump_syms/testdata/dump_syms_regtest.sym \
 	src/tools/windows/converter/ms_symbol_server_converter.cc \
 	src/tools/windows/converter/ms_symbol_server_converter.h \
 	src/tools/windows/converter/ms_symbol_server_converter.vcproj \
@@ -717,6 +783,8 @@
 	src/processor/$(DEPDIR)/$(am__dirstamp)
 src/processor/stackwalker_ppc.lo: src/processor/$(am__dirstamp) \
 	src/processor/$(DEPDIR)/$(am__dirstamp)
+src/processor/stackwalker_sparc.lo: src/processor/$(am__dirstamp) \
+	src/processor/$(DEPDIR)/$(am__dirstamp)
 src/processor/stackwalker_x86.lo: src/processor/$(am__dirstamp) \
 	src/processor/$(DEPDIR)/$(am__dirstamp)
 src/$(am__dirstamp):
@@ -860,6 +928,8 @@
 	-rm -f src/processor/stackwalker_ppc.$(OBJEXT)
 	-rm -f src/processor/stackwalker_ppc.lo
 	-rm -f src/processor/stackwalker_selftest.$(OBJEXT)
+	-rm -f src/processor/stackwalker_sparc.$(OBJEXT)
+	-rm -f src/processor/stackwalker_sparc.lo
 	-rm -f src/processor/stackwalker_x86.$(OBJEXT)
 	-rm -f src/processor/stackwalker_x86.lo
 
@@ -887,6 +957,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker_ppc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker_selftest.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker_sparc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker_x86.Plo@am__quote@
 
 .cc.o:
Index: toolkit/crashreporter/google-breakpad/src/client/mac/handler/dynamic_images.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/client/mac/handler/dynamic_images.cc,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- toolkit/crashreporter/google-breakpad/src/client/mac/handler/dynamic_images.cc	25 Jul 2007 01:06:11 -0000	1.3
+++ toolkit/crashreporter/google-breakpad/src/client/mac/handler/dynamic_images.cc	21 Oct 2007 15:36:07 -0000	1.4
@@ -27,14 +27,107 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-#include <mach-o/nlist.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <algorithm>
+extern "C" { // needed to compile on Leopard
+  #include <mach-o/nlist.h>
+  #include <stdlib.h>
+  #include <stdio.h>
+}
 
+#include <algorithm>
 #include "client/mac/handler/dynamic_images.h"
 
 namespace google_breakpad {
+  
+//==============================================================================
+// Returns the size of the memory region containing |address| and the
+// number of bytes from |address| to the end of the region.
+// We potentially, will extend the size of the original
+// region by the size of the following region if it's contiguous with the
+// first in order to handle cases when we're reading strings and they
+// straddle two vm regions.
+//
+static vm_size_t GetMemoryRegionSize(task_port_t target_task,
+                                     const void* address,
+                                     vm_size_t *size_to_end) {
+  vm_address_t region_base = (vm_address_t)address;
+  vm_size_t region_size;
+  natural_t nesting_level = 0;
+  vm_region_submap_info submap_info;
+  mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT;
+  
+  // Get information about the vm region containing |address|
+  kern_return_t result = 
+    vm_region_recurse(target_task,
+                      &region_base,
+                      &region_size,
+                      &nesting_level, 
+                      reinterpret_cast<vm_region_recurse_info_t>(&submap_info),
+                      &info_count);
+  
+  if (result == KERN_SUCCESS) {
+    // Get distance from |address| to the end of this region
+    *size_to_end = region_base + region_size -(vm_address_t)address;
+
+    // If we want to handle strings as long as 4096 characters we may need
+    // to check if there's a vm region immediately following the first one.
+    // If so, we need to extend |*size_to_end| to go all the way to the end
+    // of the second region.
+    if (*size_to_end < 4096) {
+      // Second region starts where the first one ends
+      vm_address_t region_base2 =
+        (vm_address_t)(region_base + region_size);
+      vm_size_t region_size2;
+
+      // Get information about the following vm region
+      result = 
+        vm_region_recurse(
+                      target_task,
+                      &region_base2,
+                      &region_size2,
+                      &nesting_level, 
+                      reinterpret_cast<vm_region_recurse_info_t>(&submap_info),
+                      &info_count);
+      
+      // Extend region_size to go all the way to the end of the 2nd region
+      if (result == KERN_SUCCESS
+          && region_base2 == region_base + region_size) {
+        region_size += region_size2;
+      }
+    }
+
+    *size_to_end = region_base + region_size -(vm_address_t)address;
+  } else {
+    region_size = 0;
+    *size_to_end = 0;
+  }
+  
+  return region_size;   
+}
+
+#define kMaxStringLength 8192
+//==============================================================================
+// Reads a NULL-terminated string from another task.
+//
+// Warning!  This will not read any strings longer than kMaxStringLength-1
+//
+static void* ReadTaskString(task_port_t target_task,
+                            const void* address) {
+  // The problem is we don't know how much to read until we know how long
+  // the string is. And we don't know how long the string is, until we've read
+  // the memory!  So, we'll try to read kMaxStringLength bytes
+  // (or as many bytes as we can until we reach the end of the vm region).  
+  vm_size_t size_to_end;
+  GetMemoryRegionSize(target_task, address, &size_to_end);
+  
+  if (size_to_end > 0) {
+    vm_size_t size_to_read =
+      size_to_end > kMaxStringLength ? kMaxStringLength : size_to_end;
+
+    return ReadTaskMemory(target_task, address, size_to_read);
+  }
+  
+  return NULL;
+}
 
 //==============================================================================
 // Reads an address range from another task.  A block of memory is malloced
@@ -63,7 +156,7 @@
     }
     vm_deallocate(mach_task_self(), (uintptr_t)local_start, local_length);
   }
-
+  
   return result;
 }
 
@@ -131,7 +224,7 @@
 void DynamicImages::ReadImageInfoForTask() {
   struct nlist l[8];
   memset(l, 0, sizeof(l) );
-  
+
   // First we lookup the address of the "_dyld_all_image_infos" struct
   // which lives in "dyld".  This structure contains information about all
   // of the loaded dynamic images.
@@ -163,7 +256,7 @@
                         count*sizeof(dyld_image_info)));
 
       image_list_.reserve(count);
-      
+
       for (int i = 0; i < count; ++i) {
         dyld_image_info &info = infoArray[i];
 
@@ -173,7 +266,7 @@
 
         if (!header)
           break;   // bail on this dynamic image
-        
+		
         // Now determine the total amount we really want to read based on the
         // size of the load commands.  We need the header plus all of the 
         // load commands.
@@ -182,19 +275,17 @@
 
         header = reinterpret_cast<mach_header*>
           (ReadTaskMemory(task_, info.load_address_, header_size));
-        
+
         // Read the file name from the task's memory space.
         char *file_path = NULL;
         if (info.file_path_) {
-          // Although we're reading 0x2000 bytes, this is copied in the
+          // Although we're reading kMaxStringLength bytes, it's copied in the
           // the DynamicImage constructor below with the correct string length,
           // so it's not really wasting memory.
           file_path = reinterpret_cast<char*>
-            (ReadTaskMemory(task_,
-                            info.file_path_,
-                            0x2000));
+            (ReadTaskString(task_, info.file_path_));
         }
-        
+ 
         // Create an object representing this image and add it to our list.
         DynamicImage *new_image = new DynamicImage(header,
                                                    header_size,
@@ -220,7 +311,7 @@
       // sorts based on loading address
       sort(image_list_.begin(), image_list_.end() );
     }
-  }
+  }  
 }
 
 //==============================================================================
Index: toolkit/crashreporter/google-breakpad/src/client/mac/handler/dynamic_images.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/client/mac/handler/dynamic_images.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- toolkit/crashreporter/google-breakpad/src/client/mac/handler/dynamic_images.h	25 Jul 2007 01:06:11 -0000	1.3
+++ toolkit/crashreporter/google-breakpad/src/client/mac/handler/dynamic_images.h	21 Oct 2007 15:36:07 -0000	1.4
@@ -153,7 +153,7 @@
   friend class DynamicImages;
 
   // Sanity checking
-  bool IsValid() {return GetVMAddr() != 0;}
+  bool IsValid() {return GetVMSize() != 0;}
 
   // Makes local copy of file path to mach-o binary
   void InitializeFilePath(char *inFilePath) {
Index: toolkit/crashreporter/google-breakpad/src/client/mac/handler/exception_handler.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/client/mac/handler/exception_handler.cc,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- toolkit/crashreporter/google-breakpad/src/client/mac/handler/exception_handler.cc	25 Jul 2007 01:06:11 -0000	1.3
+++ toolkit/crashreporter/google-breakpad/src/client/mac/handler/exception_handler.cc	21 Oct 2007 15:36:07 -0000	1.4
@@ -34,6 +34,20 @@
 #include "client/mac/handler/minidump_generator.h"
 #include "common/mac/macho_utilities.h"
 
+#ifndef USE_PROTECTED_ALLOCATIONS
+#define USE_PROTECTED_ALLOCATIONS 0
+#endif
+
+// If USE_PROTECTED_ALLOCATIONS is activated then the
+// gBreakpadAllocator needs to be setup in other code
+// ahead of time.  Please see ProtectedMemoryAllocator.h
+// for more details.
+#if USE_PROTECTED_ALLOCATIONS
+  #include "protected_memory_allocator.h"
+  extern ProtectedMemoryAllocator *gBreakpadAllocator;
+#endif
+
+
 namespace google_breakpad {
 
 using std::map;
@@ -70,7 +84,7 @@
 // Only catch these three exceptions.  The other ones are nebulously defined
 // and may result in treating a non-fatal exception as fatal.
 exception_mask_t s_exception_mask = EXC_MASK_BAD_ACCESS | 
-EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC;
+EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC | EXC_MASK_BREAKPOINT;
 
 extern "C"
 {
@@ -360,6 +374,8 @@
                                     MACH_RCV_MSG | MACH_RCV_LARGE, 0,
                                     sizeof(receive), self->handler_port_,
                                     MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
+
+    
     if (result == KERN_SUCCESS) {
       // Uninstall our handler so that we don't get in a loop if the process of
       // writing out a minidump causes an exception.  However, if the exception
@@ -373,23 +389,32 @@
       // to avoid misleading stacks.  If appropriate they will be resumed
       // afterwards.
       if (!receive.exception) {
-        self->UninstallHandler(false);
-      
         if (self->is_in_teardown_)
           return NULL;
 
         self->SuspendThreads();
 
+#if USE_PROTECTED_ALLOCATIONS
+        if(gBreakpadAllocator)
+          gBreakpadAllocator->Unprotect();
+#endif
+
         // Write out the dump and save the result for later retrieval
         self->last_minidump_write_result_ =
           self->WriteMinidumpWithException(0, 0, 0);
 
+        self->UninstallHandler(false);
+
+#if USE_PROTECTED_ALLOCATIONS
+        if(gBreakpadAllocator)
+          gBreakpadAllocator->Protect();
+#endif
+
         self->ResumeThreads();
 
         if (self->use_minidump_write_mutex_)
           pthread_mutex_unlock(&self->minidump_write_mutex_);
       } else {
-        self->UninstallHandler(true);
 
         // When forking a child process with the exception handler installed,
         // if the child crashes, it will send the exception back to the parent
@@ -399,10 +424,22 @@
         if (receive.task.name == mach_task_self()) {
           self->SuspendThreads();
           
+#if USE_PROTECTED_ALLOCATIONS
+        if(gBreakpadAllocator)
+          gBreakpadAllocator->Unprotect();
+#endif
+
           // Generate the minidump with the exception data.
           self->WriteMinidumpWithException(receive.exception, receive.code[0],
                                            receive.thread.name);
         
+          self->UninstallHandler(true);
+
+#if USE_PROTECTED_ALLOCATIONS
+        if(gBreakpadAllocator)
+          gBreakpadAllocator->Protect();
+#endif
+
           // Pass along the exception to the server, which will setup the 
           // message and call catch_exception_raise() and put the KERN_SUCCESS
           // into the reply.
@@ -426,7 +463,13 @@
 
 bool ExceptionHandler::InstallHandler() {
   try {
+#if USE_PROTECTED_ALLOCATIONS
+    previous_ = new (gBreakpadAllocator->Allocate(sizeof(ExceptionParameters)) )
+      ExceptionParameters();    
+#else
     previous_ = new ExceptionParameters();
+#endif
+  
   }
   catch (std::bad_alloc) {
     return false;
@@ -472,7 +515,11 @@
     
     // this delete should NOT happen if an exception just occurred!
     if (!in_exception) {
+#if USE_PROTECTED_ALLOCATIONS
+      previous_->~ExceptionParameters();
+#else
       delete previous_; 
+#endif
     }
     
     previous_ = NULL;
Index: toolkit/crashreporter/google-breakpad/src/client/mac/handler/protected_memory_allocator.cc
===================================================================
RCS file: toolkit/crashreporter/google-breakpad/src/client/mac/handler/protected_memory_allocator.cc
diff -N toolkit/crashreporter/google-breakpad/src/client/mac/handler/protected_memory_allocator.cc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/crashreporter/google-breakpad/src/client/mac/handler/protected_memory_allocator.cc	21 Oct 2007 15:36:07 -0000	1.1
@@ -0,0 +1,92 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// ProtectedMemoryAllocator
+//
+// See the header file for documentation
+
+#include "protected_memory_allocator.h"
+#include <assert.h>
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ProtectedMemoryAllocator::ProtectedMemoryAllocator(vm_size_t pool_size) 
+  : pool_size_(pool_size),
+    next_alloc_offset_(0),
+    valid_(false) {
+  
+  kern_return_t result = vm_allocate(mach_task_self(),
+                                     &base_address_,
+                                     pool_size,
+                                     TRUE
+                                     );
+  
+  valid_ = (result == KERN_SUCCESS);
+  assert(valid_);
+}
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ProtectedMemoryAllocator::~ProtectedMemoryAllocator() {
+  vm_deallocate(mach_task_self(),
+                base_address_,
+                pool_size_
+                );
+}
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+char *ProtectedMemoryAllocator::Allocate(size_t bytes) {
+  if (valid_ && next_alloc_offset_ + bytes <= pool_size_) {
+    char *p = (char*)base_address_ + next_alloc_offset_;
+    next_alloc_offset_ += bytes;
+    return p;
+  }
+  
+  return NULL;  // ran out of memory in our allocation block
+}
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+kern_return_t  ProtectedMemoryAllocator::Protect() {
+  kern_return_t result = vm_protect(mach_task_self(),
+                                    base_address_,
+                                    pool_size_,
+                                    FALSE,
+                                    VM_PROT_READ);
+  
+  return result;
+}
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+kern_return_t  ProtectedMemoryAllocator::Unprotect() {
+  kern_return_t result = vm_protect(mach_task_self(),
+                                    base_address_,
+                                    pool_size_,
+                                    FALSE,
+                                    VM_PROT_READ | VM_PROT_WRITE);
+  
+  return result;
+}
Index: toolkit/crashreporter/google-breakpad/src/client/mac/handler/protected_memory_allocator.h
===================================================================
RCS file: toolkit/crashreporter/google-breakpad/src/client/mac/handler/protected_memory_allocator.h
diff -N toolkit/crashreporter/google-breakpad/src/client/mac/handler/protected_memory_allocator.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/crashreporter/google-breakpad/src/client/mac/handler/protected_memory_allocator.h	21 Oct 2007 15:36:07 -0000	1.1
@@ -0,0 +1,85 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// ProtectedMemoryAllocator
+//
+// A very simple allocator class which allows allocation, but not deallocation.
+// The allocations can be made read-only with the Protect() method.
+// This class is NOT useful as a general-purpose memory allocation system,
+// since it does not allow deallocation.  It is useful to use for a group
+// of allocations which are created in the same time-frame and destroyed
+// in the same time-frame.  It is useful for making allocations of memory
+// which will not need to change often once initialized.  This memory can then
+// be protected from memory smashers by calling the Protect() method.
+
+#ifndef PROTECTED_MEMORY_ALLOCATOR_H__
+#define PROTECTED_MEMORY_ALLOCATOR_H__
+
+#include <mach/mach.h>
+
+//
+class ProtectedMemoryAllocator {
+ public:
+  ProtectedMemoryAllocator(vm_size_t pool_size);  
+  ~ProtectedMemoryAllocator();
+  
+  // Returns a pointer to an allocation of size n within the pool.
+  // Fails by returning NULL is no more space is available.
+  // Please note that the pointers returned from this method should not
+  // be freed in any way (for example by calling free() on them ).
+  char *         Allocate(size_t n);
+  
+  // Returns the base address of the allocation pool.
+  char *         GetBaseAddress() { return (char*)base_address_; }
+
+  // Returns the size of the allocation pool, including allocated
+  // plus free space.
+  vm_size_t      GetTotalSize() { return pool_size_; }
+
+  // Returns the number of bytes already allocated in the pool.
+  vm_size_t      GetAllocatedSize() { return next_alloc_offset_; }
+
+  // Returns the number of bytes available for allocation.
+  vm_size_t      GetFreeSize() { return pool_size_ - next_alloc_offset_; }
+  
+  // Makes the entire allocation pool read-only including, of course,
+  // all allocations made from the pool.
+  kern_return_t  Protect();  
+
+  // Makes the entire allocation pool read/write.
+  kern_return_t  Unprotect();  
+  
+ private:
+  vm_size_t      pool_size_;
+  vm_address_t   base_address_;
+  int            next_alloc_offset_;
+  bool           valid_;
+};
+
+#endif // PROTECTED_MEMORY_ALLOCATOR_H__
Index: toolkit/crashreporter/google-breakpad/src/client/solaris/handler/minidump_generator.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/client/solaris/handler/minidump_generator.cc,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/client/solaris/handler/minidump_generator.cc	10 Aug 2007 02:56:17 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/client/solaris/handler/minidump_generator.cc	21 Oct 2007 15:36:08 -0000	1.2
@@ -60,7 +60,7 @@
                                       UntypedMDRVA *memory,
                                       MDMemoryDescriptor *loc) {
   uintptr_t stack_bottom = lwp_lister_->GetLwpStackBottom(last_esp);
-  if (stack_bottom > last_esp) {
+  if (stack_bottom >= last_esp) {
     int size = stack_bottom - last_esp;
     if (size > 0) {
       if (!memory->Allocate(size))
@@ -74,6 +74,28 @@
   return false;
 }
 
+#if TARGET_CPU_SPARC
+bool MinidumpGenerator::WriteContext(MDRawContextSPARC *context, prgregset_t regs,
+                                     prfpregset_t *fp_regs) {
+  if (!context || !regs)
+    return false;
+
+  context->context_flags = MD_CONTEXT_SPARC_FULL;
+
+  context->ccr = (unsigned int)(regs[32]);
+  context->pc = (unsigned int)(regs[R_PC]);
+  context->npc = (unsigned int)(regs[R_nPC]);
+  context->y = (unsigned int)(regs[R_Y]);
+  context->asi = (unsigned int)(regs[36]);
+  context->fprs = (unsigned int)(regs[37]);
+
+  for ( int i = 0 ; i < 32 ; ++i ){
+    context->g_r[i] = (unsigned int)(regs[i]);
+  }
+
+  return true;
+}
+#elif TARGET_CPU_X86
 bool MinidumpGenerator::WriteContext(MDRawContextX86 *context, prgregset_t regs,
                                      prfpregset_t *fp_regs) {
   if (!context || !regs)
@@ -100,23 +122,41 @@
 
   return true;
 }
+#endif /* TARGET_CPU_XXX */
 
 bool MinidumpGenerator::WriteLwpStream(lwpstatus_t *lsp, MDRawThread *lwp) {
   prfpregset_t fp_regs = lsp->pr_fpreg;
   prgregset_t *gregs = &(lsp->pr_reg);
   UntypedMDRVA memory(&writer_);
-  if (!WriteLwpStack((*gregs)[UESP],
+#if TARGET_CPU_SPARC
+  if (!WriteLwpStack((*gregs)[R_SP],
                      &memory,
                      &lwp->stack))
     return false;
 
   // Write context
+  TypedMDRVA<MDRawContextSPARC> context(&writer_);
+  if (!context.Allocate())
+    return false;
+  // should be the thread_id
+  lwp->thread_id = lsp->pr_lwpid;
+  lwp->thread_context = context.location();
+  memset(context.get(), 0, sizeof(MDRawContextSPARC));
+#elif TARGET_CPU_X86
+  if (!WriteLwpStack((*gregs)[UESP],
+                     &memory,
+                     &lwp->stack))
+  return false;
+
+  // Write context
   TypedMDRVA<MDRawContextX86> context(&writer_);
   if (!context.Allocate())
     return false;
-  lwp->thread_id = lwp_lister_->getpid();
+  // should be the thread_id
+  lwp->thread_id = lsp->pr_lwpid;
   lwp->thread_context = context.location();
   memset(context.get(), 0, sizeof(MDRawContextX86));
+#endif /* TARGET_CPU_XXX */
   return WriteContext(context.get(), (int *)gregs, &fp_regs);
 }
 
@@ -220,11 +260,11 @@
   if (lwp_count < 0)
     return false;
   TypedMDRVA<MDRawThreadList> list(&writer_);
-  if (!list.AllocateObjectAndArray(lwp_count, sizeof(MDRawThread)))
+  if (!list.AllocateObjectAndArray(lwp_count - 1, sizeof(MDRawThread)))
     return false;
   dir->stream_type = MD_THREAD_LIST_STREAM;
   dir->location = list.location();
-  list.get()->number_of_threads = lwp_count;
+  list.get()->number_of_threads = lwp_count - 1;
 
   LwpInfoCallbackCtx context;
   context.generator = this;
@@ -351,8 +391,8 @@
 
 bool MinidumpGenerator::WriteExceptionStream(MDRawDirectory *dir) {
   ucontext_t uc;
-  prgregset_t *gregs;
-  prfpregset_t fp_regs;
+  gregset_t *gregs;
+  fpregset_t fp_regs;
 
   if (getcontext(&uc) != 0)
     return false;
@@ -369,8 +409,34 @@
 
   gregs = &(uc.uc_mcontext.gregs);
   fp_regs = uc.uc_mcontext.fpregs;
+#if TARGET_CPU_SPARC
+  exception.get()->exception_record.exception_address = ((unsigned int *)gregs)[1];
+  // Write context of the exception.
+  TypedMDRVA<MDRawContextSPARC> context(&writer_);
+  if (!context.Allocate())
+    return false;
+  exception.get()->thread_context = context.location();
+  memset(context.get(), 0, sizeof(MDRawContextSPARC));
+  
+  // On Solaris i386, gregset_t = prgregset_t, fpregset_t = prfpregset_t
+  // But on Solaris Sparc are diffrent, see sys/regset.h and sys/procfs_isa.h
+  context.get()->context_flags = MD_CONTEXT_SPARC_FULL;
+  context.get()->ccr = ((unsigned int *)gregs)[0];
+  context.get()->pc = ((unsigned int *)gregs)[1];
+  context.get()->npc = ((unsigned int *)gregs)[2];
+  context.get()->y = ((unsigned int *)gregs)[3];
+  context.get()->asi = ((unsigned int *)gregs)[19];
+  context.get()->fprs = ((unsigned int *)gregs)[20];
+  for (int i = 0; i < 32; ++i) {
+    context.get()->g_r[i] = 0;
+  }
+  for (int i = 1; i < 16; ++i) {
+    context.get()->g_r[i] = ((unsigned int *)gregs)[i + 3];
+  }
+ 
+  return true;
+#elif TARGET_CPU_X86
   exception.get()->exception_record.exception_address = (*gregs)[EIP];
-
   // Write context of the exception.
   TypedMDRVA<MDRawContextX86> context(&writer_);
   if (!context.Allocate())
@@ -378,6 +444,7 @@
   exception.get()->thread_context = context.location();
   memset(context.get(), 0, sizeof(MDRawContextX86));
   return WriteContext(context.get(), (int *)gregs, &fp_regs);
+#endif /* TARGET_CPU_XXX */
 }
 
 bool MinidumpGenerator::WriteMiscInfoStream(MDRawDirectory *dir) {
@@ -466,7 +533,6 @@
 bool MinidumpGenerator::WriteMinidumpToFile(const char *file_pathname,
                                             int signo) {
   assert(file_pathname != NULL);
-  assert(stack_ != NULL);
 
   if (file_pathname == NULL)
     return false;
Index: toolkit/crashreporter/google-breakpad/src/client/solaris/handler/minidump_generator.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/client/solaris/handler/minidump_generator.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/client/solaris/handler/minidump_generator.h	10 Aug 2007 02:56:17 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/client/solaris/handler/minidump_generator.h	21 Oct 2007 15:36:08 -0000	1.2
@@ -32,6 +32,14 @@
 #ifndef CLIENT_SOLARIS_HANDLER_MINIDUMP_GENERATOR_H__
 #define CLIENT_SOLARIS_HANDLER_MINIDUMP_GENERATOR_H__
 
+#if defined(sparc) || defined(__sparc__)
+#define TARGET_CPU_SPARC 1
+#elif defined(i386) || defined(__i386__)
+#define TARGET_CPU_X86 1
+#else
+#error "cannot determine cpu type"
+#endif
+
 #include "client/minidump_file_writer.h"
 #include "client/solaris/handler/solaris_lwp.h"
 #include "google_breakpad/common/breakpad_types.h"
@@ -69,8 +77,13 @@
                      MDMemoryDescriptor *loc);
 
   // Write CPU context based on provided registers.
+#if TARGET_CPU_SPARC
+  bool WriteContext(MDRawContextSPARC *context, prgregset_t regs,
+                    prfpregset_t *fp_regs);
+#elif TARGET_CPU_X86
   bool WriteContext(MDRawContextX86 *context, prgregset_t regs,
                     prfpregset_t *fp_regs);
+#endif /* TARGET_CPU_XXX */
 
   // Write information about a lwp.
   // Only processes lwp running normally at the crash.
Index: toolkit/crashreporter/google-breakpad/src/client/solaris/handler/solaris_lwp.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/client/solaris/handler/solaris_lwp.cc,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/client/solaris/handler/solaris_lwp.cc	10 Aug 2007 02:56:17 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/client/solaris/handler/solaris_lwp.cc	21 Oct 2007 15:36:08 -0000	1.2
@@ -217,7 +217,7 @@
   lwpsinfo_t *Lpsp;
   long nstat;
   long ninfo;
-  int rv;
+  int rv = 0;
 
   /*
    * The /proc/pid/lstatus file has the array of lwpstatus_t's and the
@@ -240,8 +240,9 @@
       sp = NULL;
     }
     if (callback_param &&
-        !(rv = (callback_param->call_back)(sp, callback_param->context)))
+        !(callback_param->call_back)(sp, callback_param->context))
       break;
+    ++rv;
     Lpsp = (lwpsinfo_t *)((uintptr_t)Lpsp + Lphp->pr_entsize);
   }
 
@@ -279,7 +280,8 @@
     return -1;
 
   /*
-   * Determine number of mappings.
+   * Determine number of mappings, this value must be 
+   * larger than the actual module count
    */
   size = status.st_size;
   if ((num = (int)(size / sizeof (prmap_t))) > MAP_MAX) {
@@ -287,9 +289,6 @@
     return -1;
   }
 
-  if (!callback_param)
-    return num;           // return the Module count
-
   if (read(fd, (void *)maps, size) < 0) {
     print_message2(2, "failed to read %d\n", fd);
     return -1;
@@ -297,7 +296,8 @@
 
   prmap_t *_maps;
   int _num;
-
+  int module_count = 0;
+  
   /*
    * Scan each mapping - note it is assummed that the mappings are
    * presented in order.  We fill holes between mappings.  On intel
@@ -313,15 +313,17 @@
     memset(&module, 0, sizeof (module));
     module.start_addr = _maps->pr_vaddr;
     module.size = _maps->pr_size;
-    if (name && (strcmp(name, "a.out") != 0))
+    if ((strlen(name) > 0) && (strcmp(name, "a.out") != 0)) {
       strncpy(module.name, name, sizeof (module.name) - 1);
+      ++module_count;
+    }
     if (callback_param &&
         (!callback_param->call_back(module, callback_param->context))) {
       break;
     }
   }
 
-  return num;
+  return module_count;
 }
 
 }  // namespace google_breakpad
Index: toolkit/crashreporter/google-breakpad/src/client/windows/handler/exception_handler.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/client/windows/handler/exception_handler.h,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- toolkit/crashreporter/google-breakpad/src/client/windows/handler/exception_handler.h	25 Jul 2007 01:06:11 -0000	1.5
+++ toolkit/crashreporter/google-breakpad/src/client/windows/handler/exception_handler.h	21 Oct 2007 15:36:07 -0000	1.6
@@ -169,6 +169,12 @@
   static bool WriteMinidump(const wstring &dump_path,
                             MinidumpCallback callback, void *callback_context);
 
+  // Get the thread ID of the thread requesting the dump (either the exception
+  // thread or any other thread that called WriteMinidump directly).  This
+  // may be useful if you want to include additional thread state in your
+  // dumps.
+  DWORD get_requesting_thread_id() const { return requesting_thread_id_; }
+
  private:
   friend class AutoExceptionHandler;
 
Index: toolkit/crashreporter/google-breakpad/src/client/windows/sender/crash_report_sender.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/client/windows/sender/crash_report_sender.cc,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -r1.4 -r1.5
--- toolkit/crashreporter/google-breakpad/src/client/windows/sender/crash_report_sender.cc	25 Jul 2007 01:06:11 -0000	1.4
+++ toolkit/crashreporter/google-breakpad/src/client/windows/sender/crash_report_sender.cc	21 Oct 2007 15:36:07 -0000	1.5
@@ -30,6 +30,8 @@
 // Disable exception handler warnings.
 #pragma warning( disable : 4530 )
 
+#include <errno.h>
+
 #include "client/windows/sender/crash_report_sender.h"
 #include "common/windows/http_upload.h"
 
@@ -124,6 +126,9 @@
 }
 
 int CrashReportSender::OpenCheckpointFile(const wchar_t *mode, FILE **fd) {
+  if (checkpoint_file_.empty()) {
+    return ENOENT;
+  }
 #if _MSC_VER >= 1400  // MSVC 2005/8
   return _wfopen_s(fd, checkpoint_file_.c_str(), mode);
 #else
Index: toolkit/crashreporter/google-breakpad/src/common/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/Makefile.in,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -r1.4 -r1.5
--- toolkit/crashreporter/google-breakpad/src/common/Makefile.in	25 Jul 2007 01:06:12 -0000	1.4
+++ toolkit/crashreporter/google-breakpad/src/common/Makefile.in	21 Oct 2007 15:36:05 -0000	1.5
@@ -53,6 +53,7 @@
 
 CSRCS = \
   convert_UTF.c \
+  md5.c \
   $(NULL)
 
 HOST_CPPSRCS = $(CPPSRCS)
Index: toolkit/crashreporter/google-breakpad/src/common/md5.c
===================================================================
RCS file: toolkit/crashreporter/google-breakpad/src/common/md5.c
diff -N toolkit/crashreporter/google-breakpad/src/common/md5.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/crashreporter/google-breakpad/src/common/md5.c	21 Oct 2007 15:36:05 -0000	1.1
@@ -0,0 +1,246 @@
+/*
+ * written by Colin Plumb in 1993, no copyright is claimed.
+ * This code is in the public domain; do with it what you wish.
+ *
+ * Equivalent code is available from RSA Data Security, Inc.
+ * This code has been tested against that, and is equivalent,
+ * except that you don't need to include two pages of legalese
+ * with every copy.
+ *
+ * To compute the message digest of a chunk of bytes, declare an
+ * MD5Context structure, pass it to MD5Init, call MD5Update as
+ * needed on buffers full of bytes, and then call MD5Final, which
+ * will fill a supplied 16-byte array with the digest.
+ */
+
+#include <string.h>
+
+#include "common/md5.h"
+
+#ifndef WORDS_BIGENDIAN
+#define byteReverse(buf, len)   /* Nothing */
+#else
+/*
+ * Note: this code is harmless on little-endian machines.
+ */
+static void byteReverse(unsigned char *buf, unsigned longs)
+{
+  u32 t;
+  do {
+    t = (u32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
+      ((unsigned) buf[1] << 8 | buf[0]);
+    *(u32 *) buf = t;
+    buf += 4;
+  } while (--longs);
+}
+#endif
+
+static void MD5Transform(u32 buf[4], u32 const in[16]);
+
+/*
+ * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
+ * initialization constants.
+ */
+void MD5Init(struct MD5Context *ctx)
+{
+  ctx->buf[0] = 0x67452301;
+  ctx->buf[1] = 0xefcdab89;
+  ctx->buf[2] = 0x98badcfe;
+  ctx->buf[3] = 0x10325476;
+
+  ctx->bits[0] = 0;
+  ctx->bits[1] = 0;
+}
+
+/*
+ * Update context to reflect the concatenation of another buffer full
+ * of bytes.
+ */
+void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
+{
+  u32 t;
+
+  /* Update bitcount */
+
+  t = ctx->bits[0];
+  if ((ctx->bits[0] = t + ((u32) len << 3)) < t)
+    ctx->bits[1]++;         /* Carry from low to high */
+  ctx->bits[1] += len >> 29;
+
+  t = (t >> 3) & 0x3f;        /* Bytes already in shsInfo->data */
+
+  /* Handle any leading odd-sized chunks */
+
+  if (t) {
+    unsigned char *p = (unsigned char *) ctx->in + t;
+
+    t = 64 - t;
+    if (len < t) {
+      memcpy(p, buf, len);
+      return;
+    }
+    memcpy(p, buf, t);
+    byteReverse(ctx->in, 16);
+    MD5Transform(ctx->buf, (u32 *) ctx->in);
+    buf += t;
+    len -= t;
+  }
+  /* Process data in 64-byte chunks */
+
+  while (len >= 64) {
+    memcpy(ctx->in, buf, 64);
+    byteReverse(ctx->in, 16);
+    MD5Transform(ctx->buf, (u32 *) ctx->in);
+    buf += 64;
+    len -= 64;
+  }
+
+  /* Handle any remaining bytes of data. */
+
+  memcpy(ctx->in, buf, len);
+}
+
+/*
+ * Final wrapup - pad to 64-byte boundary with the bit pattern
+ * 1 0* (64-bit count of bits processed, MSB-first)
+ */
+void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
+{
+  unsigned count;
+  unsigned char *p;
+
+  /* Compute number of bytes mod 64 */
+  count = (ctx->bits[0] >> 3) & 0x3F;
+
+  /* Set the first char of padding to 0x80.  This is safe since there is
+     always at least one byte free */
+  p = ctx->in + count;
+  *p++ = 0x80;
+
+  /* Bytes of padding needed to make 64 bytes */
+  count = 64 - 1 - count;
+
+  /* Pad out to 56 mod 64 */
+  if (count < 8) {
+    /* Two lots of padding:  Pad the first block to 64 bytes */
+    memset(p, 0, count);
+    byteReverse(ctx->in, 16);
+    MD5Transform(ctx->buf, (u32 *) ctx->in);
+
+    /* Now fill the next block with 56 bytes */
+    memset(ctx->in, 0, 56);
+  } else {
+    /* Pad block to 56 bytes */
+    memset(p, 0, count - 8);
+  }
+  byteReverse(ctx->in, 14);
+
+  /* Append length in bits and transform */
+  ((u32 *) ctx->in)[14] = ctx->bits[0];
+  ((u32 *) ctx->in)[15] = ctx->bits[1];
+
+  MD5Transform(ctx->buf, (u32 *) ctx->in);
+  byteReverse((unsigned char *) ctx->buf, 4);
+  memcpy(digest, ctx->buf, 16);
+  memset(ctx, 0, sizeof(ctx));        /* In case it's sensitive */
+}
+
+/* The four core functions - F1 is optimized somewhat */
+
+/* #define F1(x, y, z) (x & y | ~x & z) */
+#define F1(x, y, z) (z ^ (x & (y ^ z)))
+#define F2(x, y, z) F1(z, x, y)
+#define F3(x, y, z) (x ^ y ^ z)
+#define F4(x, y, z) (y ^ (x | ~z))
+
+/* This is the central step in the MD5 algorithm. */
+#define MD5STEP(f, w, x, y, z, data, s) \
+  ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
+
+/*
+ * The core of the MD5 algorithm, this alters an existing MD5 hash to
+ * reflect the addition of 16 longwords of new data.  MD5Update blocks
+ * the data and converts bytes into longwords for this routine.
+ */
+static void MD5Transform(u32 buf[4], u32 const in[16])
+{
+  register u32 a, b, c, d;
+
+  a = buf[0];
+  b = buf[1];
+  c = buf[2];
+  d = buf[3];
+
+  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
+  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
+  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
+  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
+  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
+  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
+  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
+  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
+  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
+  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
+  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
+  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
+  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
+  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
+  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
+  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
+
+  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
+  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
+  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
+  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
+  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
+  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
+  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
+  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
+  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
+  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
+  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
+  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
+  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
+  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
+  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
+  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
+
+  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
+  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
+  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
+  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
+  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
+  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
+  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
+  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
+  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
+  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
+  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
+  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
+  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
+  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
+  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
+  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
+
+  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
+  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
+  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
+  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
+  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
+  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
+  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
+  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
+  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
+  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
+  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
+  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
+  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
+  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
+  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
+  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
+
+  buf[0] += a;
+  buf[1] += b;
+  buf[2] += c;
+  buf[3] += d;
+}
Index: toolkit/crashreporter/google-breakpad/src/common/md5.h
===================================================================
RCS file: toolkit/crashreporter/google-breakpad/src/common/md5.h
diff -N toolkit/crashreporter/google-breakpad/src/common/md5.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/crashreporter/google-breakpad/src/common/md5.h	21 Oct 2007 15:36:05 -0000	1.1
@@ -0,0 +1,31 @@
+// Copyright 2007 Google Inc. All Rights Reserved.
+// Author: liuli@google.com (Liu Li)
+#ifndef COMMON_MD5_H__
+#define COMMON_MD5_H__
+
+#include <stdint.h>
+
+typedef uint32_t u32;
+typedef uint8_t u8;
+
+struct MD5Context {
+  u32 buf[4];
+  u32 bits[2];
+  u8 in[64];
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif  // __cplusplus
+
+void MD5Init(struct MD5Context *ctx);
+
+void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len);
+
+void MD5Final(unsigned char digest[16], struct MD5Context *ctx);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // COMMON_MD5_H__
Index: toolkit/crashreporter/google-breakpad/src/common/linux/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/linux/Makefile.in,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -r1.2 -r1.3
--- toolkit/crashreporter/google-breakpad/src/common/linux/Makefile.in	25 Jul 2007 01:06:12 -0000	1.2
+++ toolkit/crashreporter/google-breakpad/src/common/linux/Makefile.in	21 Oct 2007 15:36:05 -0000	1.3
@@ -57,18 +57,12 @@
   guid_creator.cc \
   $(NULL)
 
-CSRCS = \
-  md5.c \
-  $(NULL)
-
 HOST_CPPSRCS = \
   dump_symbols.cc \
   file_id.cc \
   guid_creator.cc \
   $(NULL)
 
-HOST_CSRCS = $(CSRCS)
-
 # need static lib
 FORCE_STATIC_LIB = 1
 FORCE_USE_PIC = 1
Index: toolkit/crashreporter/google-breakpad/src/common/linux/dump_symbols.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/linux/dump_symbols.cc,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- toolkit/crashreporter/google-breakpad/src/common/linux/dump_symbols.cc	25 Jul 2007 01:06:12 -0000	1.3
+++ toolkit/crashreporter/google-breakpad/src/common/linux/dump_symbols.cc	21 Oct 2007 15:36:05 -0000	1.4
@@ -494,7 +494,7 @@
     size_t slash_pos = obj_file.find_last_of("/");
     if (slash_pos != std::string::npos)
       filename = obj_file.substr(slash_pos + 1);
-    return WriteFormat(fd, "MODULE Linux %s %s %s\n", arch_name,
+    return WriteFormat(fd, "MODULE linux %s %s %s\n", arch_name,
                        id_no_dash, filename.c_str());
   }
   return false;
Index: toolkit/crashreporter/google-breakpad/src/common/linux/file_id.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/linux/file_id.cc,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -r1.2 -r1.3
--- toolkit/crashreporter/google-breakpad/src/common/linux/file_id.cc	25 Jul 2007 01:06:12 -0000	1.2
+++ toolkit/crashreporter/google-breakpad/src/common/linux/file_id.cc	21 Oct 2007 15:36:05 -0000	1.3
@@ -42,7 +42,7 @@
 #include <unistd.h>
 
 #include "common/linux/file_id.h"
-#include "common/linux/md5.h"
+#include "common/md5.h"
 
 namespace google_breakpad {
 
Index: toolkit/crashreporter/google-breakpad/src/common/linux/md5.c
===================================================================
RCS file: toolkit/crashreporter/google-breakpad/src/common/linux/md5.c
diff -N toolkit/crashreporter/google-breakpad/src/common/linux/md5.c
--- toolkit/crashreporter/google-breakpad/src/common/linux/md5.c	25 Jul 2007 01:06:12 -0000	1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,246 +0,0 @@
-/*
- * written by Colin Plumb in 1993, no copyright is claimed.
- * This code is in the public domain; do with it what you wish.
- *
- * Equivalent code is available from RSA Data Security, Inc.
- * This code has been tested against that, and is equivalent,
- * except that you don't need to include two pages of legalese
- * with every copy.
- *
- * To compute the message digest of a chunk of bytes, declare an
- * MD5Context structure, pass it to MD5Init, call MD5Update as
- * needed on buffers full of bytes, and then call MD5Final, which
- * will fill a supplied 16-byte array with the digest.
- */
-
-#include <string.h>
-
-#include "common/linux/md5.h"
-
-#ifndef WORDS_BIGENDIAN
-#define byteReverse(buf, len)   /* Nothing */
-#else
-/*
- * Note: this code is harmless on little-endian machines.
- */
-static void byteReverse(unsigned char *buf, unsigned longs)
-{
-  u32 t;
-  do {
-    t = (u32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
-      ((unsigned) buf[1] << 8 | buf[0]);
-    *(u32 *) buf = t;
-    buf += 4;
-  } while (--longs);
-}
-#endif
-
-static void MD5Transform(u32 buf[4], u32 const in[16]);
-
-/*
- * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
- * initialization constants.
- */
-void MD5Init(struct MD5Context *ctx)
-{
-  ctx->buf[0] = 0x67452301;
-  ctx->buf[1] = 0xefcdab89;
-  ctx->buf[2] = 0x98badcfe;
-  ctx->buf[3] = 0x10325476;
-
-  ctx->bits[0] = 0;
-  ctx->bits[1] = 0;
-}
-
-/*
- * Update context to reflect the concatenation of another buffer full
- * of bytes.
- */
-void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
-{
-  u32 t;
-
-  /* Update bitcount */
-
-  t = ctx->bits[0];
-  if ((ctx->bits[0] = t + ((u32) len << 3)) < t)
-    ctx->bits[1]++;         /* Carry from low to high */
-  ctx->bits[1] += len >> 29;
-
-  t = (t >> 3) & 0x3f;        /* Bytes already in shsInfo->data */
-
-  /* Handle any leading odd-sized chunks */
-
-  if (t) {
-    unsigned char *p = (unsigned char *) ctx->in + t;
-
-    t = 64 - t;
-    if (len < t) {
-      memcpy(p, buf, len);
-      return;
-    }
-    memcpy(p, buf, t);
-    byteReverse(ctx->in, 16);
-    MD5Transform(ctx->buf, (u32 *) ctx->in);
-    buf += t;
-    len -= t;
-  }
-  /* Process data in 64-byte chunks */
-
-  while (len >= 64) {
-    memcpy(ctx->in, buf, 64);
-    byteReverse(ctx->in, 16);
-    MD5Transform(ctx->buf, (u32 *) ctx->in);
-    buf += 64;
-    len -= 64;
-  }
-
-  /* Handle any remaining bytes of data. */
-
-  memcpy(ctx->in, buf, len);
-}
-
-/*
- * Final wrapup - pad to 64-byte boundary with the bit pattern
- * 1 0* (64-bit count of bits processed, MSB-first)
- */
-void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
-{
-  unsigned count;
-  unsigned char *p;
-
-  /* Compute number of bytes mod 64 */
-  count = (ctx->bits[0] >> 3) & 0x3F;
-
-  /* Set the first char of padding to 0x80.  This is safe since there is
-     always at least one byte free */
-  p = ctx->in + count;
-  *p++ = 0x80;
-
-  /* Bytes of padding needed to make 64 bytes */
-  count = 64 - 1 - count;
-
-  /* Pad out to 56 mod 64 */
-  if (count < 8) {
-    /* Two lots of padding:  Pad the first block to 64 bytes */
-    memset(p, 0, count);
-    byteReverse(ctx->in, 16);
-    MD5Transform(ctx->buf, (u32 *) ctx->in);
-
-    /* Now fill the next block with 56 bytes */
-    memset(ctx->in, 0, 56);
-  } else {
-    /* Pad block to 56 bytes */
-    memset(p, 0, count - 8);
-  }
-  byteReverse(ctx->in, 14);
-
-  /* Append length in bits and transform */
-  ((u32 *) ctx->in)[14] = ctx->bits[0];
-  ((u32 *) ctx->in)[15] = ctx->bits[1];
-
-  MD5Transform(ctx->buf, (u32 *) ctx->in);
-  byteReverse((unsigned char *) ctx->buf, 4);
-  memcpy(digest, ctx->buf, 16);
-  memset(ctx, 0, sizeof(ctx));        /* In case it's sensitive */
-}
-
-/* The four core functions - F1 is optimized somewhat */
-
-/* #define F1(x, y, z) (x & y | ~x & z) */
-#define F1(x, y, z) (z ^ (x & (y ^ z)))
-#define F2(x, y, z) F1(z, x, y)
-#define F3(x, y, z) (x ^ y ^ z)
-#define F4(x, y, z) (y ^ (x | ~z))
-
-/* This is the central step in the MD5 algorithm. */
-#define MD5STEP(f, w, x, y, z, data, s) \
-  ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
-
-/*
- * The core of the MD5 algorithm, this alters an existing MD5 hash to
- * reflect the addition of 16 longwords of new data.  MD5Update blocks
- * the data and converts bytes into longwords for this routine.
- */
-static void MD5Transform(u32 buf[4], u32 const in[16])
-{
-  register u32 a, b, c, d;
-
-  a = buf[0];
-  b = buf[1];
-  c = buf[2];
-  d = buf[3];
-
-  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
-  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
-  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
-  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
-  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
-  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
-  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
-  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
-  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
-  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
-  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
-  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
-  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
-  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
-  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
-  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
-
-  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
-  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
-  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
-  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
-  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
-  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
-  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
-  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
-  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
-  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
-  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
-  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
-  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
-  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
-  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
-  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
-
-  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
-  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
-  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
-  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
-  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
-  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
-  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
-  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
-  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
-  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
-  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
-  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
-  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
-  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
-  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
-  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
-
-  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
-  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
-  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
-  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
-  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
-  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
-  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
-  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
-  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
-  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
-  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
-  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
-  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
-  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
-  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
-  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
-
-  buf[0] += a;
-  buf[1] += b;
-  buf[2] += c;
-  buf[3] += d;
-}
Index: toolkit/crashreporter/google-breakpad/src/common/linux/md5.h
===================================================================
RCS file: toolkit/crashreporter/google-breakpad/src/common/linux/md5.h
diff -N toolkit/crashreporter/google-breakpad/src/common/linux/md5.h
--- toolkit/crashreporter/google-breakpad/src/common/linux/md5.h	25 Jul 2007 01:06:12 -0000	1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,31 +0,0 @@
-// Copyright 2007 Google Inc. All Rights Reserved.
-// Author: liuli@google.com (Liu Li)
-#ifndef COMMON_LINUX_MD5_H__
-#define COMMON_LINUX_MD5_H__
-
-#include <stdint.h>
-
-typedef uint32_t u32;
-typedef uint8_t u8;
-
-struct MD5Context {
-  u32 buf[4];
-  u32 bits[2];
-  u8 in[64];
-};
-
-#ifdef __cplusplus
-extern "C" {
-#endif  // __cplusplus
-
-void MD5Init(struct MD5Context *ctx);
-
-void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len);
-
-void MD5Final(unsigned char digest[16], struct MD5Context *ctx);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  // COMMON_LINUX_MD5_H__
Index: toolkit/crashreporter/google-breakpad/src/common/mac/HTTPMultipartUpload.m
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/mac/HTTPMultipartUpload.m,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/common/mac/HTTPMultipartUpload.m	25 Jul 2007 01:06:12 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/common/mac/HTTPMultipartUpload.m	21 Oct 2007 15:36:05 -0000	1.2
@@ -185,9 +185,16 @@
   [req setHTTPBody:postBody];
   [req setHTTPMethod:@"POST"];
 
-  return [NSURLConnection sendSynchronousRequest:req
+  [response_ release];
+  response_ = nil;
+  
+  NSData *data =  [NSURLConnection sendSynchronousRequest:req
                                returningResponse:&response_
                                            error:error];
+
+  [response_ retain];
+  
+  return data;
 }
 
 //=============================================================================
Index: toolkit/crashreporter/google-breakpad/src/common/mac/dump_syms.mm
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/mac/dump_syms.mm,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- toolkit/crashreporter/google-breakpad/src/common/mac/dump_syms.mm	25 Jul 2007 01:06:12 -0000	1.3
+++ toolkit/crashreporter/google-breakpad/src/common/mac/dump_syms.mm	21 Oct 2007 15:36:05 -0000	1.4
@@ -302,11 +302,14 @@
     NSString *fn = [NSString stringWithUTF8String:&table[n_strx]];
     NSRange range = [fn rangeOfString:@":" options:NSBackwardsSearch];
 
-    if (![fn length] || !range.length)
+    if (![fn length])
       return NO;
 
-    // The function has a ":" followed by some stuff
-    fn = [fn substringToIndex:range.location];
+    if (range.length > 0) {
+      // The function has a ":" followed by some stuff, so strip it off
+      fn = [fn substringToIndex:range.location];
+    }
+    
     [self addFunction:fn line:line address:list->n_value section:list->n_sect ];
 
     result = YES;
Index: toolkit/crashreporter/google-breakpad/src/common/mac/macho_id.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/mac/macho_id.cc,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- toolkit/crashreporter/google-breakpad/src/common/mac/macho_id.cc	25 Jul 2007 01:06:12 -0000	1.3
+++ toolkit/crashreporter/google-breakpad/src/common/mac/macho_id.cc	21 Oct 2007 15:36:05 -0000	1.4
@@ -33,17 +33,19 @@
 //
 // Author: Dan Waylonis
 
-#include <fcntl.h>
-#include <mach-o/loader.h>
-#include <mach-o/swap.h>
-#include <openssl/md5.h>
-#include <openssl/sha.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <unistd.h>
+extern "C" {  // necessary for Leopard
+  #include <fcntl.h>
+  #include <mach-o/loader.h>
+  #include <mach-o/swap.h>
+  #include <openssl/md5.h>
+  #include <openssl/sha.h>
+  #include <stdio.h>
+  #include <stdlib.h>
+  #include <string.h>
+  #include <sys/time.h>
+  #include <sys/types.h>
+  #include <unistd.h>
+}
 
 #include "common/mac/macho_id.h"
 #include "common/mac/macho_walker.h"
Index: toolkit/crashreporter/google-breakpad/src/common/mac/macho_walker.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/mac/macho_walker.cc,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -r1.2 -r1.3
--- toolkit/crashreporter/google-breakpad/src/common/mac/macho_walker.cc	25 Jul 2007 01:06:12 -0000	1.2
+++ toolkit/crashreporter/google-breakpad/src/common/mac/macho_walker.cc	21 Oct 2007 15:36:05 -0000	1.3
@@ -33,13 +33,15 @@
 //
 // Author: Dan Waylonis
 
-#include <assert.h>
-#include <fcntl.h>
-#include <mach-o/arch.h>
-#include <mach-o/loader.h>
-#include <mach-o/swap.h>
-#include <string.h>
-#include <unistd.h>
+extern "C" {  // necessary for Leopard
+  #include <assert.h>
+  #include <fcntl.h>
+  #include <mach-o/arch.h>
+  #include <mach-o/loader.h>
+  #include <mach-o/swap.h>
+  #include <string.h>
+  #include <unistd.h>
+}
 
 #include "common/mac/macho_walker.h"
 #include "common/mac/macho_utilities.h"
Index: toolkit/crashreporter/google-breakpad/src/common/mac/string_utilities.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/mac/string_utilities.cc,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/common/mac/string_utilities.cc	25 Jul 2007 01:06:12 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/common/mac/string_utilities.cc	21 Oct 2007 15:36:05 -0000	1.2
@@ -67,7 +67,11 @@
       end = str.size();
 
     temp = str.substr(start, end - start);
-    result = atoi(temp.c_str());
+
+    if (found == idx) {
+      result = atoi(temp.c_str());
+    }
+
     start = str.find_first_of(digits, end + 1);
 
     if (start == string::npos)
Index: toolkit/crashreporter/google-breakpad/src/common/solaris/dump_symbols.cc
===================================================================
RCS file: toolkit/crashreporter/google-breakpad/src/common/solaris/dump_symbols.cc
diff -N toolkit/crashreporter/google-breakpad/src/common/solaris/dump_symbols.cc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/crashreporter/google-breakpad/src/common/solaris/dump_symbols.cc	21 Oct 2007 15:36:06 -0000	1.1
@@ -0,0 +1,587 @@
+// Copyright (c) 2007, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Author: Alfred Peng
+
+#include <demangle.h>
+#include <fcntl.h>
+#include <gelf.h>
+#include <link.h>
+#include <sys/mman.h>
+#include <stab.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <functional>
+#include <vector>
+
+#include "common/solaris/dump_symbols.h"
+#include "common/solaris/file_id.h"
+#include "common/solaris/guid_creator.h"
+#include "processor/scoped_ptr.h"
+
+// This namespace contains helper functions.
+namespace {
+
+// Symbol table entry for stabs. Sun CC specific.
+struct slist {
+  // String table index.
+  unsigned int n_strx;
+  // Stab type. 
+  unsigned char n_type;
+  char n_other;
+  short n_desc;
+  unsigned long n_value;
+};
+
+// Infomation of a line.
+struct LineInfo {
+  // Offset from start of the function.
+  // Load from stab symbol.
+  GElf_Off rva_to_func;
+  // Offset from base of the loading binary.
+  GElf_Off rva_to_base;
+  // Size of the line.
+  // The first line: equals to rva_to_func.
+  // The other lines: the difference of rva_to_func of the line and
+  // rva_to_func of the previous N_SLINE.
+  uint32_t size;
+  // Line number.
+  uint32_t line_num;
+};
+
+// Information of a function.
+struct FuncInfo {
+  // Name of the function.
+  const char *name;
+  // Offset from the base of the loading address.
+  GElf_Off rva_to_base;
+  // Virtual address of the function.
+  // Load from stab symbol.
+  GElf_Addr addr;
+  // Size of the function.
+  // Equal to rva_to_func of the last function line.
+  uint32_t size;
+  // Total size of stack parameters.
+  uint32_t stack_param_size;
+  // Line information array.
+  std::vector<struct LineInfo> line_info;
+};
+
+// Information of a source file.
+struct SourceFileInfo {
+  // Name of the source file.
+  const char *name;
+  // Starting address of the source file.
+  GElf_Addr addr;
+  // Id of the source file.
+  int source_id;
+  // Functions information.
+  std::vector<struct FuncInfo> func_info;
+};
+
+// Information of a symbol table.
+// This is the root of all types of symbol.
+struct SymbolInfo {
+  std::vector<struct SourceFileInfo> source_file_info;
+};
+
+// Stab section name.
+const char *kStabName = ".stab";
+
+// Stab str section name.
+const char *kStabStrName = ".stabstr";
+
+// Default buffer lenght for demangle.
+const int demangleLen = 2000;
+
+// Demangle using demangle library on Solaris.
+std::string Demangle(const char *mangled) {
+  int status = 0;
+  char *demangled = (char *)malloc(demangleLen);
+  if (!demangled) {
+    fprintf(stderr, "no enough memory.\n");
+    goto out;
+  }
+
+  if ((status = cplus_demangle(mangled, demangled, demangleLen)) ==
+      DEMANGLE_ESPACE) {
+    fprintf(stderr, "incorrect demangle.\n");
+    goto out;
+  }
+
+  std::string str(demangled);
+  free(demangled);
+  return str;
+
+out:
+  return std::string(mangled);
+}
+
+// Find the prefered loading address of the binary.
+GElf_Addr GetLoadingAddress(const GElf_Phdr *program_headers, int nheader) {
+  for (int i = 0; i < nheader; ++i) {
+    const GElf_Phdr &header = program_headers[i];
+    // For executable, it is the PT_LOAD segment with offset to zero.
+    if (header.p_type == PT_LOAD && header.p_offset == 0)
+      return header.p_vaddr;
+  }
+  // For other types of ELF, return 0.
+  return 0;
+}
+
+bool WriteFormat(int fd, const char *fmt, ...) {
+  va_list list;
+  char buffer[4096];
+  ssize_t expected, written;
+  va_start(list, fmt);
+  vsnprintf(buffer, sizeof(buffer), fmt, list);
+  expected = strlen(buffer);
+  written = write(fd, buffer, strlen(buffer));
+  va_end(list);
+  return expected == written;
+}
+
+bool IsValidElf(const GElf_Ehdr *elf_header) {
+  return memcmp(elf_header, ELFMAG, SELFMAG) == 0;
+}
+
+static bool FindSectionByName(Elf *elf, const char *name,
+                              int shstrndx,
+                              GElf_Shdr *shdr) {
+  assert(name != NULL);
+
+  if (strlen(name) == 0)
+    return false;
+
+  Elf_Scn *scn = NULL;
+
+  while ((scn = elf_nextscn(elf, scn)) != NULL) {
+    if (gelf_getshdr(scn, shdr) == (GElf_Shdr *)0) {
+      fprintf(stderr, "failed to read section header: %s\n", elf_errmsg(0));
+      return false;
+    }
+
+    const char *section_name = elf_strptr(elf, shstrndx, shdr->sh_name);
+    if (!section_name) {
+      fprintf(stderr, "Section name error: %s\n", elf_errmsg(-1));
+      continue;
+    }
+
+    if (strcmp(section_name, name) == 0)
+      return true;
+  }
+
+  return false;
+}
+
+// The parameter size is used for FPO-optimized code, and
+// this is all tied up with the debugging data for Windows x86.
+// Set it to 0 on Solaris.
+int LoadStackParamSize(struct slist *list,
+                       struct slist *list_end,
+                       struct FuncInfo *func_info) {
+  struct slist *cur_list = list;
+  int step = 1;
+  while (cur_list < list_end && cur_list->n_type == N_PSYM) {
+    ++cur_list;
+    ++step;
+  }
+
+  func_info->stack_param_size = 0;
+  return step;
+}
+
+int LoadLineInfo(struct slist *list,
+                 struct slist *list_end,
+                 struct FuncInfo *func_info) {
+  struct slist *cur_list = list;
+  do {
+    // Skip non line information.
+    while (cur_list < list_end && cur_list->n_type != N_SLINE) {
+      // Only exit when got another function, or source file.
+      if (cur_list->n_type == N_FUN || cur_list->n_type == N_SO)
+        return cur_list - list;
+      ++cur_list;
+    }
+    struct LineInfo line;
+    while (cur_list < list_end && cur_list->n_type == N_SLINE) {
+      line.rva_to_func = cur_list->n_value;
+      // n_desc is a signed short
+      line.line_num = (unsigned short)cur_list->n_desc;
+      func_info->line_info.push_back(line);
+      ++cur_list;
+    }
+    if (cur_list == list_end && cur_list->n_type == N_ENDM)
+      break;
+  } while (list < list_end);
+
+  return cur_list - list;
+}
+
+int LoadFuncSymbols(struct slist *list,
+                    struct slist *list_end,
+                    const GElf_Shdr *stabstr_section,
+                    GElf_Word base,
+                    struct SourceFileInfo *source_file_info) {
+  struct slist *cur_list = list;
+  assert(cur_list->n_type == N_SO);
+  ++cur_list;
+
+  source_file_info->func_info.clear();
+  while (cur_list < list_end) {
+    // Go until the function symbol.
+    while (cur_list < list_end && cur_list->n_type != N_FUN) {
+      if (cur_list->n_type == N_SO) {
+        return cur_list - list;
+      }
+      ++cur_list;
+      continue;
+    }
+    while (cur_list->n_type == N_FUN) {
+      struct FuncInfo func_info;
+      memset(&func_info, 0, sizeof(func_info));
+      func_info.name =
+        reinterpret_cast<char *>(cur_list->n_strx +
+                                 stabstr_section->sh_offset + base);
+      // The n_value field is always 0 from stab generated by Sun CC.
+      // TODO(Alfred): Find the correct value.
+      func_info.addr = cur_list->n_value;
+      ++cur_list;
+      if (cur_list->n_type != N_ESYM && cur_list->n_type != N_ISYM &&
+          cur_list->n_type != N_FUN) {
+        // Stack parameter size.
+        cur_list += LoadStackParamSize(cur_list, list_end, &func_info);
+        // Line info.
+        cur_list += LoadLineInfo(cur_list, list_end, &func_info);
+      }
+      // Functions in this module should have address bigger than the module
+      // starting address.
+      //
+      // These two values are always 0 with Sun CC.
+      // TODO(Alfred): Get the correct value or remove the condition statement.
+      if (func_info.addr >= source_file_info->addr) {
+        source_file_info->func_info.push_back(func_info);
+      }
+    }
+  }
+  return cur_list - list;
+}
+
+// Compute size and rva information based on symbols loaded from stab section.
+bool ComputeSizeAndRVA(GElf_Addr loading_addr, struct SymbolInfo *symbols) {
+  std::vector<struct SourceFileInfo> *sorted_files =
+    &(symbols->source_file_info);
+  for (size_t i = 0; i < sorted_files->size(); ++i) {
+    struct SourceFileInfo &source_file = (*sorted_files)[i];
+    std::vector<struct FuncInfo> *sorted_functions = &(source_file.func_info);
+    for (size_t j = 0; j < sorted_functions->size(); ++j) {
+      struct FuncInfo &func_info = (*sorted_functions)[j];
+      assert(func_info.addr >= loading_addr);
+      func_info.rva_to_base = func_info.addr - loading_addr;
+      int line_count = func_info.line_info.size();
+      func_info.size =
+        (line_count == 0) ? 0 :
+                            func_info.line_info[line_count - 1].rva_to_func;
+      // Compute function and line size.
+      for (size_t k = 0; k < line_count; ++k) {
+        struct LineInfo &line_info = func_info.line_info[k];
+        if (k == 0) {
+          line_info.size = line_info.rva_to_func;
+        } else {
+          line_info.size =
+            line_info.rva_to_func - func_info.line_info[k - 1].rva_to_func;
+        }
+        line_info.rva_to_base = line_info.rva_to_func + func_info.rva_to_base;
+      }  // for each line.
+    }  // for each function.
+  }  // for each source file.
+  return true;
+}
+
+bool LoadAllSymbols(const GElf_Shdr *stab_section,
+                    const GElf_Shdr *stabstr_section,
+                    GElf_Addr loading_addr,
+                    GElf_Word base,
+                    struct SymbolInfo *symbols) {
+  if (stab_section == NULL || stabstr_section == NULL)
+    return false;
+
+  struct slist *lists =
+    reinterpret_cast<struct slist *>(stab_section->sh_offset + base);
+  int nstab = stab_section->sh_size / sizeof(struct slist);
+  int source_id = 0;
+  // First pass, load all symbols from the object file.
+  for (int i = 0; i < nstab; ) {
+    int step = 1;
+    struct slist *cur_list = lists + i;
+    if (cur_list->n_type == N_SO) {
+      // FUNC <address> <size> <param_stack_size> <function>
+      struct SourceFileInfo source_file_info;
+      source_file_info.name =
+        reinterpret_cast<char *>(cur_list->n_strx +
+                                 stabstr_section->sh_offset + base);
+      // The n_value field is always 0 from stab generated by Sun CC.
+      // TODO(Alfred): Find the correct value.
+      source_file_info.addr = cur_list->n_value;
+      if (strchr(source_file_info.name, '.'))
+        source_file_info.source_id = source_id++;
+      else
+        source_file_info.source_id = -1;
+      step = LoadFuncSymbols(cur_list, lists + nstab - 1,
+                             stabstr_section, base, &source_file_info);
+      symbols->source_file_info.push_back(source_file_info);
+    }
+    i += step;
+  }
+  // Second pass, compute the size of functions and lines.
+  return ComputeSizeAndRVA(loading_addr, symbols);
+}
+
+bool LoadSymbols(Elf *elf, GElf_Ehdr *elf_header, struct SymbolInfo *symbols,
+                 void *obj_base) {
+  GElf_Word base = reinterpret_cast<GElf_Word>(obj_base);
+  GElf_Addr loading_addr = GetLoadingAddress(
+      reinterpret_cast<GElf_Phdr *>(elf_header->e_phoff + base),
+      elf_header->e_phnum);
+
+  const GElf_Shdr *sections =
+    reinterpret_cast<GElf_Shdr *>(elf_header->e_shoff + base);
+  GElf_Shdr stab_section;
+  if (!FindSectionByName(elf, kStabName, elf_header->e_shstrndx,
+                         &stab_section)) {
+    fprintf(stderr, "Stab section not found.\n");
+    return false;
+  }
+  GElf_Shdr stabstr_section;
+  if (!FindSectionByName(elf, kStabStrName, elf_header->e_shstrndx,
+                         &stabstr_section)) {
+    fprintf(stderr, "Stabstr section not found.\n");
+    return false;
+  }
+
+  // Load symbols.
+  return LoadAllSymbols(&stab_section, &stabstr_section, loading_addr, base, symbols);
+}
+
+bool WriteModuleInfo(int fd, GElf_Half arch, const std::string &obj_file) {
+  const char *arch_name = NULL;
+  if (arch == EM_386)
+    arch_name = "x86";
+  else if (arch == EM_X86_64)
+    arch_name = "x86_64";
+  else
+    return false;
+
+  unsigned char identifier[16];
+  google_breakpad::FileID file_id(obj_file.c_str());
+  if (file_id.ElfFileIdentifier(identifier)) {
+    char identifier_str[40];
+    file_id.ConvertIdentifierToString(identifier,
+                                      identifier_str, sizeof(identifier_str));
+    std::string filename = obj_file;
+    size_t slash_pos = obj_file.find_last_of("/");
+    if (slash_pos != std::string::npos)
+      filename = obj_file.substr(slash_pos + 1);
+    return WriteFormat(fd, "MODULE solaris %s %s %s\n", arch_name,
+                       identifier_str, filename.c_str());
+  }
+  return false;
+}
+
+bool WriteSourceFileInfo(int fd, const struct SymbolInfo &symbols) {
+  for (size_t i = 0; i < symbols.source_file_info.size(); ++i) {
+    if (symbols.source_file_info[i].source_id != -1) {
+      const char *name = symbols.source_file_info[i].name;
+      if (!WriteFormat(fd, "FILE %d %s\n",
+                       symbols.source_file_info[i].source_id, name))
+        return false;
+    }
+  }
+  return true;
+}
+
+bool WriteOneFunction(int fd, int source_id,
+                      const struct FuncInfo &func_info){
+  // Discard the ending part of the name.
+  std::string func_name(func_info.name);
+  std::string::size_type last_colon = func_name.find_last_of(':');
+  if (last_colon != std::string::npos)
+    func_name = func_name.substr(0, last_colon);
+  func_name = Demangle(func_name.c_str());
+
+  if (func_info.size < 0)
+    return true;
+
+  // rva_to_base could be unsigned long(32 bit) or unsigned long long(64 bit).
+  if (WriteFormat(fd, "FUNC %llx %d %d %s\n",
+                  (long long)func_info.rva_to_base,
+                  func_info.size,
+                  func_info.stack_param_size,
+                  func_name.c_str())) {
+    for (size_t i = 0; i < func_info.line_info.size(); ++i) {
+      const struct LineInfo &line_info = func_info.line_info[i];
+      if (!WriteFormat(fd, "%llx %d %d %d\n",
+                       (long long)line_info.rva_to_base,
+                       line_info.size,
+                       line_info.line_num,
+                       source_id))
+        return false;
+    }
+    return true;
+  }
+  return false;
+}
+
+bool WriteFunctionInfo(int fd, const struct SymbolInfo &symbols) {
+  for (size_t i = 0; i < symbols.source_file_info.size(); ++i) {
+    const struct SourceFileInfo &file_info = symbols.source_file_info[i];
+    for (size_t j = 0; j < file_info.func_info.size(); ++j) {
+      const struct FuncInfo &func_info = file_info.func_info[j];
+      if (!WriteOneFunction(fd, file_info.source_id, func_info))
+        return false;
+    }
+  }
+  return true;
+}
+
+bool DumpStabSymbols(int fd, const struct SymbolInfo &symbols) {
+  return WriteSourceFileInfo(fd, symbols) &&
+    WriteFunctionInfo(fd, symbols);
+}
+
+//
+// FDWrapper
+//
+// Wrapper class to make sure opened file is closed.
+//
+class FDWrapper {
+ public:
+  explicit FDWrapper(int fd) :
+    fd_(fd) {
+    }
+  ~FDWrapper() {
+    if (fd_ != -1)
+      close(fd_);
+  }
+  int get() {
+    return fd_;
+  }
+  int release() {
+    int fd = fd_;
+    fd_ = -1;
+    return fd;
+  }
+ private:
+  int fd_;
+};
+
+//
+// MmapWrapper
+//
+// Wrapper class to make sure mapped regions are unmapped.
+//
+class MmapWrapper {
+ public:
+  MmapWrapper(void *mapped_address, size_t mapped_size) :
+    base_(mapped_address), size_(mapped_size) {
+  }
+  ~MmapWrapper() {
+    if (base_ != NULL) {
+      assert(size_ > 0);
+      munmap((char *)base_, size_);
+    }
+  }
+  void release() {
+    base_ = NULL;
+    size_ = 0;
+  }
+
+ private:
+  void *base_;
+  size_t size_;
+};
+
+}  // namespace
+
+namespace google_breakpad {
+
+class AutoElfEnder {
+ public:
+  AutoElfEnder(Elf *elf) : elf_(elf) {}
+  ~AutoElfEnder() { if (elf_) elf_end(elf_); }
+ private:
+  Elf *elf_;
+};
+
+
+bool DumpSymbols::WriteSymbolFile(const std::string &obj_file, int sym_fd) {
+  if (elf_version(EV_CURRENT) == EV_NONE) {
+    fprintf(stderr, "elf_version() failed: %s\n", elf_errmsg(0));
+    return false;
+  }
+
+  int obj_fd = open(obj_file.c_str(), O_RDONLY);
+  if (obj_fd < 0)
+    return false;
+  FDWrapper obj_fd_wrapper(obj_fd);
+  struct stat st;
+  if (fstat(obj_fd, &st) != 0 && st.st_size <= 0)
+    return false;
+  void *obj_base = mmap(NULL, st.st_size,
+                        PROT_READ, MAP_PRIVATE, obj_fd, 0);
+  if (!obj_base)
+    return false;
+  MmapWrapper map_wrapper(obj_base, st.st_size);
+  GElf_Ehdr elf_header;
+  Elf *elf = elf_begin(obj_fd, ELF_C_READ, NULL);
+  AutoElfEnder elfEnder(elf);
+
+  if (gelf_getehdr(elf, &elf_header) == (GElf_Ehdr *)NULL) {
+    fprintf(stderr, "failed to read elf header: %s\n", elf_errmsg(-1));
+    return false;
+  }
+
+  if (!IsValidElf(&elf_header)) {
+    fprintf(stderr, "header magic doesn't match\n");
+    return false;
+  }
+  struct SymbolInfo symbols;
+  if (!LoadSymbols(elf, &elf_header, &symbols, obj_base))
+    return false;
+  // Write to symbol file.
+  if (WriteModuleInfo(sym_fd, elf_header.e_machine, obj_file) &&
+      DumpStabSymbols(sym_fd, symbols))
+    return true;
+
+  return false;
+}
+
+}  // namespace google_breakpad
Index: toolkit/crashreporter/google-breakpad/src/common/solaris/dump_symbols.h
===================================================================
RCS file: toolkit/crashreporter/google-breakpad/src/common/solaris/dump_symbols.h
diff -N toolkit/crashreporter/google-breakpad/src/common/solaris/dump_symbols.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/crashreporter/google-breakpad/src/common/solaris/dump_symbols.h	21 Oct 2007 15:36:06 -0000	1.1
@@ -0,0 +1,49 @@
+// Copyright (c) 2007, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// dump_symbols.cc: Implements a Solaris stab debugging format dumper.
+//
+// Author: Alfred Peng
+
+#ifndef COMMON_SOLARIS_DUMP_SYMBOLS_H__
+#define COMMON_SOLARIS_DUMP_SYMBOLS_H__
+
+#include <string>
+
+namespace google_breakpad {
+
+class DumpSymbols {
+ public:
+  bool WriteSymbolFile(const std::string &obj_file,
+                       int sym_fd);
+};
+
+}  // namespace google_breakpad
+
+#endif  // COMMON_SOLARIS_DUMP_SYMBOLS_H__
Index: toolkit/crashreporter/google-breakpad/src/common/solaris/file_id.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/solaris/file_id.cc,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/common/solaris/file_id.cc	10 Aug 2007 02:56:15 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/common/solaris/file_id.cc	21 Oct 2007 15:36:06 -0000	1.2
@@ -36,8 +36,6 @@
 #include <elf.h>
 #include <fcntl.h>
 #include <gelf.h>
-#include <gnutls/openssl.h>
-#include <link.h>
 #include <sys/mman.h>
 #include <sys/ksyms.h>
 #include <stdio.h>
@@ -47,6 +45,7 @@
 #include <cassert>
 #include <cstdio>
 
+#include "common/md5.h"
 #include "common/solaris/file_id.h"
 #include "common/solaris/message_output.h"
 #include "google_breakpad/common/minidump_format.h"
@@ -130,7 +129,7 @@
 }
 
 FileID::FileID(const char *path) {
-  strncpy(path_, path, strlen(path));
+  strcpy(path_, path);
 }
 
 class AutoCloser {
@@ -160,10 +159,10 @@
   int text_size = 0;
 
   if (FindElfTextSection(fd, base, &text_section, &text_size)) {
-    MD5_CTX md5;
-    MD5_Init(&md5);
-    MD5_Update(&md5, text_section, text_size);
-    MD5_Final(identifier, &md5);
+    MD5Context md5;
+    MD5Init(&md5);
+    MD5Update(&md5, (const unsigned char *)text_section, text_size);
+    MD5Final(identifier, &md5);
     success = true;
   }
 
Index: toolkit/crashreporter/google-breakpad/src/common/windows/http_upload.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/common/windows/http_upload.cc,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- toolkit/crashreporter/google-breakpad/src/common/windows/http_upload.cc	25 Jul 2007 01:06:12 -0000	1.5
+++ toolkit/crashreporter/google-breakpad/src/common/windows/http_upload.cc	21 Oct 2007 15:36:06 -0000	1.6
@@ -137,7 +137,8 @@
   wstring content_type_header = GenerateRequestHeader(boundary);
   HttpAddRequestHeaders(request.get(),
                         content_type_header.c_str(),
-                        -1, HTTP_ADDREQ_FLAG_ADD);
+                        static_cast<DWORD>(-1),
+                        HTTP_ADDREQ_FLAG_ADD);
 
   string request_body;
   if (!GenerateRequestBody(parameters, upload_file,
@@ -179,7 +180,7 @@
   bool has_content_length_header = false;
   wchar_t content_length[32];
   DWORD content_length_size = sizeof(content_length);
-  DWORD claimed_size;
+  DWORD claimed_size = 0;
   string response_body;
 
   if (HttpQueryInfo(request, HTTP_QUERY_CONTENT_LENGTH,
Index: toolkit/crashreporter/google-breakpad/src/google_breakpad/common/minidump_format.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/google_breakpad/common/minidump_format.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -r1.4 -r1.5
--- toolkit/crashreporter/google-breakpad/src/google_breakpad/common/minidump_format.h	10 Aug 2007 02:56:15 -0000	1.4
+++ toolkit/crashreporter/google-breakpad/src/google_breakpad/common/minidump_format.h	21 Oct 2007 15:36:05 -0000	1.5
@@ -215,6 +215,87 @@
 
 #define MD_CONTEXT_CPU_MASK 0xffffffc0
 
+/*
+ * SPARC support, see (solaris)sys/procfs_isa.h also
+ */
+
+#define MD_FLOATINGSAVEAREA_SPARC_FPR_COUNT 32
+
+typedef struct {
+
+  /* FPU floating point regs */
+  u_int64_t	regs[MD_FLOATINGSAVEAREA_SPARC_FPR_COUNT];
+
+  u_int64_t	filler;
+  u_int64_t	fsr;        /* FPU status register */
+} MDFloatingSaveAreaSPARC;  /* FLOATING_SAVE_AREA */
+
+#define MD_CONTEXT_SPARC_GPR_COUNT 32
+
+typedef struct {
+  /* The next field determines the layout of the structure, and which parts
+   * of it are populated
+   */
+  u_int32_t	context_flags;
+  u_int32_t	flag_pad;
+  /*
+   * General register access (SPARC).
+   * Don't confuse definitions here with definitions in <sys/regset.h>.
+   * Registers are 32 bits for ILP32, 64 bits for LP64.
+   * SPARC V7/V8 is for 32bit, SPARC V9 is for 64bit
+   */
+
+  /* 32 Integer working registers */
+
+  /* g_r[0-7]   global registers(g0-g7)
+   * g_r[8-15]  out registers(o0-o7)
+   * g_r[16-23] local registers(l0-l7)
+   * g_r[24-31] in registers(i0-i7)
+   */
+  u_int64_t     g_r[MD_CONTEXT_SPARC_GPR_COUNT];
+
+  /* several control registers */
+
+  /* Processor State register(PSR) for SPARC V7/V8
+   * Condition Code register (CCR) for SPARC V9
+   */
+  u_int64_t     ccr;
+
+  u_int64_t     pc;     /* Program Counter register (PC) */
+  u_int64_t     npc;    /* Next Program Counter register (nPC) */
+  u_int64_t     y;      /* Y register (Y) */
+
+  /* Address Space Identifier register (ASI) for SPARC V9
+   * WIM for SPARC V7/V8
+   */
+  u_int64_t     asi;
+
+  /* Floating-Point Registers State register (FPRS) for SPARC V9
+   * TBR for for SPARC V7/V8
+   */
+  u_int64_t     fprs;
+
+  /* The next field is included with MD_CONTEXT_SPARC_FLOATING_POINT */
+  MDFloatingSaveAreaSPARC float_save;
+
+} MDRawContextSPARC;  /* CONTEXT_SPARC */
+
+/* For (MDRawContextSPARC).context_flags.  These values indicate the type of
+ * context stored in the structure.  MD_CONTEXT_SPARC is Breakpad-defined.  Its
+ * value was chosen to avoid likely conflicts with MD_CONTEXT_* for other
+ * CPUs. */
+#define MD_CONTEXT_SPARC                 0x10000000
+#define MD_CONTEXT_SPARC_CONTROL         (MD_CONTEXT_SPARC | 0x00000001)
+#define MD_CONTEXT_SPARC_INTEGER         (MD_CONTEXT_SPARC | 0x00000002)
+#define MD_CONTEXT_SAPARC_FLOATING_POINT (MD_CONTEXT_SPARC | 0x00000004)
+#define MD_CONTEXT_SAPARC_EXTRA          (MD_CONTEXT_SPARC | 0x00000008)
+
+#define MD_CONTEXT_SPARC_FULL            (MD_CONTEXT_SPARC_CONTROL | \
+                                          MD_CONTEXT_SPARC_INTEGER)
+
+#define MD_CONTEXT_SPARC_ALL             (MD_CONTEXT_SPARC_FULL | \
+                                          MD_CONTEXT_SAPARC_FLOATING_POINT | \
+                                          MD_CONTEXT_SAPARC_EXTRA)
 
 /*
  * Breakpad minidump extension for PowerPC support.  Based on Darwin/Mac OS X'
@@ -929,6 +1010,54 @@
   MD_EXCEPTION_CODE_LIN_SIGSYS = 31      /* Bad system call */
 } MDExceptionCodeLinux;
 
+/* For (MDException).exception_code.  These values come from sys/iso/signal_iso.h
+ */
+typedef enum {
+  MD_EXCEPTION_CODE_SOL_SIGHUP = 1,      /* Hangup */
+  MD_EXCEPTION_CODE_SOL_SIGINT = 2,      /* interrupt (rubout) */
+  MD_EXCEPTION_CODE_SOL_SIGQUIT = 3,     /* quit (ASCII FS) */
+  MD_EXCEPTION_CODE_SOL_SIGILL = 4,      /* illegal instruction (not reset when caught) */
+  MD_EXCEPTION_CODE_SOL_SIGTRAP = 5,     /* trace trap (not reset when caught) */
+  MD_EXCEPTION_CODE_SOL_SIGIOT = 6,      /* IOT instruction */
+  MD_EXCEPTION_CODE_SOL_SIGABRT = 6,     /* used by abort, replace SIGIOT in the future */
+  MD_EXCEPTION_CODE_SOL_SIGEMT = 7,      /* EMT instruction */
+  MD_EXCEPTION_CODE_SOL_SIGFPE = 8,      /* floating point exception */
+  MD_EXCEPTION_CODE_SOL_SIGKILL = 9,     /* kill (cannot be caught or ignored) */
+  MD_EXCEPTION_CODE_SOL_SIGBUS = 10,     /* bus error */
+  MD_EXCEPTION_CODE_SOL_SIGSEGV = 11,    /* segmentation violation */
+  MD_EXCEPTION_CODE_SOL_SIGSYS = 12,     /* bad argument to system call */
+  MD_EXCEPTION_CODE_SOL_SIGPIPE = 13,    /* write on a pipe with no one to read it */
+  MD_EXCEPTION_CODE_SOL_SIGALRM = 14,    /* alarm clock */
+  MD_EXCEPTION_CODE_SOL_SIGTERM = 15,    /* software termination signal from kill */
+  MD_EXCEPTION_CODE_SOL_SIGUSR1 = 16,    /* user defined signal 1 */
+  MD_EXCEPTION_CODE_SOL_SIGUSR2 = 17,    /* user defined signal 2 */
+  MD_EXCEPTION_CODE_SOL_SIGCLD = 18,     /* child status change */
+  MD_EXCEPTION_CODE_SOL_SIGCHLD = 18,    /* child status change alias (POSIX) */
+  MD_EXCEPTION_CODE_SOL_SIGPWR = 19,     /* power-fail restart */
+  MD_EXCEPTION_CODE_SOL_SIGWINCH = 20,   /* window size change */
+  MD_EXCEPTION_CODE_SOL_SIGURG = 21,     /* urgent socket condition */
+  MD_EXCEPTION_CODE_SOL_SIGPOLL = 22,    /* pollable event occured */
+  MD_EXCEPTION_CODE_SOL_SIGIO = 22,      /* socket I/O possible (SIGPOLL alias) */
+  MD_EXCEPTION_CODE_SOL_SIGSTOP = 23,    /* stop (cannot be caught or ignored) */
+  MD_EXCEPTION_CODE_SOL_SIGTSTP = 24,    /* user stop requested from tty */
+  MD_EXCEPTION_CODE_SOL_SIGCONT = 25,    /* stopped process has been continued */
+  MD_EXCEPTION_CODE_SOL_SIGTTIN = 26,    /* background tty read attempted */
+  MD_EXCEPTION_CODE_SOL_SIGTTOU = 27,    /* background tty write attempted */
+  MD_EXCEPTION_CODE_SOL_SIGVTALRM = 28,  /* virtual timer expired */
+  MD_EXCEPTION_CODE_SOL_SIGPROF = 29,    /* profiling timer expired */
+  MD_EXCEPTION_CODE_SOL_SIGXCPU = 30,    /* exceeded cpu limit */
+  MD_EXCEPTION_CODE_SOL_SIGXFSZ = 31,    /* exceeded file size limit */
+  MD_EXCEPTION_CODE_SOL_SIGWAITING = 32, /* reserved signal no longer used by threading code */
+  MD_EXCEPTION_CODE_SOL_SIGLWP = 33,     /* reserved signal no longer used by threading code */
+  MD_EXCEPTION_CODE_SOL_SIGFREEZE = 34,  /* special signal used by CPR */
+  MD_EXCEPTION_CODE_SOL_SIGTHAW = 35,    /* special signal used by CPR */
+  MD_EXCEPTION_CODE_SOL_SIGCANCEL = 36,  /* reserved signal for thread cancellation */
+  MD_EXCEPTION_CODE_SOL_SIGLOST = 37,    /* resource lost (eg, record-lock lost) */
+  MD_EXCEPTION_CODE_SOL_SIGXRES = 38,    /* resource control exceeded */
+  MD_EXCEPTION_CODE_SOL_SIGJVM1 = 39,    /* reserved signal for Java Virtual Machine */
+  MD_EXCEPTION_CODE_SOL_SIGJVM2 = 40     /* reserved signal for Java Virtual Machine */
+} MDExceptionCodeSolaris;
+
 typedef struct {
   u_int32_t            thread_id;         /* Thread in which the exception
                                            * occurred.  Corresponds to
Index: toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/basic_source_line_resolver.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/basic_source_line_resolver.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/basic_source_line_resolver.h	25 Jul 2007 01:06:12 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/basic_source_line_resolver.h	21 Oct 2007 15:36:05 -0000	1.2
@@ -33,14 +33,28 @@
 #ifndef GOOGLE_BREAKPAD_PROCESSOR_BASIC_SOURCE_LINE_RESOLVER_H__
 #define GOOGLE_BREAKPAD_PROCESSOR_BASIC_SOURCE_LINE_RESOLVER_H__
 
+// TODO: Platforms that have no hash_map can use map, at the likely cost of
+// performance.
+#ifdef __SUNPRO_CC
+#define BSLR_NO_HASH_MAP
+#endif  // __SUNPRO_CC
+
+#ifdef BSLR_NO_HASH_MAP
+#include <map>
+#else  // BSLR_NO_HASH_MAP
 #include <ext/hash_map>
+#endif  // BSLR_NO_HASH_MAP
 
 #include "google_breakpad/processor/source_line_resolver_interface.h"
 
 namespace google_breakpad {
 
 using std::string;
+#ifdef BSLR_NO_HASH_MAP
+using std::map;
+#else  // BSLR_NO_HASH_MAP
 using __gnu_cxx::hash_map;
+#endif  // BSLR_NO_HASH_MAP
 
 class BasicSourceLineResolver : public SourceLineResolverInterface {
  public:
@@ -65,13 +79,23 @@
   struct Function;
   struct PublicSymbol;
   struct File;
+#ifdef BSLR_NO_HASH_MAP
+  struct CompareString {
+    bool operator()(const string &s1, const string &s2) const;
+  };
+#else  // BSLR_NO_HASH_MAP
   struct HashString {
     size_t operator()(const string &s) const;
   };
+#endif  // BSLR_NO_HASH_MAP
   class Module;
 
   // All of the modules we've loaded
+#ifdef BSLR_NO_HASH_MAP
+  typedef map<string, Module*, CompareString> ModuleMap;
+#else  // BSLR_NO_HASH_MAP
   typedef hash_map<string, Module*, HashString> ModuleMap;
+#endif  // BSLR_NO_HASH_MAP
   ModuleMap *modules_;
 
   // Disallow unwanted copy ctor and assignment operator
Index: toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/code_module.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/code_module.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/code_module.h	25 Jul 2007 01:06:12 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/code_module.h	21 Oct 2007 15:36:05 -0000	1.2
@@ -36,6 +36,7 @@
 #define GOOGLE_BREAKPAD_PROCESSOR_CODE_MODULE_H__
 
 #include <string>
+#include "google_breakpad/common/breakpad_types.h"
 
 namespace google_breakpad {
 
Index: toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/minidump.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/minidump.h,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -r1.2 -r1.3
--- toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/minidump.h	25 Jul 2007 01:06:13 -0000	1.2
+++ toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/minidump.h	21 Oct 2007 15:36:05 -0000	1.3
@@ -177,7 +177,8 @@
   // NULL.
   const MDRawContextX86* GetContextX86() const;
   const MDRawContextPPC* GetContextPPC() const;
-
+  const MDRawContextSPARC* GetContextSPARC() const;
+ 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
@@ -204,6 +205,9 @@
     MDRawContextBase* base;
     MDRawContextX86*  x86;
     MDRawContextPPC*  ppc;
+    // on Solaris SPARC, sparc is defined as a numeric constant,
+    // so variables can NOT be named as sparc
+    MDRawContextSPARC*  ctx_sparc;
   } context_;
 };
 
Index: toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/minidump_processor.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/minidump_processor.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/minidump_processor.h	25 Jul 2007 01:06:13 -0000	1.3
+++ toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/minidump_processor.h	21 Oct 2007 15:36:05 -0000	1.4
@@ -31,6 +31,7 @@
 #define GOOGLE_BREAKPAD_PROCESSOR_MINIDUMP_PROCESSOR_H__
 
 #include <string>
+#include "google_breakpad/common/breakpad_types.h"
 
 namespace google_breakpad {
 
Index: toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/process_state.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/process_state.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/process_state.h	25 Jul 2007 01:06:13 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/process_state.h	21 Oct 2007 15:36:05 -0000	1.2
@@ -37,6 +37,7 @@
 #include <string>
 #include <vector>
 #include "google_breakpad/processor/system_info.h"
+#include "google_breakpad/common/breakpad_types.h"
 
 namespace google_breakpad {
 
Index: toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/stack_frame_cpu.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/stack_frame_cpu.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/stack_frame_cpu.h	25 Jul 2007 01:06:13 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/google_breakpad/processor/stack_frame_cpu.h	21 Oct 2007 15:36:05 -0000	1.2
@@ -98,6 +98,30 @@
   int context_validity;
 };
 
+struct StackFrameSPARC : public StackFrame {
+  // to be confirmed
+  enum ContextValidity {
+    CONTEXT_VALID_NONE = 0,
+    CONTEXT_VALID_PC   = 0 << 0,
+    CONTEXT_VALID_SP   = 0 << 1,
+    CONTEXT_VALID_FP   = 0 << 2,
+    CONTEXT_VALID_ALL  = -1
+  };
+
+  StackFrameSPARC() : context(), context_validity(CONTEXT_VALID_NONE) {}
+
+  // Register state.  This is only fully valid for the topmost frame in a
+  // stack.  In other frames, the values of nonvolatile registers may be
+  // present, given sufficient debugging information.  Refer to
+  // context_validity.
+  MDRawContextSPARC context;
+
+  // context_validity is actually ContextValidity, but int is used because
+  // the OR operator doesn't work well with enumerated types.  This indicates
+  // which fields in context are valid.
+  int context_validity;
+};
+
 }  // namespace google_breakpad
 
 #endif  // GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_CPU_H__
Index: toolkit/crashreporter/google-breakpad/src/processor/basic_source_line_resolver.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/processor/basic_source_line_resolver.cc,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -r1.2 -r1.3
--- toolkit/crashreporter/google-breakpad/src/processor/basic_source_line_resolver.cc	25 Jul 2007 01:06:13 -0000	1.2
+++ toolkit/crashreporter/google-breakpad/src/processor/basic_source_line_resolver.cc	21 Oct 2007 15:36:00 -0000	1.3
@@ -48,7 +48,9 @@
 using std::map;
 using std::vector;
 using std::make_pair;
+#ifndef BSLR_NO_HASH_MAP
 using __gnu_cxx::hash;
+#endif  // BSLR_NO_HASH_MAP
 
 namespace google_breakpad {
 
@@ -116,7 +118,11 @@
 
  private:
   friend class BasicSourceLineResolver;
+#ifdef BSLR_NO_HASH_MAP
+  typedef map<int, string> FileMap;
+#else  // BSLR_NO_HASH_MAP
   typedef hash_map<int, string> FileMap;
+#endif  // BSLR_NO_HASH_MAP
 
   // The types for stack_info_.  This is equivalent to MS DIA's
   // StackFrameTypeEnum.  Each identifies a different type of frame
@@ -594,8 +600,15 @@
   return true;
 }
 
+#ifdef BSLR_NO_HASH_MAP
+bool BasicSourceLineResolver::CompareString::operator()(
+    const string &s1, const string &s2) const {
+  return strcmp(s1.c_str(), s2.c_str()) < 0;
+}
+#else  // BSLR_NO_HASH_MAP
 size_t BasicSourceLineResolver::HashString::operator()(const string &s) const {
   return hash<const char*>()(s.c_str());
 }
+#endif  // BSLR_NO_HASH_MAP
 
 }  // namespace google_breakpad
Index: toolkit/crashreporter/google-breakpad/src/processor/contained_range_map-inl.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/processor/contained_range_map-inl.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- toolkit/crashreporter/google-breakpad/src/processor/contained_range_map-inl.h	25 Jul 2007 01:06:13 -0000	1.3
+++ toolkit/crashreporter/google-breakpad/src/processor/contained_range_map-inl.h	21 Oct 2007 15:36:00 -0000	1.4
@@ -70,7 +70,7 @@
 
   MapIterator iterator_base = map_->lower_bound(base);
   MapIterator iterator_high = map_->lower_bound(high);
-  MapConstIterator iterator_end = map_->end();
+  MapIterator iterator_end = map_->end();
 
   if (iterator_base == iterator_high && iterator_base != iterator_end &&
       base >= iterator_base->second->base_) {
Index: toolkit/crashreporter/google-breakpad/src/processor/minidump.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/processor/minidump.cc,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- toolkit/crashreporter/google-breakpad/src/processor/minidump.cc	25 Jul 2007 01:06:13 -0000	1.5
+++ toolkit/crashreporter/google-breakpad/src/processor/minidump.cc	21 Oct 2007 15:36:00 -0000	1.6
@@ -106,7 +106,7 @@
 }
 
 
-static void Swap(u_int64_t* value) {
+static inline void Swap(u_int64_t* value) {
   u_int32_t* value32 = reinterpret_cast<u_int32_t*>(value);
   Swap(&value32[0]);
   Swap(&value32[1]);
@@ -450,6 +450,62 @@
       break;
     }
 
+    case MD_CONTEXT_SPARC: {
+      if (expected_size != sizeof(MDRawContextSPARC)) {
+        BPLOG(ERROR) << "MinidumpContext sparc size mismatch, " <<
+                        expected_size << " != " << sizeof(MDRawContextSPARC);
+        return false;
+      }
+
+      scoped_ptr<MDRawContextSPARC> context_sparc(new MDRawContextSPARC());
+
+      // Set the context_flags member, which has already been read, and
+      // read the rest of the structure beginning with the first member
+      // after context_flags.
+      context_sparc->context_flags = context_flags;
+
+      size_t flags_size = sizeof(context_sparc->context_flags);
+      u_int8_t* context_after_flags =
+          reinterpret_cast<u_int8_t*>(context_sparc.get()) + flags_size;
+      if (!minidump_->ReadBytes(context_after_flags,
+                                sizeof(MDRawContextSPARC) - flags_size)) {
+        BPLOG(ERROR) << "MinidumpContext could not read sparc context";
+        return false;
+      }
+
+      // Do this after reading the entire MDRawContext structure because
+      // GetSystemInfo may seek minidump to a new position.
+      if (!CheckAgainstSystemInfo(cpu_type)) {
+        BPLOG(ERROR) << "MinidumpContext sparc does not match system info";
+        return false;
+      }
+
+      if (minidump_->swap()) {
+        // context_sparc->context_flags was already swapped.
+        for (unsigned int gpr_index = 0;
+             gpr_index < MD_CONTEXT_SPARC_GPR_COUNT;
+             ++gpr_index) {
+          Swap(&context_sparc->g_r[gpr_index]);
+        }
+        Swap(&context_sparc->ccr);
+        Swap(&context_sparc->pc);
+        Swap(&context_sparc->npc);
+        Swap(&context_sparc->y);
+        Swap(&context_sparc->asi);
+        Swap(&context_sparc->fprs);
+        for (unsigned int fpr_index = 0;
+             fpr_index < MD_FLOATINGSAVEAREA_SPARC_FPR_COUNT;
+             ++fpr_index) {
+          Swap(&context_sparc->float_save.regs[fpr_index]);
+        }
+        Swap(&context_sparc->float_save.filler);
+        Swap(&context_sparc->float_save.fsr);
+      }
+      context_.ctx_sparc = context_sparc.release();
+
+      break;
+    }
+
     default: {
       // Unknown context type
       BPLOG(ERROR) << "MinidumpContext unknown context type " <<
@@ -494,6 +550,14 @@
   return context_.ppc;
 }
 
+const MDRawContextSPARC* MinidumpContext::GetContextSPARC() const {
+  if (GetContextCPU() != MD_CONTEXT_SPARC) {
+    BPLOG(ERROR) << "MinidumpContext cannot get sparc context";
+    return NULL;
+  }
+
+  return context_.ctx_sparc;
+}
 
 void MinidumpContext::FreeContext() {
   switch (GetContextCPU()) {
@@ -505,6 +569,10 @@
       delete context_.ppc;
       break;
 
+    case MD_CONTEXT_SPARC:
+      delete context_.ctx_sparc;
+      break;
+
     default:
       // There is no context record (valid_ is false) or there's a
       // context record for an unknown CPU (shouldn't happen, only known
@@ -552,6 +620,11 @@
       if (system_info_cpu_type == MD_CPU_ARCHITECTURE_PPC)
         return_value = true;
       break;
+
+    case MD_CONTEXT_SPARC:
+      if (system_info_cpu_type == MD_CPU_ARCHITECTURE_SPARC)
+        return_value = true;
+      break;
   }
 
   BPLOG_IF(ERROR, !return_value) << "MinidumpContext CPU " <<
@@ -672,6 +745,37 @@
       break;
     }
 
+    case MD_CONTEXT_SPARC: {
+      const MDRawContextSPARC* context_sparc = GetContextSPARC();
+      printf("MDRawContextSPARC\n");
+      printf("  context_flags       = 0x%x\n",
+             context_sparc->context_flags);
+      for (unsigned int g_r_index = 0;
+           g_r_index < MD_CONTEXT_SPARC_GPR_COUNT;
+           ++g_r_index) {
+        printf("  g_r[%2d]             = 0x%llx\n",
+               g_r_index, context_sparc->g_r[g_r_index]);
+      }
+      printf("  ccr                 = 0x%llx\n", context_sparc->ccr);
+      printf("  pc                  = 0x%llx\n", context_sparc->pc);
+      printf("  npc                 = 0x%llx\n", context_sparc->npc);
+      printf("  y                   = 0x%llx\n", context_sparc->y);
+      printf("  asi                 = 0x%llx\n", context_sparc->asi);
+      printf("  fprs                = 0x%llx\n", context_sparc->fprs);
+
+      for (unsigned int fpr_index = 0;
+           fpr_index < MD_FLOATINGSAVEAREA_SPARC_FPR_COUNT;
+           ++fpr_index) {
+        printf("  float_save.regs[%2d] = 0x%llx\n",
+               fpr_index, context_sparc->float_save.regs[fpr_index]);
+      }
+      printf("  float_save.filler   = 0x%llx\n",
+             context_sparc->float_save.filler);
+      printf("  float_save.fsr      = 0x%llx\n",
+             context_sparc->float_save.fsr);
+      break;
+    }
+
     default: {
       break;
     }
@@ -1068,12 +1172,23 @@
 
   if (expected_size != sizeof(thread_count) +
                        thread_count * sizeof(MDRawThread)) {
-    BPLOG(ERROR) << "MinidumpThreadList size mismatch, " << expected_size <<
-                    " != " <<
-                    sizeof(thread_count) + thread_count * sizeof(MDRawThread);
-    return false;
+    // may be padded with 4 bytes on 64bit ABIs for alignment
+    if (expected_size == sizeof(thread_count) + 4 +
+                         thread_count * sizeof(MDRawThread)) {
+      u_int32_t useless;
+      if (!minidump_->ReadBytes(&useless, 4)) {
+        BPLOG(ERROR) << "MinidumpThreadList cannot read threadlist padded bytes";
+        return false;
+      }
+    } else {
+      BPLOG(ERROR) << "MinidumpThreadList size mismatch, " << expected_size <<
+                    " != " << sizeof(thread_count) +
+                    thread_count * sizeof(MDRawThread);
+      return false;
+    }
   }
 
+  
   if (thread_count > max_threads_) {
     BPLOG(ERROR) << "MinidumpThreadList count " << thread_count <<
                     " exceeds maximum " << max_threads_;
@@ -1328,6 +1443,7 @@
     }
 
     case MD_OS_MAC_OS_X:
+    case MD_OS_SOLARIS:
     case MD_OS_LINUX: {
       // TODO(mmentovai): support uuid extension if present, otherwise fall
       // back to version (from LC_ID_DYLIB?), otherwise fall back to something
@@ -1924,10 +2040,20 @@
 
   if (expected_size != sizeof(module_count) +
                        module_count * MD_MODULE_SIZE) {
-    BPLOG(ERROR) << "MinidumpModuleList size mismatch, " << expected_size <<
-                    " != " <<
-                    sizeof(module_count) + module_count * MD_MODULE_SIZE;
-    return false;
+    // may be padded with 4 bytes on 64bit ABIs for alignment
+    if (expected_size == sizeof(module_count) + 4 +
+                         module_count * MD_MODULE_SIZE) {
+      u_int32_t useless;
+      if (!minidump_->ReadBytes(&useless, 4)) {
+        BPLOG(ERROR) << "MinidumpModuleList cannot read modulelist padded bytes";
+        return false;
+      }
+    } else {
+      BPLOG(ERROR) << "MinidumpModuleList size mismatch, " << expected_size <<
+                      " != " << sizeof(module_count) +
+                      module_count * MD_MODULE_SIZE;
+      return false;
+    }
   }
 
   if (module_count > max_modules_) {
@@ -2155,9 +2281,20 @@
 
   if (expected_size != sizeof(region_count) +
                        region_count * sizeof(MDMemoryDescriptor)) {
-    BPLOG(ERROR) << "MinidumpMemoryList size mismatch, " << expected_size <<
-                    " != " << region_count * sizeof(MDMemoryDescriptor);
-    return false;
+    // may be padded with 4 bytes on 64bit ABIs for alignment
+    if (expected_size == sizeof(region_count) + 4 +
+                         region_count * sizeof(MDMemoryDescriptor)) {
+      u_int32_t useless;
+      if (!minidump_->ReadBytes(&useless, 4)) {
+        BPLOG(ERROR) << "MinidumpMemoryList cannot read memorylist padded bytes";
+        return false;
+      }
+    } else {
+      BPLOG(ERROR) << "MinidumpMemoryList size mismatch, " << expected_size <<
+                      " != " << sizeof(region_count) + 
+                      region_count * sizeof(MDMemoryDescriptor);
+      return false;
+    }
   }
 
   if (region_count > max_regions_) {
@@ -2526,6 +2663,10 @@
       os = "linux";
       break;
 
+    case MD_OS_SOLARIS:
+      os = "solaris";
+      break;
+
     default:
       BPLOG(ERROR) << "MinidumpSystemInfo unknown OS for platform " <<
                       HexString(system_info_.platform_id);
Index: toolkit/crashreporter/google-breakpad/src/processor/minidump_processor.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/processor/minidump_processor.cc,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- toolkit/crashreporter/google-breakpad/src/processor/minidump_processor.cc	25 Jul 2007 01:06:13 -0000	1.5
+++ toolkit/crashreporter/google-breakpad/src/processor/minidump_processor.cc	21 Oct 2007 15:36:00 -0000	1.6
@@ -280,6 +280,11 @@
       break;
     }
 
+    case MD_CPU_ARCHITECTURE_SPARC: {
+      info->cpu = "sparc";
+      break;
+    }
+
     default: {
       // Assign the numeric architecture ID into the CPU string.
       char cpu_string[7];
@@ -332,6 +337,11 @@
       break;
     }
 
+    case MD_OS_SOLARIS: {
+      info->os = "Solaris";
+      break;
+    }
+
     default: {
       // Assign the numeric platform ID into the OS string.
       char os_string[11];
@@ -731,8 +741,9 @@
           break;
       }
       break;
+    }
 
-    case MD_OS_LINUX:
+    case MD_OS_LINUX: {
       switch (exception_code) {
         case MD_EXCEPTION_CODE_LIN_SIGHUP:
           reason = "SIGHUP";
@@ -834,6 +845,135 @@
       break;
     }
 
+    case MD_OS_SOLARIS: {
+      switch (exception_code) {
+        case MD_EXCEPTION_CODE_SOL_SIGHUP:
+          reason = "SIGHUP";
+          break;
+        case MD_EXCEPTION_CODE_SOL_SIGINT:
+          reason = "SIGINT";
+          break;
+        case MD_EXCEPTION_CODE_SOL_SIGQUIT:
+          reason = "SIGQUIT";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGILL:
+          reason = "SIGILL";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGTRAP:
+          reason = "SIGTRAP";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGIOT:
+          reason = "SIGIOT | SIGABRT";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGEMT:
+          reason = "SIGEMT";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGFPE:
+          reason = "SIGFPE";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGKILL:
+          reason = "SIGKILL";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGBUS:
+          reason = "SIGBUS";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGSEGV:
+          reason = "SIGSEGV";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGSYS:
+          reason = "SIGSYS";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGPIPE:
+          reason = "SIGPIPE";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGALRM:
+          reason = "SIGALRM";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGTERM:
+          reason = "SIGTERM";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGUSR1:
+          reason = "SIGUSR1";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGUSR2:
+          reason = "SIGUSR2";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGCLD:
+          reason = "SIGCLD | SIGCHLD";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGPWR:
+          reason = "SIGPWR";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGWINCH:
+          reason = "SIGWINCH";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGURG:
+          reason = "SIGURG";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGPOLL:
+          reason = "SIGPOLL | SIGIO";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGSTOP:
+          reason = "SIGSTOP";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGTSTP:
+          reason = "SIGTSTP";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGCONT:
+          reason = "SIGCONT";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGTTIN:
+          reason = "SIGTTIN";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGTTOU:
+          reason = "SIGTTOU";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGVTALRM:
+          reason = "SIGVTALRM";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGPROF:
+          reason = "SIGPROF";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGXCPU:
+          reason = "SIGXCPU";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGXFSZ:
+          reason = "SIGXFSZ";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGWAITING:
+          reason = "SIGWAITING";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGLWP:
+          reason = "SIGLWP";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGFREEZE:
+          reason = "SIGFREEZE";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGTHAW:
+          reason = "SIGTHAW";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGCANCEL:
+          reason = "SIGCANCEL";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGLOST:
+          reason = "SIGLOST";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGXRES:
+          reason = "SIGXRES";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGJVM1:
+          reason = "SIGJVM1";
+          break;  
+        case MD_EXCEPTION_CODE_SOL_SIGJVM2:
+          reason = "SIGJVM2";
+          break;  
+        default:
+          BPLOG(INFO) << "Unknown exception reason " << reason;
+          break;
+      }
+      break;
+    }
+
     default: {
       BPLOG(INFO) << "Unknown exception reason " << reason;
       break;
Index: toolkit/crashreporter/google-breakpad/src/processor/minidump_stackwalk.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/processor/minidump_stackwalk.cc,v
retrieving revision 1.6
retrieving revision 1.7
diff -u -r1.6 -r1.7
--- toolkit/crashreporter/google-breakpad/src/processor/minidump_stackwalk.cc	25 Jul 2007 01:06:13 -0000	1.6
+++ toolkit/crashreporter/google-breakpad/src/processor/minidump_stackwalk.cc	21 Oct 2007 15:36:00 -0000	1.7
@@ -66,6 +66,7 @@
 using google_breakpad::SimpleSymbolSupplier;
 using google_breakpad::StackFrame;
 using google_breakpad::StackFramePPC;
+using google_breakpad::StackFrameSPARC;
 using google_breakpad::StackFrameX86;
 
 // Separator character for machine readable output.
@@ -164,6 +165,16 @@
         sequence = PrintRegister("srr0", frame_ppc->context.srr0, sequence);
       if (frame_ppc->context_validity & StackFramePPC::CONTEXT_VALID_GPR1)
         sequence = PrintRegister("r1", frame_ppc->context.gpr[1], sequence);
+    } else if (cpu == "sparc") {
+      const StackFrameSPARC *frame_sparc =
+          reinterpret_cast<const StackFrameSPARC*>(frame);
+
+      if (frame_sparc->context_validity & StackFrameSPARC::CONTEXT_VALID_SP)
+        sequence = PrintRegister("sp", frame_sparc->context.g_r[14], sequence);
+      if (frame_sparc->context_validity & StackFrameSPARC::CONTEXT_VALID_FP)
+        sequence = PrintRegister("fp", frame_sparc->context.g_r[30], sequence);
+      if (frame_sparc->context_validity & StackFrameSPARC::CONTEXT_VALID_PC)
+        sequence = PrintRegister("pc", frame_sparc->context.pc, sequence);
     }
 
     printf("\n");
Index: toolkit/crashreporter/google-breakpad/src/processor/postfix_evaluator-inl.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/processor/postfix_evaluator-inl.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -r1.4 -r1.5
--- toolkit/crashreporter/google-breakpad/src/processor/postfix_evaluator-inl.h	25 Jul 2007 01:06:13 -0000	1.4
+++ toolkit/crashreporter/google-breakpad/src/processor/postfix_evaluator-inl.h	21 Oct 2007 15:36:00 -0000	1.5
@@ -1,16 +1,31 @@
-// Copyright (C) 2006 Google Inc.
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
 //
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
 //
-//     http://www.apache.org/licenses/LICENSE-2.0
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
 //
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 // postfix_evaluator-inl.h: Postfix (reverse Polish) notation expression
 // evaluator.
Index: toolkit/crashreporter/google-breakpad/src/processor/postfix_evaluator.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/processor/postfix_evaluator.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- toolkit/crashreporter/google-breakpad/src/processor/postfix_evaluator.h	25 Jul 2007 01:06:13 -0000	1.3
+++ toolkit/crashreporter/google-breakpad/src/processor/postfix_evaluator.h	21 Oct 2007 15:36:00 -0000	1.4
@@ -1,16 +1,31 @@
-// Copyright (C) 2006 Google Inc.
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
 //
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 // postfix_evaluator.h: Postfix (reverse Polish) notation expression evaluator.
 //
Index: toolkit/crashreporter/google-breakpad/src/processor/simple_symbol_supplier.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/processor/simple_symbol_supplier.cc,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -r1.4 -r1.5
--- toolkit/crashreporter/google-breakpad/src/processor/simple_symbol_supplier.cc	10 Aug 2007 02:56:15 -0000	1.4
+++ toolkit/crashreporter/google-breakpad/src/processor/simple_symbol_supplier.cc	21 Oct 2007 15:36:00 -0000	1.5
@@ -113,8 +113,8 @@
   string debug_file_extension;
   if (debug_file_name.size() > 4)
     debug_file_extension = debug_file_name.substr(debug_file_name.size() - 4);
-  transform(debug_file_extension.begin(), debug_file_extension.end(),
-            debug_file_extension.begin(), tolower);
+  std::transform(debug_file_extension.begin(), debug_file_extension.end(),
+                 debug_file_extension.begin(), tolower);
   if (debug_file_extension == ".pdb") {
     path.append(debug_file_name.substr(0, debug_file_name.size() - 4));
   } else {
Index: toolkit/crashreporter/google-breakpad/src/processor/stackwalker.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/processor/stackwalker.cc,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -r1.5 -r1.6
--- toolkit/crashreporter/google-breakpad/src/processor/stackwalker.cc	25 Jul 2007 01:06:13 -0000	1.5
+++ toolkit/crashreporter/google-breakpad/src/processor/stackwalker.cc	21 Oct 2007 15:36:00 -0000	1.6
@@ -49,6 +49,7 @@
 #include "processor/scoped_ptr.h"
 #include "processor/stack_frame_info.h"
 #include "processor/stackwalker_ppc.h"
+#include "processor/stackwalker_sparc.h"
 #include "processor/stackwalker_x86.h"
 
 namespace google_breakpad {
@@ -163,6 +164,13 @@
                                            memory, modules, supplier,
                                            resolver);
       break;
+  
+    case MD_CONTEXT_SPARC:
+      cpu_stackwalker = new StackwalkerSPARC(system_info,
+                                             context->GetContextSPARC(),
+                                             memory, modules, supplier,
+                                             resolver);
+      break;
   }
 
   BPLOG_IF(ERROR, !cpu_stackwalker) << "Unknown CPU type " << HexString(cpu) <<
Index: toolkit/crashreporter/google-breakpad/src/processor/stackwalker_selftest.cc
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/processor/stackwalker_selftest.cc,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -r1.4 -r1.5
--- toolkit/crashreporter/google-breakpad/src/processor/stackwalker_selftest.cc	25 Jul 2007 01:06:13 -0000	1.4
+++ toolkit/crashreporter/google-breakpad/src/processor/stackwalker_selftest.cc	21 Oct 2007 15:36:00 -0000	1.5
@@ -49,7 +49,17 @@
 //
 // Author: Mark Mentovai
 
-#if defined(__GNUC__) && (defined(__i386__) || defined(__ppc__))
+#include "processor/logging.h"
+
+#if defined(__i386) && !defined(__i386__)
+#define __i386__
+#endif
+#if defined(__sparc) && !defined(__sparc__)
+#define __sparc__
+#endif
+ 
+#if (defined(__SUNPRO_CC) || defined(__GNUC__)) && \
+    (defined(__i386__) || defined(__ppc__) || defined(__sparc__))
 
 
 #include <cstdio>
@@ -61,7 +71,6 @@
 #include "google_breakpad/processor/memory_region.h"
 #include "google_breakpad/processor/stack_frame.h"
 #include "google_breakpad/processor/stack_frame_cpu.h"
-#include "processor/logging.h"
 #include "processor/scoped_ptr.h"
 
 using google_breakpad::BasicSourceLineResolver;
@@ -71,6 +80,7 @@
 using google_breakpad::StackFrame;
 using google_breakpad::StackFramePPC;
 using google_breakpad::StackFrameX86;
+using google_breakpad::StackFrameSPARC;
 
 #if defined(__i386__)
 #include "processor/stackwalker_x86.h"
@@ -78,7 +88,10 @@
 #elif defined(__ppc__)
 #include "processor/stackwalker_ppc.h"
 using google_breakpad::StackwalkerPPC;
-#endif  // __i386__ || __ppc__
+#elif defined(__sparc__)
+#include "processor/stackwalker_sparc.h"
+using google_breakpad::StackwalkerSPARC;
+#endif  // __i386__ || __ppc__ || __sparc__
 
 #define RECURSION_DEPTH 100
 
@@ -117,6 +130,9 @@
 };
 
 
+#if defined(__GNUC__)
+
+
 #if defined(__i386__)
 
 // GetEBP returns the current value of the %ebp register.  Because it's
@@ -210,14 +226,87 @@
 }
 
 
-#endif  // __i386__ || __ppc__
+#elif defined(__sparc__)
+
+
+// GetSP returns the current value of the %sp/%o6/%g_r[14] register, which 
+// by convention, is the stack pointer on sparc.  Because it's implemented
+// as a function, %sp itself contains GetSP's own stack pointer and not 
+// the caller's stack pointer.  Dereference  to obtain the caller's stack 
+// pointer, which the compiler-generated prolog stored on the stack.
+// Because this function depends on the compiler-generated prolog, inlining
+// is disabled.
+static u_int32_t GetSP() __attribute__((noinline));
+static u_int32_t GetSP() {
+  u_int32_t sp;
+  __asm__ __volatile__(
+    "mov %%fp, %0"
+    : "=r" (sp)
+  );
+  return sp;
+}
+
+// GetFP returns the current value of the %fp register.  Because it's
+// implemented as a function, %fp itself contains GetFP's frame pointer
+// and not the caller's frame pointer.  Dereference %fp to obtain the
+// caller's frame pointer, which the compiler-generated preamble stored
+// on the stack (provided frame pointers are not being omitted.)  Because
+// this function depends on the compiler-generated preamble, inlining is
+// disabled.
+static u_int32_t GetFP() __attribute__((noinline));
+static u_int32_t GetFP() {
+  u_int32_t fp;
+  __asm__ __volatile__(
+    "ld [%%fp+56], %0"
+    : "=r" (fp)
+  );
+  return fp;
+}
+
+// GetPC returns the program counter identifying the next instruction to
+// execute after GetPC returns.  It obtains this information from the
+// link register, where it was placed by the branch instruction that called
+// GetPC.  Because this function depends on the caller's use of a branch
+// instruction, inlining is disabled.
+static u_int32_t GetPC() __attribute__((noinline));
+static u_int32_t GetPC() {
+  u_int32_t pc;
+  __asm__ __volatile__(
+    "mov %%i7, %0"
+    : "=r" (pc)
+  );
+  return pc + 8;
+}
+
+#endif  // __i386__ || __ppc__ || __sparc__
+
+#elif defined(__SUNPRO_CC)
+
+#if defined(__i386__)
+extern "C" {
+extern u_int32_t GetEIP();
+extern u_int32_t GetEBP();
+extern u_int32_t GetESP();
+}
+#elif defined(__sparc__)
+extern "C" {
+extern u_int32_t GetPC();
+extern u_int32_t GetFP();
+extern u_int32_t GetSP();
+}
+#endif // __i386__ || __sparc__
 
+#endif // __GNUC__ || __SUNPRO_CC
 
 // CountCallerFrames returns the number of stack frames beneath the function
 // that called CountCallerFrames.  Because this function's return value
 // is dependent on the size of the stack beneath it, inlining is disabled,
 // and any function that calls this should not be inlined either.
+#if defined(__GNUC__)
 static unsigned int CountCallerFrames() __attribute__((noinline));
+#elif defined(__SUNPRO_CC)
+static unsigned int CountCallerFrames();
+#endif
 static unsigned int CountCallerFrames() {
   SelfMemoryRegion memory;
   BasicSourceLineResolver resolver;
@@ -237,7 +326,15 @@
 
   StackwalkerPPC stackwalker = StackwalkerPPC(NULL, &context, &memory, NULL,
                                               NULL, &resolver);
-#endif  // __i386__ || __ppc__
+#elif defined(__sparc__)
+  MDRawContextSPARC context = MDRawContextSPARC();
+  context.pc = GetPC();
+  context.g_r[14] = GetSP();
+  context.g_r[30] = GetFP();
+
+  StackwalkerSPARC stackwalker = StackwalkerSPARC(NULL, &context, &memory,
+                                                  NULL, NULL, &resolver);
+#endif  // __i386__ || __ppc__ || __sparc__
 
   CallStack stack;
   stackwalker.Walk(&stack);
@@ -257,7 +354,11 @@
 #elif defined(__ppc__)
     StackFramePPC *frame_ppc = reinterpret_cast<StackFramePPC*>(frame);
     printf("  gpr[1] = 0x%08x\n", frame_ppc->context.gpr[1]);
-#endif  // __i386__ || __ppc__
+#elif defined(__sparc__)
+    StackFrameSPARC *frame_sparc = reinterpret_cast<StackFrameSPARC*>(frame);
+    printf("  sp = 0x%08x  fp = 0x%08x\n",
+           frame_sparc->context.g_r[14], frame_sparc->context.g_r[30]);
+#endif  // __i386__ || __ppc__ || __sparc__
   }
 #endif  // PRINT_STACKS
 
@@ -273,8 +374,12 @@
 // have been reached, Recursor stops checking and returns success.  If the
 // frame count check fails at any depth, Recursor will stop and return false.
 // Because this calls CountCallerFrames, inlining is disabled.
+#if defined(__GNUC__)
 static bool Recursor(unsigned int depth, unsigned int parent_callers)
     __attribute__((noinline));
+#elif defined(__SUNPRO_CC)
+static bool Recursor(unsigned int depth, unsigned int parent_callers);
+#endif
 static bool Recursor(unsigned int depth, unsigned int parent_callers) {
   unsigned int callers = CountCallerFrames();
   if (callers != parent_callers + 1)
@@ -291,7 +396,11 @@
 // Because this calls CountCallerFrames, inlining is disabled - but because
 // it's main (and nobody calls it other than the entry point), it wouldn't
 // be inlined anyway.
+#if defined(__GNUC__)
 int main(int argc, char** argv) __attribute__((noinline));
+#elif defined(__SUNPRO_CC)
+int main(int argc, char** argv);
+#endif
 int main(int argc, char** argv) {
   BPLOG_INIT(&argc, &argv);
 
@@ -299,9 +408,8 @@
 }
 
 
-#else  // __GNUC__ && (__i386__ || __ppc__)
-// Not gcc?  We use gcc's __asm__.
-// Not i386 or ppc?  We can only test stacks we know how to walk.
+#else
+// Not i386 or ppc or sparc?  We can only test stacks we know how to walk.
 
 
 int main(int argc, char **argv) {
@@ -314,4 +422,4 @@
 }
 
 
-#endif  // __GNUC__ && (__i386__ || __ppc__)
+#endif  // (__GNUC__ || __SUNPRO_CC) && (__i386__ || __ppc__ || __sparc__)
Index: toolkit/crashreporter/google-breakpad/src/processor/stackwalker_selftest_sol.s
===================================================================
RCS file: toolkit/crashreporter/google-breakpad/src/processor/stackwalker_selftest_sol.s
diff -N toolkit/crashreporter/google-breakpad/src/processor/stackwalker_selftest_sol.s
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/crashreporter/google-breakpad/src/processor/stackwalker_selftest_sol.s	21 Oct 2007 15:36:00 -0000	1.1
@@ -0,0 +1,111 @@
+/* Copyright (c) 2007, Google Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* stackwalker_selftest_sol.s
+ * On Solaris, the recommeded compiler is CC, so we can not use gcc inline
+ * asm, use this method instead.
+ *
+ * How to compile: as -P -L -D_ASM -D_STDC -K PIC -o \
+ *                 src/processor/stackwalker_selftest_sol.o \
+ *                 src/processor/stackwalker_selftest_sol.s
+ *
+ * Author: Michael Shang
+ */
+
+#include <sys/asm_linkage.h>
+
+#if defined(__i386)
+
+
+ENTRY(GetEBP) 
+      pushl    %ebp
+      movl     %esp,%ebp
+      subl     $0x00000004,%esp
+      movl     0x00000000(%ebp),%eax
+      movl     %eax,0xfffffffc(%ebp)
+      movl     0xfffffffc(%ebp),%eax
+      leave    
+      ret      
+SET_SIZE(GetEBP)
+
+ENTRY(GetEIP) 
+      pushl    %ebp
+      movl     %esp,%ebp
+      subl     $0x00000004,%esp
+      movl     0x00000004(%ebp),%eax
+      movl     %eax,0xfffffffc(%ebp)
+      movl     0xfffffffc(%ebp),%eax
+      leave    
+      ret      
+SET_SIZE(GetEIP)
+
+ENTRY(GetESP) 
+      pushl    %ebp
+      movl     %esp,%ebp
+      subl     $0x00000004,%esp
+      movl     %ebp,%eax
+      movl     %eax,0xfffffffc(%ebp)
+      movl     0xfffffffc(%ebp),%eax
+      addl     $0x00000008,%eax
+      leave    
+      ret      
+SET_SIZE(GetESP)
+
+
+#elif defined(__sparc)
+
+
+ENTRY(GetPC)
+      save     %sp, -120, %sp
+      mov      %i7, %i4
+      inccc    8, %i4
+      mov      %i4, %i0
+      ret      
+      restore  
+SET_SIZE(GetPC)
+
+ENTRY(GetSP)
+      save     %sp, -120, %sp
+      mov      %fp, %i4
+      mov      %i4, %i0
+      ret      
+      restore  
+SET_SIZE(GetSP)
+
+ENTRY(GetFP)
+      save     %sp, -120, %sp
+      ld       [%fp + 56], %g1
+      mov      %g1, %i0
+      ret      
+      restore  
+SET_SIZE(GetFP)
+
+
+#endif  // __i386 || __sparc
Index: toolkit/crashreporter/google-breakpad/src/processor/stackwalker_sparc.cc
===================================================================
RCS file: toolkit/crashreporter/google-breakpad/src/processor/stackwalker_sparc.cc
diff -N toolkit/crashreporter/google-breakpad/src/processor/stackwalker_sparc.cc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/crashreporter/google-breakpad/src/processor/stackwalker_sparc.cc	21 Oct 2007 15:36:00 -0000	1.1
@@ -0,0 +1,139 @@
+// Copyright (c) 2007, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// stackwalker_sparc.cc: sparc-specific stackwalker.
+//
+// See stackwalker_sparc.h for documentation.
+//
+// Author: Michael Shang
+
+
+#include "google_breakpad/processor/call_stack.h"
+#include "google_breakpad/processor/memory_region.h"
+#include "google_breakpad/processor/stack_frame_cpu.h"
+#include "processor/logging.h"
+#include "processor/stackwalker_sparc.h"
+
+namespace google_breakpad {
+
+
+StackwalkerSPARC::StackwalkerSPARC(const SystemInfo *system_info,
+                                   const MDRawContextSPARC *context,
+                                   MemoryRegion *memory,
+                                   const CodeModules *modules,
+                                   SymbolSupplier *supplier,
+                                   SourceLineResolverInterface *resolver)
+    : Stackwalker(system_info, memory, modules, supplier, resolver),
+      context_(context) {
+}
+
+
+StackFrame* StackwalkerSPARC::GetContextFrame() {
+  if (!context_ || !memory_) {
+    BPLOG(ERROR) << "Can't get context frame without context or memory";
+    return NULL;
+  }
+
+  StackFrameSPARC *frame = new StackFrameSPARC();
+
+  // The instruction pointer is stored directly in a register, so pull it
+  // straight out of the CPU context structure.
+  frame->context = *context_;
+  frame->context_validity = StackFrameSPARC::CONTEXT_VALID_ALL;
+  frame->instruction = frame->context.pc;
+
+  return frame;
+}
+
+
+StackFrame* StackwalkerSPARC::GetCallerFrame(
+    const CallStack *stack,
+    const vector< linked_ptr<StackFrameInfo> > &stack_frame_info) {
+  if (!memory_ || !stack) {
+    BPLOG(ERROR) << "Can't get caller frame without memory or stack";
+    return NULL;
+  }
+
+  StackFrameSPARC *last_frame = static_cast<StackFrameSPARC*>(
+      stack->frames()->back());
+
+  // new: caller
+  // old: callee
+  // %fp, %i6 and g_r[30] is the same, see minidump_format.h
+  // %sp, %o6 and g_r[14] is the same, see minidump_format.h
+  // %sp_new = %fp_old
+  // %fp_new = *(%fp_old + 32 + 32 - 8), where the callee's %i6 
+  // %pc_new = *(%fp_old + 32 + 32 - 4) + 8
+  // which is callee's %i7 plus 8
+
+  // A caller frame must reside higher in memory than its callee frames.
+  // Anything else is an error, or an indication that we've reached the
+  // end of the stack.
+  u_int32_t stack_pointer = last_frame->context.g_r[30];
+  if (stack_pointer <= last_frame->context.g_r[14]) {
+    return NULL;
+  }
+
+  u_int32_t instruction;
+  if (!memory_->GetMemoryAtAddress(stack_pointer + 60,
+                     &instruction) || instruction <= 1) {
+    return NULL;
+  }
+
+  u_int32_t stack_base;
+  if (!memory_->GetMemoryAtAddress(stack_pointer + 56,
+                     &stack_base) || stack_base <= 1) {
+    return NULL;
+  }
+
+  StackFrameSPARC *frame = new StackFrameSPARC();
+
+  frame->context = last_frame->context;
+  frame->context.g_r[14] = stack_pointer;
+  frame->context.g_r[30] = stack_base;
+  
+  // frame->context.pc is the return address, which is 2 instruction
+  // past the branch that caused us to arrive at the callee, which are 
+  // a CALL instruction then a NOP instruction.
+  // frame_ppc->instruction to 8 less than that.  Since all sparc
+  // instructions are 4 bytes wide, this is the address of the branch
+  // instruction.  This allows source line information to match up with the
+  // line that contains a function call.  Callers that require the exact
+  // return address value may access the %i7/g_r[31] field of StackFrameSPARC.
+  frame->context.pc = instruction + 8;
+  frame->instruction = instruction;
+  frame->context_validity = StackFrameSPARC::CONTEXT_VALID_PC |
+                            StackFrameSPARC::CONTEXT_VALID_SP |
+                            StackFrameSPARC::CONTEXT_VALID_FP;
+                            
+  return frame;
+}
+
+
+}  // namespace google_breakpad
Index: toolkit/crashreporter/google-breakpad/src/processor/stackwalker_sparc.h
===================================================================
RCS file: toolkit/crashreporter/google-breakpad/src/processor/stackwalker_sparc.h
diff -N toolkit/crashreporter/google-breakpad/src/processor/stackwalker_sparc.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ toolkit/crashreporter/google-breakpad/src/processor/stackwalker_sparc.h	21 Oct 2007 15:36:00 -0000	1.1
@@ -0,0 +1,86 @@
+// Copyright (c) 2007, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// stackwalker_sparc.h: sparc-specific stackwalker.
+//
+// Provides stack frames given sparc register context and a memory region
+// corresponding to an sparc stack.
+//
+// Author: Michael Shang
+
+
+#ifndef PROCESSOR_STACKWALKER_SPARC_H__
+#define PROCESSOR_STACKWALKER_SPARC_H__
+
+
+#include "google_breakpad/common/breakpad_types.h"
+#include "google_breakpad/common/minidump_format.h"
+#include "google_breakpad/processor/stackwalker.h"
+
+namespace google_breakpad {
+
+class CodeModules;
+
+class StackwalkerSPARC : public Stackwalker {
+ public:
+  // context is a sparc context object that gives access to sparc-specific
+  // register state corresponding to the innermost called frame to be
+  // included in the stack.  The other arguments are passed directly through
+  // to the base Stackwalker constructor.
+  StackwalkerSPARC(const SystemInfo *system_info,
+                   const MDRawContextSPARC *context,
+                   MemoryRegion *memory,
+                   const CodeModules *modules,
+                   SymbolSupplier *supplier,
+                   SourceLineResolverInterface *resolver);
+
+ private:
+  // Implementation of Stackwalker, using x86 context (%ebp, %esp, %eip) and
+  // stack conventions (saved %ebp at [%ebp], saved %eip at 4[%ebp], or
+  // alternate conventions as guided by stack_frame_info_).
+  // Implementation of Stackwalker, using ppc context (stack pointer in %r1,
+  // saved program counter in %srr0) and stack conventions (saved stack
+  // pointer at 0(%r1), return address at 8(0(%r1)).
+  // Implementation of Stackwalker, using sparc context (%fp, %sp, %pc) and
+  // stack conventions (saved %sp at)
+  virtual StackFrame* GetContextFrame();
+  virtual StackFrame* GetCallerFrame(
+      const CallStack *stack,
+      const vector< linked_ptr<StackFrameInfo> > &stack_frame_info);
+
+  // Stores the CPU context corresponding to the innermost stack frame to
+  // be returned by GetContextFrame.
+  const MDRawContextSPARC *context_;
+};
+
+
+}  // namespace google_breakpad
+
+
+#endif  // PROCESSOR_STACKWALKER_SPARC_H__
Index: toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/crash_report.mm
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/crash_report.mm,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/crash_report.mm	25 Jul 2007 01:06:14 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/crash_report.mm	21 Oct 2007 15:36:01 -0000	1.2
@@ -72,6 +72,7 @@
 typedef struct {
   NSString *minidumpPath;
   NSString *searchDir;
+  NSString *symbolSearchDir;
 } Options;
 
 //=============================================================================
@@ -190,8 +191,10 @@
   BasicSourceLineResolver resolver;
   string search_dir = options->searchDir ?
     [options->searchDir fileSystemRepresentation] : "";
+  string symbol_search_dir = options->symbolSearchDir ?
+    [options->symbolSearchDir fileSystemRepresentation] : "";
   scoped_ptr<OnDemandSymbolSupplier> symbol_supplier(
-    new OnDemandSymbolSupplier(search_dir));
+    new OnDemandSymbolSupplier(search_dir, symbol_search_dir));
   scoped_ptr<MinidumpProcessor>
     minidump_processor(new MinidumpProcessor(symbol_supplier.get(), &resolver));
   ProcessState process_state;
@@ -253,12 +256,19 @@
 
 //=============================================================================
 static void Usage(int argc, const char *argv[]) {
-  fprintf(stderr, "Convert a minidump to a crash report.  Breakpad symbol files\n");
-  fprintf(stderr, "will be used (or created if missing) in /tmp.\n");
-  fprintf(stderr, "Usage: %s [-s search-dir] minidump-file\n", argv[0]);
-  fprintf(stderr, "\t-s: Specify a search directory to use for missing modules\n");
-  fprintf(stderr, "\t-h: Usage\n");
-  fprintf(stderr, "\t-?: Usage\n");
+  fprintf(stderr, "Convert a minidump to a crash report.  Breakpad symbol "
+                  "files will be used (or created if missing) in /tmp.\n"
+                  "If a symbol-file-search-dir is specified, any symbol " 
+                  "files in it will be used instead of being loaded from "  
+                  "modules on disk.\n" 
+                  "If modules cannot be found at the paths stored in the "
+                  "minidump file, they will be searched for at "    
+                  "<module-search-dir>/<path-in-minidump-file>.\n");
+  fprintf(stderr, "Usage: %s [-s module-search-dir] [-S symbol-file-search-dir] minidump-file\n", argv[0]);
+  fprintf(stderr, "\t-s: Specify a search directory to use for missing modules\n" 
+                  "\t-S: Specify a search directory to use for symbol files\n"  
+                  "\t-h: Usage\n"
+                  "\t-?: Usage\n");
 }
 
 //=============================================================================
@@ -266,7 +276,7 @@
   extern int optind;
   char ch;
 
-  while ((ch = getopt(argc, (char * const *)argv, "s:h?")) != -1) {
+  while ((ch = getopt(argc, (char * const *)argv, "S:s:h?")) != -1) {
     switch (ch) {
       case 's':
         options->searchDir = [[NSFileManager defaultManager]
@@ -274,6 +284,12 @@
                                       length:strlen(optarg)];
         break;
 
+      case 'S':
+        options->symbolSearchDir = [[NSFileManager defaultManager]
+          stringWithFileSystemRepresentation:optarg
+                                      length:strlen(optarg)];
+        break;
+        
       case 'h':
       case '?':
         Usage(argc, argv);
Index: toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/on_demand_symbol_supplier.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/on_demand_symbol_supplier.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/on_demand_symbol_supplier.h	25 Jul 2007 01:06:14 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/on_demand_symbol_supplier.h	21 Oct 2007 15:36:01 -0000	1.2
@@ -47,7 +47,8 @@
  public:
   // |search_dir| is the directory to search for alternative symbols with
   // the same name as the module in the minidump
-  OnDemandSymbolSupplier(const string &search_dir);
+  OnDemandSymbolSupplier(const string &search_dir, 
+                         const string &symbol_search_dir);
   virtual ~OnDemandSymbolSupplier() {}
 
   // Returns the path to the symbol file for the given module.
@@ -58,7 +59,8 @@
  protected:
   // Search directory
   string search_dir_;
-
+  string symbol_search_dir_;
+  
   // When we create a symbol file for a module, save the name of the module
   // and the path to that module's symbol file.
   map<string, string> module_file_map_;
Index: toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/on_demand_symbol_supplier.mm
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/on_demand_symbol_supplier.mm,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -r1.1 -r1.2
--- toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/on_demand_symbol_supplier.mm	25 Jul 2007 01:06:14 -0000	1.1
+++ toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/on_demand_symbol_supplier.mm	21 Oct 2007 15:36:01 -0000	1.2
@@ -47,8 +47,73 @@
 using google_breakpad::SymbolSupplier;
 using google_breakpad::SystemInfo;
 
-OnDemandSymbolSupplier::OnDemandSymbolSupplier(const string &search_dir)
+OnDemandSymbolSupplier::OnDemandSymbolSupplier(const string &search_dir, 
+                                               const string &symbol_search_dir)
   : search_dir_(search_dir) {
+  NSFileManager *mgr = [NSFileManager defaultManager];
+  int length = symbol_search_dir.length();
+  if (length) {
+    // Load all sym files in symbol_search_dir into our module_file_map
+    // A symbol file always starts with a line like this:
+    // MODULE mac x86 BBF0A8F9BEADDD2048E6464001CA193F0 GoogleDesktopDaemon
+    // or
+    // MODULE mac ppc BBF0A8F9BEADDD2048E6464001CA193F0 GoogleDesktopDaemon
+    const char *symbolSearchStr = symbol_search_dir.c_str();
+    NSString *symbolSearchPath = 
+      [mgr stringWithFileSystemRepresentation:symbolSearchStr 
+                                       length:strlen(symbolSearchStr)];
+    NSDirectoryEnumerator *dirEnum = [mgr enumeratorAtPath:symbolSearchPath];
+    NSString *fileName;
+    NSCharacterSet *hexSet = 
+      [NSCharacterSet characterSetWithCharactersInString:@"0123456789ABCDEF"];
+    NSCharacterSet *newlineSet = 
+      [NSCharacterSet characterSetWithCharactersInString:@"\r\n"];
+    while ((fileName = [dirEnum nextObject])) {
+      // Check to see what type of file we have
+      NSDictionary *attrib = [dirEnum fileAttributes];
+      NSString *fileType = [attrib objectForKey:NSFileType];
+      if ([fileType isEqualToString:NSFileTypeDirectory]) {
+        // Skip subdirectories
+        [dirEnum skipDescendents];
+      } else {
+        NSString *filePath = [symbolSearchPath stringByAppendingPathComponent:fileName];
+        NSString *dataStr = [[[NSString alloc] initWithContentsOfFile:filePath] autorelease];
+        if (dataStr) {
+          // Check file to see if it is of appropriate type, and grab module
+          // name.
+          NSScanner *scanner = [NSScanner scannerWithString:dataStr];
+          BOOL goodScan = [scanner scanString:@"MODULE mac " intoString:nil];
+          if (goodScan) {
+            goodScan = ([scanner scanString:@"x86 " intoString:nil] ||
+                        [scanner scanString:@"ppc " intoString:nil]);
+            if (goodScan) {
+              NSString *moduleID;
+              goodScan = [scanner scanCharactersFromSet:hexSet 
+                                             intoString:&moduleID];
+              if (goodScan) {
+                // Module IDs are always 33 chars long
+                goodScan = [moduleID length] == 33;
+                if (goodScan) {
+                  NSString *moduleName;
+                  goodScan = [scanner scanUpToCharactersFromSet:newlineSet 
+                                                     intoString:&moduleName];
+                  if (goodScan) {
+                    goodScan = [moduleName length] > 0;
+                    if (goodScan) {
+                      const char *moduleNameStr = [moduleName UTF8String];
+                      const char *filePathStr = [filePath fileSystemRepresentation];
+                      // Map our file
+                      module_file_map_[moduleNameStr] = filePathStr;
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
 }
 
 SymbolSupplier::SymbolResult
Index: toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/crash_report.xcodeproj/project.pbxproj
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/crash_report.xcodeproj/project.pbxproj,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/crash_report.xcodeproj/project.pbxproj	25 Jul 2007 01:06:14 -0000	1.3
+++ toolkit/crashreporter/google-breakpad/src/tools/mac/crash_report/crash_report.xcodeproj/project.pbxproj	21 Oct 2007 15:36:01 -0000	1.4
@@ -43,6 +43,8 @@
 		9BE650B50B52FE3000611104 /* macho_id.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = 9BE650AF0B52FE3000611104 /* macho_id.h */; };
 		9BE650B60B52FE3000611104 /* macho_walker.cc in Sources */ = {isa = PBXBuildFile; fileRef = 9BE650B00B52FE3000611104 /* macho_walker.cc */; };
 		9BE650B70B52FE3000611104 /* macho_walker.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = 9BE650B10B52FE3000611104 /* macho_walker.h */; };
+		FD8EDEAE0CADDAD400A5EDF1 /* stackwalker_sparc.cc in Sources */ = {isa = PBXBuildFile; fileRef = FD8EDEAC0CADDAD400A5EDF1 /* stackwalker_sparc.cc */; };
+		FD8EDEAF0CADDAD400A5EDF1 /* stackwalker_sparc.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = FD8EDEAD0CADDAD400A5EDF1 /* stackwalker_sparc.h */; };
 /* End PBXBuildFile section */
 
 /* Begin PBXCopyFilesBuildPhase section */
@@ -69,6 +71,7 @@
 				9BE650B70B52FE3000611104 /* macho_walker.h in CopyFiles */,
 				9B44619E0B66C66B00BBB817 /* system_info.h in CopyFiles */,
 				557800410BE1F28500EC23E0 /* macho_utilities.h in CopyFiles */,
+				FD8EDEAF0CADDAD400A5EDF1 /* stackwalker_sparc.h in CopyFiles */,
 			);
 			runOnlyForDeploymentPostprocessing = 1;
 		};
@@ -123,6 +126,8 @@
 		9BE650AF0B52FE3000611104 /* macho_id.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = macho_id.h; path = ../../../common/mac/macho_id.h; sourceTree = SOURCE_ROOT; };
 		9BE650B00B52FE3000611104 /* macho_walker.cc */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = macho_walker.cc; path = ../../../common/mac/macho_walker.cc; sourceTree = SOURCE_ROOT; };
 		9BE650B10B52FE3000611104 /* macho_walker.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = macho_walker.h; path = ../../../common/mac/macho_walker.h; sourceTree = SOURCE_ROOT; };
+		FD8EDEAC0CADDAD400A5EDF1 /* stackwalker_sparc.cc */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = stackwalker_sparc.cc; path = ../../../processor/stackwalker_sparc.cc; sourceTree = SOURCE_ROOT; };
+		FD8EDEAD0CADDAD400A5EDF1 /* stackwalker_sparc.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = stackwalker_sparc.h; path = ../../../processor/stackwalker_sparc.h; sourceTree = SOURCE_ROOT; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
@@ -240,6 +245,8 @@
 				9BDF17530B1B8BF900F8391B /* stackwalker.cc */,
 				9BDF17510B1B8BF900F8391B /* stackwalker_ppc.cc */,
 				9BDF17520B1B8BF900F8391B /* stackwalker_x86.cc */,
+				FD8EDEAC0CADDAD400A5EDF1 /* stackwalker_sparc.cc */,
+				FD8EDEAD0CADDAD400A5EDF1 /* stackwalker_sparc.h */,
 			);
 			name = processor;
 			sourceTree = "<group>";
@@ -316,6 +323,7 @@
 				9BE650B60B52FE3000611104 /* macho_walker.cc in Sources */,
 				557800400BE1F28500EC23E0 /* macho_utilities.cc in Sources */,
 				8B40BDC00C0638E4009535AF /* logging.cc in Sources */,
+				FD8EDEAE0CADDAD400A5EDF1 /* stackwalker_sparc.cc in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -333,6 +341,12 @@
 				GCC_MODEL_TUNING = G5;
 				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = NO;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"$(GCC_PREPROCESSOR_DEFINITIONS)",
+					_GLIBCXX_DEBUG_PEDANTIC,
+					_GLIBCXX_DEBUG,
+					_GLIBCPP_CONCEPT_CHECKS,
+				);
 				INSTALL_PATH = "$(HOME)/bin";
 				OTHER_LDFLAGS = "-lcrypto";
 				PRODUCT_NAME = crash_report;
@@ -350,7 +364,7 @@
 				);
 				GCC_C_LANGUAGE_STANDARD = c99;
 				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
-				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
 				GCC_MODEL_TUNING = G5;
 				GCC_PRECOMPILE_PREFIX_HEADER = NO;
 				INSTALL_PATH = "$(HOME)/bin";
Index: toolkit/crashreporter/test/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/toolkit/crashreporter/test/Makefile.in,v
retrieving revision 1.11
retrieving revision 1.12
diff -u -r1.11 -r1.12
--- toolkit/crashreporter/test/Makefile.in	8 Aug 2007 15:20:00 -0000	1.11
+++ toolkit/crashreporter/test/Makefile.in	21 Oct 2007 18:13:17 -0000	1.12
@@ -89,8 +89,8 @@
 LIBS += \
   $(DEPTH)/toolkit/crashreporter/google-breakpad/src/client/linux/handler/$(LIB_PREFIX)exception_handler_s.$(LIB_SUFFIX) \
   $(DEPTH)/toolkit/crashreporter/google-breakpad/src/client/$(LIB_PREFIX)minidump_file_writer_s.$(LIB_SUFFIX) \
-  $(DEPTH)/toolkit/crashreporter/google-breakpad/src/common/$(LIB_PREFIX)breakpad_common_s.$(LIB_SUFFIX) \
   $(DEPTH)/toolkit/crashreporter/google-breakpad/src/common/linux/$(LIB_PREFIX)breakpad_linux_common_s.$(LIB_SUFFIX) \
+  $(DEPTH)/toolkit/crashreporter/google-breakpad/src/common/$(LIB_PREFIX)breakpad_common_s.$(LIB_SUFFIX) \
   $(NULL)
 endif
 
