Index: layout/xul/base/src/nsResizerFrame.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/xul/base/src/nsResizerFrame.cpp,v
retrieving revision 1.20.10.1
diff -u -p -r1.20.10.1 nsResizerFrame.cpp
--- layout/xul/base/src/nsResizerFrame.cpp	26 May 2006 06:27:57 -0000	1.20.10.1
+++ layout/xul/base/src/nsResizerFrame.cpp	10 Jan 2007 02:00:57 -0000
@@ -21,6 +21,7 @@
  *
  * Contributor(s):
  *   Original Author: Eric J. Burley (ericb@neoplanet.com)
+ *   Ben Turner <mozilla@songbirdnest.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
@@ -55,6 +56,7 @@
 #include "nsIViewManager.h"
 #include "nsXULAtoms.h"
 #include "nsGUIEvent.h"
+#include "nsIPresShell.h"
 
 //
 // NS_NewXULButtonFrame
@@ -79,7 +81,9 @@ NS_NewResizerFrame( nsIPresShell* aPresS
 } // NS_NewTitleBarFrame
 
 nsResizerFrame::nsResizerFrame(nsIPresShell* aPresShell)
-:nsTitleBarFrame(aPresShell) 
+: nsTitleBarFrame(aPresShell),
+  mSizeConstraints(-1, -1, -1, -1),
+  mDisabled(PR_FALSE)
 {
 	mDirection = topleft; // by default...
 }
@@ -92,7 +96,9 @@ NS_IMETHODIMP  nsResizerFrame::Init(nsPr
 {
 	nsresult rv = nsTitleBarFrame::Init(aPresContext, aContent, aParent, aContext, asPrevInFlow);
 
-	GetInitialDirection(mDirection);
+  NS_WARN_IF_FALSE(GetInitialDirection(mDirection),
+                   "GetInitialDirection failed!");
+  NS_WARN_IF_FALSE(CacheDisabledAttr(), "CacheDisabledAttr failed!");
 
 	return rv;
 }
@@ -109,64 +115,62 @@ nsResizerFrame::HandleEvent(nsPresContex
 
 	 case NS_MOUSE_LEFT_BUTTON_DOWN:	{
 			 
-			 // we're tracking.
-			 mTrackingMouseMove = PR_TRUE;
-			 
-			 // start capture.		 
-			 aEvent->widget->CaptureMouse(PR_TRUE);
-			 CaptureMouseEvents(aPresContext,PR_TRUE);
+       // Prevent default processing
+       doDefault = PR_FALSE;
 
+       if (!IsDisabled(aPresContext)) {
 
-			 
-			 // remember current mouse coordinates.
-			 mLastPoint = aEvent->refPoint;
-			 aEvent->widget->GetScreenBounds(mWidgetRect);
+         nsresult rv =
+           GetWindowFromPresContext(aPresContext,
+                                    getter_AddRefs(mResizingWindow));
+         NS_ENSURE_SUCCESS(rv, rv);
+
+         // we're tracking.
+         mTrackingMouseMove = PR_TRUE;
+
+         // start capture.
+         aEvent->widget->CaptureMouse(PR_TRUE);
+         CaptureMouseEvents(aPresContext, PR_TRUE);
 
-			 *aEventStatus = nsEventStatus_eConsumeNoDefault;
-			 doDefault = PR_FALSE;
+         // remember current mouse coordinates.
+         mLastPoint = aEvent->refPoint;
+
+         *aEventStatus = nsEventStatus_eConsumeNoDefault;
+       }
 		 }
 		 break;
 		 
 
 	 case NS_MOUSE_LEFT_BUTTON_UP: {
 
-			 if(mTrackingMouseMove)
-			 {
-				 // we're done tracking.
-				 mTrackingMouseMove = PR_FALSE;
-				 
-				 // end capture
-				 aEvent->widget->CaptureMouse(PR_FALSE);				 
-				 CaptureMouseEvents(aPresContext,PR_FALSE);
+			 if(mTrackingMouseMove) {
+
+         // we're done tracking.
+         mTrackingMouseMove = PR_FALSE;
+
+         // Clear all cached data
+         mResizingWindow = nsnull;
+         mSizeConstraints.minWidth = mSizeConstraints.maxWidth = -1;
+         mSizeConstraints.minHeight = mSizeConstraints.maxHeight = -1;
+
+         // end capture
+         aEvent->widget->CaptureMouse(PR_FALSE);
+         CaptureMouseEvents(aPresContext, PR_FALSE);
 
-				 *aEventStatus = nsEventStatus_eConsumeNoDefault;
-				 doDefault = PR_FALSE;
+         *aEventStatus = nsEventStatus_eConsumeNoDefault;
+         doDefault = PR_FALSE;
 			 }
 		 }
 		 break;
 
 	 case NS_MOUSE_MOVE: {
-			 if(mTrackingMouseMove)
-			 {				 				 
-			   // get the document and the global script object - should this be cached?
-			   nsIScriptGlobalObject *scriptGlobalObject =
-           aPresContext->PresShell()->GetDocument()->GetScriptGlobalObject();
-         NS_ENSURE_TRUE(scriptGlobalObject, NS_ERROR_FAILURE);
-
-         nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
-           do_QueryInterface(scriptGlobalObject->GetDocShell());
-         NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
 
-         nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
-         docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
+       if (mTrackingMouseMove && !IsDisabled(aPresContext)) {
 
-         nsCOMPtr<nsIBaseWindow> window(do_QueryInterface(treeOwner));
+         NS_ENSURE_STATE(mResizingWindow);
 
-         if (!window) {
-           return NS_OK;
-         }
-
-				 nsPoint nsMoveBy(0,0),nsSizeBy(0,0);
+				 nsPoint nsMoveBy(0,0), nsSizeBy(0,0);
+         nsPoint nsBeyondMaximum(0,0), nsBeyondMinimum(0,0);
 				 nsPoint nsMouseMove(aEvent->refPoint - mLastPoint);
 				 				 
 
@@ -210,43 +214,129 @@ nsResizerFrame::HandleEvent(nsPresContex
 							break;
 				 }
 
+         // Remember this because nsSizeBy is about to be changed
+         nsPoint requestedSizeChange(nsSizeBy);
 
+         PRInt32 x,y,cx,cy;
+				 mResizingWindow->GetPositionAndSize(&x,&y,&cx,&cy);
 
-				 PRInt32 x,y,cx,cy;
-				 window->GetPositionAndSize(&x,&y,&cx,&cy);
-
-				 x+=nsMoveBy.x;
-				 y+=nsMoveBy.y;
-				 cx+=nsSizeBy.x;
-				 cy+=nsSizeBy.y;
+         // Figure out the size constraints
+         nsresult rv;
+         nsCOMPtr<nsIWidget> mainWidget;
+         rv = mResizingWindow->GetMainWidget(getter_AddRefs(mainWidget));
+         NS_ENSURE_SUCCESS(rv, rv);
+
+         rv = mainWidget->GetSizeConstraints(&mSizeConstraints.minWidth,
+                                             &mSizeConstraints.maxWidth,
+                                             &mSizeConstraints.minHeight,
+                                             &mSizeConstraints.maxHeight);
+         NS_ENSURE_SUCCESS(rv, rv);
+
+         // It would be nice to simply pass the new size on to the window but
+         // we have to have a way to keep the window from moving
+         // inappropriately when size constraints are in effect. Also platform
+         // support for size constraints may not exist everywhere, so we go on
+         // and do all the necessary calculations here. This will make resizers
+         // support size constraints even if native window decorations don't.
+
+         // Make sure a constraint is set
+         if (mSizeConstraints.minWidth != -1) {
+           PRInt32 newWidth = cx + requestedSizeChange.x;
+           if (newWidth < mSizeConstraints.minWidth) {
+             // Always fix the size
+             nsSizeBy.x = mSizeConstraints.minWidth - cx;
+             if (mDirection == topleft || mDirection == left || mDirection == bottomleft) {
+               // Move as far as possible
+               nsMoveBy.x = cx - mSizeConstraints.minWidth;
+             }
+             else {
+               // Track the distance beyond the minimum
+               nsBeyondMinimum.x = mSizeConstraints.minWidth - newWidth;
+               // Don't move at all
+               nsMoveBy.x = 0;
+             }
+           }
+         }
 
-				 window->SetPositionAndSize(x,y,cx,cy,PR_TRUE); // do the repaint.
+         // Make sure a constraint is set
+         if (mSizeConstraints.minHeight != -1) {
+           PRInt32 newHeight = cy + requestedSizeChange.y;
+           if (newHeight < mSizeConstraints.minHeight) {
+             // Always fix the size
+             nsSizeBy.y = mSizeConstraints.minHeight - cy;
+             if (mDirection == topleft || mDirection == top || mDirection == topright) {
+              // Move as far as possible
+              nsMoveBy.y = cy - mSizeConstraints.minHeight;
+             }
+             else {
+               // Track the distance beyond the minimum
+               nsBeyondMinimum.y = mSizeConstraints.minHeight - newHeight;
+               // Don't move at all
+               nsMoveBy.y = 0;
+             }
+           }
+         }
 
-				 /*
-				 if(nsSizeBy.x || nsSizeBy.y)
-				 {
-					window->ResizeBy(nsSizeBy.x,nsSizeBy.y);
-				 }
+         // Make sure a constraint is set
+         if (mSizeConstraints.maxWidth != -1) {
+           PRInt32 newWidth = cx + requestedSizeChange.x;
+           if (newWidth > mSizeConstraints.maxWidth) {
+             // Always fix the size
+             nsSizeBy.x = mSizeConstraints.maxWidth - cx;
+             if (mDirection == topleft || mDirection == left || mDirection == bottomleft) {
+               // Move as far as possible
+               nsMoveBy.x = cx - mSizeConstraints.maxWidth;
+             }
+             else {
+               // Track the distance beyond the maximum
+               nsBeyondMaximum.x = newWidth - mSizeConstraints.maxWidth;
+               // Don't move at all
+               nsMoveBy.x = 0;
+             }
+           }
+         }
 
-				 if(nsMoveBy.x || nsMoveBy.y)
-				 {
-					window->MoveBy(nsMoveBy.x,nsMoveBy.y);
-				 }	*/
-				 
-				 
-				 
-				 *aEventStatus = nsEventStatus_eConsumeNoDefault;				
-				 
-				 doDefault = PR_FALSE;
-			 }
-		 }
-		 break;
+         // Make sure a constraint is set
+         if (mSizeConstraints.maxHeight != -1) {
+           PRInt32 newHeight = cy + requestedSizeChange.y;
+           if (newHeight > mSizeConstraints.maxHeight) {
+             // Always fix the size
+             nsSizeBy.y = mSizeConstraints.maxHeight - cy;
+             if (mDirection == topleft || mDirection == top || mDirection == topright) {
+               // Move as far as possible
+               nsMoveBy.y = cy - mSizeConstraints.maxHeight;
+             }
+             else {
+               // Track the distance beyond the maximum
+               nsBeyondMaximum.y = newHeight - mSizeConstraints.maxHeight;
+               // Don't move at all
+               nsMoveBy.y = 0;
+             }
+           }
+         }
 
+         // Update all the variables
+         x += nsMoveBy.x;
+         y += nsMoveBy.y;
+         cx += nsSizeBy.x;
+         cy += nsSizeBy.y;
+
+         // Update our tracking point
+         mLastPoint += nsBeyondMinimum - nsBeyondMaximum;
+
+         // Do the repaint
+         mResizingWindow->SetPositionAndSize(x, y, cx, cy, PR_TRUE);
+         *aEventStatus = nsEventStatus_eConsumeNoDefault;
+       }
 
+       doDefault = PR_FALSE;
+     }
+		 break;
 
     case NS_MOUSE_LEFT_CLICK:
-      MouseClicked(aPresContext, aEvent);
-      break;
+      if (!IsDisabled(aPresContext))
+        MouseClicked(aPresContext, aEvent);
+    break;
   }
   
   if ( doDefault )  
@@ -256,7 +346,6 @@ nsResizerFrame::HandleEvent(nsPresContex
 }
 
 
-
 /* returns true if aText represented a valid direction 
  */
 PRBool 
@@ -360,3 +449,81 @@ nsResizerFrame::MouseClicked(nsPresConte
   mContent->HandleDOMEvent(aPresContext, &event, nsnull, NS_EVENT_FLAG_INIT,
                            &status);
 }
+
+PRBool
+nsResizerFrame::CacheDisabledAttr()
+{
+  nsCOMPtr<nsIContent> content;
+  GetContentOf(getter_AddRefs(content));
+
+  if (!content)
+    return PR_FALSE;
+
+  nsAutoString disabled;
+  content->GetAttr(kNameSpaceID_None, nsXULAtoms::disabled, disabled);
+  mDisabled = disabled.EqualsLiteral("true");
+
+  return PR_TRUE;
+}
+
+
+nsresult
+nsResizerFrame::GetWindowFromPresContext(nsPresContext* aPresContext,
+                                         nsIBaseWindow** _retval)
+{
+  NS_ENSURE_ARG_POINTER(aPresContext);
+  NS_ENSURE_ARG_POINTER(_retval);
+
+  nsIPresShell* presShell = aPresContext->PresShell();
+  NS_ENSURE_STATE(presShell);
+
+  nsIDocument* document = presShell->GetDocument();
+  NS_ENSURE_STATE(document);
+
+  nsIScriptGlobalObject* scriptObj = document->GetScriptGlobalObject();
+  NS_ENSURE_STATE(scriptObj);
+
+  nsIDocShell* docShell = scriptObj->GetDocShell();
+  NS_ENSURE_STATE(docShell);
+
+  nsresult rv;
+  nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
+    do_QueryInterface(docShell, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
+  rv = docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(treeOwner, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  NS_ADDREF(*_retval = baseWindow);
+  return NS_OK;
+}
+
+
+PRBool
+nsResizerFrame::IsDisabled(nsPresContext* aPresContext)
+{
+  if (mDisabled)
+    return PR_TRUE;
+
+  // Resizers shouldn't be active if the window is maximized
+  nsresult rv;
+  nsCOMPtr<nsIBaseWindow> baseWindow = mResizingWindow;
+  if (!baseWindow) {
+    rv = GetWindowFromPresContext(aPresContext, getter_AddRefs(baseWindow));
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+  }
+
+  nsCOMPtr<nsIWidget> mainWidget;
+  rv = baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
+  NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+  PRInt32 sizeMode;
+  rv = mainWidget->GetSizeMode(&sizeMode);
+  NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+  return sizeMode == nsSizeMode_Maximized;
+}
Index: layout/xul/base/src/nsResizerFrame.h
===================================================================
RCS file: /cvsroot/mozilla/layout/xul/base/src/nsResizerFrame.h,v
retrieving revision 1.9
diff -u -p -r1.9 nsResizerFrame.h
--- layout/xul/base/src/nsResizerFrame.h	28 Apr 2005 23:48:00 -0000	1.9
+++ layout/xul/base/src/nsResizerFrame.h	10 Jan 2007 02:00:57 -0000
@@ -39,6 +39,10 @@
 #define nsResizerFrame_h___
 
 #include "nsTitleBarFrame.h"
+#include "nsCOMPtr.h"
+
+class nsIBaseWindow;
+class nsPresContext;
 
 class nsResizerFrame : public nsTitleBarFrame 
 {
@@ -47,14 +51,29 @@ protected:
   enum eDirection {
     topleft,
     top,
-	 topright,
-	 left,	 
-	 right,
-	 bottomleft,
-	 bottom,
-	 bottomright
+    topright,
+    left,	 
+    right,
+    bottomleft,
+    bottom,
+    bottomright
+  };
+
+  struct SizeConstraints {
+    PRInt32 minHeight;
+    PRInt32 maxHeight;
+    PRInt32 minWidth;
+    PRInt32 maxWidth;
+
+    SizeConstraints(PRInt32 aMinHeight,
+                    PRInt32 aMaxHeight,
+                    PRInt32 aMinWidth,
+                    PRInt32 aMaxWidth) :
+      minHeight(aMinHeight),
+      maxHeight(aMaxHeight),
+      minWidth(aMinWidth),
+      maxWidth(aMaxWidth) { }
   };
-  
 
 public:
   friend nsresult NS_NewResizerFrame(nsIPresShell* aPresShell, nsIFrame** aNewFrame);  
@@ -80,15 +99,18 @@ public:
   virtual void MouseClicked(nsPresContext* aPresContext, nsGUIEvent *aEvent);
 
 protected:
-	PRBool GetInitialDirection(eDirection& aDirection);
-	PRBool EvalDirection(nsAutoString& aText,eDirection& aResult);
+  PRBool GetInitialDirection(eDirection& aDirection);
+  PRBool EvalDirection(nsAutoString& aText,eDirection& aResult);
+  PRBool CacheDisabledAttr();
+  static nsresult GetWindowFromPresContext(nsPresContext* aPresContext,
+                                           nsIBaseWindow** _retval);
+  PRBool IsDisabled(nsPresContext* aPresContext);
 
 protected:
-	eDirection mDirection;
-	nsRect mWidgetRect;
-
-
-
+  eDirection mDirection;
+  SizeConstraints mSizeConstraints;
+  PRBool mDisabled;
+  nsCOMPtr<nsIBaseWindow> mResizingWindow;
 }; // class nsResizerFrame
 
 #endif /* nsResizerFrame_h___ */
Index: widget/public/nsIWidget.h
===================================================================
RCS file: /cvsroot/mozilla/widget/public/nsIWidget.h,v
retrieving revision 3.140.4.3
diff -u -p -r3.140.4.3 nsIWidget.h
--- widget/public/nsIWidget.h	20 Jul 2006 01:11:31 -0000	3.140.4.3
+++ widget/public/nsIWidget.h	10 Jan 2007 02:00:57 -0000
@@ -451,6 +451,57 @@ class nsIWidget : public nsISupports {
                                  PRInt32 *aY) = 0;
 
     /**
+     * Platform-dependent method that uses the OS to ensure that the size of
+     * widget never exceeds the given minimum or maximum values. Also affects
+     * the behavior of the <xul:resizer> element.
+     *
+     * This is only guaranteed to work on top-level window widgets (i.e.
+     * widgets created with the 'eWindowType_dialog', 'eWindowType_toplevel',
+     * or 'eWindowType_invisible' windowTypes that have no parent). Calling
+     * this function on any other type of window will throw
+     * NS_ERROR_UNEXPECTED. In contrast, calls to GetSizeConstraints will
+     * always succeed, but each constraint will be set to -1.
+     *
+     * XXXbent All of the following pixel values are supposed to be device
+     *         pixels, but note that we currently assume device pixels map 1:1
+     *         to CSS pixels.
+     *
+     * @param aMinWidth: the minimum width in device pixels (-1 to ignore)
+     * @param aMaxWidth: the maximum width in device pixels (-1 to ignore)
+     * @param aMinHeight: the minimum height in device pixels (-1 to ignore)
+     * @param aMaxHeight: the maximum height in device pixels (-1 to ignore)
+     *
+     * @throws NS_ERROR_UNEXPECTED if called on a non-top-level widget
+     **/
+    NS_IMETHOD SetSizeConstraints(PRInt32 aMinWidth,
+                                  PRInt32 aMaxWidth,
+                                  PRInt32 aMinHeight,
+                                  PRInt32 aMaxHeight) = 0;
+
+    /**
+     * Return the size constraints currently observed by the widget.
+     *
+     * You can pass nsnull for any of the parameters if you don't care to
+     * retrieve their value. Constraint values set to -1 by this function
+     * indicate that that particular constraint is not observed.
+     *
+     * Calling this function on non-top-level widgets will succeed, however
+     * *all* constraints will be reported as -1 (unconstrained).
+     *
+     * XXXbent All of the following pixel values are supposed to be device
+     *         pixels, but note that we currently assume device pixels map 1:1
+     *         to CSS pixels.
+     *
+     * @param aMinWidth: the minimum width of the widget in device pixels
+     * @param aMaxWidth: the maximum width for the widget in device pixels
+     * @param aMinHeight: the minimum height for the widget in device pixels
+     * @param aMaxHeight: the maximum height for the widget in device pixels
+     **/
+    NS_IMETHOD GetSizeConstraints(PRInt32* aMinWidth,
+                                  PRInt32* aMaxWidth,
+                                  PRInt32* aMinHeight,
+                                  PRInt32* aMaxHeight) = 0;
+    /**
      * Move this widget.
      *
      * @param aX the new x position expressed in the parent's coordinate system
Index: widget/src/windows/nsWindow.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/windows/nsWindow.cpp,v
retrieving revision 3.569.2.44
diff -u -p -r3.569.2.44 nsWindow.cpp
--- widget/src/windows/nsWindow.cpp	9 Jan 2007 11:27:05 -0000	3.569.2.44
+++ widget/src/windows/nsWindow.cpp	10 Jan 2007 02:01:00 -0000
@@ -33,6 +33,7 @@
  *   Masayuki Nakano <masayuki@d-toybox.com>
  *   Dainis Jonitis <Dainis_Jonitis@swh-t.lv>
  *   Christian Biesinger <cbiesinger@web.de>
+ *   Ben Turner <mozilla@songbirdnest.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -1083,6 +1084,14 @@ nsWindow::nsWindow() : nsBaseWidget()
   mOldStyle           = 0;
   mOldExStyle         = 0;
   mPainting           = 0;
+  mIsHideChrome       = PR_FALSE;
+  mIsMaximizing       = PR_FALSE;
+  mWasMaximized       = PR_FALSE;
+
+  mConstrainedMinWidth  = -1;
+  mConstrainedMaxWidth  = -1;
+  mConstrainedMinHeight = -1;
+  mConstrainedMaxHeight = -1;
 
   mLeadByte = '\0';
   mBlurEventSuppressionLevel = 0;
@@ -2318,6 +2327,43 @@ NS_METHOD nsWindow::ConstrainPosition(PR
   return NS_OK;
 }
 
+NS_IMETHODIMP nsWindow::SetSizeConstraints(PRInt32 aMinWidth,
+                                           PRInt32 aMaxWidth,
+                                           PRInt32 aMinHeight,
+                                           PRInt32 aMaxHeight)
+{
+  // This function is only guaranteed to work with top-level widget windows
+  if (!mIsTopWidgetWindow)
+    return NS_ERROR_UNEXPECTED;
+
+  PRInt32 sysMinWidth = ::GetSystemMetrics(SM_CXMINTRACK);
+  mConstrainedMinWidth = PR_MAX(sysMinWidth, aMinWidth);
+
+  PRInt32 sysMinHeight = ::GetSystemMetrics(SM_CYMINTRACK);
+  mConstrainedMinHeight = PR_MAX(sysMinHeight, aMinHeight);
+
+  mConstrainedMaxWidth = aMaxWidth;
+  mConstrainedMaxHeight = aMaxHeight;
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsWindow::GetSizeConstraints(PRInt32* aMinWidth,
+                                           PRInt32* aMaxWidth,
+                                           PRInt32* aMinHeight,
+                                           PRInt32* aMaxHeight)
+{
+  if (aMinWidth)
+    *aMinWidth = mConstrainedMinWidth;
+  if (aMaxWidth)
+    *aMaxWidth = mConstrainedMaxWidth;
+  if (aMinHeight)
+    *aMinHeight = mConstrainedMinHeight;
+  if (aMaxHeight)
+    *aMaxHeight = mConstrainedMaxHeight;
+  return NS_OK;
+}
+
 //-------------------------------------------------------------------------
 //
 // Move this component
@@ -3257,6 +3303,8 @@ NS_IMETHODIMP nsWindow::HideWindowChrome
   nsToolkit::mSetWindowLong(hwnd, GWL_STYLE, style);
   nsToolkit::mSetWindowLong(hwnd, GWL_EXSTYLE, exStyle);
 
+  mIsHideChrome = aShouldHide;
+
   return NS_OK;
 }
 
@@ -4548,6 +4596,12 @@ PRBool nsWindow::ProcessMessage(UINT msg
 #ifndef WINCE
     case WM_DISPLAYCHANGE:
       DispatchStandardEvent(NS_DISPLAYCHANGED);
+
+      // When the window's chrome is hidden and the work area changes, 
+      // the window is not invalidated as it is supposed to
+      if (mIsHideChrome)
+        Invalidate(PR_TRUE);
+
       break;
 #endif
 
@@ -5124,6 +5178,62 @@ PRBool nsWindow::ProcessMessage(UINT msg
     break;
 #endif
 
+    case WM_GETMINMAXINFO:
+    {
+      PRInt32 minTrackWidth = mConstrainedMinWidth;
+      PRInt32 minTrackHeight = mConstrainedMinHeight;
+      PRInt32 maxTrackWidth = mConstrainedMaxWidth;
+      PRInt32 maxTrackHeight = mConstrainedMaxHeight;
+      PRInt32 maxWidth = mConstrainedMaxWidth;
+      PRInt32 maxHeight = mConstrainedMaxHeight;
+
+      PRInt32 left = -1, top = -1;
+
+      // Restrict the window from covering the taskbar if hidechrome is enabled
+      // (because the OS doesn't do this for us) and the size mode is set to
+      // maximized (because 'fullscreen' mode still uses nsSizeMode_Normal).
+      if (mIsHideChrome &&
+          (mSizeMode == nsSizeMode_Maximized || mIsMaximizing)) {
+
+        // Figure out the maximized window's size and position
+        RECT workArea;
+        if (::SystemParametersInfo(SPI_GETWORKAREA, 0, &workArea, 0)) {
+          PRInt32 workWidth = workArea.right - workArea.left;
+          maxWidth = mConstrainedMaxWidth != -1 ?
+                     PR_MIN(workWidth, mConstrainedMaxWidth) :
+                     workWidth;
+
+          PRInt32 workHeight = workArea.bottom - workArea.top;
+          maxHeight = mConstrainedMaxHeight != -1 ?
+                      PR_MIN(workHeight, mConstrainedMaxHeight) :
+                      workHeight;
+          
+          left = workArea.left;
+          top = workArea.top;
+        }
+      }
+
+      // Set our values
+      MINMAXINFO* mmi = (MINMAXINFO*)lParam;
+      if (minTrackWidth != -1 && minTrackWidth > mmi->ptMinTrackSize.x)
+        mmi->ptMinTrackSize.x = minTrackWidth;
+      if (minTrackHeight != -1 && minTrackHeight > mmi->ptMinTrackSize.y)
+        mmi->ptMinTrackSize.y = minTrackHeight;
+      if (maxTrackWidth != -1 && maxTrackWidth < mmi->ptMaxTrackSize.x)
+        mmi->ptMaxTrackSize.x = maxTrackWidth;
+      if (maxTrackHeight != -1 && maxTrackHeight < mmi->ptMaxTrackSize.y)
+        mmi->ptMaxTrackSize.y = maxTrackHeight;
+      if (maxWidth != -1 && maxWidth < mmi->ptMaxSize.x)
+        mmi->ptMaxSize.x = maxWidth;
+      if (maxHeight != -1 && maxHeight < mmi->ptMaxSize.y)
+        mmi->ptMaxSize.y = maxHeight;
+      if (left != -1 && left > mmi->ptMaxPosition.x)
+        mmi->ptMaxPosition.x = left;
+      if (top != -1 && top > mmi->ptMaxPosition.y)
+        mmi->ptMaxPosition.y = top;
+    }
+    break;
+
     case WM_SETFOCUS:
 #ifdef WINCE
       {
@@ -5204,6 +5314,11 @@ PRBool nsWindow::ProcessMessage(UINT msg
       }
 #endif
 
+      // Reset our special case flag for maximizing a hidechrome window now
+      // that all sizing is completed
+      if (mIsMaximizing)
+        mIsMaximizing = PR_FALSE;
+
       WINDOWPOS *wp = (LPWINDOWPOS)lParam;
 
       // We only care about a resize, so filter out things like z-order
@@ -5481,10 +5596,29 @@ PRBool nsWindow::ProcessMessage(UINT msg
 
 #ifndef WINCE
     case WM_SYSCOMMAND:
-      // prevent Windows from trimming the working set. bug 76831
-      if (!gTrimOnMinimize && wParam == SC_MINIMIZE) {
-        ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
-        result = PR_TRUE;
+      if (wParam == SC_MINIMIZE) {
+        // prevent Windows from trimming the working set. bug 76831
+        if (!gTrimOnMinimize) {
+          ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
+          result = PR_TRUE;
+        }
+        // Set this flag so that we restore to the proper size
+        if (mIsHideChrome && mSizeMode == nsSizeMode_Maximized)
+          mWasMaximized = PR_TRUE;
+      }
+      else if (wParam == SC_MAXIMIZE) {
+        if (mIsHideChrome) {
+          // Set a flag to properly animate the maximizing of a hidechrome window
+          // that will be handled in WM_GETMINMAXINFO
+          mWasMaximized = PR_FALSE;
+          mIsMaximizing = PR_TRUE;
+        }
+      }
+      else if (wParam == SC_RESTORE) {
+        if (mIsHideChrome && mWasMaximized) {
+          mWasMaximized = PR_FALSE;
+          mIsMaximizing = PR_TRUE;
+        }
       }
       break;
 #endif
Index: widget/src/windows/nsWindow.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/windows/nsWindow.h,v
retrieving revision 3.204.2.12
diff -u -p -r3.204.2.12 nsWindow.h
--- widget/src/windows/nsWindow.h	28 Nov 2006 12:17:35 -0000	3.204.2.12
+++ widget/src/windows/nsWindow.h	10 Jan 2007 02:01:00 -0000
@@ -57,6 +57,8 @@
 
 #include "nsVoidArray.h"
 
+#include "nsRect.h"
+
 #include <imm.h>
 
 class nsNativeDragTarget;
@@ -331,6 +333,10 @@ public:
   NS_IMETHOD              ModalEventFilter(PRBool aRealEvent, void *aEvent, PRBool *aForWindow);
   NS_IMETHOD              CaptureMouse(PRBool aCapture);
   NS_IMETHOD              ConstrainPosition(PRBool aAllowSlop, PRInt32 *aX, PRInt32 *aY);
+  NS_IMETHOD              SetSizeConstraints(PRInt32 aMinWidth, PRInt32 aMaxWidth,
+                                             PRInt32 aMinHeight, PRInt32 aMaxHeight);
+  NS_IMETHOD              GetSizeConstraints(PRInt32* aMinWidth, PRInt32* aMaxWidth,
+                                             PRInt32* aMinHeight, PRInt32* aMaxHeight);
   NS_IMETHOD              Move(PRInt32 aX, PRInt32 aY);
   NS_IMETHOD              Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint);
   NS_IMETHOD              Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint);
@@ -520,6 +526,7 @@ protected:
   void GetTextRangeList(PRUint32* textRangeListLengthResult, nsTextRangeArray* textRangeListResult);
 
   void ConstrainZLevel(HWND *aAfter);
+  void EnsureSizeConstraints(WINDOWPOS* aInfo);
 
   PRBool CanTakeFocus();
 
@@ -596,7 +603,9 @@ protected:
   PRPackedBool  mIsInMouseCapture;
   PRPackedBool  mIsInMouseWheelProcessing;
   PRPackedBool  mUnicodeWidget;
-
+  PRPackedBool  mIsHideChrome;
+  PRPackedBool  mIsMaximizing;
+  PRPackedBool  mWasMaximized;
   PRPackedBool  mPainting;
   char          mLeadByte;
   PRUint32      mBlurEventSuppressionLevel;
@@ -623,6 +632,11 @@ protected:
   // Drag & Drop
   nsNativeDragTarget * mNativeDragTarget;
 
+  PRInt32 mConstrainedMinWidth;
+  PRInt32 mConstrainedMaxWidth;
+  PRInt32 mConstrainedMinHeight;
+  PRInt32 mConstrainedMaxHeight;
+
   // Enumeration of the methods which are accessible on the "main GUI thread"
   // via the CallMethod(...) mechanism...
   // see nsSwitchToUIThread
Index: widget/src/xpwidgets/nsBaseWidget.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/xpwidgets/nsBaseWidget.cpp,v
retrieving revision 1.135
diff -u -p -r1.135 nsBaseWidget.cpp
--- widget/src/xpwidgets/nsBaseWidget.cpp	21 Jul 2005 04:28:40 -0000	1.135
+++ widget/src/xpwidgets/nsBaseWidget.cpp	10 Jan 2007 02:01:00 -0000
@@ -796,7 +796,32 @@ NS_METHOD nsBaseWidget::SetBounds(const 
   return NS_OK;
 }
  
+NS_IMETHODIMP nsBaseWidget::SetSizeConstraints(PRInt32 aMinWidth,
+                                               PRInt32 aMaxWidth,
+                                               PRInt32 aMinHeight,
+                                               PRInt32 aMaxHeight)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsBaseWidget::GetSizeConstraints(PRInt32* aMinWidth,
+                                               PRInt32* aMaxWidth,
+                                               PRInt32* aMinHeight,
+                                               PRInt32* aMaxHeight)
+{
+  // Returning -1 indicates that no constraints have been set
+  if (aMinWidth)
+    *aMinWidth = -1;
+  if (aMaxWidth)
+    *aMaxWidth = -1;
+  if (aMinHeight)
+    *aMinHeight = -1;
+  if (aMaxHeight)
+    *aMaxHeight = -1;
+  return NS_OK;
+}
 
+//-------------------------------------------------------------------------
 
 /**
 * Calculates the border width and height  
Index: widget/src/xpwidgets/nsBaseWidget.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/xpwidgets/nsBaseWidget.h,v
retrieving revision 1.75
diff -u -p -r1.75 nsBaseWidget.h
--- widget/src/xpwidgets/nsBaseWidget.h	21 Jul 2005 04:28:40 -0000	1.75
+++ widget/src/xpwidgets/nsBaseWidget.h	10 Jan 2007 02:01:00 -0000
@@ -134,6 +134,10 @@ public:
   NS_IMETHOD              SetIcon(const nsAString &anIconSpec);
   virtual void            ConvertToDeviceCoordinates(nscoord  &aX,nscoord &aY) {}
   virtual void            FreeNativeData(void * data, PRUint32 aDataType) {}//~~~
+  NS_IMETHOD              SetSizeConstraints(PRInt32 aMinWidth, PRInt32 aMaxWidth,
+                                             PRInt32 aMinHeight, PRInt32 aMaxHeight);
+  NS_IMETHOD              GetSizeConstraints(PRInt32* aMinWidth, PRInt32* aMaxWidth,
+                                             PRInt32* aMinHeight, PRInt32* aMaxHeight);
 
 protected:
 
