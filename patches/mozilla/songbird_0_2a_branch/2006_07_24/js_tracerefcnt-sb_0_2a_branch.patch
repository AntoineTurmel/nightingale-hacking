? compiled
? js_tracerefcnt-sb_0_2a_branch.patch
? js_tracerefcnt.patch
? accessible/src/base/sanity_diff.patch
Index: xpcom/glue/nsTraceRefcnt.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/glue/Attic/nsTraceRefcnt.cpp,v
retrieving revision 3.2
diff -p -u -1 -0 -r3.2 nsTraceRefcnt.cpp
--- xpcom/glue/nsTraceRefcnt.cpp	29 Oct 2004 19:43:51 -0000	3.2
+++ xpcom/glue/nsTraceRefcnt.cpp	19 May 2006 01:39:04 -0000
@@ -69,33 +69,33 @@ nsresult GlueStartupTraceRefcnt() 
   return NS_OK;
 }
 
 void GlueShutdownTraceRefcnt()
 {
   NS_IF_RELEASE(gTraceRefcntObject);
 }
 #endif
 
 NS_COM_GLUE void 
-nsTraceRefcnt::LogAddRef(void * aPtr, nsrefcnt aNewRefcnt, const char *aTypeName, PRUint32 aInstanceSize)
+nsTraceRefcnt::LogAddRef(void * aPtr, nsrefcnt aNewRefCnt, const char *aTypeName, PRUint32 aInstanceSize)
 {
   if (!ENSURE_TRACEOBJECT)
     return;
-  gTraceRefcntObject->LogAddRef(aPtr, aNewRefcnt, aTypeName, aInstanceSize);
+  gTraceRefcntObject->LogAddRef(aPtr, aNewRefCnt, aTypeName, aInstanceSize);
 }
 
 NS_COM_GLUE void 
-nsTraceRefcnt::LogRelease(void * aPtr, nsrefcnt aNewRefcnt, const char *aTypeName)
+nsTraceRefcnt::LogRelease(void * aPtr, nsrefcnt aNewRefCnt, const char *aTypeName)
 {
   if (!ENSURE_TRACEOBJECT)
     return;
-  gTraceRefcntObject->LogRelease(aPtr, aNewRefcnt, aTypeName);
+  gTraceRefcntObject->LogRelease(aPtr, aNewRefCnt, aTypeName);
 }
 
 NS_COM_GLUE void 
 nsTraceRefcnt::LogCtor(void * aPtr, const char *aTypeName, PRUint32 aInstanceSize)
 {
   if (!ENSURE_TRACEOBJECT)
     return;
   gTraceRefcntObject->LogCtor(aPtr, aTypeName, aInstanceSize);
 }
 
@@ -116,10 +116,44 @@ nsTraceRefcnt::LogAddCOMPtr(void * aPtr,
 }
 
 NS_COM_GLUE void 
 nsTraceRefcnt::LogReleaseCOMPtr(void * aPtr, nsISupports *aObject)
 {
   if (!ENSURE_TRACEOBJECT)
     return;
   gTraceRefcntObject->LogReleaseCOMPtr(aPtr, aObject);
 }
 
+void NS_TraceRefcnt_LogAddRef(void* aPtr,
+                              nsrefcnt aNewRefCnt,
+                              const char* aTypeName,
+                              PRUint32 aInstanceSize)
+{
+  if (!ENSURE_TRACEOBJECT)
+    return;
+  gTraceRefcntObject->LogAddRef(aPtr, aNewRefCnt, aTypeName, aInstanceSize);
+}
+
+void NS_TraceRefcnt_LogRelease(void* aPtr,
+                               nsrefcnt aNewRefCnt,
+                               const char* aTypeName)
+{
+  if (!ENSURE_TRACEOBJECT)
+    return;
+  gTraceRefcntObject->LogRelease(aPtr, aNewRefCnt, aTypeName);
+}
+
+void NS_TraceRefcnt_LogCtor(void* aPtr, const char* aTypeName,
+                            PRUint32 aInstanceSize)
+{
+  if (!ENSURE_TRACEOBJECT)
+    return;
+  gTraceRefcntObject->LogCtor(aPtr, aTypeName, aInstanceSize);
+}
+
+void NS_TraceRefcnt_LogDtor(void* aPtr, const char* aTypeName,
+                            PRUint32 aInstanceSize)
+{
+  if (!ENSURE_TRACEOBJECT)
+    return;
+  gTraceRefcntObject->LogDtor(aPtr, aTypeName, aInstanceSize);
+}
Index: xpcom/glue/nsTraceRefcnt.h
===================================================================
RCS file: /cvsroot/mozilla/xpcom/glue/nsTraceRefcnt.h,v
retrieving revision 3.5
diff -p -u -1 -0 -r3.5 nsTraceRefcnt.h
--- xpcom/glue/nsTraceRefcnt.h	29 Oct 2004 19:43:51 -0000	3.5
+++ xpcom/glue/nsTraceRefcnt.h	19 May 2006 01:39:04 -0000
@@ -33,60 +33,62 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 #ifndef nsTraceRefcnt_h___
 #define nsTraceRefcnt_h___
 
 #include "nscore.h"
 
-class nsISupports;
-
-// By default refcnt logging is not part of the build.
+/* By default refcnt logging is not part of the build. */
 #undef NS_BUILD_REFCNT_LOGGING
 
 #if (defined(DEBUG) || defined(FORCE_BUILD_REFCNT_LOGGING))
-// Make refcnt logging part of the build. This doesn't mean that
-// actual logging will occur (that requires a separate enable; see
-// nsTraceRefcnt.h for more information).
+/* Make refcnt logging part of the build. This doesn't mean that
+ * actual logging will occur (that requires a separate enable; see
+ * nsTraceRefcnt.h for more information). */
 #define NS_BUILD_REFCNT_LOGGING 1
 #endif
 
-// If NO_BUILD_REFCNT_LOGGING is defined then disable refcnt logging
-// in the build. This overrides FORCE_BUILD_REFCNT_LOGGING.
+/* If NO_BUILD_REFCNT_LOGGING is defined then disable refcnt logging
+ * in the build. This overrides FORCE_BUILD_REFCNT_LOGGING. */
 #if defined(NO_BUILD_REFCNT_LOGGING)
 #undef NS_BUILD_REFCNT_LOGGING
 #endif
 
+#ifdef __cplusplus
+
+class nsISupports;
+
 #ifdef NS_BUILD_REFCNT_LOGGING
 
 #define NS_LOG_ADDREF(_p, _rc, _type, _size) \
   nsTraceRefcnt::LogAddRef((_p), (_rc), (_type), (PRUint32) (_size))
 
 #define NS_LOG_RELEASE(_p, _rc, _type) \
   nsTraceRefcnt::LogRelease((_p), (_rc), (_type))
 
 #define MOZ_DECL_CTOR_COUNTER(_type)
 
 #define MOZ_COUNT_CTOR(_type)                                 \
 PR_BEGIN_MACRO                                                \
   nsTraceRefcnt::LogCtor((void*)this, #_type, sizeof(*this)); \
 PR_END_MACRO
 
 #define MOZ_COUNT_DTOR(_type)                                 \
 PR_BEGIN_MACRO                                                \
   nsTraceRefcnt::LogDtor((void*)this, #_type, sizeof(*this)); \
 PR_END_MACRO
 
-#ifdef HAVE_CPP_DYNAMIC_CAST_TO_VOID_PTR  // from autoconf (XXX needs to be
-                                          // set for non-autoconf platforms)
+// from autoconf (XXX needs to be set for non-autoconf platforms)
+#ifdef HAVE_CPP_DYNAMIC_CAST_TO_VOID_PTR
 
 // nsCOMPtr.h allows these macros to be defined by clients
 // These logging functions require dynamic_cast<void *>, so we don't
 // define these macros if we don't have dynamic_cast.
 #define NSCAP_LOG_ASSIGNMENT(_c, _p)                                \
   if (_p)                                                           \
     nsTraceRefcnt::LogAddCOMPtr((_c),NS_STATIC_CAST(nsISupports*,_p))
 
 #define NSCAP_LOG_RELEASE(_c, _p)                                   \
   if (_p)                                                           \
@@ -97,26 +99,61 @@ PR_END_MACRO
 #else /* !NS_BUILD_REFCNT_LOGGING */
 
 #define NS_LOG_ADDREF(_p, _rc, _type, _size)
 #define NS_LOG_RELEASE(_p, _rc, _type)
 #define MOZ_DECL_CTOR_COUNTER(_type)
 #define MOZ_COUNT_CTOR(_type)
 #define MOZ_COUNT_DTOR(_type)
 
 #endif /* NS_BUILD_REFCNT_LOGGING */
 
+#else /* !defined(__cplusplus) */
+
+/* copied from nsISupportsBase.h */
+#if defined(XP_WIN) && PR_BYTES_PER_LONG == 4
+typedef unsigned long nsrefcnt;
+#else
+typedef PRUint32 nsrefcnt;
+#endif
+
+#ifdef NS_BUILD_REFCNT_LOGGING
+
+#define NS_LOG_ADDREF(p_, rc_, type_, size_) \
+  NS_TraceRefcnt_LogAddRef((p_), (rc_), (type_), (PRUint32) (size_))
+
+#define NS_LOG_RELEASE(p_, rc_, type_) \
+  NS_TraceRefcnt_LogRelease((p_), (rc_), (type_))
+
+#define NS_LOG_CREATE(obj_, type_) \
+  NS_TraceRefcnt_LogCtor((void*)(obj_), #type_, sizeof(*(obj_)))
+
+#define NS_LOG_DESTROY(obj_, type_) \
+  NS_TraceRefcnt_LogDtor((void*)(obj_), #type_, sizeof(*(obj_)))
+
+#else /* !defined(NS_BUILD_REFCNT_LOGGING) */
+
+#define NS_LOG_ADDREF(p_, rc_, type_, size_)
+#define NS_LOG_RELEASE(p_, rc_, type_)
+#define NS_LOG_CREATE(obj_, type_)
+#define NS_LOG_DESTROY(obj_, type_)
+
+#endif /* !defined(NS_BUILD_REFCNT_LOGGING) */
+
+#endif /* !defined(__cplusplus) */
+
 //----------------------------------------------------------------------
 
 /**
  * Note: The implementations for these methods are no-ops in a build
  * where NS_BUILD_REFCNT_LOGGING is disabled.
  */
+#ifdef __cplusplus
 class nsTraceRefcnt {
 public:
   static NS_COM_GLUE void LogAddRef(void* aPtr,
                                     nsrefcnt aNewRefCnt,
                                     const char* aTypeName,
                                     PRUint32 aInstanceSize);
 
   static NS_COM_GLUE void LogRelease(void* aPtr,
                                      nsrefcnt aNewRefCnt,
                                      const char* aTypeName);
@@ -125,11 +162,32 @@ public:
                                   PRUint32 aInstanceSize);
 
   static NS_COM_GLUE void LogDtor(void* aPtr, const char* aTypeName,
                                   PRUint32 aInstanceSize);
 
   static NS_COM_GLUE void LogAddCOMPtr(void *aCOMPtr, nsISupports *aObject);
 
   static NS_COM_GLUE void LogReleaseCOMPtr(void *aCOMPtr, nsISupports *aObject);
 
 };
+#endif
+
+PR_BEGIN_EXTERN_C
+
+NS_COM_GLUE void NS_TraceRefcnt_LogAddRef(void* aPtr,
+                                          nsrefcnt aNewRefCnt,
+                                          const char* aTypeName,
+                                          PRUint32 aInstanceSize);
+
+NS_COM_GLUE void NS_TraceRefcnt_LogRelease(void* aPtr,
+                                           nsrefcnt aNewRefCnt,
+                                           const char* aTypeName);
+
+NS_COM_GLUE void NS_TraceRefcnt_LogCtor(void* aPtr, const char* aTypeName,
+                                        PRUint32 aInstanceSize);
+
+NS_COM_GLUE void NS_TraceRefcnt_LogDtor(void* aPtr, const char* aTypeName,
+                                        PRUint32 aInstanceSize);
+
+PR_END_EXTERN_C
+
 #endif /* nsTraceRefcnt_h___ */
