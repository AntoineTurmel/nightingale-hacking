? .mozconfig.mk
? a.out
? bug176182-jsautorequest-sb_0_2a_branch.patch
? compiled
? confdefs.h
? config.cache
? config.log
? sanity.diff
? sanity13.diff
Index: caps/src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.266.2.14
diff -U8 -p -r1.266.2.14 nsScriptSecurityManager.cpp
--- caps/src/nsScriptSecurityManager.cpp	6 Jul 2006 21:07:15 -0000	1.266.2.14
+++ caps/src/nsScriptSecurityManager.cpp	13 Jul 2006 18:25:47 -0000
@@ -93,37 +93,40 @@ JSRuntime       *nsScriptSecurityManager
 
 ///////////////////////////
 // Convenience Functions //
 ///////////////////////////
 // Result of this function should not be freed.
 static inline const PRUnichar *
 JSValIDToString(JSContext *cx, const jsval idval)
 {
+    JSAutoRequest ar(cx);
     JSString *str = JS_ValueToString(cx, idval);
     if(!str)
         return nsnull;
     return NS_REINTERPRET_CAST(PRUnichar*, JS_GetStringChars(str));
 }
 
 static nsIScriptContext *
 GetScriptContext(JSContext *cx)
 {
     return GetScriptContextFromJSContext(cx);
 }
 
 inline void SetPendingException(JSContext *cx, const char *aMsg)
 {
+    JSAutoRequest ar(cx);
     JSString *str = JS_NewStringCopyZ(cx, aMsg);
     if (str)
         JS_SetPendingException(cx, STRING_TO_JSVAL(str));
 }
 
 inline void SetPendingException(JSContext *cx, const PRUnichar *aMsg)
 {
+    JSAutoRequest ar(cx);
     JSString *str = JS_NewUCStringCopyZ(cx,
                         NS_REINTERPRET_CAST(const jschar*, aMsg));
     if (str)
         JS_SetPendingException(cx, STRING_TO_JSVAL(str));
 }
 
 // DomainPolicy members
 #ifdef DEBUG_CAPS_DomainPolicyLifeCycle
@@ -506,16 +509,18 @@ nsScriptSecurityManager::CheckConnect(JS
         cx = GetCurrentJSContext();
         if (!cx)
             return NS_OK; // No JS context, so allow the load
     }
 
     nsresult rv = CheckLoadURIFromScript(cx, aTargetURI);
     if (NS_FAILED(rv)) return rv;
 
+    JSAutoRequest ar(cx);
+
     JSString* propertyName = ::JS_InternString(cx, aPropertyName);
     if (!propertyName)
         return NS_ERROR_OUT_OF_MEMORY;
 
     return CheckPropertyAccessImpl(nsIXPCSecurityManager::ACCESS_CALL_METHOD, nsnull,
                                    cx, nsnull, nsnull, aTargetURI,
                                    nsnull, aClassName, STRING_TO_JSVAL(propertyName), nsnull);
 }
@@ -2742,16 +2747,18 @@ nsScriptSecurityManager::CheckComponentP
     nsCAutoString cid(NS_LITERAL_CSTRING("CID") +
                       Substring(cidTemp, 1, cidTemp.Length() - 2));
     ToUpperCase(cid);
 
 #ifdef DEBUG_CAPS_CheckComponentPermissions
     printf("### CheckComponentPermissions(ClassID.%s) ",cid.get());
 #endif
 
+    JSAutoRequest ar(cx);
+
     // Look up the policy for this class.
     // while this isn't a property we'll treat it as such, using ACCESS_CALL_METHOD
     jsval cidVal = STRING_TO_JSVAL(::JS_InternString(cx, cid.get()));
 
     SecurityLevel securityLevel;
     rv = LookupPolicy(subjectPrincipal, "ClassID", cidVal,
                       nsIXPCSecurityManager::ACCESS_CALL_METHOD, 
                       nsnull, &securityLevel);
@@ -3365,16 +3372,18 @@ nsScriptSecurityManager::InitDomainPolic
         }
 
         // Get the property name
         start = end + 1;
         end = PL_strchr(start, '.');
         if (end)
             *end = '\0';
 
+        JSAutoRequest ar(cx);
+
         JSString* propertyKey = ::JS_InternString(cx, start);
         if (!propertyKey)
             return NS_ERROR_OUT_OF_MEMORY;
 
         // Store this property in the class policy
         const void* ppkey =
           NS_REINTERPRET_CAST(const void*, STRING_TO_JSVAL(propertyKey));
         PropertyPolicy* ppolicy = 
Index: caps/src/nsSecurityManagerFactory.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsSecurityManagerFactory.cpp,v
retrieving revision 1.41
diff -U8 -p -r1.41 nsSecurityManagerFactory.cpp
--- caps/src/nsSecurityManagerFactory.cpp	22 Jul 2005 19:05:40 -0000	1.41
+++ caps/src/nsSecurityManagerFactory.cpp	13 Jul 2006 18:25:47 -0000
@@ -289,16 +289,17 @@ nsSecurityNameSet::InitializeNameSet(nsI
     JSObject *global = JS_GetGlobalObject(cx);
 
     /*
      * Find Object.prototype's class by walking up the global object's
      * prototype chain.
      */
     JSObject *obj = global;
     JSObject *proto;
+    JSAutoRequest ar(cx);
     while ((proto = JS_GetPrototype(cx, obj)) != nsnull)
         obj = proto;
     JSClass *objectClass = JS_GetClass(cx, obj);
 
     jsval v;
     if (!JS_GetProperty(cx, global, "netscape", &v))
         return NS_ERROR_FAILURE;
     JSObject *securityObj;
Index: content/base/src/nsScriptLoader.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsScriptLoader.cpp,v
retrieving revision 1.74.2.4
diff -U8 -p -r1.74.2.4 nsScriptLoader.cpp
--- content/base/src/nsScriptLoader.cpp	7 Jul 2006 02:12:00 -0000	1.74.2.4
+++ content/base/src/nsScriptLoader.cpp	13 Jul 2006 18:25:48 -0000
@@ -769,16 +769,18 @@ nsScriptLoader::EvaluateScript(nsScriptL
   PRBool isUndefined;
   rv = context->EvaluateString(aScript, globalObject->GetGlobalJSObject(),
                                principal, url.get(), aRequest->mLineNo,
                                aRequest->mJSVersion, nsnull, &isUndefined);
 
   // Put the old script back in case it wants to do anything else.
   mCurrentScript = oldCurrent;
 
+  JSAutoRequest ar(cx);
+
   ::JS_ReportPendingException(cx);
   if (changed) {
     ::JS_SetOptions(cx, options);
   }
 
   context->SetProcessingScriptTag(oldProcessingScriptTag);
 
   nsCOMPtr<nsIXPCNativeCallContext> ncc;
Index: content/base/src/nsXMLHttpRequest.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsXMLHttpRequest.cpp,v
retrieving revision 1.156.2.3
diff -U8 -p -r1.156.2.3 nsXMLHttpRequest.cpp
--- content/base/src/nsXMLHttpRequest.cpp	15 Jun 2006 03:15:45 -0000	1.156.2.3
+++ content/base/src/nsXMLHttpRequest.cpp	13 Jul 2006 18:25:48 -0000
@@ -1039,16 +1039,17 @@ nsXMLHttpRequest::Open(const nsACString&
     if (NS_FAILED(rv)) return rv;
     if (crossSiteAccessEnabled) {
       mState |= XML_HTTP_REQUEST_XSITEENABLED;
     } else {
       mState &= ~XML_HTTP_REQUEST_XSITEENABLED;
     }
 
     if (argc > 2) {
+      JSAutoRequest ar(cx);
       JSBool asyncBool;
       ::JS_ValueToBoolean(cx, argv[2], &asyncBool);
       async = (PRBool)asyncBool;
 
       if (argc > 3 && !JSVAL_IS_NULL(argv[3]) && !JSVAL_IS_VOID(argv[3])) {
         JSString* userStr = ::JS_ValueToString(cx, argv[3]);
 
         if (userStr) {
Index: content/events/src/nsEventListenerManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/events/src/nsEventListenerManager.cpp,v
retrieving revision 1.206.2.8
diff -U8 -p -r1.206.2.8 nsEventListenerManager.cpp
--- content/events/src/nsEventListenerManager.cpp	15 Jun 2006 03:15:46 -0000	1.206.2.8
+++ content/events/src/nsEventListenerManager.cpp	13 Jul 2006 18:25:49 -0000
@@ -1423,16 +1423,17 @@ nsEventListenerManager::RegisterScriptEv
 
   JSObject *jsobj = nsnull;
 
   rv = holder->GetJSObject(&jsobj);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (cx) {
     if (sAddListenerID == JSVAL_VOID) {
+      JSAutoRequest ar(cx);
       sAddListenerID =
         STRING_TO_JSVAL(::JS_InternString(cx, "addEventListener"));
     }
 
     rv = nsContentUtils::GetSecurityManager()->
       CheckPropertyAccess(cx, jsobj,
                           "EventTarget",
                           sAddListenerID,
Index: content/html/document/src/nsHTMLDocument.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/html/document/src/nsHTMLDocument.cpp,v
retrieving revision 3.615.2.21
diff -U8 -p -r3.615.2.21 nsHTMLDocument.cpp
--- content/html/document/src/nsHTMLDocument.cpp	7 Jul 2006 01:42:40 -0000	3.615.2.21
+++ content/html/document/src/nsHTMLDocument.cpp	13 Jul 2006 18:25:51 -0000
@@ -2343,30 +2343,34 @@ nsHTMLDocument::ScriptWriteCommon(PRBool
     rv = ncc->GetJSContext(&cx);
     NS_ENSURE_SUCCESS(rv, rv);
 
     jsval *argv = nsnull;
     ncc->GetArgvPtr(&argv);
     NS_ENSURE_TRUE(argv, NS_ERROR_UNEXPECTED);
 
     if (argc == 1) {
+      JSAutoRequest ar(cx);
+
       JSString *jsstr = JS_ValueToString(cx, argv[0]);
       NS_ENSURE_TRUE(jsstr, NS_ERROR_OUT_OF_MEMORY);
 
       nsDependentString str(NS_REINTERPRET_CAST(const PRUnichar *,
                                               ::JS_GetStringChars(jsstr)),
                           ::JS_GetStringLength(jsstr));
 
       return WriteCommon(str, aNewlineTerminate);
     }
 
     if (argc > 1) {
       nsAutoString string_buffer;
 
       for (i = 0; i < argc; ++i) {
+        JSAutoRequest ar(cx);
+
         JSString *str = JS_ValueToString(cx, argv[i]);
         NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
 
         string_buffer.Append(NS_REINTERPRET_CAST(const PRUnichar *,
                                                  ::JS_GetStringChars(str)),
                              ::JS_GetStringLength(str));
       }
 
Index: content/xbl/src/nsXBLBinding.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xbl/src/nsXBLBinding.cpp,v
retrieving revision 1.199.2.2
diff -U8 -p -r1.199.2.2 nsXBLBinding.cpp
--- content/xbl/src/nsXBLBinding.cpp	15 Jun 2006 03:15:46 -0000	1.199.2.2
+++ content/xbl/src/nsXBLBinding.cpp	13 Jul 2006 18:25:51 -0000
@@ -996,16 +996,17 @@ nsXBLBinding::DoInitJSClass(JSContext *c
                             void **aClassObject)
 {
   // First ensure our JS class is initialized.
   jsval val;
   JSObject* proto;
 
   nsCAutoString className(aClassName);
   JSObject* parent_proto = nsnull;  // If we have an "obj" we can set this
+  JSAutoRequest ar(cx);
   if (obj) {
     // Retrieve the current prototype of obj.
     parent_proto = ::JS_GetPrototype(cx, obj);
     if (parent_proto) {
       // We need to create a unique classname based on aClassName and
       // parent_proto.  Append a space (an invalid URI character) to ensure that
       // we don't have accidental collisions with the case when parent_proto is
       // null and aClassName ends in some bizarre numbers (yeah, it's unlikely).
Index: content/xbl/src/nsXBLDocumentInfo.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xbl/src/nsXBLDocumentInfo.cpp,v
retrieving revision 1.29.2.6
diff -U8 -p -r1.29.2.6 nsXBLDocumentInfo.cpp
--- content/xbl/src/nsXBLDocumentInfo.cpp	23 Oct 2005 09:13:04 -0000	1.29.2.6
+++ content/xbl/src/nsXBLDocumentInfo.cpp	13 Jul 2006 18:25:52 -0000
@@ -261,16 +261,18 @@ nsXBLDocGlobalObject::GetContext()
     NS_ENSURE_TRUE(factory, nsnull);
 
     nsresult rv =  factory->NewScriptContext(nsnull, getter_AddRefs(mScriptContext));
     if (NS_FAILED(rv))
         return nsnull;
 
     JSContext *cx = (JSContext *)mScriptContext->GetNativeContext();
 
+    JSAutoRequest ar(cx);
+
     JS_SetErrorReporter(cx, XBL_ProtoErrorReporter);
     mJSObject = ::JS_NewObject(cx, &gSharedGlobalClass, nsnull, nsnull);
     if (!mJSObject)
         return nsnull;
 
     ::JS_SetGlobalObject(cx, mJSObject);
 
     // Add an owning reference from JS back to us. This'll be
Index: content/xbl/src/nsXBLProtoImplField.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xbl/src/nsXBLProtoImplField.cpp,v
retrieving revision 1.12.26.2
diff -U8 -p -r1.12.26.2 nsXBLProtoImplField.cpp
--- content/xbl/src/nsXBLProtoImplField.cpp	26 Sep 2005 13:30:07 -0000	1.12.26.2
+++ content/xbl/src/nsXBLProtoImplField.cpp	13 Jul 2006 18:25:52 -0000
@@ -133,18 +133,19 @@ nsXBLProtoImplField::InstallMember(nsISc
                                         mLineNumber, nsnull,
                                         (void*) &result, &undefined);
   if (NS_FAILED(rv))
     return rv;
 
   if (!undefined) {
     // Define the evaluated result as a JS property
     nsDependentString name(mName);
+    JSAutoRequest ar(cx);
     if (!::JS_DefineUCProperty(cx, scriptObject, NS_REINTERPRET_CAST(const jschar*, mName), 
-                               name.Length(), result, nsnull, nsnull, mJSAttributes))
+                                 name.Length(), result, nsnull, nsnull, mJSAttributes))
       return NS_ERROR_OUT_OF_MEMORY;
   }
   
   return NS_OK;
 }
 
 nsresult 
 nsXBLProtoImplField::CompileMember(nsIScriptContext* aContext, const nsCString& aClassStr,
Index: content/xbl/src/nsXBLProtoImplMethod.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xbl/src/nsXBLProtoImplMethod.cpp,v
retrieving revision 1.22.2.4
diff -U8 -p -r1.22.2.4 nsXBLProtoImplMethod.cpp
--- content/xbl/src/nsXBLProtoImplMethod.cpp	1 Jun 2006 21:51:48 -0000	1.22.2.4
+++ content/xbl/src/nsXBLProtoImplMethod.cpp	13 Jul 2006 18:25:52 -0000
@@ -151,16 +151,17 @@ nsXBLProtoImplMethod::InstallMember(nsIS
     return NS_ERROR_FAILURE;
 
   JSObject * targetClassObject = (JSObject *) aTargetClassObject;
   JSObject * globalObject = sgo->GetGlobalJSObject();
 
   // now we want to reevaluate our property using aContext and the script object for this window...
   if (mJSMethodObject && targetClassObject) {
     nsDependentString name(mName);
+    JSAutoRequest ar(cx);
     JSObject * method = ::JS_CloneFunctionObject(cx, mJSMethodObject, globalObject);
     if (!method) {
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
     nsresult rv;
     nsAutoGCRoot root(&method, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
@@ -315,24 +316,24 @@ nsXBLProtoImplAnonymousMethod::Execute(n
                                             NS_GET_IID(nsISupports),
                                             getter_AddRefs(wrapper));
   NS_ENSURE_SUCCESS(rv, rv);
 
   JSObject* thisObject;
   rv = wrapper->GetJSObject(&thisObject);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  JSAutoRequest ar(cx);
+
   // Clone the function object, using thisObject as the parent so "this" is in
   // the scope chain of the resulting function (for backwards compat to the
   // days when this was an event handler).
-  JSObject* method = ::JS_CloneFunctionObject(cx, mJSMethodObject,
-                                              thisObject);
-  if (!method) {
+  JSObject* method = ::JS_CloneFunctionObject(cx, mJSMethodObject, thisObject);
+  if (!method)
     return NS_ERROR_OUT_OF_MEMORY;
-  }
 
   // Now call the method
 
   // Use nsCxPusher to make sure we call ScriptEvaluated when we're done.
   nsCxPusher pusher(aBoundElement);
 
   // Check whether it's OK to call the method.
   rv = nsContentUtils::GetSecurityManager()->CheckFunctionAccess(cx, method, thisObject);
Index: content/xbl/src/nsXBLProtoImplProperty.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xbl/src/nsXBLProtoImplProperty.cpp,v
retrieving revision 1.19.2.4
diff -U8 -p -r1.19.2.4 nsXBLProtoImplProperty.cpp
--- content/xbl/src/nsXBLProtoImplProperty.cpp	10 Mar 2006 18:39:43 -0000	1.19.2.4
+++ content/xbl/src/nsXBLProtoImplProperty.cpp	13 Jul 2006 18:25:52 -0000
@@ -189,16 +189,17 @@ nsXBLProtoImplProperty::InstallMember(ns
     return NS_ERROR_FAILURE;
 
   JSObject * targetClassObject = (JSObject *) aTargetClassObject;
   JSObject * globalObject = sgo->GetGlobalJSObject();
 
   // now we want to reevaluate our property using aContext and the script object for this window...
   if ((mJSGetterObject || mJSSetterObject) && targetClassObject) {
     JSObject * getter = nsnull;
+    JSAutoRequest ar(cx);
     if (mJSGetterObject)
       if (!(getter = ::JS_CloneFunctionObject(cx, mJSGetterObject, globalObject)))
         return NS_ERROR_OUT_OF_MEMORY;
 
     nsresult rv;
     nsAutoGCRoot getterroot(&getter, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     
Index: content/xul/content/src/nsXULElement.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xul/content/src/nsXULElement.cpp,v
retrieving revision 1.578.2.12
diff -U8 -p -r1.578.2.12 nsXULElement.cpp
--- content/xul/content/src/nsXULElement.cpp	23 Jun 2006 00:13:50 -0000	1.578.2.12
+++ content/xul/content/src/nsXULElement.cpp	13 Jul 2006 18:25:54 -0000
@@ -3328,16 +3328,17 @@ nsXULPrototypeScript::Serialize(nsIObjec
                                         aContext->GetNativeContext());
     JSXDRState *xdr = ::JS_XDRNewMem(cx, JSXDR_ENCODE);
     if (! xdr)
         return NS_ERROR_OUT_OF_MEMORY;
     xdr->userdata = (void*) aStream;
 
     JSScript *script = NS_REINTERPRET_CAST(JSScript*,
                                            ::JS_GetPrivate(cx, mJSObject));
+    JSAutoRequest ar(cx);
     if (! ::JS_XDRScript(xdr, &script)) {
         rv = NS_ERROR_FAILURE;  // likely to be a principals serialization error
     } else {
         // Get the encoded JSXDRState data and write it.  The JSXDRState owns
         // this buffer memory and will free it beneath ::JS_XDRDestroy.
         //
         // If an XPCOM object needs to be written in the midst of the JS XDR
         // encoding process, the C++ code called back from the JS engine (e.g.,
@@ -3463,16 +3464,17 @@ nsXULPrototypeScript::Deserialize(nsIObj
         JSContext* cx = NS_REINTERPRET_CAST(JSContext*,
                                             aContext->GetNativeContext());
 
         JSXDRState *xdr = ::JS_XDRNewMem(cx, JSXDR_DECODE);
         if (! xdr) {
             rv = NS_ERROR_OUT_OF_MEMORY;
         } else {
             xdr->userdata = (void*) aStream;
+            JSAutoRequest ar(cx);
             ::JS_XDRMemSetData(xdr, data, size);
 
             JSScript *script = nsnull;
             if (! ::JS_XDRScript(xdr, &script)) {
                 rv = NS_ERROR_FAILURE;  // principals deserialization error?
             } else {
                 mJSObject = ::JS_NewScriptObject(cx, script);
                 if (! mJSObject) {
Index: content/xul/document/src/nsXULPrototypeDocument.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xul/document/src/nsXULPrototypeDocument.cpp,v
retrieving revision 1.64.2.3
diff -U8 -p -r1.64.2.3 nsXULPrototypeDocument.cpp
--- content/xul/document/src/nsXULPrototypeDocument.cpp	12 Oct 2005 20:19:49 -0000	1.64.2.3
+++ content/xul/document/src/nsXULPrototypeDocument.cpp	13 Jul 2006 18:25:54 -0000
@@ -824,16 +824,18 @@ nsXULPDGlobalObject::GetContext()
 
         nsresult rv =
             factory->NewScriptContext(nsnull, getter_AddRefs(mScriptContext));
         if (NS_FAILED(rv))
             return nsnull;
 
         JSContext *cx = (JSContext *)mScriptContext->GetNativeContext();
 
+        JSAutoRequest ar(cx);
+
         mJSObject = ::JS_NewObject(cx, &gSharedGlobalClass, nsnull, nsnull);
         if (!mJSObject)
             return nsnull;
 
         ::JS_SetGlobalObject(cx, mJSObject);
 
         // Add an owning reference from JS back to us. This'll be
         // released when the JSObject is finalized.
Index: dom/src/base/nsDOMClassInfo.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsDOMClassInfo.cpp,v
retrieving revision 1.292.2.44
diff -U8 -p -r1.292.2.44 nsDOMClassInfo.cpp
--- dom/src/base/nsDOMClassInfo.cpp	7 Jul 2006 02:12:00 -0000	1.292.2.44
+++ dom/src/base/nsDOMClassInfo.cpp	13 Jul 2006 18:25:59 -0000
@@ -1313,16 +1313,18 @@ nsresult
 nsDOMClassInfo::DefineStaticJSVals(JSContext *cx)
 {
 #define SET_JSVAL_TO_STRING(_val, _cx, _str)                                  \
   _val = GetInternedJSVal(_cx, _str);                                         \
   if (!JSVAL_IS_STRING(_val)) {                                               \
     return NS_ERROR_OUT_OF_MEMORY;                                            \
   }
 
+  JSAutoRequest ar(cx);
+
   SET_JSVAL_TO_STRING(sTop_id,             cx, "top");
   SET_JSVAL_TO_STRING(sParent_id,          cx, "parent");
   SET_JSVAL_TO_STRING(sScrollbars_id,      cx, "scrollbars");
   SET_JSVAL_TO_STRING(sLocation_id,        cx, "location");
   SET_JSVAL_TO_STRING(sComponents_id,      cx, "Components");
   SET_JSVAL_TO_STRING(sConstructor_id,     cx, "constructor");
   SET_JSVAL_TO_STRING(s_content_id,        cx, "_content");
   SET_JSVAL_TO_STRING(sContent_id,         cx, "content");
@@ -1422,16 +1424,18 @@ nsDOMClassInfo::WrapNative(JSContext *cx
 
   return rv;
 }
 
 // static
 nsresult
 nsDOMClassInfo::ThrowJSException(JSContext *cx, nsresult aResult)
 {
+  JSAutoRequest ar(cx);
+
   do {
     nsCOMPtr<nsIExceptionService> xs =
       do_GetService(NS_EXCEPTIONSERVICE_CONTRACTID);
     if (!xs) {
       break;
     }
 
     nsCOMPtr<nsIExceptionManager> xm;
@@ -3026,16 +3030,18 @@ PRInt32
 nsDOMClassInfo::GetArrayIndexFromId(JSContext *cx, jsval id, PRBool *aIsNumber)
 {
   jsdouble array_index;
 
   if (aIsNumber) {
     *aIsNumber = PR_FALSE;
   }
 
+  JSAutoRequest ar(cx);
+
   if (!::JS_ValueToNumber(cx, id, &array_index)) {
     return -1;
   }
 
   jsint i = -1;
 
   if (!JSDOUBLE_IS_INT(array_index, i)) {
     return -1;
@@ -3217,16 +3223,18 @@ nsDOMClassInfo::PostCreate(nsIXPConnectW
                  "Multiple wrappers created for global object!");
   }
 #endif
 
   JSObject *proto = nsnull;
 
   wrapper->GetJSObjectPrototype(&proto);
 
+  JSAutoRequest ar(cx);
+
   JSObject *proto_proto = ::JS_GetPrototype(cx, proto);
 
   JSClass *proto_proto_class = JS_GET_CLASS(cx, proto_proto);
 
   if (proto_proto_class != sObjectClass) {
     // We've just wrapped an object of a type that has been wrapped on
     // this scope already so the prototype of the xpcwrapped native's
     // prototype is already set up.
@@ -3346,16 +3354,17 @@ nsDOMClassInfo::NewEnumerate(nsIXPConnec
 
 nsresult
 nsDOMClassInfo::ResolveConstructor(JSContext *cx, JSObject *obj,
                                    JSObject **objp)
 {
   JSObject *global = GetGlobalJSObject(cx, obj);
 
   jsval val;
+  JSAutoRequest ar(cx);
   if (!::JS_GetProperty(cx, global, mData->mName, &val)) {
     return NS_ERROR_UNEXPECTED;
   }
 
   if (!JSVAL_IS_PRIMITIVE(val)) {
     // If val is not an (non-null) object there either is no
     // constructor for this class, or someone messed with
     // window.classname, just fall through and let the JS engine
@@ -3823,16 +3832,17 @@ NS_IMETHODIMP
 nsWindowSH::PreCreate(nsISupports *nativeObj, JSContext *cx,
                       JSObject *globalObj, JSObject **parentObj)
 {
   // Since this is one of the first calls we'll get from XPConnect,
   // grab the pointer to the Object class so we'll have it later on.
 
   if (!sObjectClass) {
     JSObject *obj, *proto = globalObj;
+    JSAutoRequest ar(cx);
 
     do {
       obj = proto;
       proto = ::JS_GetPrototype(cx, obj);
     } while (proto);
 
     sObjectClass = JS_GET_CLASS(cx, obj);
   }
@@ -4002,16 +4012,18 @@ nsWindowSH::GlobalScopePolluterNewResolv
 }
 
 // static
 void
 nsWindowSH::InvalidateGlobalScopePolluter(JSContext *cx, JSObject *obj)
 {
   JSObject *proto;
 
+  JSAutoRequest ar(cx);
+
   while ((proto = ::JS_GetPrototype(cx, obj))) {
     if (JS_GET_CLASS(cx, proto) == &sGlobalScopePolluterClass) {
       nsIHTMLDocument *doc = (nsIHTMLDocument *)::JS_GetPrivate(cx, proto);
 
       NS_IF_RELEASE(doc);
 
       ::JS_SetPrivate(cx, proto, nsnull);
 
@@ -4032,16 +4044,18 @@ nsWindowSH::InstallGlobalScopePolluter(J
                                        nsIHTMLDocument *doc)
 {
   // If global scope pollution is disabled, or if our document is not
   // a HTML document, do nothing
   if (sDisableGlobalScopePollutionSupport || !doc) {
     return NS_OK;
   }
 
+  JSAutoRequest ar(cx);
+
   JSObject *gsp = ::JS_NewObject(cx, &sGlobalScopePolluterClass, nsnull, obj);
   if (!gsp) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   JSObject *o = obj, *proto;
 
   // Find the place in the prototype chain where we want this global
@@ -4094,28 +4108,33 @@ GetChildFrame(nsGlobalWindow *win, jsval
 }
 
 NS_IMETHODIMP
 nsWindowSH::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                         JSObject *obj, jsval id, jsval *vp, PRBool *_retval)
 {
   nsGlobalWindow *win = nsGlobalWindow::FromWrapper(wrapper);
 
+  JSAutoRequest ar(cx);
+
 #ifdef DEBUG_SH_FORWARDING
   {
-    nsDependentJSString str(::JS_ValueToString(cx, id));
+    jschar *jsstr = ::JS_ValueToString(cx, id);
+    if (jsstr) {
+      nsDependentJSString str(jsstr);
 
-    if (win->IsInnerWindow()) {
+      if (win->IsInnerWindow()) {
 #ifdef DEBUG_PRINT_INNER
-      printf("Property '%s' get on inner window %p\n",
-             NS_ConvertUTF16toUTF8(str).get(), (void *)win);
+        printf("Property '%s' get on inner window %p\n",
+              NS_ConvertUTF16toUTF8(str).get(), (void *)win);
 #endif
-    } else {
-      printf("Property '%s' get on outer window %p\n",
-             NS_ConvertUTF16toUTF8(str).get(), (void *)win);
+      } else {
+        printf("Property '%s' get on outer window %p\n",
+              NS_ConvertUTF16toUTF8(str).get(), (void *)win);
+      }
     }
   }
 #endif
 
   if (win->IsOuterWindow() && !ObjectIsNativeWrapper(cx, obj)) {
     // XXXjst: Do security checks here when we remove the security
     // checks on the inner window.
 
@@ -4284,16 +4303,18 @@ nsWindowSH::SetProperty(nsIXPConnectWrap
 
       *_retval = PR_FALSE;
 
       return NS_OK;
     }
   }
 
   if (id == sLocation_id) {
+    JSAutoRequest ar(cx);
+
     JSString *val = ::JS_ValueToString(cx, *vp);
     NS_ENSURE_TRUE(val, NS_ERROR_UNEXPECTED);
 
     nsCOMPtr<nsIDOMWindowInternal> window(do_QueryWrappedNative(wrapper));
     NS_ENSURE_TRUE(window, NS_ERROR_UNEXPECTED);
 
     nsCOMPtr<nsIDOMLocation> location;
     nsresult rv = window->GetLocation(getter_AddRefs(location));
@@ -6010,16 +6031,18 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
         // this domain. Set the sDoSecurityCheckInAddProperty flag to
         // false (and set it to true immediagtely when we're done) to
         // tell nsWindowSH::AddProperty() that defining this new
         // property is 'ok' in this case, even if the call comes from
         // a different context.
 
         sDoSecurityCheckInAddProperty = PR_FALSE;
 
+        JSAutoRequest ar(cx);
+
         PRBool ok = ::JS_DefineUCProperty(cx, obj, chars,
                                           ::JS_GetStringLength(str), v, nsnull,
                                           nsnull, 0);
 
         sDoSecurityCheckInAddProperty = PR_TRUE;
 
         if (!ok) {
           return NS_ERROR_FAILURE;
@@ -6031,16 +6054,18 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
       }
     }
   }
 
   // It is not worth calling GlobalResolve() if we are resolving
   // for assignment, since only read-write properties get dealt
   // with there.
   if (!(flags & JSRESOLVE_ASSIGNING)) {
+    JSAutoRequest ar(cx);
+
     // Call GlobalResolve() after we call FindChildWithName() so
     // that named child frames will override external properties
     // which have been registered with the script namespace manager.
 
     JSBool did_resolve = JS_FALSE;
     rv = GlobalResolve(win, cx, obj, str, flags, &did_resolve);
     NS_ENSURE_SUCCESS(rv, rv);
 
@@ -6054,16 +6079,18 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
 
   if (id == s_content_id) {
     // Map window._content to window.content for backwards
     // compatibility, this should spit out an message on the JS
     // console.
 
     JSObject *windowObj = win->GetGlobalJSObject();
 
+    JSAutoRequest ar(cx);
+
     JSFunction *fun = ::JS_NewFunction(cx, ContentWindowGetter, 0, 0,
                                        windowObj, "_content");
     if (!fun) {
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
     JSObject *funObj = ::JS_GetFunctionObject(fun);
 
@@ -6112,16 +6139,18 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     rv = WrapNative(cx, scope, location, NS_GET_IID(nsIDOMLocation), &v,
                     getter_AddRefs(holder));
     NS_ENSURE_SUCCESS(rv, rv);
 
     PRBool doSecurityCheckInAddProperty = sDoSecurityCheckInAddProperty;
     sDoSecurityCheckInAddProperty = PR_FALSE;
 
+    JSAutoRequest ar(cx);
+
     JSBool ok = ::JS_DefineUCProperty(cx, obj, ::JS_GetStringChars(str),
                                       ::JS_GetStringLength(str), v, nsnull,
                                       nsnull, JSPROP_ENUMERATE);
 
     sDoSecurityCheckInAddProperty = doSecurityCheckInAddProperty;
 
     if (!ok) {
       return NS_ERROR_FAILURE;
@@ -6136,16 +6165,18 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
     if (IsReadonlyReplaceable(id) ||
         (!(flags & JSRESOLVE_QUALIFIED) && IsWritableReplaceable(id))) {
       // A readonly "replaceable" property is being set, or a
       // readwrite "replaceable" property is being set w/o being
       // fully qualified. Define the property on obj with the value
       // undefined to override the predefined property. This is done
       // for compatibility with other browsers.
 
+      JSAutoRequest ar(cx);
+
       if (!::JS_DefineUCProperty(cx, obj, ::JS_GetStringChars(str),
                                  ::JS_GetStringLength(str),
                                  JSVAL_VOID, nsnull, nsnull,
                                  JSPROP_ENUMERATE)) {
         return NS_ERROR_FAILURE;
       }
 
       *objp = obj;
@@ -6159,16 +6190,18 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
       NS_ENSURE_SUCCESS(rv, rv);
 
       jsval v;
       nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
       rv = WrapNative(cx, obj, navigator, NS_GET_IID(nsIDOMNavigator), &v,
                       getter_AddRefs(holder));
       NS_ENSURE_SUCCESS(rv, rv);
 
+      JSAutoRequest ar(cx);
+
       if (!::JS_DefineUCProperty(cx, obj, ::JS_GetStringChars(str),
                                  ::JS_GetStringLength(str), v, nsnull,
                                  nsnull, JSPROP_ENUMERATE)) {
         return NS_ERROR_FAILURE;
       }
 
       *objp = obj;
 
@@ -6193,24 +6226,25 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
       return NS_OK;
     }
 
     if (id == sWindow_id) {
       // window should *always* be the outer window object.
       win = win->GetOuterWindowInternal();
       NS_ENSURE_TRUE(win, NS_ERROR_NOT_AVAILABLE);
 
+      JSAutoRequest ar(cx);
+
       if (!::JS_DefineUCProperty(cx, obj, ::JS_GetStringChars(str),
-                                 ::JS_GetStringLength(str),
-                                 OBJECT_TO_JSVAL(win->GetGlobalJSObject()),
-                                 nsnull, nsnull,
-                                 JSPROP_READONLY | JSPROP_ENUMERATE)) {
+                                ::JS_GetStringLength(str),
+                                OBJECT_TO_JSVAL(win->GetGlobalJSObject()),
+                                nsnull, nsnull,
+                                JSPROP_READONLY | JSPROP_ENUMERATE)) {
         return NS_ERROR_FAILURE;
       }
-
       *objp = obj;
 
       return NS_OK;
     }
 
     // Do a security check when resolving heretofore unknown string
     // properties on window objects to prevent detection of a
     // property's existence across origins. We only do this when
@@ -6865,16 +6899,18 @@ nsEventReceiverSH::NewResolve(nsIXPConne
                                           _retval);
 }
 
 NS_IMETHODIMP
 nsEventReceiverSH::SetProperty(nsIXPConnectWrappedNative *wrapper,
                                JSContext *cx, JSObject *obj, jsval id,
                                jsval *vp, PRBool *_retval)
 {
+  JSAutoRequest ar(cx);
+
   if ((::JS_TypeOfValue(cx, *vp) != JSTYPE_FUNCTION && !JSVAL_IS_NULL(*vp)) ||
       !JSVAL_IS_STRING(id) || id == sAddEventListener_id) {
     return NS_OK;
   }
 
   PRBool did_compile; // Ignored here.
 
   return RegisterCompileHandler(wrapper, cx, obj, id, PR_FALSE,
@@ -7040,16 +7076,17 @@ nsGenericArraySH::Enumerate(nsIXPConnect
   if (sCurrentlyEnumerating) {
     // Don't recurse to death.
     return NS_OK;
   }
 
   sCurrentlyEnumerating = PR_TRUE;
 
   jsval len_val;
+  JSAutoRequest ar(cx);
   JSBool ok = ::JS_GetProperty(cx, obj, "length", &len_val);
 
   if (ok && JSVAL_IS_INT(len_val)) {
     PRInt32 length = JSVAL_TO_INT(len_val);
     char buf[11];
 
     for (PRInt32 i = 0; ok && i < length; ++i) {
       PR_snprintf(buf, sizeof(buf), "%d", i);
@@ -7416,16 +7453,18 @@ nsDocumentSH::NewResolve(nsIXPConnectWra
     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     rv = WrapNative(cx, obj, location, NS_GET_IID(nsIDOMLocation), &v,
                     getter_AddRefs(holder));
     NS_ENSURE_SUCCESS(rv, rv);
 
     PRBool doSecurityCheckInAddProperty = sDoSecurityCheckInAddProperty;
     sDoSecurityCheckInAddProperty = PR_FALSE;
 
+    JSAutoRequest ar(cx);
+
     JSString *str = JSVAL_TO_STRING(id);
     JSBool ok = ::JS_DefineUCProperty(cx, obj, ::JS_GetStringChars(str),
                                       ::JS_GetStringLength(str), v, nsnull,
                                       nsnull, JSPROP_ENUMERATE);
 
     sDoSecurityCheckInAddProperty = doSecurityCheckInAddProperty;
 
     if (!ok) {
@@ -7512,16 +7551,18 @@ nsDocumentSH::SetProperty(nsIXPConnectWr
     NS_ENSURE_TRUE(doc, NS_ERROR_UNEXPECTED);
 
     nsCOMPtr<nsIDOMLocation> location;
 
     nsresult rv = doc->GetLocation(getter_AddRefs(location));
     NS_ENSURE_SUCCESS(rv, rv);
 
     if (location) {
+      JSAutoRequest ar(cx);
+
       JSString *val = ::JS_ValueToString(cx, *vp);
       NS_ENSURE_TRUE(val, NS_ERROR_UNEXPECTED);
 
       rv = location->SetHref(nsDependentJSString(val));
       NS_ENSURE_SUCCESS(rv, rv);
 
       nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
       rv = WrapNative(cx, obj, location, NS_GET_IID(nsIDOMLocation), vp,
@@ -8167,16 +8208,19 @@ nsHTMLDocumentSH::NewResolve(nsIXPConnec
   // nsDocumentSH::NewResolve() does a security check that we'd kinda
   // want to do here too before doing anything else. But given that we
   // only define dynamic properties here before the call to
   // nsDocumentSH::NewResolve() we're ok, since once those properties
   // are accessed, we'll do the necessary security check.
 
   if (!(flags & JSRESOLVE_ASSIGNING)) {
     // For native wrappers, do not resolve random names on document
+
+    JSAutoRequest ar(cx);
+
     if (!ObjectIsNativeWrapper(cx, obj)) {
       nsCOMPtr<nsISupports> result;
 
       nsresult rv = ResolveImpl(cx, wrapper, id, getter_AddRefs(result));
       NS_ENSURE_SUCCESS(rv, rv);
 
       if (result) {
         JSString *str = JS_ValueToString(cx, id);
@@ -8289,16 +8333,18 @@ nsHTMLDocumentSH::GetProperty(nsIXPConne
 
   // For native wrappers, do not get random names on document
   if (ObjectIsNativeWrapper(cx, obj)) {
     return rv;
   }
   
   nsCOMPtr<nsISupports> result;
 
+  JSAutoRequest ar(cx);
+
   rv = ResolveImpl(cx, wrapper, id, getter_AddRefs(result));
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (result) {
     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     rv = WrapNative(cx, obj, result, NS_GET_IID(nsISupports), vp,
                     getter_AddRefs(holder));
     if (NS_SUCCEEDED(rv)) {
@@ -8344,16 +8390,17 @@ nsHTMLElementSH::ScrollIntoView(JSContex
 
 NS_IMETHODIMP
 nsHTMLElementSH::NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
                             JSObject *obj, jsval id, PRUint32 flags,
                             JSObject **objp, PRBool *_retval)
 {
   if (id == sScrollIntoView_id && !(JSRESOLVE_ASSIGNING & flags)) {
     JSString *str = JSVAL_TO_STRING(id);
+    JSAutoRequest ar(cx);
     JSFunction *cfnc =
       ::JS_DefineFunction(cx, obj, ::JS_GetStringBytes(str), ScrollIntoView,
                           0, 0);
 
     *objp = obj;
 
     return cfnc ? NS_OK : NS_ERROR_UNEXPECTED;
   }
@@ -8503,16 +8550,17 @@ nsHTMLFormElementSH::NewResolve(nsIXPCon
       !ObjectIsNativeWrapper(cx, obj)) {
     nsCOMPtr<nsIForm> form(do_QueryWrappedNative(wrapper));
     nsCOMPtr<nsISupports> result;
 
     JSString *str = JSVAL_TO_STRING(id);
     FindNamedItem(form, str, getter_AddRefs(result));
 
     if (result) {
+      JSAutoRequest ar(cx);
       *_retval = ::JS_DefineUCProperty(cx, obj, ::JS_GetStringChars(str),
                                        ::JS_GetStringLength(str),
                                        JSVAL_VOID, nsnull, nsnull, 0);
 
       *objp = obj;
 
       return *_retval ? NS_OK : NS_ERROR_FAILURE;
     }
@@ -8614,16 +8662,19 @@ nsHTMLFormElementSH::NewEnumerate(nsIXPC
         NS_ENSURE_TRUE(domElement, NS_ERROR_FAILURE);
 
         nsAutoString attr;
         domElement->GetAttribute(NS_LITERAL_STRING("name"), attr);
         if (attr.IsEmpty()) {
           // If name is not there, use index instead
           attr.AppendInt(index);
         }
+
+        JSAutoRequest ar(cx);
+
         JSString *jsname =
           JS_NewUCStringCopyN(cx, NS_REINTERPRET_CAST(const jschar *,
                                                       attr.get()),
                               attr.Length());
         NS_ENSURE_TRUE(jsname, NS_ERROR_OUT_OF_MEMORY);
 
         JS_ValueToId(cx, STRING_TO_JSVAL(jsname), idp);
 
@@ -8677,19 +8728,20 @@ nsHTMLSelectElementSH::GetProperty(nsIXP
   return rv;
 }
 
 // static
 nsresult
 nsHTMLSelectElementSH::SetOption(JSContext *cx, jsval *vp, PRUint32 aIndex,
                                  nsIDOMNSHTMLOptionCollection *aOptCollection)
 {
+  JSAutoRequest ar(cx);
+
   // vp must refer to an object
-  if (!JSVAL_IS_OBJECT(*vp) && !::JS_ConvertValue(cx, *vp, JSTYPE_OBJECT,
-                                                  vp)) {
+  if (!JSVAL_IS_OBJECT(*vp) && !::JS_ConvertValue(cx, *vp, JSTYPE_OBJECT, vp)) {
     return NS_ERROR_UNEXPECTED;
   }
 
   nsCOMPtr<nsIDOMHTMLOptionElement> new_option;
 
   if (!JSVAL_IS_NULL(*vp)) {
     nsCOMPtr<nsIXPConnectWrappedNative> new_wrapper;
     nsresult rv;
@@ -8791,16 +8843,18 @@ nsHTMLExternalObjSH::GetPluginInstance(n
 
 // Check if proto is already in obj's prototype chain.
 
 static PRBool
 IsObjInProtoChain(JSContext *cx, JSObject *obj, JSObject *proto)
 {
   JSObject *o = obj;
 
+  JSAutoRequest ar(cx);
+
   while (o) {
     JSObject *p = ::JS_GetPrototype(cx, o);
 
     if (p == proto) {
       return PR_TRUE;
     }
 
     o = p;
@@ -8859,16 +8913,18 @@ nsHTMLExternalObjSH::PostCreate(nsIXPCon
   // prototype's prototype to the scriptable plugin.
 
   JSObject *my_proto = nsnull;
 
   // Get 'this.__proto__'
   rv = wrapper->GetJSObjectPrototype(&my_proto);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  JSAutoRequest ar(cx);
+
   // Set 'this.__proto__' to pi
   if (!::JS_SetPrototype(cx, obj, pi_obj)) {
     return NS_ERROR_UNEXPECTED;
   }
 
   if (pi_proto && JS_GET_CLASS(cx, pi_proto) != sObjectClass) {
     // The plugin wrapper has a proto that's not Object.prototype, set
     // 'pi.__proto__.__proto__' to the original 'this.__proto__'
@@ -8937,16 +8993,18 @@ nsHTMLExternalObjSH::PostCreate(nsIXPCon
 }
 
 
 NS_IMETHODIMP
 nsHTMLExternalObjSH::GetProperty(nsIXPConnectWrappedNative *wrapper,
                                  JSContext *cx, JSObject *obj, jsval id,
                                  jsval *vp, PRBool *_retval)
 {
+  JSAutoRequest ar(cx);
+
   JSObject *pi_obj = ::JS_GetPrototype(cx, obj);
 
   const jschar *id_chars = nsnull;
   size_t id_length = 0;
 
   JSBool found = PR_FALSE;
 
   if (!ObjectIsNativeWrapper(cx, obj)) {
@@ -8979,16 +9037,18 @@ nsHTMLExternalObjSH::GetProperty(nsIXPCo
   return nsElementSH::GetProperty(wrapper, cx, obj, id, vp, _retval);
 }
 
 NS_IMETHODIMP
 nsHTMLExternalObjSH::SetProperty(nsIXPConnectWrappedNative *wrapper,
                                  JSContext *cx, JSObject *obj, jsval id,
                                  jsval *vp, PRBool *_retval)
 {
+  JSAutoRequest ar(cx);
+
   JSObject *pi_obj = ::JS_GetPrototype(cx, obj);
 
   const jschar *id_chars = nsnull;
   size_t id_length = 0;
 
   JSBool found = PR_FALSE;
 
   if (!ObjectIsNativeWrapper(cx, obj)) {
@@ -9044,16 +9104,17 @@ nsHTMLExternalObjSH::Call(nsIXPConnectWr
 
   if (!pi) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   // XPConnect passes us the XPConnect wrapper JSObject as obj, and
   // not the 'this' parameter that the JS engine passes in. Pass in
   // the real this parameter from JS (argv[-1]) here.
+  JSAutoRequest ar(cx);
   *_retval = ::JS_CallFunctionValue(cx, JSVAL_TO_OBJECT(argv[-1]),
                                     OBJECT_TO_JSVAL(pi_obj), argc, argv, vp);
 
   return NS_OK;
 }
 
 
 // HTMLAppletElement helper
@@ -9318,16 +9379,19 @@ nsHTMLOptionsCollectionSH::SetProperty(n
 NS_IMETHODIMP
 nsHTMLOptionsCollectionSH::NewResolve(nsIXPConnectWrappedNative *wrapper,
                                       JSContext *cx, JSObject *obj, 
                                       jsval id, PRUint32 flags, 
                                       JSObject **objp, PRBool *_retval)
 {
   if (id == sAdd_id) {
     JSString *str = JSVAL_TO_STRING(id);
+
+    JSAutoRequest ar(cx);
+
     JSFunction *fnc =
       ::JS_DefineFunction(cx, obj, ::JS_GetStringBytes(str),
                           Add, 0, JSPROP_ENUMERATE);
     
     *objp = obj;
     
     return fnc ? NS_OK : NS_ERROR_UNEXPECTED;
   }
@@ -9535,16 +9599,18 @@ nsStringArraySH::GetProperty(nsIXPConnec
 
   nsAutoString val;
 
   nsresult rv = GetStringAt(wrapper->Native(), n, val);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // XXX: Null strings?
 
+  JSAutoRequest ar(cx);
+
   JSString *str =
     ::JS_NewUCStringCopyN(cx, NS_REINTERPRET_CAST(const jschar *, val.get()),
                           val.Length());
   NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
 
   *vp = STRING_TO_JSVAL(str);
 
   return NS_SUCCESS_I_DID_SOMETHING;
Index: dom/src/base/nsGlobalWindow.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsGlobalWindow.cpp,v
retrieving revision 1.761.2.44
diff -U8 -p -r1.761.2.44 nsGlobalWindow.cpp
--- dom/src/base/nsGlobalWindow.cpp	6 Jul 2006 02:57:24 -0000	1.761.2.44
+++ dom/src/base/nsGlobalWindow.cpp	13 Jul 2006 18:26:01 -0000
@@ -48,16 +48,17 @@
 #include "nsHistory.h"
 #include "nsBarProps.h"
 #include "nsDOMStorage.h"
 
 // Helper Classes
 #include "nsXPIDLString.h"
 #include "nsJSUtils.h"
 #include "prmem.h"
+#include "jsapi.h"              // for JSAutoRequest
 #include "jsdbgapi.h"           // for JS_ClearWatchPointsForObject
 #include "nsReadableUtils.h"
 #include "nsDOMClassInfo.h"
 
 // Other Classes
 #include "nsIEventListenerManager.h"
 #include "nsEscape.h"
 #include "nsStyleCoord.h"
@@ -512,16 +513,18 @@ nsGlobalWindow::FreeInnerObjects(JSConte
     // Remember the document's principal.
     mDocumentPrincipal = doc->GetPrincipal();
   }
 
   // Remove our reference to the document and the document principal.
   mDocument = nsnull;
 
   if (mJSObject && cx) {
+    JSAutoRequest ar(cx);
+
     ::JS_ClearScope(cx, mJSObject);
     ::JS_ClearWatchPointsForObject(cx, mJSObject);
 
     nsWindowSH::InvalidateGlobalScopePolluter(cx, mJSObject);
   }
 }
 
 //*****************************************************************************
@@ -840,16 +843,18 @@ WindowStateHolder::~WindowStateHolder()
     if (stack)
       stack->GetSafeJSContext(&cx);
 
     if (!cx) {
       NS_WARNING("Trusting GC to finish cleaning up this inner window");
       return;
     }
 
+    JSAutoRequest ar(cx);
+
     mInnerWindow->FreeInnerObjects(cx);
   }
 }
 
 NS_IMPL_ISUPPORTS1(WindowStateHolder, WindowStateHolder)
 
 nsresult
 nsGlobalWindow::SetNewDocument(nsIDOMDocument* aDocument,
@@ -1047,16 +1052,18 @@ nsGlobalWindow::SetNewDocument(nsIDOMDoc
     nsRefPtr<nsGlobalWindow> newInnerWindow;
 
     nsCOMPtr<nsIDOMChromeWindow> thisChrome =
       do_QueryInterface(NS_STATIC_CAST(nsIDOMWindow *, this));
     nsCOMPtr<nsIXPConnectJSObjectHolder> navigatorHolder;
 
     PRUint32 flags = 0;
 
+    JSAutoRequest ar(cx);
+
     // Make sure to clear scope on the outer window *before* we
     // initialize the new inner window. If we don't, things
     // (Object.prototype etc) could leak from the old outer to the new
     // inner scope.
     ::JS_ClearScope(cx, mJSObject);
     ::JS_ClearWatchPointsForObject(cx, mJSObject);
 
     // Clear the regexp statics for the new page unconditionally.
@@ -1168,28 +1175,32 @@ nsGlobalWindow::SetNewDocument(nsIDOMDoc
           nsIScriptContext *callerScx;
           if (cx && (callerScx = GetScriptContextFromJSContext(cx))) {
             // We're called from document.open() (and document.open() is
             // called from JS), clear the scope etc in a termination
             // function on the calling context to prevent clearing the
             // calling scope.
             NS_ASSERTION(!currentInner->IsFrozen(),
                 "How does this opened window get into session history");
+
+            JSAutoRequest ar(cx);
+
             callerScx->SetTerminationFunction(ClearWindowScope,
                                               NS_STATIC_CAST(nsIDOMWindow *,
                                                              currentInner));
 
             termFuncSet = PR_TRUE;
           }
         }
 
         // Don't clear scope on our current inner window if it's going to be
         // held in the bfcache.
         if (!currentInner->IsFrozen()) {
           if (!termFuncSet) {
+            JSAutoRequest ar(cx);
             ::JS_ClearScope(cx, currentInner->mJSObject);
             ::JS_ClearWatchPointsForObject(cx, currentInner->mJSObject);
           }
 
           // Make the current inner window release its strong references
           // to the document to prevent it from keeping everything
           // around. But remember the document's principal.
           currentInner->mDocument = nsnull;
@@ -1199,16 +1210,18 @@ nsGlobalWindow::SetNewDocument(nsIDOMDoc
 
       mInnerWindow = newInnerWindow;
     }
 
     if (!aState && !reUseInnerWindow) {
       // Loading a new page and creating a new inner window, *not*
       // restoring from session history.
 
+      JSAutoRequest ar(cx);
+
       // InitClassesWithNewWrappedGlobal() for the new inner window
       // sets the global object in cx to be the new wrapped global. We
       // don't want that, but re-initializing the outer window will
       // fix that for us. And perhaps more importantly, this will
       // ensure that the outer window gets a new prototype so we don't
       // leak prototype properties from the old inner window to the
       // new one.
 
@@ -1301,41 +1314,47 @@ nsGlobalWindow::SetNewDocument(nsIDOMDoc
     if (!aState) {
       if (reUseInnerWindow) {
         newInnerWindow->mDocument = aDocument;
 
         // We're reusing the inner window for a new document. In this
         // case we don't clear the inner window's scope, but we must
         // make sure the cached document property gets updated.
 
+        JSAutoRequest ar(cx);
+
         ::JS_DeleteProperty(cx, currentInner->mJSObject, "document");
       } else {
         rv = newInnerWindow->SetNewDocument(aDocument, nsnull,
                                             aRemoveEventListeners,
                                             aClearScopeHint, PR_TRUE);
         NS_ENSURE_SUCCESS(rv, rv);
 
         // Initialize DOM classes etc on the inner window.
         rv = scx->InitClasses(newInnerWindow->mJSObject);
         NS_ENSURE_SUCCESS(rv, rv);
 
         if (navigatorHolder) {
           // Restore window.navigator onto the new inner window.
           JSObject *nav;
           navigatorHolder->GetJSObject(&nav);
 
+          JSAutoRequest ar(cx);
+
           ::JS_DefineProperty(cx, newInnerWindow->mJSObject, "navigator",
                               OBJECT_TO_JSVAL(nav), nsnull, nsnull,
                               JSPROP_ENUMERATE);
         }
       }
 
       if (mArguments) {
         jsval args = OBJECT_TO_JSVAL(mArguments);
 
+        JSAutoRequest ar(cx);
+
         ::JS_SetProperty(cx, newInnerWindow->mJSObject, "arguments",
                          &args);
 
         ::JS_UnlockGCThing(cx, mArguments);
         mArguments = nsnull;
       }
 
       // Give the new inner window our chrome event handler (since it
@@ -1372,16 +1391,18 @@ nsGlobalWindow::SetDocShell(nsIDocShell*
 
   if (!aDocShell && mContext) {
     NS_ASSERTION(!mTimeouts, "Uh, outer window holds timeouts!");
 
     JSContext *cx = (JSContext *)mContext->GetNativeContext();
     nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
 
     if (currentInner) {
+      JSAutoRequest ar(cx);
+
       currentInner->FreeInnerObjects(cx);
 
       nsCOMPtr<nsIDocument> doc =
         do_QueryInterface(mDocument);
 
       // Remember the document's principal.
       mDocumentPrincipal = doc->GetPrincipal();
 
@@ -1768,16 +1789,18 @@ nsGlobalWindow::SetNewArguments(PRUint32
 {
   FORWARD_TO_OUTER(SetNewArguments, (aArgc, aArgv), NS_ERROR_NOT_INITIALIZED);
 
   JSContext *cx;
   NS_ENSURE_TRUE(mContext &&
                  (cx = (JSContext *)mContext->GetNativeContext()),
                  NS_ERROR_NOT_INITIALIZED);
 
+  JSAutoRequest ar(cx);
+
   if (mArguments) {
     ::JS_UnlockGCThing(cx, mArguments);
     mArguments = nsnull;
   }
   
   if (aArgc == 0) {
     return NS_OK;
   }
@@ -3470,28 +3493,28 @@ nsGlobalWindow::Prompt(nsAString& aRetur
   jsval *argv = nsnull;
 
   ncc->GetArgc(&argc);
   ncc->GetArgvPtr(&argv);
 
   PRUint32 savePassword = nsIAuthPrompt::SAVE_PASSWORD_NEVER;
 
   if (argc > 0) {
-    nsJSUtils::ConvertJSValToString(message, cx, argv[0]);
-
-    if (argc > 1) {
-      nsJSUtils::ConvertJSValToString(initial, cx, argv[1]);
-
-      if (argc > 2) {
+    JSAutoRequest ar(cx);
+    switch (argc) {
+      default:
+      case 4:
+        nsJSUtils::ConvertJSValToUint32(&savePassword, cx, argv[3]);
+      case 3:
         nsJSUtils::ConvertJSValToString(title, cx, argv[2]);
-
-        if (argc > 3) {
-          nsJSUtils::ConvertJSValToUint32(&savePassword, cx, argv[3]);
-        }
-      }
+      case 2:
+        nsJSUtils::ConvertJSValToString(initial, cx, argv[1]);
+      case 1:
+        nsJSUtils::ConvertJSValToString(message, cx, argv[0]);
+        break;
     }
   }
 
   return Prompt(message, initial, title, savePassword, aReturn);
 }
 
 NS_IMETHODIMP
 nsGlobalWindow::Focus()
@@ -4329,24 +4352,26 @@ nsGlobalWindow::Open(nsIDOMWindow **_ret
 
   PRUint32 argc;
   jsval *argv = nsnull;
 
   ncc->GetArgc(&argc);
   ncc->GetArgvPtr(&argv);
 
   if (argc > 0) {
-    nsJSUtils::ConvertJSValToString(url, cx, argv[0]);
-
-    if (argc > 1) {
-      nsJSUtils::ConvertJSValToString(name, cx, argv[1]);
-
-      if (argc > 2) {
+    JSAutoRequest ar(cx);
+    switch (argc) {
+      default:
+      case 3:
         nsJSUtils::ConvertJSValToString(options, cx, argv[2]);
-      }
+      case 2:
+        nsJSUtils::ConvertJSValToString(name, cx, argv[1]);
+      case 1:
+        nsJSUtils::ConvertJSValToString(url, cx, argv[0]);
+        break;
     }
   }
 
   return OpenInternal(url, name, options,
                       PR_FALSE,          // aDialog
                       PR_FALSE,          // aCalledNoScript
                       PR_TRUE,           // aDoJSFixups
                       nsnull, 0, nsnull, // No args
@@ -4392,24 +4417,26 @@ nsGlobalWindow::OpenDialog(nsIDOMWindow*
 
   PRUint32 argc;
   jsval *argv = nsnull;
 
   ncc->GetArgc(&argc);
   ncc->GetArgvPtr(&argv);
 
   if (argc > 0) {
-    nsJSUtils::ConvertJSValToString(url, cx, argv[0]);
-
-    if (argc > 1) {
-      nsJSUtils::ConvertJSValToString(name, cx, argv[1]);
-
-      if (argc > 2) {
+    JSAutoRequest ar(cx);
+    switch (argc) {
+      default:
+      case 3:
         nsJSUtils::ConvertJSValToString(options, cx, argv[2]);
-      }
+      case 2:
+        nsJSUtils::ConvertJSValToString(name, cx, argv[1]);
+      case 1:
+        nsJSUtils::ConvertJSValToString(url, cx, argv[0]);
+        break;
     }
   }
 
   return OpenInternal(url, name, options,
                       PR_TRUE,             // aDialog
                       PR_FALSE,            // aCalledNoScript
                       PR_FALSE,            // aDoJSFixups
                       argv, argc, nsnull,  // Arguments
@@ -4871,48 +4898,54 @@ nsGlobalWindow::Find(PRBool *aDidFind)
   PRBool caseSensitive  = PR_FALSE;
   PRBool backwards      = PR_FALSE;
   PRBool wrapAround     = PR_FALSE;
   PRBool showDialog     = PR_FALSE;
   PRBool wholeWord      = PR_FALSE;
   PRBool searchInFrames = PR_FALSE;
 
   if (argc > 0) {
-    // First arg is the search pattern
-    nsJSUtils::ConvertJSValToString(searchStr, cx, argv[0]);
-  }
-
-  if (argc > 1 && !JS_ValueToBoolean(cx, argv[1], &caseSensitive)) {
-    // Second arg is the case sensitivity
-    caseSensitive = PR_FALSE;
-  }
-
-  if (argc > 2 && !JS_ValueToBoolean(cx, argv[2], &backwards)) {
-    // Third arg specifies whether to search backwards
-    backwards = PR_FALSE;
-  }
-
-  if (argc > 3 && !JS_ValueToBoolean(cx, argv[3], &wrapAround)) {
-    // Fourth arg specifies whether we should wrap the search
-    wrapAround = PR_FALSE;
-  }
-
-  if (argc > 4 && !JS_ValueToBoolean(cx, argv[4], &wholeWord)) {
-    // Fifth arg specifies whether we should show the Find dialog
-    wholeWord = PR_FALSE;
-  }
-
-  if (argc > 5 && !JS_ValueToBoolean(cx, argv[5], &searchInFrames)) {
-    // Sixth arg specifies whether we should search only for whole words
-    searchInFrames = PR_FALSE;
-  }
-
-  if (argc > 6 && !JS_ValueToBoolean(cx, argv[6], &showDialog)) {
-    // Seventh arg specifies whether we should search in all frames
-    showDialog = PR_FALSE;
+    JSAutoRequest ar(cx);
+    switch (argc) {
+      default:
+      case 7:
+        if (!JS_ValueToBoolean(cx, argv[6], &showDialog)) {
+          // Seventh arg specifies whether we should search in all frames
+          showDialog = PR_FALSE;
+        }
+      case 6:
+        if (!JS_ValueToBoolean(cx, argv[5], &searchInFrames)) {
+          // Sixth arg specifies whether we should search only for whole words
+          searchInFrames = PR_FALSE;
+        }
+      case 5:
+        if (!JS_ValueToBoolean(cx, argv[4], &wholeWord)) {
+          // Fifth arg specifies whether we should show the Find dialog
+          wholeWord = PR_FALSE;
+        }
+      case 4:
+        if (!JS_ValueToBoolean(cx, argv[3], &wrapAround)) {
+          // Fourth arg specifies whether we should wrap the search
+          wrapAround = PR_FALSE;
+        }
+      case 3:
+        if (!JS_ValueToBoolean(cx, argv[2], &backwards)) {
+          // Third arg specifies whether to search backwards
+          backwards = PR_FALSE;
+        }
+      case 2:
+        if (!JS_ValueToBoolean(cx, argv[1], &caseSensitive)) {
+          // Second arg is the case sensitivity
+          caseSensitive = PR_FALSE;
+        }
+      case 1:
+        // First arg is the search pattern
+        nsJSUtils::ConvertJSValToString(searchStr, cx, argv[0]);
+        break;
+    }
   }
 
   return FindInternal(searchStr, caseSensitive, backwards, wrapAround,
                       wholeWord, searchInFrames, showDialog, aDidFind);
 }
 
 nsresult
 nsGlobalWindow::FindInternal(const nsAString& aStr, PRBool caseSensitive,
@@ -5420,16 +5453,18 @@ nsGlobalWindow::GetObjectProperty(const 
 
   if (!cx) {
     stack->GetSafeJSContext(&cx);
     NS_ENSURE_TRUE(cx, NS_ERROR_FAILURE);
   }
 
   jsval propertyVal;
 
+  JSAutoRequest ar(cx);
+
   if (!::JS_LookupUCProperty(cx, mJSObject,
                              NS_REINTERPRET_CAST(const jschar *, aProperty),
                              nsCRT::strlen(aProperty), &propertyVal)) {
     return NS_ERROR_FAILURE;
   }
 
   if (!nsJSUtils::ConvertJSValToXPCObject(aObject, NS_GET_IID(nsISupports),
                                           cx, propertyVal)) {
@@ -6196,16 +6231,18 @@ nsGlobalWindow::ClearWindowScope(nsISupp
   nsCOMPtr<nsIScriptGlobalObject> sgo(do_QueryInterface(aWindow));
 
   nsIScriptContext *scx = sgo->GetContext();
 
   if (scx) {
     JSContext *cx = (JSContext *)scx->GetNativeContext();
     JSObject *global = sgo->GetGlobalJSObject();
 
+    JSAutoRequest ar(cx);
+
     if (global) {
       ::JS_ClearScope(cx, global);
       ::JS_ClearWatchPointsForObject(cx, global);
     }
 
     ::JS_ClearRegExpStatics(cx);
   }
 }
@@ -6251,27 +6288,29 @@ nsGlobalWindow::SetTimeoutOrInterval(PRB
   ncc->GetArgc(&argc);
   ncc->GetArgvPtr(&argv);
 
   JSString *expr = nsnull;
   JSObject *funobj = nsnull;
   nsTimeout *timeout;
   jsdouble interval = 0.0;
 
+  JSAutoRequest ar(cx);
+
   if (argc < 1) {
     ::JS_ReportError(cx, "Function %s requires at least 1 parameter",
-                     aIsInterval ? kSetIntervalStr : kSetTimeoutStr);
+                    aIsInterval ? kSetIntervalStr : kSetTimeoutStr);
 
     return ncc->SetExceptionWasThrown(PR_TRUE);
   }
 
   if (argc > 1 && !::JS_ValueToNumber(cx, argv[1], &interval)) {
     ::JS_ReportError(cx,
-                     "Second argument to %s must be a millisecond interval",
-                     aIsInterval ? kSetIntervalStr : kSetTimeoutStr);
+                    "Second argument to %s must be a millisecond interval",
+                    aIsInterval ? kSetIntervalStr : kSetTimeoutStr);
 
     return ncc->SetExceptionWasThrown(PR_TRUE);
   }
 
   switch (::JS_TypeOfValue(cx, argv[0])) {
   case JSTYPE_FUNCTION:
     funobj = JSVAL_TO_OBJECT(argv[0]);
     break;
@@ -6281,17 +6320,17 @@ nsGlobalWindow::SetTimeoutOrInterval(PRB
     expr = ::JS_ValueToString(cx, argv[0]);
     if (!expr)
       return NS_ERROR_OUT_OF_MEMORY;
     argv[0] = STRING_TO_JSVAL(expr);
     break;
 
   default:
     ::JS_ReportError(cx, "useless %s call (missing quotes around argument?)",
-                     aIsInterval ? kSetIntervalStr : kSetTimeoutStr);
+                    aIsInterval ? kSetIntervalStr : kSetTimeoutStr);
 
     return ncc->SetExceptionWasThrown(PR_TRUE);
   }
 
   if (interval < DOM_MIN_TIMEOUT_VALUE) {
     // Don't allow timeouts less than DOM_MIN_TIMEOUT_VALUE from
     // now...
 
@@ -6321,17 +6360,17 @@ nsGlobalWindow::SetTimeoutOrInterval(PRB
       timeout->Release(scx);
 
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
     timeout->mExpr = expr;
   } else if (funobj) {
     /* Leave an extra slot for a secret final argument that
-       indicates to the called function how "late" the timeout is. */
+      indicates to the called function how "late" the timeout is. */
     timeout->mArgv = (jsval *) PR_MALLOC((argc - 1) * sizeof(jsval));
 
     if (!timeout->mArgv) {
       timeout->Release(scx);
 
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
@@ -6878,16 +6917,18 @@ nsGlobalWindow::ClearTimeoutOrInterval()
   }
 
   jsval *argv = nsnull;
 
   ncc->GetArgvPtr(&argv);
 
   int32 timer_id;
 
+  JSAutoRequest ar(cx);
+
   if (argv[0] == JSVAL_VOID || !::JS_ValueToInt32(cx, argv[0], &timer_id) ||
       timer_id <= 0) {
     // Undefined or non-positive number passed as argument, return
     // early.
 
     return NS_OK;
   }
 
@@ -8073,16 +8114,18 @@ nsNavigator::Preference()
   ncc->GetArgvPtr(&argv);
   NS_ENSURE_TRUE(argv, NS_ERROR_UNEXPECTED);
 
   JSContext *cx = nsnull;
 
   rv = ncc->GetJSContext(&cx);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  JSAutoRequest ar(cx);
+
   //--Check to see if the caller is allowed to access prefs
   if (sPrefInternal_id == JSVAL_VOID) {
     sPrefInternal_id =
       STRING_TO_JSVAL(::JS_InternString(cx, "preferenceinternal"));
   }
 
   PRUint32 action;
   if (argc == 1) {
Index: dom/src/base/nsJSEnvironment.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsJSEnvironment.cpp,v
retrieving revision 1.262.2.9
diff -U8 -p -r1.262.2.9 nsJSEnvironment.cpp
--- dom/src/base/nsJSEnvironment.cpp	23 Jun 2006 22:48:01 -0000	1.262.2.9
+++ dom/src/base/nsJSEnvironment.cpp	13 Jul 2006 18:26:02 -0000
@@ -923,18 +923,21 @@ nsJSContext::EvaluateStringWithValue(con
     // SecurityManager said "ok", but don't execute if aVersion is specified
     // and unknown.  Do execute with the default version (and avoid thrashing
     // the context's version) if aVersion is not specified.
     ok = (!aVersion ||
           (newVersion = ::JS_StringToVersion(aVersion)) != JSVERSION_UNKNOWN);
     if (ok) {
       JSVersion oldVersion = JSVERSION_UNKNOWN;
 
+      JSAutoRequest ar(mContext);
+
       if (aVersion)
         oldVersion = ::JS_SetVersion(mContext, newVersion);
+
       ok = ::JS_EvaluateUCScriptForPrincipals(mContext,
                                               (JSObject *)aScopeObject,
                                               jsprin,
                                               (jschar*)PromiseFlatString(aScript).get(),
                                               aScript.Length(),
                                               aURL,
                                               aLineNo,
                                               &val);
@@ -1107,18 +1110,21 @@ nsJSContext::EvaluateString(const nsAStr
     // SecurityManager said "ok", but don't execute if aVersion is specified
     // and unknown.  Do execute with the default version (and avoid thrashing
     // the context's version) if aVersion is not specified.
     ok = (!aVersion ||
           (newVersion = ::JS_StringToVersion(aVersion)) != JSVERSION_UNKNOWN);
     if (ok) {
       JSVersion oldVersion = JSVERSION_UNKNOWN;
 
+      JSAutoRequest ar(mContext);
+
       if (aVersion)
         oldVersion = ::JS_SetVersion(mContext, newVersion);
+
       ok = ::JS_EvaluateUCScriptForPrincipals(mContext,
                                               (JSObject *)aScopeObject,
                                               jsprin,
                                               (jschar*)PromiseFlatString(aScript).get(),
                                               aScript.Length(),
                                               aURL,
                                               aLineNo,
                                               &val);
@@ -1137,16 +1143,17 @@ nsJSContext::EvaluateString(const nsAStr
     }
   }
 
   // Whew!  Finally done with these manually ref-counted things.
   JSPRINCIPALS_DROP(mContext, jsprin);
 
   // If all went well, convert val to a string (XXXbe unless undefined?).
   if (ok) {
+    JSAutoRequest ar(mContext);
     rv = JSValueToAString(mContext, val, aRetValue, aIsUndefined);
   }
   else {
     if (aIsUndefined) {
       *aIsUndefined = PR_TRUE;
     }
 
     if (aRetValue) {
@@ -1199,16 +1206,19 @@ nsJSContext::CompileScript(const PRUnich
     JSVersion newVersion = JSVERSION_UNKNOWN;
 
     // SecurityManager said "ok", but don't compile if aVersion is specified
     // and unknown.  Do compile with the default version (and avoid thrashing
     // the context's version) if aVersion is not specified.
     if (!aVersion ||
         (newVersion = ::JS_StringToVersion(aVersion)) != JSVERSION_UNKNOWN) {
       JSVersion oldVersion = JSVERSION_UNKNOWN;
+
+      JSAutoRequest ar(mContext);
+
       if (aVersion)
         oldVersion = ::JS_SetVersion(mContext, newVersion);
 
       JSScript* script =
         ::JS_CompileUCScriptForPrincipals(mContext,
                                           (JSObject*) aScopeObject,
                                           jsprin,
                                           (jschar*) aText,
@@ -1216,18 +1226,17 @@ nsJSContext::CompileScript(const PRUnich
                                           aURL,
                                           aLineNo);
       if (script) {
         *aScriptObject = (void*) ::JS_NewScriptObject(mContext, script);
         if (! *aScriptObject) {
           ::JS_DestroyScript(mContext, script);
           script = nsnull;
         }
-      }
-      if (!script)
+      } else
         rv = NS_ERROR_OUT_OF_MEMORY;
 
       if (aVersion)
         ::JS_SetVersion(mContext, oldVersion);
     }
   }
 
   // Whew!  Finally done with these manually ref-counted things.
@@ -1271,25 +1280,25 @@ nsJSContext::ExecuteScript(void* aScript
   // The result of evaluation, used only if there were no errors.  This need
   // not be a GC root currently, provided we run the GC only from the branch
   // callback or from ScriptEvaluated.  TODO: use JS_Begin/EndRequest to keep
   // the GC from racing with JS execution on any thread.
   jsval val;
   JSBool ok;
 
   nsJSContext::TerminationFuncHolder holder(this);
+  JSAutoRequest ar(mContext);
   ok = ::JS_ExecuteScript(mContext,
                           (JSObject*) aScopeObject,
                           (JSScript*) ::JS_GetPrivate(mContext,
                                                     (JSObject*)aScriptObject),
                           &val);
 
   if (ok) {
     // If all went well, convert val to a string (XXXbe unless undefined?).
-
     rv = JSValueToAString(mContext, val, aRetValue, aIsUndefined);
   } else {
     if (aIsUndefined) {
       *aIsUndefined = PR_TRUE;
     }
 
     if (aRetValue) {
       aRetValue->Truncate();
@@ -1368,16 +1377,18 @@ nsJSContext::CompileEventHandler(void *a
     prin->GetJSPrincipals(mContext, &jsprin);
     NS_ENSURE_TRUE(jsprin, NS_ERROR_NOT_AVAILABLE);
   }
 
   const char *charName = AtomToEventHandlerName(aName);
 
   const char *argList[] = { aEventName };
 
+  JSAutoRequest ar(mContext);
+
   JSFunction* fun =
       ::JS_CompileUCFunctionForPrincipals(mContext,
                                           aShared ? nsnull : target, jsprin,
                                           charName, 1, argList,
                                           (jschar*)PromiseFlatString(aBody).get(),
                                           aBody.Length(),
                                           aURL, aLineNo);
 
@@ -1417,16 +1428,19 @@ nsJSContext::CompileFunction(void* aTarg
       nsIPrincipal *prin = globalData->GetPrincipal();
       if (!prin)
         return NS_ERROR_FAILURE;
       prin->GetJSPrincipals(mContext, &jsprin);
     }
   }
 
   JSObject *target = (JSObject*)aTarget;
+
+  JSAutoRequest ar(mContext);
+
   JSFunction* fun =
       ::JS_CompileUCFunctionForPrincipals(mContext,
                                           aShared ? nsnull : target, jsprin,
                                           PromiseFlatCString(aName).get(),
                                           aArgCount, aArgArray,
                                           (jschar*)PromiseFlatString(aBody).get(),
                                           aBody.Length(),
                                           aURL, aLineNo);
@@ -1465,18 +1479,20 @@ nsJSContext::CallEventHandler(JSObject *
 
   // check if the event handler can be run on the object in question
   rv = sSecurityManager->CheckFunctionAccess(mContext, aHandler, aTarget);
 
   nsJSContext::TerminationFuncHolder holder(this);
 
   if (NS_SUCCEEDED(rv)) {
     jsval funval = OBJECT_TO_JSVAL(aHandler);
-    PRBool ok = ::JS_CallFunctionValue(mContext, aTarget, funval, argc, argv,
-                                       rval);
+
+    JSAutoRequest ar(mContext);
+
+    PRBool ok = ::JS_CallFunctionValue(mContext, aTarget, funval, argc, argv, rval);
 
     if (!ok) {
       // Tell XPConnect about any pending exceptions. This is needed
       // to avoid dropping JS exceptions in case we got here through
       // nested calls through XPConnect.
 
       nsContentUtils::NotifyXPCIfExceptionPending(mContext);
 
@@ -1486,16 +1502,18 @@ nsJSContext::CallEventHandler(JSObject *
       // Tell the caller that the handler threw an error.
       rv = NS_ERROR_FAILURE;
     }
   }
 
   if (NS_FAILED(stack->Pop(nsnull)))
     return NS_ERROR_FAILURE;
 
+  JSAutoRequest ar(mContext);
+
   // Need to lock, since ScriptEvaluated can GC.
   PRBool locked = PR_FALSE;
   if (NS_SUCCEEDED(rv) && JSVAL_IS_GCTHING(*rval)) {
     locked = ::JS_LockGCThing(mContext, JSVAL_TO_GCTHING(*rval));
     if (!locked) {
       rv = NS_ERROR_OUT_OF_MEMORY;
     }
   }
@@ -1526,16 +1544,18 @@ nsJSContext::BindCompiledEventHandler(vo
   // Push our JSContext on our thread's context stack, in case native code
   // called from JS calls back into JS via XPConnect.
   nsCOMPtr<nsIJSContextStack> stack =
            do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
   if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext))) {
     return NS_ERROR_FAILURE;
   }
 
+  JSAutoRequest ar(mContext);
+
   // Make sure the handler function is parented by its event target object
   if (funobj && ::JS_GetParent(mContext, funobj) != target) {
     funobj = ::JS_CloneFunctionObject(mContext, funobj, target);
     if (!funobj)
       rv = NS_ERROR_OUT_OF_MEMORY;
   }
 
   if (NS_SUCCEEDED(rv) &&
@@ -1666,16 +1686,17 @@ nsJSContext::InitContext(nsIScriptGlobal
                                               NS_GET_IID(nsISupports),
                                               flags,
                                               getter_AddRefs(holder));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // Now check whether we need to grab a pointer to the
     // XPCNativeWrapper class
     if (!NS_DOMClassInfo_GetXPCNativeWrapperClass()) {
+      JSAutoRequest ar(mContext);
       rv = FindXPCNativeWrapperClass(holder);
       NS_ENSURE_SUCCESS(rv, rv);
     }
   } else {
     // If there's already a global object in mContext we're called
     // after ::JS_ClearScope() was called. We'll have to tell
     // XPConnect to re-initialize the global object to do things like
     // define the Components object on the global again and forget all
@@ -1734,16 +1755,17 @@ nsJSContext::InitializeLiveConnectClasse
 
     rv = jvmManager->GetJavaEnabled(&javaEnabled);
 
     if (NS_SUCCEEDED(rv) && javaEnabled) {
       nsCOMPtr<nsILiveConnectManager> liveConnectManager =
         do_QueryInterface(jvmManager);
 
       if (liveConnectManager) {
+        JSAutoRequest ar(mContext);
         rv = liveConnectManager->InitLiveConnectClasses(mContext, aGlobalObj);
       }
     }
   }
 #endif /* OJI */
 
   // return all is well until things are stable.
   return NS_OK;
@@ -2037,16 +2059,18 @@ nsJSContext::InitClasses(JSObject *aGlob
   nsresult rv = NS_OK;
 
   rv = InitializeExternalClasses();
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = InitializeLiveConnectClasses(aGlobalObj);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  JSAutoRequest ar(mContext);
+
   // Initialize the options object and set default options in mContext
   JSObject *optionsObj = ::JS_DefineObject(mContext, aGlobalObj, "_options",
                                            &OptionsClass, nsnull, 0);
   if (optionsObj &&
       ::JS_DefineProperties(mContext, optionsObj, OptionsProperties)) {
     ::JS_SetOptions(mContext, mDefaultJSOptions);
   } else {
     rv = NS_ERROR_FAILURE;
Index: dom/src/base/nsLocation.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsLocation.cpp,v
retrieving revision 1.136.2.2
diff -U8 -p -r1.136.2.2 nsLocation.cpp
--- dom/src/base/nsLocation.cpp	22 Jun 2006 22:19:29 -0000	1.136.2.2
+++ dom/src/base/nsLocation.cpp	13 Jul 2006 18:26:02 -0000
@@ -908,16 +908,17 @@ nsLocation::Reload()
     ncc->GetArgvPtr(&argv);
     NS_ENSURE_TRUE(argv, NS_ERROR_UNEXPECTED);
 
     JSContext *cx = nsnull;
 
     rv = ncc->GetJSContext(&cx);
     NS_ENSURE_SUCCESS(rv, rv);
 
+    JSAutoRequest ar(cx);
     JS_ValueToBoolean(cx, argv[0], &force_get);
   }
 
   return Reload(force_get);
 }
 
 NS_IMETHODIMP
 nsLocation::Replace(const nsAString& aUrl)
Index: dom/src/base/nsPluginArray.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsPluginArray.cpp,v
retrieving revision 1.29.12.1
diff -U8 -p -r1.29.12.1 nsPluginArray.cpp
--- dom/src/base/nsPluginArray.cpp	25 Jun 2006 06:57:13 -0000	1.29.12.1
+++ dom/src/base/nsPluginArray.cpp	13 Jul 2006 18:26:03 -0000
@@ -265,16 +265,17 @@ nsPluginArray::Refresh()
     ncc->GetArgvPtr(&argv);
     NS_ENSURE_TRUE(argv, NS_ERROR_UNEXPECTED);
 
     JSContext *cx = nsnull;
 
     rv = ncc->GetJSContext(&cx);
     NS_ENSURE_SUCCESS(rv, rv);
 
+    JSAutoRequest ar(cx);
     JS_ValueToBoolean(cx, argv[0], &reload_doc);
   }
 
   return Refresh(reload_doc);
 }
 
 nsresult
 nsPluginArray::GetPlugins()
Index: dom/src/events/nsJSEventListener.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/events/nsJSEventListener.cpp,v
retrieving revision 1.50.2.1
diff -U8 -p -r1.50.2.1 nsJSEventListener.cpp
--- dom/src/events/nsJSEventListener.cpp	19 Sep 2005 19:09:11 -0000	1.50.2.1
+++ dom/src/events/nsJSEventListener.cpp	13 Jul 2006 18:26:03 -0000
@@ -55,25 +55,29 @@ nsJSEventListener::nsJSEventListener(nsI
                                      JSObject *aScopeObject,
                                      nsISupports *aObject)
   : nsIJSEventListener(aContext, aScopeObject, aObject),
     mReturnResult(nsReturnResult_eNotSet)
 {
   if (aScopeObject && aContext) {
     JSContext *cx = (JSContext *)aContext->GetNativeContext();
 
+    JSAutoRequest ar(cx);
+
     ::JS_LockGCThing(cx, aScopeObject);
   }
 }
 
 nsJSEventListener::~nsJSEventListener() 
 {
   if (mScopeObject && mContext) {
     JSContext *cx = (JSContext *)mContext->GetNativeContext();
 
+    JSAutoRequest ar(cx);
+
     ::JS_UnlockGCThing(cx, mScopeObject);
   }
 }
 
 NS_INTERFACE_MAP_BEGIN(nsJSEventListener)
   NS_INTERFACE_MAP_ENTRY(nsIDOMEventListener)
   NS_INTERFACE_MAP_ENTRY(nsIJSEventListener)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMEventListener)
@@ -133,16 +137,18 @@ nsJSEventListener::HandleEvent(nsIDOMEve
   rv = xpc->WrapNative(cx, mScopeObject, mTarget, NS_GET_IID(nsISupports),
                        getter_AddRefs(wrapper));
   NS_ENSURE_SUCCESS(rv, rv);
 
   JSObject* obj = nsnull;
   rv = wrapper->GetJSObject(&obj);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  JSAutoRequest ar(cx);
+
   if (!JS_LookupUCProperty(cx, obj,
                            NS_REINTERPRET_CAST(const jschar *,
                                                eventString.get()),
                            eventString.Length(), &funval)) {
     return NS_ERROR_FAILURE;
   }
 
   if (JS_TypeOfValue(cx, funval) != JSTYPE_FUNCTION) {
@@ -165,34 +171,33 @@ nsJSEventListener::HandleEvent(nsIDOMEve
       NS_ENSURE_TRUE(argv, NS_ERROR_OUT_OF_MEMORY);
       argc = 3;
       handledScriptError = PR_TRUE;
     }
   }
 
   if (!handledScriptError) {
     rv = xpc->WrapNative(cx, obj, aEvent, NS_GET_IID(nsIDOMEvent),
-                         getter_AddRefs(wrapper));
+                        getter_AddRefs(wrapper));
     NS_ENSURE_SUCCESS(rv, rv);
 
     JSObject *eventObj = nsnull;
     rv = wrapper->GetJSObject(&eventObj);
     NS_ENSURE_SUCCESS(rv, rv);
 
     argv[0] = OBJECT_TO_JSVAL(eventObj);
     argc = 1;
   }
 
   jsval rval;
   rv = mContext->CallEventHandler(obj, JSVAL_TO_OBJECT(funval), argc, argv,
                                   &rval);
 
-  if (argv != &arg) {
+  if (argv != &arg)
     ::JS_PopArguments(cx, stackPtr);
-  }
 
   if (NS_SUCCEEDED(rv)) {
     if (eventString.EqualsLiteral("onbeforeunload")) {
       nsCOMPtr<nsIPrivateDOMEvent> priv(do_QueryInterface(aEvent));
       NS_ENSURE_TRUE(priv, NS_ERROR_UNEXPECTED);
 
       nsEvent* event;
       priv->GetInternalNSEvent(&event);
@@ -213,19 +218,18 @@ nsJSEventListener::HandleEvent(nsIDOMEve
         }
       }
     } else if (JSVAL_IS_BOOLEAN(rval)) {
       // If the handler returned false and its sense is not reversed,
       // or the handler returned true and its sense is reversed from
       // the usual (false means cancel), then prevent default.
 
       if (JSVAL_TO_BOOLEAN(rval) ==
-          (mReturnResult == nsReturnResult_eReverseReturnResult)) {
+           (mReturnResult == nsReturnResult_eReverseReturnResult))
         aEvent->PreventDefault();
-      }
     }
   }
 
   return rv;
 }
 
 /*
  * Factory functions
Index: embedding/components/windowwatcher/src/nsWindowWatcher.cpp
===================================================================
RCS file: /cvsroot/mozilla/embedding/components/windowwatcher/src/nsWindowWatcher.cpp,v
retrieving revision 1.100.2.12
diff -U8 -p -r1.100.2.12 nsWindowWatcher.cpp
--- embedding/components/windowwatcher/src/nsWindowWatcher.cpp	6 Jul 2006 20:30:09 -0000	1.100.2.12
+++ embedding/components/windowwatcher/src/nsWindowWatcher.cpp	13 Jul 2006 18:26:05 -0000
@@ -2066,32 +2066,35 @@ nsWindowWatcher::AddSupportsTojsvals(nsI
     case nsISupportsPrimitive::TYPE_CSTRING : {
       nsCOMPtr<nsISupportsCString> p(do_QueryInterface(argPrimitive));
       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
 
       nsCAutoString data;
 
       p->GetData(data);
 
-      
+      JSAutoRequest ar(cx);
+
       JSString *str = ::JS_NewStringCopyN(cx, data.get(), data.Length());
       NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
 
       *aArgv = STRING_TO_JSVAL(str);
 
       break;
     }
     case nsISupportsPrimitive::TYPE_STRING : {
       nsCOMPtr<nsISupportsString> p(do_QueryInterface(argPrimitive));
       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
 
       nsAutoString data;
 
       p->GetData(data);
 
+      JSAutoRequest ar(cx);
+
       // cast is probably safe since wchar_t and jschar are expected
       // to be equivalent; both unsigned 16-bit entities
       JSString *str =
         ::JS_NewUCStringCopyN(cx,
                               NS_REINTERPRET_CAST(const jschar *,data.get()),
                               data.Length());
       NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
 
@@ -2149,16 +2152,18 @@ nsWindowWatcher::AddSupportsTojsvals(nsI
     case nsISupportsPrimitive::TYPE_CHAR : {
       nsCOMPtr<nsISupportsChar> p(do_QueryInterface(argPrimitive));
       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
 
       char data;
 
       p->GetData(&data);
 
+      JSAutoRequest ar(cx);
+
       JSString *str = ::JS_NewStringCopyN(cx, &data, 1);
       NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
 
       *aArgv = STRING_TO_JSVAL(str);
 
       break;
     }
     case nsISupportsPrimitive::TYPE_PRINT16 : {
@@ -2188,30 +2193,34 @@ nsWindowWatcher::AddSupportsTojsvals(nsI
     case nsISupportsPrimitive::TYPE_FLOAT : {
       nsCOMPtr<nsISupportsFloat> p(do_QueryInterface(argPrimitive));
       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
 
       float data;
 
       p->GetData(&data);
 
+      JSAutoRequest ar(cx);
+
       jsdouble *d = ::JS_NewDouble(cx, data);
 
       *aArgv = DOUBLE_TO_JSVAL(d);
 
       break;
     }
     case nsISupportsPrimitive::TYPE_DOUBLE : {
       nsCOMPtr<nsISupportsDouble> p(do_QueryInterface(argPrimitive));
       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
 
       double data;
 
       p->GetData(&data);
 
+      JSAutoRequest ar(cx);
+
       jsdouble *d = ::JS_NewDouble(cx, data);
 
       *aArgv = DOUBLE_TO_JSVAL(d);
 
       break;
     }
     case nsISupportsPrimitive::TYPE_INTERFACE_POINTER : {
       nsCOMPtr<nsISupportsInterfacePointer> p(do_QueryInterface(argPrimitive));
Index: js/jsd/jsd_high.c
===================================================================
RCS file: /cvsroot/mozilla/js/jsd/jsd_high.c,v
retrieving revision 3.12
diff -U8 -p -r3.12 jsd_high.c
--- js/jsd/jsd_high.c	18 Apr 2004 21:57:30 -0000	3.12
+++ js/jsd/jsd_high.c	13 Jul 2006 18:26:11 -0000
@@ -130,37 +130,40 @@ _newJSDContext(JSRuntime*         jsrt, 
 
     if( ! jsd_InitScriptManager(jsdc) )
         goto label_newJSDContext_failure;
 
     jsdc->dumbContext = JS_NewContext(jsdc->jsrt, 256);
     if( ! jsdc->dumbContext )
         goto label_newJSDContext_failure;
 
+    JS_BeginRequest(jsdc->dumbContext);
     jsdc->glob = JS_NewObject(jsdc->dumbContext, &global_class, NULL, NULL);
     if( ! jsdc->glob )
         goto label_newJSDContext_failure;
 
     if( ! JS_InitStandardClasses(jsdc->dumbContext, jsdc->glob) )
         goto label_newJSDContext_failure;
+    JS_EndRequest(jsdc->dumbContext);
 
     jsdc->data = NULL;
     jsdc->inited = JS_TRUE;
 
     JSD_LOCK();
     JS_INSERT_LINK(&jsdc->links, &_jsd_context_list);
     JSD_UNLOCK();
 
     return jsdc;
 
 label_newJSDContext_failure:
     jsd_DestroyObjectManager(jsdc);
     jsd_DestroyAtomTable(jsdc);
     if( jsdc )
         free(jsdc);
+    JS_EndRequest(jsdc->dumbContext);
     return NULL;
 }
 
 static void
 _destroyJSDContext(JSDContext* jsdc)
 {
     JSD_ASSERT_VALID_CONTEXT(jsdc);
 
Index: js/jsd/jsd_stak.c
===================================================================
RCS file: /cvsroot/mozilla/js/jsd/jsd_stak.c,v
retrieving revision 3.21
diff -U8 -p -r3.21 jsd_stak.c
--- js/jsd/jsd_stak.c	8 Aug 2004 19:56:49 -0000	3.21
+++ js/jsd/jsd_stak.c	13 Jul 2006 18:26:11 -0000
@@ -311,17 +311,19 @@ jsd_GetScopeChainForStackFrame(JSDContex
 {
     JSObject* obj;
     JSDValue* jsdval = NULL;
 
     JSD_LOCK_THREADSTATES(jsdc);
 
     if( jsd_IsValidFrameInThreadState(jsdc, jsdthreadstate, jsdframe) )
     {
+        JS_BeginRequest(jsdthreadstate->context);
         obj = JS_GetFrameScopeChain(jsdthreadstate->context, jsdframe->fp); 
+        JS_EndRequest(jsdthreadstate->context);
         if(obj)                                                             
             jsdval = JSD_NewValue(jsdc, OBJECT_TO_JSVAL(obj));              
     }
 
     JSD_UNLOCK_THREADSTATES(jsdc);
 
     return jsdval;
 }
Index: js/jsd/jsd_val.c
===================================================================
RCS file: /cvsroot/mozilla/js/jsd/jsd_val.c,v
retrieving revision 3.9.28.1
diff -U8 -p -r3.9.28.1 jsd_val.c
--- js/jsd/jsd_val.c	7 Jul 2006 02:12:01 -0000	3.9.28.1
+++ js/jsd/jsd_val.c	13 Jul 2006 18:26:11 -0000
@@ -148,25 +148,26 @@ jsd_IsValueNative(JSDContext* jsdc, JSDV
 {
     JSContext* cx = jsdc->dumbContext;
     jsval val = jsdval->val;
     JSFunction* fun;
     JSExceptionState* exceptionState;
 
     if(jsd_IsValueFunction(jsdc, jsdval))
     {
+        JSBool ok;
+        JS_BeginRequest(cx);
         exceptionState = JS_SaveExceptionState(cx);
         fun = JS_ValueToFunction(cx, val);
         JS_RestoreExceptionState(cx, exceptionState);
-        if(!fun)
-        {
-            JS_ASSERT(0);
-            return JS_FALSE;
-        }
-        return JS_GetFunctionScript(cx, fun) ? JS_FALSE : JS_TRUE;
+        if(fun)
+          ok = JS_GetFunctionScript(cx, fun) ? JS_TRUE : JS_FALSE;
+        JS_EndRequest(cx);
+        JS_ASSERT(fun);
+        return ok;
     }
     return !JSVAL_IS_PRIMITIVE(val);
 }
 
 /***************************************************************************/
 
 JSBool
 jsd_GetValueBoolean(JSDContext* jsdc, JSDValue* jsdval)
@@ -203,41 +204,45 @@ jsd_GetValueString(JSDContext* jsdc, JSD
 
     if(!jsdval->string)
     {
         /* if the jsval is a string, then we don't need to double root it */
         if(JSVAL_IS_STRING(jsdval->val))
             jsdval->string = JSVAL_TO_STRING(jsdval->val);
         else
         {
+            JS_BeginRequest(cx);
             exceptionState = JS_SaveExceptionState(cx);
             jsdval->string = JS_ValueToString(cx, jsdval->val);
             JS_RestoreExceptionState(cx, exceptionState);
             if(jsdval->string)
             {
                 if(!JS_AddNamedRoot(cx, &jsdval->string, "ValueString"))
                     jsdval->string = NULL;
             }
+            JS_EndRequest(cx);
         }
     }
     return jsdval->string;
 }
 
 const char*
 jsd_GetValueFunctionName(JSDContext* jsdc, JSDValue* jsdval)
 {
     JSContext* cx = jsdc->dumbContext;
     JSFunction* fun;
     JSExceptionState* exceptionState;
 
     if(!jsdval->funName && jsd_IsValueFunction(jsdc, jsdval))
     {
+        JS_BeginRequest(cx);
         exceptionState = JS_SaveExceptionState(cx);
         fun = JS_ValueToFunction(cx, jsdval->val);
         JS_RestoreExceptionState(cx, exceptionState);
+        JS_EndRequest(cx);
         if(!fun)
             return NULL;
         jsdval->funName = JS_GetFunctionName(fun);
     }
     return jsdval->funName;
 }
 
 /***************************************************************************/
@@ -247,17 +252,21 @@ jsd_NewValue(JSDContext* jsdc, jsval val
 {
     JSDValue* jsdval;
 
     if(!(jsdval = (JSDValue*) calloc(1, sizeof(JSDValue))))
         return NULL;
 
     if(JSVAL_IS_GCTHING(val))
     {
-        if(!JS_AddNamedRoot(jsdc->dumbContext, &jsdval->val, "JSDValue"))
+        JSBool ok = JS_FALSE;
+        JS_BeginRequest(jsdc->dumbContext);
+        ok = JS_AddNamedRoot(jsdc->dumbContext, &jsdval->val, "JSDValue");
+        JS_EndRequest(jsdc->dumbContext);
+        if(!ok)
         {
             free(jsdval);
             return NULL;
         }
     }
     jsdval->val  = val;
     jsdval->nref = 1;
     JS_INIT_CLIST(&jsdval->props);
@@ -268,17 +277,21 @@ jsd_NewValue(JSDContext* jsdc, jsval val
 void
 jsd_DropValue(JSDContext* jsdc, JSDValue* jsdval)
 {
     JS_ASSERT(jsdval->nref > 0);
     if(0 == --jsdval->nref)
     {
         jsd_RefreshValue(jsdc, jsdval);
         if(JSVAL_IS_GCTHING(jsdval->val))
+        {
+            JS_BeginRequest(jsdc->dumbContext);
             JS_RemoveRoot(jsdc->dumbContext, &jsdval->val);
+            JS_EndRequest(jsdc->dumbContext);
+        }
         free(jsdval);
     }
 }
 
 jsval
 jsd_GetValueWrappedJSVal(JSDContext* jsdc, JSDValue* jsdval)
 {
     return jsdval->val;
@@ -335,47 +348,56 @@ static JSBool _buildProps(JSDContext* js
 
     JS_ASSERT(JS_CLIST_IS_EMPTY(&jsdval->props));
     JS_ASSERT(!(CHECK_BIT_FLAG(jsdval->flags, GOT_PROPS)));
     JS_ASSERT(JSVAL_IS_OBJECT(jsdval->val));
 
     if(!JSVAL_IS_OBJECT(jsdval->val) || JSVAL_IS_NULL(jsdval->val))
         return JS_FALSE;
 
+    JS_BeginRequest(cx);
     if(!JS_GetPropertyDescArray(cx, JSVAL_TO_OBJECT(jsdval->val), &pda))
+    {
+        JS_EndRequest(cx);
         return JS_FALSE;
+    }
 
     for(i = 0; i < pda.length; i++)
     {
         JSDProperty* prop = _newProperty(jsdc, &pda.array[i], 0);
         if(!prop)
         {
             _freeProps(jsdc, jsdval);
             break;
         }
         JS_APPEND_LINK(&prop->links, &jsdval->props);
     }
     JS_PutPropertyDescArray(cx, &pda);
+    JS_EndRequest(cx);
     SET_BIT_FLAG(jsdval->flags, GOT_PROPS);
     return !JS_CLIST_IS_EMPTY(&jsdval->props);
 }
 
 #undef  DROP_CLEAR_VALUE
 #define DROP_CLEAR_VALUE(jsdc, x) if(x){jsd_DropValue(jsdc,x); x = NULL;}
 
 void
 jsd_RefreshValue(JSDContext* jsdc, JSDValue* jsdval)
 {
     JSContext* cx = jsdc->dumbContext;
 
     if(jsdval->string)
     {
         /* if the jsval is a string, then we didn't need to root the string */
         if(!JSVAL_IS_STRING(jsdval->val))
+        {
+            JS_BeginRequest(cx);
             JS_RemoveRoot(cx, &jsdval->string);
+            JS_EndRequest(cx);
+        }
         jsdval->string = NULL;
     }
 
     jsdval->funName = NULL;
     jsdval->className = NULL;
     DROP_CLEAR_VALUE(jsdc, jsdval->proto);
     DROP_CLEAR_VALUE(jsdc, jsdval->parent);
     DROP_CLEAR_VALUE(jsdc, jsdval->ctor);
@@ -454,41 +476,51 @@ jsd_GetValueProperty(JSDContext* jsdc, J
     /* Not found in property list, look it up explicitly */
 
     if(!(obj = JSVAL_TO_OBJECT(jsdval->val)))
         return NULL;
 
     nameChars = JS_GetStringChars(name);
     nameLen   = JS_GetStringLength(name);
 
+    JS_BeginRequest(cx);
+
     JS_GetUCPropertyAttributes(cx, obj, nameChars, nameLen, &attrs, &found);
     if (!found)
+    {
+        JS_EndRequest(cx);
         return NULL;
+    }
 
     JS_ClearPendingException(cx);
 
     if(!JS_GetUCProperty(cx, obj, nameChars, nameLen, &val))
     {
         if (JS_IsExceptionPending(cx))
         {
             if (!JS_GetPendingException(cx, &pd.value))
+            {
+                JS_EndRequest(cx);
                 return NULL;
+            }
             pd.flags = JSPD_EXCEPTION;
         }
         else
         {
             pd.flags = JSPD_ERROR;
             pd.value = JSVAL_VOID;
         }
     }
     else
     {
         pd.value = val;
     }
 
+    JS_EndRequest(cx);
+
     pd.id = STRING_TO_JSVAL(name);
     pd.alias = pd.slot = pd.spare = 0;
     pd.flags |= (attrs & JSPROP_ENUMERATE) ? JSPD_ENUMERATE : 0
         | (attrs & JSPROP_READONLY)  ? JSPD_READONLY  : 0
         | (attrs & JSPROP_PERMANENT) ? JSPD_PERMANENT : 0;
 
     return _newProperty(jsdc, &pd, JSDPD_HINTED);
 }
@@ -502,17 +534,20 @@ jsd_GetValuePrototype(JSDContext* jsdc, 
         JSObject* obj;
         JSObject* proto;
         JS_ASSERT(!jsdval->proto);
         SET_BIT_FLAG(jsdval->flags, GOT_PROTO);
         if(!JSVAL_IS_OBJECT(jsdval->val))
             return NULL;
         if(!(obj = JSVAL_TO_OBJECT(jsdval->val)))
             return NULL;
-        if(!(proto = JS_GetPrototype(jsdc->dumbContext, obj)))
+        JS_BeginRequest(jsdc->dumbContext);
+        proto = JS_GetPrototype(jsdc->dumbContext,obj);
+        JS_EndRequest(jsdc->dumbContext);
+        if(!proto)
             return NULL;
         jsdval->proto = jsd_NewValue(jsdc, OBJECT_TO_JSVAL(proto));
     }
     if(jsdval->proto)
         jsdval->proto->nref++;
     return jsdval->proto;
 }
 
@@ -524,17 +559,20 @@ jsd_GetValueParent(JSDContext* jsdc, JSD
         JSObject* obj;
         JSObject* parent;
         JS_ASSERT(!jsdval->parent);
         SET_BIT_FLAG(jsdval->flags, GOT_PARENT);
         if(!JSVAL_IS_OBJECT(jsdval->val))
             return NULL;
         if(!(obj = JSVAL_TO_OBJECT(jsdval->val)))
             return NULL;
-        if(!(parent = JS_GetParent(jsdc->dumbContext,obj)))
+        JS_BeginRequest(jsdc->dumbContext);
+        parent = JS_GetParent(jsdc->dumbContext,obj);
+        JS_EndRequest(jsdc->dumbContext);
+        if(!parent)
             return NULL;
         jsdval->parent = jsd_NewValue(jsdc, OBJECT_TO_JSVAL(parent));
     }
     if(jsdval->parent)
         jsdval->parent->nref++;
     return jsdval->parent;
 }
 
@@ -549,17 +587,20 @@ jsd_GetValueConstructor(JSDContext* jsdc
         JS_ASSERT(!jsdval->ctor);
         SET_BIT_FLAG(jsdval->flags, GOT_CTOR);
         if(!JSVAL_IS_OBJECT(jsdval->val))
             return NULL;
         if(!(obj = JSVAL_TO_OBJECT(jsdval->val)))
             return NULL;
         if(!(proto = JS_GetPrototype(jsdc->dumbContext,obj)))
             return NULL;
-        if(!(ctor = JS_GetConstructor(jsdc->dumbContext,proto)))
+        JS_BeginRequest(jsdc->dumbContext);
+        ctor = JS_GetConstructor(jsdc->dumbContext,proto);
+        JS_EndRequest(jsdc->dumbContext);
+        if(!ctor)
             return NULL;
         jsdval->ctor = jsd_NewValue(jsdc, OBJECT_TO_JSVAL(ctor));
     }
     if(jsdval->ctor)
         jsdval->ctor->nref++;
     return jsdval->ctor;
 }
 
@@ -567,18 +608,20 @@ const char*
 jsd_GetValueClassName(JSDContext* jsdc, JSDValue* jsdval)
 {
     jsval val = jsdval->val;
     if(!jsdval->className && JSVAL_IS_OBJECT(val))
     {
         JSObject* obj;
         if(!(obj = JSVAL_TO_OBJECT(val)))
             return NULL;
+        JS_BeginRequest(jsdc->dumbContext);
         if(JS_GET_CLASS(jsdc->dumbContext, obj))
             jsdval->className = JS_GET_CLASS(jsdc->dumbContext, obj)->name;
+        JS_EndRequest(jsdc->dumbContext);
     }
     return jsdval->className;
 }
 
 /***************************************************************************/
 /***************************************************************************/
 
 JSDValue*
Index: js/jsd/jsd_xpc.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/jsd/jsd_xpc.cpp,v
retrieving revision 1.72.2.1
diff -U8 -p -r1.72.2.1 jsd_xpc.cpp
--- js/jsd/jsd_xpc.cpp	20 Jun 2006 15:54:58 -0000	1.72.2.1
+++ js/jsd/jsd_xpc.cpp	13 Jul 2006 18:26:12 -0000
@@ -1012,16 +1012,17 @@ jsdScript::~jsdScript () 
  * This method populates a line <-> pc map for a pretty printed version of this
  * script.  It does this by decompiling, and then recompiling the script.  The
  * resulting script is scanned for the line map, and then left as GC fodder.
  */
 PCMapEntry *
 jsdScript::CreatePPLineMap()
 {    
     JSContext  *cx  = JSD_GetDefaultJSContext (mCx);
+    JSAutoRequest ar(cx);
     JSObject   *obj = JS_NewObject(cx, NULL, NULL, NULL);
     JSFunction *fun = JSD_GetJSFunction (mCx, mScript);
     JSScript   *script;
     PRUint32    baseLine;
     PRBool      scriptOwner = PR_FALSE;
     
     if (fun) {
         if (fun->nargs > 12)
@@ -1257,28 +1258,29 @@ jsdScript::GetFunctionSource(nsAString &
 {
     ASSERT_VALID_EPHEMERAL;
     JSContext *cx = JSD_GetDefaultJSContext (mCx);
     if (!cx) {
         NS_WARNING("No default context !?");
         return NS_ERROR_FAILURE;
     }
     JSFunction *fun = JSD_GetJSFunction (mCx, mScript);
+
+    JSAutoRequest ar(cx);
+
     JSString *jsstr;
     if (fun)
-    {
         jsstr = JS_DecompileFunction (cx, fun, 4);
-    }
-    else
-    {
+    else {
         JSScript *script = JSD_GetJSScript (mCx, mScript);
         jsstr = JS_DecompileScript (cx, script, "ppscript", 4);
     }
     if (!jsstr)
         return NS_ERROR_FAILURE;
+
     aFunctionSource = NS_REINTERPRET_CAST(PRUnichar*, JS_GetStringChars(jsstr));
     return NS_OK;
 }
 
 NS_IMETHODIMP
 jsdScript::GetBaseLineNumber(PRUint32 *_rval)
 {
     *_rval = mBaseLineNumber;
@@ -1906,31 +1908,35 @@ jsdStackFrame::Eval (const nsAString &by
     nsAString::const_iterator h;
     bytes.BeginReading(h);
     const jschar *char_bytes = NS_REINTERPRET_CAST(const jschar *, h.get());
 
     JSExceptionState *estate = 0;
     jsval jv;
 
     JSContext *cx = JSD_GetJSContext (mCx, mThreadState);
+
+    JSAutoRequest ar(cx);
+
     estate = JS_SaveExceptionState (cx);
     JS_ClearPendingException (cx);
 
     *_rval = JSD_AttemptUCScriptInStackFrame (mCx, mThreadState,
                                               mStackFrameInfo,
                                               char_bytes, bytes.Length(),
                                               fileName, line, &jv);
     if (!*_rval) {
         if (JS_IsExceptionPending(cx))
             JS_GetPendingException (cx, &jv);
         else
             jv = 0;
     }
 
     JS_RestoreExceptionState (cx, estate);
+
     JSDValue *jsdv = JSD_NewValue (mCx, jv);
     if (!jsdv)
         return NS_ERROR_FAILURE;
     *result = jsdValue::FromPtr (mCx, jsdv);
     if (!*result)
         return NS_ERROR_FAILURE;
     
     return NS_OK;
@@ -2226,18 +2232,23 @@ jsdValue::GetProperties (jsdIProperty **
     return NS_OK;
 }
 
 NS_IMETHODIMP
 jsdValue::GetProperty (const char *name, jsdIProperty **_rval)
 {
     ASSERT_VALID_EPHEMERAL;
     JSContext *cx = JSD_GetDefaultJSContext (mCx);
+
+    JSAutoRequest ar(cx);
+
     /* not rooting this */
     JSString *jstr_name = JS_NewStringCopyZ (cx, name);
+    if (!jstr_name)
+        return NS_ERROR_OUT_OF_MEMORY;
 
     JSDProperty *prop = JSD_GetValueProperty (mCx, mValue, jstr_name);
     
     *_rval = jsdProperty::FromPtr (mCx, prop);
     return NS_OK;
 }
 
 NS_IMETHODIMP
Index: js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp,v
retrieving revision 1.18.56.2
diff -U8 -p -r1.18.56.2 mozJSSubScriptLoader.cpp
--- js/src/xpconnect/loader/mozJSSubScriptLoader.cpp	24 Jun 2006 02:27:01 -0000	1.18.56.2
+++ js/src/xpconnect/loader/mozJSSubScriptLoader.cpp	13 Jul 2006 18:26:15 -0000
@@ -132,16 +132,18 @@ mozJSSubScriptLoader::LoadSubScript (con
         if (!secman)
             return rv;
 
         rv = secman->GetSystemPrincipal(getter_AddRefs(mSystemPrincipal));
         if (NS_FAILED(rv) || !mSystemPrincipal)
             return rv;
 
     }
+
+    JSAutoRequest ar(cx);
     
     char     *url;
     JSObject *target_obj = nsnull;
     ok = JS_ConvertArguments (cx, argc, argv, "s / o", &url, &target_obj);
     if (!ok)
     {
         cc->SetExceptionWasThrown (JS_TRUE);
         /* let the exception raised by JS_ConvertArguments show through */
Index: js/src/xpconnect/shell/xpcshell.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/shell/xpcshell.cpp,v
retrieving revision 1.87.2.1
diff -U8 -p -r1.87.2.1 xpcshell.cpp
--- js/src/xpconnect/shell/xpcshell.cpp	1 Sep 2005 23:21:12 -0000	1.87.2.1
+++ js/src/xpconnect/shell/xpcshell.cpp	13 Jul 2006 18:26:15 -0000
@@ -1082,22 +1082,29 @@ main(int argc, char **argv, char **envp)
         if (NS_FAILED(rv))
             return 1;
         
         rv = holder->GetJSObject(&glob);
         if (NS_FAILED(rv)) {
             NS_ASSERTION(glob == nsnull, "bad GetJSObject?");
             return 1;
         }
-        if (!JS_DefineFunctions(cx, glob, glob_functions))
+
+        JS_BeginRequest(cx);
+
+        if (!JS_DefineFunctions(cx, glob, glob_functions)) {
+            JS_EndRequest(cx);
             return 1;
+        }
 
         envobj = JS_DefineObject(cx, glob, "environment", &env_class, NULL, 0);
-        if (!envobj || !JS_SetPrivate(cx, envobj, envp))
+        if (!envobj || !JS_SetPrivate(cx, envobj, envp)) {
+            JS_EndRequest(cx);
             return 1;
+        }
 
         argc--;
         argv++;
 
         result = ProcessArgs(cx, glob, argv, argc);
 
 
 //#define TEST_CALL_ON_WRAPPED_JS_AFTER_SHUTDOWN 1
Index: js/src/xpconnect/src/XPCNativeWrapper.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/XPCNativeWrapper.cpp,v
retrieving revision 1.31.2.9
diff -U8 -p -r1.31.2.9 XPCNativeWrapper.cpp
--- js/src/xpconnect/src/XPCNativeWrapper.cpp	15 Jun 2006 03:59:46 -0000	1.31.2.9
+++ js/src/xpconnect/src/XPCNativeWrapper.cpp	13 Jul 2006 18:26:16 -0000
@@ -688,16 +688,18 @@ XPC_NW_NewResolve(JSContext *cx, JSObjec
   // the wrapped native's object.
 
   if (ShouldBypassNativeWrapper(cx, obj)) {
     XPCWrappedNative *wn = XPCNativeWrapper::GetWrappedNative(cx, obj);
     if (!wn) {
       return JS_TRUE;
     }
 
+    JSAutoRequest ar(cx);
+
     jsid interned_id;
     JSObject *pobj;
     JSProperty *prop;
 
     if (!::JS_ValueToId(cx, id, &interned_id) ||
         !OBJ_LOOKUP_PROPERTY(cx, wn->GetFlatJSObject(), interned_id,
                              &pobj, &prop)) {
       return JS_FALSE;
@@ -872,18 +874,18 @@ XPC_NW_NewResolve(JSContext *cx, JSObjec
 #endif
 
     if (!WrapFunction(cx, funobj, &v)) {
       return JS_FALSE;
     }
   }
 
   if (!::JS_DefineUCProperty(cx, obj, ::JS_GetStringChars(str),
-                             ::JS_GetStringLength(str), v, nsnull, nsnull,
-                             attrs)) {
+                            ::JS_GetStringLength(str), v, nsnull, nsnull,
+                            attrs)) {
     return JS_FALSE;
   }
 
   *objp = obj;
 
   return JS_TRUE;
 }
 
Index: js/src/xpconnect/src/xpcdebug.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcdebug.cpp,v
retrieving revision 1.14
diff -U8 -p -r1.14 xpcdebug.cpp
--- js/src/xpconnect/src/xpcdebug.cpp	23 May 2005 21:00:06 -0000	1.14
+++ js/src/xpconnect/src/xpcdebug.cpp	13 Jul 2006 18:26:18 -0000
@@ -43,16 +43,17 @@
 
 #ifdef TAB
 #undef TAB
 #endif
 #define TAB "    "
 
 static const char* JSVAL2String(JSContext* cx, jsval val, JSBool* isString)
 {
+    JSAutoRequest ar(cx);
     const char* value = nsnull;
     JSString* value_str = JS_ValueToString(cx, val);
     if(value_str)
         value = JS_GetStringBytes(value_str);
     if(value)
     {
         const char* found = strstr(value, "function ");
         if(found && (value == found || value+1 == found || value+2 == found))
@@ -84,16 +85,19 @@ static char* FormatJSFrame(JSContext* cx
     const char* name;
     const char* value;
     JSBool isString;
 
     // get the info for this stack frame
 
     JSScript* script = JS_GetFrameScript(cx, fp);
     jsbytecode* pc = JS_GetFramePC(cx, fp);
+
+    JSAutoRequest ar(cx);
+
     if(script && pc)
     {
         filename = JS_GetScriptFilename(cx, script);
         lineno =  (PRInt32) JS_PCToLineNumber(cx, script, pc);
         fun = JS_GetFrameFunction(cx, fp);
         if(fun)
             funname = JS_GetFunctionName(fun);
 
@@ -332,16 +336,18 @@ xpc_DumpEvalInJSStackFrame(JSContext* cx
     }
 
     if(!fp)
     {
         puts("invalid frame number!");
         return JS_FALSE;
     }
 
+    JSAutoRequest ar(cx);
+
     JSExceptionState* exceptionState = JS_SaveExceptionState(cx);
     JSErrorReporter older = JS_SetErrorReporter(cx, xpcDumpEvalErrorReporter);
 
     jsval rval;
     JSString* str;
     const char* chars;
     if(JS_EvaluateInStackFrame(cx, fp, text, strlen(text), "eval", 1, &rval) &&
        nsnull != (str = JS_ValueToString(cx, rval)) &&
Index: js/src/xpconnect/src/xpcjsruntime.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcjsruntime.cpp,v
retrieving revision 1.43
diff -U8 -p -r1.43 xpcjsruntime.cpp
--- js/src/xpconnect/src/xpcjsruntime.cpp	15 Jun 2005 00:23:32 -0000	1.43
+++ js/src/xpconnect/src/xpcjsruntime.cpp	13 Jul 2006 18:26:19 -0000
@@ -907,17 +907,20 @@ XPCJSRuntime::SyncXPCContextList(JSConte
         }
         if(xpcc)
         {
             xpcc->Mark();
         }
 
         // if it is our first context then we need to generate our string ids
         if(!mStrIDs[0])
+        {
+            JSAutoRequest ar(cur);
             GenerateStringIDs(cur);
+        }
 
         if(cx && cx == cur)
             found = xpcc;
     }
     // get rid of any XPCContexts that represent dead JSContexts
     mContextMap->Enumerate(SweepContextsCB, 0);
 
     XPCPerThreadData* tls = XPCPerThreadData::GetData();
Index: js/src/xpconnect/src/xpcwrappednativeinfo.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcwrappednativeinfo.cpp,v
retrieving revision 1.12.4.3
diff -U8 -p -r1.12.4.3 xpcwrappednativeinfo.cpp
--- js/src/xpconnect/src/xpcwrappednativeinfo.cpp	10 Mar 2006 18:38:07 -0000	1.12.4.3
+++ js/src/xpconnect/src/xpcwrappednativeinfo.cpp	13 Jul 2006 18:26:20 -0000
@@ -175,16 +175,18 @@ XPCNativeMember::Resolve(XPCCallContext&
         if(IsWritableAttribute())
             flags = JSFUN_GETTER | JSFUN_SETTER;
         else
             flags = JSFUN_GETTER;
         argc = 0;
         callback = XPC_WN_GetterSetter;
     }
 
+    JSAutoRequest ar(cx);
+
     JSFunction *fun = JS_NewFunction(cx, callback, argc, flags, nsnull,
                                      iface->GetMemberName(ccx, this));
     if(!fun)
         return JS_FALSE;
 
     JSObject* funobj = JS_GetFunctionObject(fun);
     if(!funobj)
         return JS_FALSE;
Index: modules/plugin/base/src/ns4xPlugin.cpp
===================================================================
RCS file: /cvsroot/mozilla/modules/plugin/base/src/ns4xPlugin.cpp,v
retrieving revision 1.127.2.3
diff -U8 -p -r1.127.2.3 ns4xPlugin.cpp
--- modules/plugin/base/src/ns4xPlugin.cpp	16 Feb 2006 00:25:45 -0000	1.127.2.3
+++ modules/plugin/base/src/ns4xPlugin.cpp	13 Jul 2006 18:26:28 -0000
@@ -1553,16 +1553,17 @@ _getstringidentifier(const NPUTF8* name)
   if (!stack)
     return NULL;
 
   JSContext *cx = nsnull;
   stack->GetSafeJSContext(&cx);
   if (!cx)
     return NULL;
 
+  JSAutoRequest ar(cx);
   return doGetIdentifier(cx, name);
 }
 
 void NP_EXPORT
 _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
                       NPIdentifier *identifiers)
 {
   nsCOMPtr<nsIThreadJSContextStack> stack =
@@ -1570,16 +1571,18 @@ _getstringidentifiers(const NPUTF8** nam
   if (!stack)
     return;
 
   JSContext *cx = nsnull;
   stack->GetSafeJSContext(&cx);
   if (!cx)
     return;
 
+  JSAutoRequest ar(cx);
+
   for (int32_t i = 0; i < nameCount; ++i) {
     identifiers[i] = doGetIdentifier(cx, names[i]);
   }
 }
 
 NPIdentifier NP_EXPORT
 _getintidentifier(int32_t intid)
 {
Index: modules/plugin/base/src/nsJSNPRuntime.cpp
===================================================================
RCS file: /cvsroot/mozilla/modules/plugin/base/src/nsJSNPRuntime.cpp,v
retrieving revision 1.7.2.5
diff -U8 -p -r1.7.2.5 nsJSNPRuntime.cpp
--- modules/plugin/base/src/nsJSNPRuntime.cpp	25 Mar 2006 00:59:41 -0000	1.7.2.5
+++ modules/plugin/base/src/nsJSNPRuntime.cpp	13 Jul 2006 18:26:28 -0000
@@ -496,16 +496,17 @@ nsJSObjWrapper::NP_HasMethod(NPObject *n
   JSContext *cx = GetJSContext(npp);
 
   if (!cx || !npobj) {
     return PR_FALSE;
   }
 
   nsJSObjWrapper *npjsobj = (nsJSObjWrapper *)npobj;
   jsval v;
+  JSAutoRequest ar(cx);
   JSBool ok = GetProperty(cx, npjsobj->mJSObj, identifier, &v);
 
   return ok && !JSVAL_IS_PRIMITIVE(v) &&
     ::JS_ObjectIsFunction(cx, JSVAL_TO_OBJECT(v));
 }
 
 static bool
 doInvoke(NPObject *npobj, NPIdentifier method, const NPVariant *args,
@@ -515,16 +516,18 @@ doInvoke(NPObject *npobj, NPIdentifier m
   JSContext *cx = GetJSContext(npp);
 
   if (!cx || !npobj || !result) {
     // XXX: Throw null-ptr exception
 
     return PR_FALSE;
   }
 
+  JSAutoRequest ar(cx);
+
   // Initialize *result
   VOID_TO_NPVARIANT(*result);
 
   nsJSObjWrapper *npjsobj = (nsJSObjWrapper *)npobj;
   jsval fv;
 
   AutoCXPusher pusher(cx);
 
@@ -605,16 +608,18 @@ nsJSObjWrapper::NP_HasProperty(NPObject 
 
     return PR_FALSE;
   }
 
   nsJSObjWrapper *npjsobj = (nsJSObjWrapper *)npobj;
   jsval id = (jsval)identifier;
   JSBool found, ok = JS_FALSE;
 
+  JSAutoRequest ar(cx);
+
   if (JSVAL_IS_STRING(id)) {
     JSString *str = JSVAL_TO_STRING(id);
 
     ok = ::JS_HasUCProperty(cx, npjsobj->mJSObj, ::JS_GetStringChars(str),
                             ::JS_GetStringLength(str), &found);
   } else {
     NS_ASSERTION(JSVAL_IS_INT(id), "id must be either string or int!\n");
 
@@ -635,16 +640,17 @@ nsJSObjWrapper::NP_GetProperty(NPObject 
   if (!cx || !npobj)
     return PR_FALSE;
 
   nsJSObjWrapper *npjsobj = (nsJSObjWrapper *)npobj;
 
   AutoCXPusher pusher(cx);
 
   jsval v;
+  JSAutoRequest ar(cx);
   return (GetProperty(cx, npjsobj->mJSObj, identifier, &v) &&
           JSValToNPVariant(npp, cx, v, result));
 }
 
 // static
 bool
 nsJSObjWrapper::NP_SetProperty(NPObject *npobj, NPIdentifier identifier,
                                const NPVariant *value)
@@ -655,16 +661,17 @@ nsJSObjWrapper::NP_SetProperty(NPObject 
   if (!cx || !npobj)
     return PR_FALSE;
 
   nsJSObjWrapper *npjsobj = (nsJSObjWrapper *)npobj;
   jsval id = (jsval)identifier;
   JSBool ok = JS_FALSE;
 
   AutoCXPusher pusher(cx);
+  JSAutoRequest ar(cx);
 
   jsval v = NPVariantToJSVal(npp, cx, value);
 
   if (JSVAL_IS_STRING(id)) {
     JSString *str = JSVAL_TO_STRING(id);
 
     ok = ::JS_SetUCProperty(cx, npjsobj->mJSObj, ::JS_GetStringChars(str),
                             ::JS_GetStringLength(str), &v);
@@ -689,16 +696,17 @@ nsJSObjWrapper::NP_RemoveProperty(NPObje
   if (!cx || !npobj)
     return PR_FALSE;
 
   nsJSObjWrapper *npjsobj = (nsJSObjWrapper *)npobj;
   jsval id = (jsval)identifier;
   JSBool ok = JS_FALSE;
 
   AutoCXPusher pusher(cx);
+  JSAutoRequest ar(cx);
 
   if (JSVAL_IS_STRING(id)) {
     JSString *str = JSVAL_TO_STRING(id);
 
     jsval unused;
     ok = ::JS_DeleteUCProperty2(cx, npjsobj->mJSObj, ::JS_GetStringChars(str),
                                 ::JS_GetStringLength(str), &unused);
   } else {
@@ -833,16 +841,18 @@ nsJSObjWrapper::GetNewOrUsed(NPP npp, JS
   }
 
   wrapper->mJSObj = obj;
 
   entry->mJSObjWrapper = wrapper;
 
   NS_ASSERTION(wrapper->mNpp == npp, "nsJSObjWrapper::mNpp not initialized!");
 
+  JSAutoRequest ar(cx);
+
   // Root the JSObject, its lifetime is now tied to that of the
   // NPObject.
   if (!::JS_AddNamedRoot(cx, &wrapper->mJSObj, "nsJSObjWrapper::mJSObject")) {
     NS_ERROR("Failed to root JSObject!");
 
     _releaseobject(wrapper);
 
     PL_DHashTableRawRemove(&sJSObjWrappers, entry);
@@ -1265,16 +1275,18 @@ nsNPObjWrapper::GetNewOrUsed(NPP npp, JS
   if (PL_DHASH_ENTRY_IS_BUSY(entry) && entry->mJSObj) {
     // Found a live NPObject wrapper, return it.
     return entry->mJSObj;
   }
 
   entry->mNPObj = npobj;
   entry->mNpp = npp;
 
+  JSAutoRequest ar(cx);
+
   // No existing JSObject, create one.
 
   JSObject *obj = ::JS_NewObject(cx, &sNPObjectJSWrapperClass, nsnull, nsnull);
 
   if (!obj) {
     // OOM? Remove the stale entry from the hash.
 
     PL_DHashTableRawRemove(&sJSObjWrappers, entry);
