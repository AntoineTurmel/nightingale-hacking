? .mozconfig.mk
? a.out
? bug280236-classinfo-sb_0_2a_branch.patch
? compiled
? confdefs.h
? config.cache
? config.log
? sanity.diff
? sanity13.diff
Index: js/src/xpconnect/src/xpccomponents.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpccomponents.cpp,v
retrieving revision 1.75.2.12
diff -U8 -p -r1.75.2.12 xpccomponents.cpp
--- js/src/xpconnect/src/xpccomponents.cpp	7 Jul 2006 02:12:02 -0000	1.75.2.12
+++ js/src/xpconnect/src/xpccomponents.cpp	13 Jul 2006 18:37:07 -0000
@@ -42,16 +42,18 @@
 
 /* The "Components" xpcom objects for JavaScript. */
 
 #include "xpcprivate.h"
 #include "nsReadableUtils.h"
 #include "nsIScriptObjectPrincipal.h"
 #include "nsIDOMWindow.h"
 
+// XXX Need to make a base class.
+
 /***************************************************************************/
 // stuff used by all
 
 static nsresult ThrowAndFail(uintN errNum, JSContext* cx, JSBool* retval)
 {
     XPCThrower::Throw(errNum, cx);
     *retval = JS_FALSE;
     return NS_OK;
@@ -91,16 +93,116 @@ char * xpc_CheckAccessList(const PRUnich
     for(const char** p = list; *p; p++)
         if(!strcmp(*p, asciiName.get()))
             return xpc_CloneAllAccess();
 
     return nsnull;
 }
 #endif
 
+  /* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
+                         out nsIIDPtr array); */
+  NS_IMETHODIMP
+  nsXPCComponents_Interfaces::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+  {
+      nsresult rv = NS_OK;
+      PRUint32 count = 2;
+  #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
+      ++count;
+  #endif
+      *aCount = count;
+      nsIID **array;
+      *aArray = array = NS_STATIC_CAST(nsIID**, nsMemory::Alloc(count * sizeof(nsIID*)));
+      if(!array)
+          return NS_ERROR_OUT_OF_MEMORY;
+ 
+      PRUint32 index = 0;
+      nsIID* clone;
+  #define PUSH_IID(id) \
+      clone = NS_STATIC_CAST(nsIID *, nsMemory::Clone(&NS_GET_IID( id ), \
+                                                      sizeof(nsIID)));  \
+      if (!clone)                                                       \
+          goto oom;                                                     \
+      array[index++] = clone;
+ 
+      PUSH_IID(nsIScriptableInterfaces)
+      PUSH_IID(nsIXPCScriptable)
+  #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
+      PUSH_IID(nsISecurityCheckedComponent)
+  #endif
+  #undef PUSH_IID
+ 
+      return NS_OK;
+  oom:
+      while (index)
+          nsMemory::Free(array[--index]);
+      nsMemory::Free(array);
+      *aArray = nsnull;
+      return NS_ERROR_OUT_OF_MEMORY;
+  }
+ 
+  /* nsISupports getHelperForLanguage (in PRUint32 language); */
+  NS_IMETHODIMP
+  nsXPCComponents_Interfaces::GetHelperForLanguage(PRUint32 language,
+                                        nsISupports **retval)
+  {
+      *retval = nsnull;
+      return NS_OK;
+  }
+ 
+  /* readonly attribute string contractID; */
+  NS_IMETHODIMP
+  nsXPCComponents_Interfaces::GetContractID(char * *aContractID)
+  {
+      *aContractID = nsnull;
+      return NS_ERROR_NOT_AVAILABLE;
+  }
+ 
+  /* readonly attribute string classDescription; */
+  NS_IMETHODIMP
+  nsXPCComponents_Interfaces::GetClassDescription(char * *aClassDescription)
+  {
+      static const char classDescription[] = "XPCComponents_Interfaces";
+      *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
+      return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+  }
+ 
+  /* readonly attribute nsCIDPtr classID; */
+  NS_IMETHODIMP
+  nsXPCComponents_Interfaces::GetClassID(nsCID * *aClassID)
+  {
+      *aClassID = nsnull;
+      return NS_OK;
+  }
+ 
+  /* readonly attribute PRUint32 implementationLanguage; */
+  NS_IMETHODIMP
+  nsXPCComponents_Interfaces::GetImplementationLanguage(
+      PRUint32 *aImplementationLanguage)
+  {
+      *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+      return NS_OK;
+  }
+ 
+  /* readonly attribute PRUint32 flags; */
+  NS_IMETHODIMP
+  nsXPCComponents_Interfaces::GetFlags(PRUint32 *aFlags)
+  {
+      *aFlags = nsIClassInfo::THREADSAFE;
+      return NS_OK;
+  }
+ 
+  /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
+  NS_IMETHODIMP
+  nsXPCComponents_Interfaces::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+  {
+      return NS_ERROR_NOT_AVAILABLE;
+  }
+ 
+
 /***************************************************************************/
 
 nsXPCComponents_Interfaces::nsXPCComponents_Interfaces()
 {
     mManager = dont_AddRef(XPTI_GetInterfaceInfoManager());
 }
 
 nsXPCComponents_Interfaces::~nsXPCComponents_Interfaces()
@@ -120,16 +222,17 @@ NS_IMETHODIMP nsXPCComponents_Interfaces
 {
     mManager = aManager;
     return NS_OK;
 }
 
 NS_INTERFACE_MAP_BEGIN(nsXPCComponents_Interfaces)
   NS_INTERFACE_MAP_ENTRY(nsIScriptableInterfaces)
   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
 #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
   NS_INTERFACE_MAP_ENTRY(nsISecurityCheckedComponent)
 #endif
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIScriptableInterfaces)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_Interfaces)
 NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_Interfaces)
@@ -314,52 +417,154 @@ nsXPCComponents_Interfaces::CanSetProper
 #endif
 
 /***************************************************************************/
 /***************************************************************************/
 /***************************************************************************/
 
 class nsXPCComponents_InterfacesByID :
             public nsIScriptableInterfacesByID,
-            public nsIXPCScriptable
+            public nsIXPCScriptable,
+            public nsIClassInfo
 #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
           , public nsISecurityCheckedComponent
 #endif
 {
 public:
     // all the interface method declarations...
     NS_DECL_ISUPPORTS
     NS_DECL_NSISCRIPTABLEINTERFACESBYID
     NS_DECL_NSIXPCSCRIPTABLE
+    NS_DECL_NSICLASSINFO
 #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
     NS_DECL_NSISECURITYCHECKEDCOMPONENT
 #endif
 
 public:
     nsXPCComponents_InterfacesByID();
     virtual ~nsXPCComponents_InterfacesByID();
 
 private:
     nsCOMPtr<nsIInterfaceInfoManager> mManager;
 };
 
+/***************************************************************************/
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
+                       out nsIIDPtr array); */
+NS_IMETHODIMP
+nsXPCComponents_InterfacesByID::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+    nsresult rv = NS_OK;
+    PRUint32 count = 2;
+#ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
+    ++count;
+#endif
+    *aCount = count;
+    nsIID **array;
+    *aArray = array = NS_STATIC_CAST(nsIID**, nsMemory::Alloc(count * sizeof(nsIID*)));
+    if(!array)
+        return NS_ERROR_OUT_OF_MEMORY;
+ 
+    PRUint32 index = 0;
+    nsIID* clone;
+#define PUSH_IID(id) \
+    clone = NS_STATIC_CAST(nsIID *, nsMemory::Clone(&NS_GET_IID( id ), \
+                                                    sizeof(nsIID)));  \
+    if (!clone)                                                       \
+        goto oom;                                                     \
+    array[index++] = clone;
+ 
+    PUSH_IID(nsIScriptableInterfacesByID)
+    PUSH_IID(nsIXPCScriptable)
+#ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
+    PUSH_IID(nsISecurityCheckedComponent)
+#endif
+#undef PUSH_IID
+ 
+    return NS_OK;
+oom:
+    while (index)
+        nsMemory::Free(array[--index]);
+    nsMemory::Free(array);
+    *aArray = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+}
+ 
+/* nsISupports getHelperForLanguage (in PRUint32 language); */
+NS_IMETHODIMP
+nsXPCComponents_InterfacesByID::GetHelperForLanguage(PRUint32 language,
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+ 
+/* readonly attribute string contractID; */
+NS_IMETHODIMP
+nsXPCComponents_InterfacesByID::GetContractID(char * *aContractID)
+{
+    *aContractID = nsnull;
+    return NS_ERROR_NOT_AVAILABLE;
+}
+ 
+/* readonly attribute string classDescription; */
+NS_IMETHODIMP
+nsXPCComponents_InterfacesByID::GetClassDescription(char * *aClassDescription)
+{
+    static const char classDescription[] = "XPCComponents_Interfaces";
+    *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
+    return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+ 
+/* readonly attribute nsCIDPtr classID; */
+NS_IMETHODIMP
+nsXPCComponents_InterfacesByID::GetClassID(nsCID * *aClassID)
+{
+    *aClassID = nsnull;
+    return NS_OK;
+}
+ 
+/* readonly attribute PRUint32 implementationLanguage; */
+NS_IMETHODIMP
+nsXPCComponents_InterfacesByID::GetImplementationLanguage(
+    PRUint32 *aImplementationLanguage)
+{
+    *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+    return NS_OK;
+}
+ 
+/* readonly attribute PRUint32 flags; */
+NS_IMETHODIMP
+nsXPCComponents_InterfacesByID::GetFlags(PRUint32 *aFlags)
+{
+    *aFlags = nsIClassInfo::THREADSAFE;
+    return NS_OK;
+}
+ 
+/* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
+NS_IMETHODIMP
+nsXPCComponents_InterfacesByID::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+    return NS_ERROR_NOT_AVAILABLE;
+}
 
 nsXPCComponents_InterfacesByID::nsXPCComponents_InterfacesByID()
 {
     mManager = dont_AddRef(XPTI_GetInterfaceInfoManager());
 }
 
 nsXPCComponents_InterfacesByID::~nsXPCComponents_InterfacesByID()
 {
     // empty
 }
 
 NS_INTERFACE_MAP_BEGIN(nsXPCComponents_InterfacesByID)
   NS_INTERFACE_MAP_ENTRY(nsIScriptableInterfacesByID)
   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
 #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
   NS_INTERFACE_MAP_ENTRY(nsISecurityCheckedComponent)
 #endif
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIScriptableInterfacesByID)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_InterfacesByID)
 NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_InterfacesByID)
@@ -554,41 +759,140 @@ nsXPCComponents_InterfacesByID::CanSetPr
 #endif
 
 /***************************************************************************/
 /***************************************************************************/
 /***************************************************************************/
 
 
 
-class nsXPCComponents_Classes : public nsIXPCComponents_Classes, public nsIXPCScriptable
+class nsXPCComponents_Classes : 
+  public nsIXPCComponents_Classes,
+  public nsIXPCScriptable,
+  public nsIClassInfo
 {
 public:
     // all the interface method declarations...
     NS_DECL_ISUPPORTS
     NS_DECL_NSIXPCCOMPONENTS_CLASSES
     NS_DECL_NSIXPCSCRIPTABLE
+    NS_DECL_NSICLASSINFO
 
 public:
     nsXPCComponents_Classes();
     virtual ~nsXPCComponents_Classes();
 };
 
+/***************************************************************************/
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
+                       out nsIIDPtr array); */
+NS_IMETHODIMP 
+nsXPCComponents_Classes::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+    nsresult rv = NS_OK;
+    PRUint32 count = 2;
+    *aCount = count;
+    nsIID **array;
+    *aArray = array = NS_STATIC_CAST(nsIID**, nsMemory::Alloc(count * sizeof(nsIID*)));
+    if(!array)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    PRUint32 index = 0;
+    nsIID* clone;
+#define PUSH_IID(id) \
+    clone = NS_STATIC_CAST(nsIID *, nsMemory::Clone(&NS_GET_IID( id ), \
+                                                    sizeof(nsIID)));  \
+    if (!clone)                                                       \
+        goto oom;                                                     \
+    array[index++] = clone;
+
+    PUSH_IID(nsIXPCComponents_Classes)
+    PUSH_IID(nsIXPCScriptable)
+#undef PUSH_IID
+
+    return NS_OK;
+oom:
+    while (index)
+        nsMemory::Free(array[--index]);
+    nsMemory::Free(array);
+    *aArray = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* nsISupports getHelperForLanguage (in PRUint32 language); */
+NS_IMETHODIMP 
+nsXPCComponents_Classes::GetHelperForLanguage(PRUint32 language, 
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP 
+nsXPCComponents_Classes::GetContractID(char * *aContractID)
+{
+    *aContractID = nsnull;
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
+/* readonly attribute string classDescription; */
+NS_IMETHODIMP 
+nsXPCComponents_Classes::GetClassDescription(char * *aClassDescription)
+{
+    static const char classDescription[] = "XPCComponents_Classes";
+    *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
+    return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* readonly attribute nsCIDPtr classID; */
+NS_IMETHODIMP 
+nsXPCComponents_Classes::GetClassID(nsCID * *aClassID)
+{
+    *aClassID = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 implementationLanguage; */
+NS_IMETHODIMP 
+nsXPCComponents_Classes::GetImplementationLanguage(
+    PRUint32 *aImplementationLanguage)
+{
+    *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 flags; */
+NS_IMETHODIMP 
+nsXPCComponents_Classes::GetFlags(PRUint32 *aFlags)
+{
+    *aFlags = nsIClassInfo::THREADSAFE;
+    return NS_OK;
+}
+
+/* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
+NS_IMETHODIMP 
+nsXPCComponents_Classes::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 nsXPCComponents_Classes::nsXPCComponents_Classes()
 {
 }
 
 nsXPCComponents_Classes::~nsXPCComponents_Classes()
 {
     // empty
 }
 
 NS_INTERFACE_MAP_BEGIN(nsXPCComponents_Classes)
   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_Classes)
   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_Classes)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_Classes)
 NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_Classes)
 
 // The nsIXPCScriptable map declaration that will generate stubs for us...
 #define XPC_MAP_CLASSNAME           nsXPCComponents_Classes
@@ -711,41 +1015,140 @@ nsXPCComponents_Classes::NewResolve(nsIX
     }
     return NS_OK;
 }
 
 /***************************************************************************/
 /***************************************************************************/
 /***************************************************************************/
 
-class nsXPCComponents_ClassesByID : public nsIXPCComponents_ClassesByID, public nsIXPCScriptable
+class nsXPCComponents_ClassesByID :
+  public nsIXPCComponents_ClassesByID,
+  public nsIXPCScriptable,
+  public nsIClassInfo
 {
 public:
     // all the interface method declarations...
     NS_DECL_ISUPPORTS
     NS_DECL_NSIXPCCOMPONENTS_CLASSESBYID
     NS_DECL_NSIXPCSCRIPTABLE
+    NS_DECL_NSICLASSINFO
 
 public:
     nsXPCComponents_ClassesByID();
     virtual ~nsXPCComponents_ClassesByID();
 };
 
+/***************************************************************************/
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
+                       out nsIIDPtr array); */
+NS_IMETHODIMP 
+nsXPCComponents_ClassesByID::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+    nsresult rv = NS_OK;
+    PRUint32 count = 2;
+    *aCount = count;
+    nsIID **array;
+    *aArray = array = NS_STATIC_CAST(nsIID**, nsMemory::Alloc(count * sizeof(nsIID*)));
+    if(!array)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    PRUint32 index = 0;
+    nsIID* clone;
+#define PUSH_IID(id) \
+    clone = NS_STATIC_CAST(nsIID *, nsMemory::Clone(&NS_GET_IID( id ), \
+                                                    sizeof(nsIID)));  \
+    if (!clone)                                                       \
+        goto oom;                                                     \
+    array[index++] = clone;
+
+    PUSH_IID(nsIXPCComponents_ClassesByID)
+    PUSH_IID(nsIXPCScriptable)
+#undef PUSH_IID
+
+    return NS_OK;
+oom:
+    while (index)
+        nsMemory::Free(array[--index]);
+    nsMemory::Free(array);
+    *aArray = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* nsISupports getHelperForLanguage (in PRUint32 language); */
+NS_IMETHODIMP 
+nsXPCComponents_ClassesByID::GetHelperForLanguage(PRUint32 language, 
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP 
+nsXPCComponents_ClassesByID::GetContractID(char * *aContractID)
+{
+    *aContractID = nsnull;
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
+/* readonly attribute string classDescription; */
+NS_IMETHODIMP 
+nsXPCComponents_ClassesByID::GetClassDescription(char * *aClassDescription)
+{
+    static const char classDescription[] = "XPCComponents_Interfaces";
+    *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
+    return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* readonly attribute nsCIDPtr classID; */
+NS_IMETHODIMP 
+nsXPCComponents_ClassesByID::GetClassID(nsCID * *aClassID)
+{
+    *aClassID = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 implementationLanguage; */
+NS_IMETHODIMP 
+nsXPCComponents_ClassesByID::GetImplementationLanguage(
+    PRUint32 *aImplementationLanguage)
+{
+    *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 flags; */
+NS_IMETHODIMP 
+nsXPCComponents_ClassesByID::GetFlags(PRUint32 *aFlags)
+{
+    *aFlags = nsIClassInfo::THREADSAFE;
+    return NS_OK;
+}
+
+/* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
+NS_IMETHODIMP 
+nsXPCComponents_ClassesByID::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 nsXPCComponents_ClassesByID::nsXPCComponents_ClassesByID()
 {
 }
 
 nsXPCComponents_ClassesByID::~nsXPCComponents_ClassesByID()
 {
     // empty
 }
 
 NS_INTERFACE_MAP_BEGIN(nsXPCComponents_ClassesByID)
   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_ClassesByID)
   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_ClassesByID)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_ClassesByID)
 NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_ClassesByID)
 
 // The nsIXPCScriptable map declaration that will generate stubs for us...
 #define XPC_MAP_CLASSNAME           nsXPCComponents_ClassesByID
@@ -887,41 +1290,140 @@ nsXPCComponents_ClassesByID::NewResolve(
 }
 
 
 /***************************************************************************/
 
 // Currently the possible results do not change at runtime, so they are only
 // cached once (unlike ContractIDs, CLSIDs, and IIDs)
 
-class nsXPCComponents_Results : public nsIXPCComponents_Results, public nsIXPCScriptable
+class nsXPCComponents_Results :
+  public nsIXPCComponents_Results,
+  public nsIXPCScriptable,
+  public nsIClassInfo
 {
 public:
     // all the interface method declarations...
     NS_DECL_ISUPPORTS
     NS_DECL_NSIXPCCOMPONENTS_RESULTS
     NS_DECL_NSIXPCSCRIPTABLE
+    NS_DECL_NSICLASSINFO
 
 public:
     nsXPCComponents_Results();
     virtual ~nsXPCComponents_Results();
 };
 
+/***************************************************************************/
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
+                       out nsIIDPtr array); */
+NS_IMETHODIMP 
+nsXPCComponents_Results::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+    nsresult rv = NS_OK;
+    PRUint32 count = 2;
+    *aCount = count;
+    nsIID **array;
+    *aArray = array = NS_STATIC_CAST(nsIID**, nsMemory::Alloc(count * sizeof(nsIID*)));
+    if(!array)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    PRUint32 index = 0;
+    nsIID* clone;
+#define PUSH_IID(id) \
+    clone = NS_STATIC_CAST(nsIID *, nsMemory::Clone(&NS_GET_IID( id ), \
+                                                    sizeof(nsIID)));  \
+    if (!clone)                                                       \
+        goto oom;                                                     \
+    array[index++] = clone;
+
+    PUSH_IID(nsIXPCComponents_Results)
+    PUSH_IID(nsIXPCScriptable)
+#undef PUSH_IID
+
+    return NS_OK;
+oom:
+    while (index)
+        nsMemory::Free(array[--index]);
+    nsMemory::Free(array);
+    *aArray = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* nsISupports getHelperForLanguage (in PRUint32 language); */
+NS_IMETHODIMP 
+nsXPCComponents_Results::GetHelperForLanguage(PRUint32 language, 
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP 
+nsXPCComponents_Results::GetContractID(char * *aContractID)
+{
+    *aContractID = nsnull;
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
+/* readonly attribute string classDescription; */
+NS_IMETHODIMP 
+nsXPCComponents_Results::GetClassDescription(char * *aClassDescription)
+{
+    static const char classDescription[] = "XPCComponents_Interfaces";
+    *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
+    return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* readonly attribute nsCIDPtr classID; */
+NS_IMETHODIMP 
+nsXPCComponents_Results::GetClassID(nsCID * *aClassID)
+{
+    *aClassID = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 implementationLanguage; */
+NS_IMETHODIMP 
+nsXPCComponents_Results::GetImplementationLanguage(
+    PRUint32 *aImplementationLanguage)
+{
+    *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 flags; */
+NS_IMETHODIMP 
+nsXPCComponents_Results::GetFlags(PRUint32 *aFlags)
+{
+    *aFlags = nsIClassInfo::THREADSAFE;
+    return NS_OK;
+}
+
+/* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
+NS_IMETHODIMP 
+nsXPCComponents_Results::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 nsXPCComponents_Results::nsXPCComponents_Results()
 {
 }
 
 nsXPCComponents_Results::~nsXPCComponents_Results()
 {
     // empty
 }
 
 NS_INTERFACE_MAP_BEGIN(nsXPCComponents_Results)
   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_Results)
   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_Results)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_Results)
 NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_Results)
 
 // The nsIXPCScriptable map declaration that will generate stubs for us...
 #define XPC_MAP_CLASSNAME           nsXPCComponents_Results
@@ -1014,48 +1516,147 @@ nsXPCComponents_Results::NewResolve(nsIX
         }
     }
     return NS_OK;
 }
 
 /***************************************************************************/
 // JavaScript Constructor for nsIJSID objects (Components.ID)
 
-class nsXPCComponents_ID : public nsIXPCComponents_ID, public nsIXPCScriptable
+class nsXPCComponents_ID :
+  public nsIXPCComponents_ID,
+  public nsIXPCScriptable,
+  public nsIClassInfo
 {
 public:
     // all the interface method declarations...
     NS_DECL_ISUPPORTS
     NS_DECL_NSIXPCCOMPONENTS_ID
     NS_DECL_NSIXPCSCRIPTABLE
+    NS_DECL_NSICLASSINFO
 
 
 public:
     nsXPCComponents_ID();
     virtual ~nsXPCComponents_ID();
 
 private:
     NS_METHOD CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
                               JSContext * cx, JSObject * obj,
                               PRUint32 argc, jsval * argv,
                               jsval * vp, PRBool *_retval);
 };
 
+/***************************************************************************/
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
+                       out nsIIDPtr array); */
+NS_IMETHODIMP 
+nsXPCComponents_ID::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+    nsresult rv = NS_OK;
+    PRUint32 count = 2;
+    *aCount = count;
+    nsIID **array;
+    *aArray = array = NS_STATIC_CAST(nsIID**, nsMemory::Alloc(count * sizeof(nsIID*)));
+    if(!array)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    PRUint32 index = 0;
+    nsIID* clone;
+#define PUSH_IID(id) \
+    clone = NS_STATIC_CAST(nsIID *, nsMemory::Clone(&NS_GET_IID( id ), \
+                                                    sizeof(nsIID)));  \
+    if (!clone)                                                       \
+        goto oom;                                                     \
+    array[index++] = clone;
+
+    PUSH_IID(nsIXPCComponents_ID)
+    PUSH_IID(nsIXPCScriptable)
+#undef PUSH_IID
+
+    return NS_OK;
+oom:
+    while (index)
+        nsMemory::Free(array[--index]);
+    nsMemory::Free(array);
+    *aArray = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* nsISupports getHelperForLanguage (in PRUint32 language); */
+NS_IMETHODIMP 
+nsXPCComponents_ID::GetHelperForLanguage(PRUint32 language, 
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP 
+nsXPCComponents_ID::GetContractID(char * *aContractID)
+{
+    *aContractID = nsnull;
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
+/* readonly attribute string classDescription; */
+NS_IMETHODIMP 
+nsXPCComponents_ID::GetClassDescription(char * *aClassDescription)
+{
+    static const char classDescription[] = "XPCComponents_Interfaces";
+    *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
+    return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* readonly attribute nsCIDPtr classID; */
+NS_IMETHODIMP 
+nsXPCComponents_ID::GetClassID(nsCID * *aClassID)
+{
+    *aClassID = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 implementationLanguage; */
+NS_IMETHODIMP 
+nsXPCComponents_ID::GetImplementationLanguage(
+    PRUint32 *aImplementationLanguage)
+{
+    *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 flags; */
+NS_IMETHODIMP 
+nsXPCComponents_ID::GetFlags(PRUint32 *aFlags)
+{
+    *aFlags = nsIClassInfo::THREADSAFE;
+    return NS_OK;
+}
+
+/* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
+NS_IMETHODIMP 
+nsXPCComponents_ID::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 nsXPCComponents_ID::nsXPCComponents_ID()
 {
 }
 
 nsXPCComponents_ID::~nsXPCComponents_ID()
 {
     // empty
 }
 
 NS_INTERFACE_MAP_BEGIN(nsXPCComponents_ID)
   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_ID)
   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_ID)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_ID)
 NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_ID)
 
 // The nsIXPCScriptable map declaration that will generate stubs for us...
 #define XPC_MAP_CLASSNAME           nsXPCComponents_ID
@@ -1143,48 +1744,147 @@ nsXPCComponents_ID::HasInstance(nsIXPCon
     if(bp)
         *bp = JSValIsInterfaceOfType(cx, val, NS_GET_IID(nsIJSID));
     return NS_OK;
 }
 
 /***************************************************************************/
 // JavaScript Constructor for nsIXPCException objects (Components.Exception)
 
-class nsXPCComponents_Exception : public nsIXPCComponents_Exception, public nsIXPCScriptable
+class nsXPCComponents_Exception :
+  public nsIXPCComponents_Exception,
+  public nsIXPCScriptable,
+  public nsIClassInfo
 {
 public:
     // all the interface method declarations...
     NS_DECL_ISUPPORTS
     NS_DECL_NSIXPCCOMPONENTS_EXCEPTION
     NS_DECL_NSIXPCSCRIPTABLE
+    NS_DECL_NSICLASSINFO
 
 
 public:
     nsXPCComponents_Exception();
     virtual ~nsXPCComponents_Exception();
 
 private:
     NS_METHOD CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
                               JSContext * cx, JSObject * obj,
                               PRUint32 argc, jsval * argv,
                               jsval * vp, PRBool *_retval);
 };
 
+/***************************************************************************/
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
+                       out nsIIDPtr array); */
+NS_IMETHODIMP 
+nsXPCComponents_Exception::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+    nsresult rv = NS_OK;
+    PRUint32 count = 2;
+    *aCount = count;
+    nsIID **array;
+    *aArray = array = NS_STATIC_CAST(nsIID**, nsMemory::Alloc(count * sizeof(nsIID*)));
+    if(!array)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    PRUint32 index = 0;
+    nsIID* clone;
+#define PUSH_IID(id) \
+    clone = NS_STATIC_CAST(nsIID *, nsMemory::Clone(&NS_GET_IID( id ), \
+                                                    sizeof(nsIID)));  \
+    if (!clone)                                                       \
+        goto oom;                                                     \
+    array[index++] = clone;
+
+    PUSH_IID(nsIXPCComponents_Exception)
+    PUSH_IID(nsIXPCScriptable)
+#undef PUSH_IID
+
+    return NS_OK;
+oom:
+    while (index)
+        nsMemory::Free(array[--index]);
+    nsMemory::Free(array);
+    *aArray = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* nsISupports getHelperForLanguage (in PRUint32 language); */
+NS_IMETHODIMP 
+nsXPCComponents_Exception::GetHelperForLanguage(PRUint32 language, 
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP 
+nsXPCComponents_Exception::GetContractID(char * *aContractID)
+{
+    *aContractID = nsnull;
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
+/* readonly attribute string classDescription; */
+NS_IMETHODIMP 
+nsXPCComponents_Exception::GetClassDescription(char * *aClassDescription)
+{
+    static const char classDescription[] = "XPCComponents_Interfaces";
+    *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
+    return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* readonly attribute nsCIDPtr classID; */
+NS_IMETHODIMP 
+nsXPCComponents_Exception::GetClassID(nsCID * *aClassID)
+{
+    *aClassID = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 implementationLanguage; */
+NS_IMETHODIMP 
+nsXPCComponents_Exception::GetImplementationLanguage(
+    PRUint32 *aImplementationLanguage)
+{
+    *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 flags; */
+NS_IMETHODIMP 
+nsXPCComponents_Exception::GetFlags(PRUint32 *aFlags)
+{
+    *aFlags = nsIClassInfo::THREADSAFE;
+    return NS_OK;
+}
+
+/* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
+NS_IMETHODIMP 
+nsXPCComponents_Exception::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 nsXPCComponents_Exception::nsXPCComponents_Exception()
 {
 }
 
 nsXPCComponents_Exception::~nsXPCComponents_Exception()
 {
     // empty
 }
 
 NS_INTERFACE_MAP_BEGIN(nsXPCComponents_Exception)
   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_Exception)
   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_Exception)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_Exception)
 NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_Exception)
 
 // The nsIXPCScriptable map declaration that will generate stubs for us...
 #define XPC_MAP_CLASSNAME           nsXPCComponents_Exception
@@ -1330,25 +2030,29 @@ nsXPCComponents_Exception::HasInstance(n
 // it since it has no registed factory. Security really kicks in when we try
 // to build a wrapper around an instance.
 
 // {B4A95150-E25A-11d3-8F61-0010A4E73D9A}
 #define NS_XPCCONSTRUCTOR_CID  \
 { 0xb4a95150, 0xe25a, 0x11d3, \
     { 0x8f, 0x61, 0x0, 0x10, 0xa4, 0xe7, 0x3d, 0x9a } }
 
-class nsXPCConstructor : public nsIXPCConstructor, public nsIXPCScriptable
+class nsXPCConstructor :
+  public nsIXPCConstructor,
+  public nsIXPCScriptable,
+  public nsIClassInfo
 {
 public:
     NS_DEFINE_STATIC_CID_ACCESSOR(NS_XPCCONSTRUCTOR_CID)
 public:
     // all the interface method declarations...
     NS_DECL_ISUPPORTS
     NS_DECL_NSIXPCCONSTRUCTOR
     NS_DECL_NSIXPCSCRIPTABLE
+    NS_DECL_NSICLASSINFO
 
 public:
     nsXPCConstructor(); // not implemented
     nsXPCConstructor(nsIJSCID* aClassID,
                      nsIJSIID* aInterfaceID,
                      const char* aInitializer);
     virtual ~nsXPCConstructor();
 
@@ -1358,16 +2062,110 @@ private:
                               PRUint32 argc, jsval * argv,
                               jsval * vp, PRBool *_retval);
 private:
     nsIJSCID* mClassID;
     nsIJSIID* mInterfaceID;
     char*     mInitializer;
 };
 
+/***************************************************************************/
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
+                       out nsIIDPtr array); */
+NS_IMETHODIMP 
+nsXPCConstructor::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+    nsresult rv = NS_OK;
+    PRUint32 count = 2;
+    *aCount = count;
+    nsIID **array;
+    *aArray = array = NS_STATIC_CAST(nsIID**, nsMemory::Alloc(count * sizeof(nsIID*)));
+    if(!array)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    PRUint32 index = 0;
+    nsIID* clone;
+#define PUSH_IID(id) \
+    clone = NS_STATIC_CAST(nsIID *, nsMemory::Clone(&NS_GET_IID( id ), \
+                                                    sizeof(nsIID)));  \
+    if (!clone)                                                       \
+        goto oom;                                                     \
+    array[index++] = clone;
+
+    PUSH_IID(nsIXPCConstructor)
+    PUSH_IID(nsIXPCScriptable)
+#undef PUSH_IID
+
+    return NS_OK;
+oom:
+    while (index)
+        nsMemory::Free(array[--index]);
+    nsMemory::Free(array);
+    *aArray = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* nsISupports getHelperForLanguage (in PRUint32 language); */
+NS_IMETHODIMP 
+nsXPCConstructor::GetHelperForLanguage(PRUint32 language, 
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP 
+nsXPCConstructor::GetContractID(char * *aContractID)
+{
+    *aContractID = nsnull;
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
+/* readonly attribute string classDescription; */
+NS_IMETHODIMP 
+nsXPCConstructor::GetClassDescription(char * *aClassDescription)
+{
+    static const char classDescription[] = "XPCComponents_Interfaces";
+    *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
+    return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* readonly attribute nsCIDPtr classID; */
+NS_IMETHODIMP 
+nsXPCConstructor::GetClassID(nsCID * *aClassID)
+{
+    *aClassID = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 implementationLanguage; */
+NS_IMETHODIMP 
+nsXPCConstructor::GetImplementationLanguage(
+    PRUint32 *aImplementationLanguage)
+{
+    *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 flags; */
+NS_IMETHODIMP 
+nsXPCConstructor::GetFlags(PRUint32 *aFlags)
+{
+    *aFlags = nsIClassInfo::THREADSAFE;
+    return NS_OK;
+}
+
+/* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
+NS_IMETHODIMP 
+nsXPCConstructor::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 nsXPCConstructor::nsXPCConstructor(nsIJSCID* aClassID,
                                    nsIJSIID* aInterfaceID,
                                    const char* aInitializer)
 {
     NS_IF_ADDREF(mClassID = aClassID);
     NS_IF_ADDREF(mInterfaceID = aInterfaceID);
     mInitializer = aInitializer ?
         (char*) nsMemory::Clone(aInitializer, strlen(aInitializer)+1) :
@@ -1403,16 +2201,17 @@ NS_IMETHODIMP
 nsXPCConstructor::GetInitializer(char * *aInitializer)
 {
     XPC_STRING_GETTER_BODY(aInitializer, mInitializer);
 }
 
 NS_INTERFACE_MAP_BEGIN(nsXPCConstructor)
   NS_INTERFACE_MAP_ENTRY(nsIXPCConstructor)
   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCConstructor)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMPL_THREADSAFE_ADDREF(nsXPCConstructor)
 NS_IMPL_THREADSAFE_RELEASE(nsXPCConstructor)
 
 // The nsIXPCScriptable map declaration that will generate stubs for us...
 #define XPC_MAP_CLASSNAME           nsXPCConstructor
@@ -1506,47 +2305,146 @@ nsXPCConstructor::CallOrConstruct(nsIXPC
     }
 
     return NS_OK;
 }
 
 /*******************************************************/
 // JavaScript Constructor for nsIXPCConstructor objects (Components.Constructor)
 
-class nsXPCComponents_Constructor : public nsIXPCComponents_Constructor, public nsIXPCScriptable
+class nsXPCComponents_Constructor :
+  public nsIXPCComponents_Constructor,
+  public nsIXPCScriptable,
+  public nsIClassInfo
 {
 public:
     // all the interface method declarations...
     NS_DECL_ISUPPORTS
     NS_DECL_NSIXPCCOMPONENTS_CONSTRUCTOR
     NS_DECL_NSIXPCSCRIPTABLE
+    NS_DECL_NSICLASSINFO
 
 public:
     nsXPCComponents_Constructor();
     virtual ~nsXPCComponents_Constructor();
 
 private:
     NS_METHOD CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
                               JSContext * cx, JSObject * obj,
                               PRUint32 argc, jsval * argv,
                               jsval * vp, PRBool *_retval);
 };
 
+/***************************************************************************/
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
+                       out nsIIDPtr array); */
+NS_IMETHODIMP 
+nsXPCComponents_Constructor::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+    nsresult rv = NS_OK;
+    PRUint32 count = 2;
+    *aCount = count;
+    nsIID **array;
+    *aArray = array = NS_STATIC_CAST(nsIID**, nsMemory::Alloc(count * sizeof(nsIID*)));
+    if(!array)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    PRUint32 index = 0;
+    nsIID* clone;
+#define PUSH_IID(id) \
+    clone = NS_STATIC_CAST(nsIID *, nsMemory::Clone(&NS_GET_IID( id ), \
+                                                    sizeof(nsIID)));  \
+    if (!clone)                                                       \
+        goto oom;                                                     \
+    array[index++] = clone;
+
+    PUSH_IID(nsIXPCComponents_Constructor)
+    PUSH_IID(nsIXPCScriptable)
+#undef PUSH_IID
+
+    return NS_OK;
+oom:
+    while (index)
+        nsMemory::Free(array[--index]);
+    nsMemory::Free(array);
+    *aArray = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* nsISupports getHelperForLanguage (in PRUint32 language); */
+NS_IMETHODIMP 
+nsXPCComponents_Constructor::GetHelperForLanguage(PRUint32 language, 
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP 
+nsXPCComponents_Constructor::GetContractID(char * *aContractID)
+{
+    *aContractID = nsnull;
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
+/* readonly attribute string classDescription; */
+NS_IMETHODIMP 
+nsXPCComponents_Constructor::GetClassDescription(char * *aClassDescription)
+{
+    static const char classDescription[] = "XPCComponents_Interfaces";
+    *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
+    return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* readonly attribute nsCIDPtr classID; */
+NS_IMETHODIMP 
+nsXPCComponents_Constructor::GetClassID(nsCID * *aClassID)
+{
+    *aClassID = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 implementationLanguage; */
+NS_IMETHODIMP 
+nsXPCComponents_Constructor::GetImplementationLanguage(
+    PRUint32 *aImplementationLanguage)
+{
+    *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 flags; */
+NS_IMETHODIMP 
+nsXPCComponents_Constructor::GetFlags(PRUint32 *aFlags)
+{
+    *aFlags = nsIClassInfo::THREADSAFE;
+    return NS_OK;
+}
+
+/* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
+NS_IMETHODIMP 
+nsXPCComponents_Constructor::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 nsXPCComponents_Constructor::nsXPCComponents_Constructor()
 {
 }
 
 nsXPCComponents_Constructor::~nsXPCComponents_Constructor()
 {
     // empty
 }
 
 NS_INTERFACE_MAP_BEGIN(nsXPCComponents_Constructor)
   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_Constructor)
   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_Constructor)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_Constructor)
 NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_Constructor)
 
 // The nsIXPCScriptable map declaration that will generate stubs for us...
 #define XPC_MAP_CLASSNAME           nsXPCComponents_Constructor
@@ -2653,25 +3551,125 @@ nsXPCComponents_Utils::CanSetProperty(co
 /***************************************************************************/
 
 // XXXjband We ought to cache the wrapper in the object's slots rather than
 // re-wrapping on demand
 
 NS_INTERFACE_MAP_BEGIN(nsXPCComponents)
   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents)
   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
 #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
   NS_INTERFACE_MAP_ENTRY(nsISecurityCheckedComponent)
 #endif
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents)
 NS_INTERFACE_MAP_END_THREADSAFE
 
 NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents)
 NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents)
 
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
+                       out nsIIDPtr array); */
+NS_IMETHODIMP 
+nsXPCComponents::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+    nsresult rv = NS_OK;
+    PRUint32 count = 2;
+#ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
+    ++count;
+#endif
+    *aCount = count;
+    nsIID **array;
+    *aArray = array = NS_STATIC_CAST(nsIID**, nsMemory::Alloc(count * sizeof(nsIID*)));
+    if(!array)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    PRUint32 index = 0;
+    nsIID* clone;
+#define PUSH_IID(id) \
+    clone = NS_STATIC_CAST(nsIID *, nsMemory::Clone(&NS_GET_IID( id ), \
+                                                    sizeof(nsIID)));  \
+    if (!clone)                                                       \
+        goto oom;                                                     \
+    array[index++] = clone;
+
+    PUSH_IID(nsIXPCComponents)
+    PUSH_IID(nsIXPCScriptable)
+#ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
+    PUSH_IID(nsISecurityCheckedComponent)
+#endif
+#undef PUSH_IID
+
+    return NS_OK;
+oom:
+    while (index)
+        nsMemory::Free(array[--index]);
+    nsMemory::Free(array);
+    *aArray = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* nsISupports getHelperForLanguage (in PRUint32 language); */
+NS_IMETHODIMP 
+nsXPCComponents::GetHelperForLanguage(PRUint32 language, 
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP 
+nsXPCComponents::GetContractID(char * *aContractID)
+{
+    *aContractID = nsnull;
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
+/* readonly attribute string classDescription; */
+NS_IMETHODIMP 
+nsXPCComponents::GetClassDescription(char * *aClassDescription)
+{
+    static const char classDescription[] = "XPCComponents";
+    *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
+    return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* readonly attribute nsCIDPtr classID; */
+NS_IMETHODIMP 
+nsXPCComponents::GetClassID(nsCID * *aClassID)
+{
+    *aClassID = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 implementationLanguage; */
+NS_IMETHODIMP 
+nsXPCComponents::GetImplementationLanguage(
+    PRUint32 *aImplementationLanguage)
+{
+    *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 flags; */
+NS_IMETHODIMP 
+nsXPCComponents::GetFlags(PRUint32 *aFlags)
+{
+    *aFlags = nsIClassInfo::THREADSAFE;
+    return NS_OK;
+}
+
+/* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
+NS_IMETHODIMP 
+nsXPCComponents::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 nsXPCComponents::nsXPCComponents()
     :   mInterfaces(nsnull),
         mInterfacesByID(nsnull),
         mClasses(nsnull),
         mClassesByID(nsnull),
         mResults(nsnull),
         mID(nsnull),
         mException(nsnull),
Index: js/src/xpconnect/src/xpcconvert.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcconvert.cpp,v
retrieving revision 1.96.4.4
diff -U8 -p -r1.96.4.4 xpcconvert.cpp
--- js/src/xpconnect/src/xpcconvert.cpp	7 Jul 2006 02:12:02 -0000	1.96.4.4
+++ js/src/xpconnect/src/xpcconvert.cpp	13 Jul 2006 18:37:08 -0000
@@ -1268,29 +1268,35 @@ nsresult
 XPCConvert::ConstructException(nsresult rv, const char* message,
                                const char* ifaceName, const char* methodName,
                                nsISupports* data,
                                nsIException** exceptn)
 {
     static const char format[] = "\'%s\' when calling method: [%s::%s]";
     const char * msg = message;
     char* sz = nsnull;
+    nsXPIDLString xmsg;
+    nsCAutoString sxmsg;
 
+    nsCOMPtr<nsIScriptError> errorObject = do_QueryInterface(data);
+    if(errorObject) {
+        if (NS_SUCCEEDED(errorObject->GetMessage(getter_Copies(xmsg)))) {
+            CopyUTF16toUTF8(xmsg, sxmsg);
+            msg = sxmsg.get();
+        }
+    }
     if(!msg)
         if(!nsXPCException::NameAndFormatForNSResult(rv, nsnull, &msg) || ! msg)
             msg = "<error>";
-
     if(ifaceName && methodName)
-        sz = JS_smprintf(format, msg, ifaceName, methodName);
-    else
-        sz = (char*) msg; // I promise to play nice after casting away const
+        msg = sz = JS_smprintf(format, msg, ifaceName, methodName);
 
-    nsresult res = nsXPCException::NewException(sz, rv, nsnull, data, exceptn);
+    nsresult res = nsXPCException::NewException(msg, rv, nsnull, data, exceptn);
 
-    if(sz && sz != msg)
+    if(sz)
         JS_smprintf_free(sz);
     return res;
 }
 
 /********************************/
 
 // static
 nsresult
Index: js/src/xpconnect/src/xpcjsid.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcjsid.cpp,v
retrieving revision 1.66
diff -U8 -p -r1.66 xpcjsid.cpp
--- js/src/xpconnect/src/xpcjsid.cpp	7 Nov 2004 23:59:26 -0000	1.66
+++ js/src/xpconnect/src/xpcjsid.cpp	13 Jul 2006 18:37:08 -0000
@@ -292,33 +292,35 @@ NS_METHOD GetSharedScriptableHelperForJS
 
 /******************************************************/
 
 static JSBool gClassObjectsWereInited = JS_FALSE;
 
 NS_DECL_CI_INTERFACE_GETTER(nsJSIID)
 // Can't make this static. http://bugzilla.mozilla.org/show_bug.cgi?id=81436
 nsIClassInfo* NS_CLASSINFO_NAME(nsJSIID);
+
 static const nsModuleComponentInfo CI_nsJSIID =
     {"JSIID",
      {0x26ecb8d0, 0x35c9, 0x11d5, { 0x90, 0xb2, 0x0, 0x10, 0xa4, 0xe7, 0x3d, 0x9a }},
      nsnull, nsnull, nsnull,nsnull, nsnull,
      NS_CI_INTERFACE_GETTER_NAME(nsJSIID),
      GetSharedScriptableHelperForJSIID,
-     &NS_CLASSINFO_NAME(nsJSIID), 0};
+     &NS_CLASSINFO_NAME(nsJSIID), nsIClassInfo::THREADSAFE};
 
 NS_DECL_CI_INTERFACE_GETTER(nsJSCID)
 // Can't make this static. http://bugzilla.mozilla.org/show_bug.cgi?id=81436
 nsIClassInfo* NS_CLASSINFO_NAME(nsJSCID);
+
 static const nsModuleComponentInfo CI_nsJSCID =
     {"JSCID",
      {0x9255b5b0, 0x35cf, 0x11d5, { 0x90, 0xb2, 0x0, 0x10, 0xa4, 0xe7, 0x3d, 0x9a }},
      nsnull, nsnull, nsnull,nsnull, nsnull,
      NS_CI_INTERFACE_GETTER_NAME(nsJSCID), nsnull,
-     &NS_CLASSINFO_NAME(nsJSCID), 0};
+     &NS_CLASSINFO_NAME(nsJSCID), nsIClassInfo::THREADSAFE};
 
 JSBool xpc_InitJSxIDClassObjects()
 {
     if(gClassObjectsWereInited)
         return JS_TRUE;
 
     nsresult rv = NS_OK;
 
Index: js/src/xpconnect/src/xpcmodule.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcmodule.cpp,v
retrieving revision 1.40.28.2
diff -U8 -p -r1.40.28.2 xpcmodule.cpp
--- js/src/xpconnect/src/xpcmodule.cpp	16 May 2006 18:29:35 -0000	1.40.28.2
+++ js/src/xpconnect/src/xpcmodule.cpp	13 Jul 2006 18:37:09 -0000
@@ -83,17 +83,17 @@ NS_DECL_CLASSINFO(nsXPCException)
 
 static const nsModuleComponentInfo components[] = {
   {nsnull, NS_JS_ID_CID,                         XPC_ID_CONTRACTID,            nsJSIDConstructor             },
   {nsnull, NS_XPCONNECT_CID,                     XPC_XPCONNECT_CONTRACTID,     nsIXPConnectConstructor       },
   {nsnull, NS_XPC_THREAD_JSCONTEXT_STACK_CID,    XPC_CONTEXT_STACK_CONTRACTID, nsIJSContextStackConstructor  },
   {nsnull, NS_XPCEXCEPTION_CID,                  XPC_EXCEPTION_CONTRACTID,     nsXPCExceptionConstructor, nsnull, nsnull, nsnull, NS_CI_INTERFACE_GETTER_NAME(nsXPCException), nsnull, &NS_CLASSINFO_NAME(nsXPCException)},
   {nsnull, NS_JS_RUNTIME_SERVICE_CID,            XPC_RUNTIME_CONTRACTID,       nsIJSRuntimeServiceConstructor},
   {NS_SCRIPTERROR_CLASSNAME, NS_SCRIPTERROR_CID, NS_SCRIPTERROR_CONTRACTID,    nsScriptErrorConstructor      },
-  {nsnull, SCRIPTABLE_INTERFACES_CID,            NS_SCRIPTABLE_INTERFACES_CONTRACTID,        nsXPCComponents_InterfacesConstructor },
+  {nsnull, SCRIPTABLE_INTERFACES_CID,            NS_SCRIPTABLE_INTERFACES_CONTRACTID,        nsXPCComponents_InterfacesConstructor, 0, 0, 0, 0, 0, 0, nsIClassInfo::THREADSAFE },
   {nsnull, XPCVARIANT_CID,                       XPCVARIANT_CONTRACTID,        nsnull, nsnull, nsnull, nsnull, NS_CI_INTERFACE_GETTER_NAME(XPCVariant), nsnull, &NS_CLASSINFO_NAME(XPCVariant)},
   {nsnull, NS_XPC_JSCONTEXT_STACK_ITERATOR_CID,  XPC_JSCONTEXT_STACK_ITERATOR_CONTRACTID, nsXPCJSContextStackIteratorConstructor }
 
 #ifdef MOZ_JSLOADER
   // jsloader stuff
  ,{ "JS component loader", MOZJSCOMPONENTLOADER_CID,
     MOZJSCOMPONENTLOADER_CONTRACTID, mozJSComponentLoaderConstructor,
     RegisterJSLoader, UnregisterJSLoader }
Index: js/src/xpconnect/src/xpcprivate.h
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcprivate.h,v
retrieving revision 1.162.2.10
diff -U8 -p -r1.162.2.10 xpcprivate.h
--- js/src/xpconnect/src/xpcprivate.h	7 Jul 2006 02:12:02 -0000	1.162.2.10
+++ js/src/xpconnect/src/xpcprivate.h	13 Jul 2006 18:37:10 -0000
@@ -132,16 +132,18 @@
 #undef GetMessage
 #endif
 
 /***************************************************************************/
 // Compile time switches for instrumentation and stuff....
 
 // Note that one would not normally turn *any* of these on in a non-DEBUG build.
 
+#define DEBUG_xpc_hacker
+
 #if defined(DEBUG_jband) || defined(DEBUG_jst) || defined(DEBUG_dbradley) || defined(DEBUG_shaver_no) || defined(DEBUG_timeless)
 #define DEBUG_xpc_hacker
 #endif
 
 #if defined(DEBUG_brendan) || defined(DEBUG_bzbarsky)
 #define DEBUG_XPCNativeWrapper 1
 #endif
 
@@ -285,17 +287,17 @@ class XPCAutoLock : public nsAutoLockBas
 public:
 
     static XPCLock* NewLock(const char* name)
                         {return nsAutoMonitor::NewMonitor(name);}
     static void     DestroyLock(XPCLock* lock)
                         {nsAutoMonitor::DestroyMonitor(lock);}
 
     XPCAutoLock(XPCLock* lock)
-#ifdef DEBUG
+#ifdef DEBUG_jband
         : nsAutoLockBase(lock ? (void*) lock : (void*) this, eAutoMonitor),
 #else
         : nsAutoLockBase(lock, eAutoMonitor),
 #endif
           mLock(lock)
     {
         if(mLock)
             PR_EnterMonitor(mLock);
@@ -2079,21 +2081,19 @@ private:
         XPCWrappedNativeProto*   mMaybeProto;
     };
     XPCNativeSet*                mSet;
     JSObject*                    mFlatJSObject;
     XPCNativeScriptableInfo*     mScriptableInfo;
     XPCWrappedNativeTearOffChunk mFirstChunk;
     JSObject*                    mNativeWrapper;
 
-#ifdef XPC_CHECK_WRAPPER_THREADSAFETY
 public:
-    PRThread*          mThread; // Don't want to overload _mOwningThread
-    static PRThread*   gMainThread;
-#endif
+    PRThread*                    mThread; // Don't want to overload _mOwningThread
+    static PRThread*             gMainThread;
 };
 
 /***************************************************************************
 ****************************************************************************
 *
 * Core classes for wrapped JSObject for use from native code...
 *
 ****************************************************************************
@@ -2843,18 +2843,19 @@ public:
         {jsval old = mResolveName; mResolveName = name; return old;}
 
     XPCWrappedNative* GetResolvingWrapper() const {return mResolvingWrapper;}
     XPCWrappedNative* SetResolvingWrapper(XPCWrappedNative* w)
         {XPCWrappedNative* old = mResolvingWrapper;
          mResolvingWrapper = w; return old;}
 
     void Cleanup();
+    void ReleaseNatives();
 
-    PRBool IsValid() const {return mJSContextStack != nsnull;}
+    PRBool IsValid() const {return mJSContextStack && mNativesLock;}
 
     static PRLock* GetLock() {return gLock;}
     // Must be called with the threads locked.
     static XPCPerThreadData* IterateThreads(XPCPerThreadData** iteratorp);
 
     XPCContext* GetRecentXPCContext(JSContext* cx) const
         {return cx == mMostRecentJSContext ? mMostRecentXPCContext : nsnull;}
 
@@ -2895,16 +2896,19 @@ private:
     nsIExceptionManager* mExceptionManager;
     nsIException*        mException;
     JSBool               mExceptionManagerNotAvailable;
     AutoMarkingPtr*      mAutoRoots;
 
 #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
     JSUint32             mWrappedNativeThreadsafetyReportDepth;
 #endif
+    PRThread*            mThread;
+    nsVoidArray          mNativesToReleaseArray;
+    PRLock*              mNativesLock;
 
     static PRLock*           gLock;
     static XPCPerThreadData* gThreads;
     static PRUintn           gTLSIndex;
 };
 
 /**************************************************************/
 
@@ -2945,21 +2949,24 @@ private:
 {0xb5e65b52, 0x1dd1, 0x11b2, \
     { 0xae, 0x8f, 0xf0, 0x92, 0x8e, 0xd8, 0x84, 0x82 }}
 
 #ifndef XPCONNECT_STANDALONE
 #include "nsIScriptSecurityManager.h"
 #include "nsIPrincipal.h"
 #include "nsIScriptObjectPrincipal.h"
 
-class BackstagePass : public nsIScriptObjectPrincipal, public nsIXPCScriptable
+class BackstagePass : public nsIScriptObjectPrincipal,
+                      public nsIXPCScriptable,
+                      public nsIClassInfo
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIXPCSCRIPTABLE
+  NS_DECL_NSICLASSINFO
   
   virtual nsIPrincipal* GetPrincipal() {
     return mPrincipal;
   }
 
   BackstagePass(nsIPrincipal *prin) :
     mPrincipal(prin)
   {
@@ -2968,21 +2975,22 @@ public:
   virtual ~BackstagePass() { }
 
 private:
   nsCOMPtr<nsIPrincipal> mPrincipal;
 };
 
 #else
 
-class BackstagePass : public nsIXPCScriptable
+class BackstagePass : public nsIXPCScriptable, public nsIClassInfo
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIXPCSCRIPTABLE
+  NS_DECL_NSICLASSINFO
 
   BackstagePass()
   {
   }
 
   virtual ~BackstagePass() { }
 };
 
@@ -3011,25 +3019,27 @@ class nsJSRuntimeServiceImpl : public ns
     static nsJSRuntimeServiceImpl* gJSRuntimeService;
     nsCOMPtr<nsIXPCScriptable> mBackstagePass;
 };
 
 /***************************************************************************/
 // 'Components' object
 
 class nsXPCComponents : public nsIXPCComponents,
-                        public nsIXPCScriptable
+                        public nsIXPCScriptable,
+                        public nsIClassInfo
 #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
                       , public nsISecurityCheckedComponent
 #endif
 {
 public:
     NS_DECL_ISUPPORTS
     NS_DECL_NSIXPCCOMPONENTS
     NS_DECL_NSIXPCSCRIPTABLE
+    NS_DECL_NSICLASSINFO
 
 #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
     NS_DECL_NSISECURITYCHECKEDCOMPONENT
 #endif
 
 public:
     static JSBool
     AttachNewComponentsObject(XPCCallContext& ccx,
@@ -3055,26 +3065,28 @@ private:
     nsXPCComponents_Constructor*    mConstructor;
     nsXPCComponents_Utils*          mUtils;
 };
 
 /***************************************************************************/
 
 class nsXPCComponents_Interfaces :
             public nsIScriptableInterfaces,
-            public nsIXPCScriptable
+            public nsIXPCScriptable,
+            public nsIClassInfo
 #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
           , public nsISecurityCheckedComponent
 #endif
 {
 public:
     // all the interface method declarations...
     NS_DECL_ISUPPORTS
     NS_DECL_NSISCRIPTABLEINTERFACES
     NS_DECL_NSIXPCSCRIPTABLE
+    NS_DECL_NSICLASSINFO
 #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
     NS_DECL_NSISECURITYCHECKEDCOMPONENT
 #endif
 
 public:
     nsXPCComponents_Interfaces();
     virtual ~nsXPCComponents_Interfaces();
 
Index: js/src/xpconnect/src/xpcruntimesvc.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcruntimesvc.cpp,v
retrieving revision 1.18.6.1
diff -U8 -p -r1.18.6.1 xpcruntimesvc.cpp
--- js/src/xpconnect/src/xpcruntimesvc.cpp	23 Feb 2006 21:41:10 -0000	1.18.6.1
+++ js/src/xpconnect/src/xpcruntimesvc.cpp	13 Jul 2006 18:37:10 -0000
@@ -36,21 +36,27 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "xpcprivate.h"
 
+NS_INTERFACE_MAP_BEGIN(BackstagePass)
+  NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
 #ifndef XPCONNECT_STANDALONE
-NS_IMPL_THREADSAFE_ISUPPORTS2(BackstagePass, nsIScriptObjectPrincipal, nsIXPCScriptable)
-#else
-NS_IMPL_THREADSAFE_ISUPPORTS1(BackstagePass, nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY(nsIScriptObjectPrincipal)
 #endif
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCScriptable)
+NS_INTERFACE_MAP_END_THREADSAFE
+
+NS_IMPL_THREADSAFE_ADDREF(BackstagePass)
+NS_IMPL_THREADSAFE_RELEASE(BackstagePass)
 
 // The nsIXPCScriptable map declaration that will generate stubs for us...
 #define XPC_MAP_CLASSNAME           BackstagePass
 #define XPC_MAP_QUOTED_CLASSNAME   "BackstagePass"
 #define                             XPC_MAP_WANT_NEWRESOLVE
 #define XPC_MAP_FLAGS       nsIXPCScriptable::USE_JSSTUB_FOR_ADDPROPERTY   | \
                             nsIXPCScriptable::USE_JSSTUB_FOR_DELPROPERTY   | \
                             nsIXPCScriptable::USE_JSSTUB_FOR_SETPROPERTY   | \
@@ -69,16 +75,115 @@ BackstagePass::NewResolve(nsIXPConnectWr
     JSBool resolved;
 
     *_retval = JS_ResolveStandardClass(cx, obj, id, &resolved);
     if(*_retval && resolved)
         *objp = obj;
     return NS_OK;
 }
 
+/***************************************************************************/
+/* void getInterfaces (out PRUint32 count, [array, size_is (count), retval] 
+                       out nsIIDPtr array); */
+NS_IMETHODIMP 
+BackstagePass::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+    nsresult rv = NS_OK;
+    PRUint32 count = 1;
+#ifndef XPCONNECT_STANDALONE
+    ++count;
+#endif
+    *aCount = count;
+    nsIID **array;
+    *aArray = array = NS_STATIC_CAST(nsIID**, nsMemory::Alloc(count * sizeof(nsIID*)));
+    if(!array)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    PRUint32 index = 0;
+    nsIID* clone;
+#define PUSH_IID(id) \
+    clone = NS_STATIC_CAST(nsIID *, nsMemory::Clone(&NS_GET_IID( id ), \
+                                                    sizeof(nsIID)));  \
+    if (!clone)                                                       \
+        goto oom;                                                     \
+    array[index++] = clone;
+
+    PUSH_IID(nsIXPCScriptable)
+#ifndef XPCONNECT_STANDALONE
+    PUSH_IID(nsIScriptObjectPrincipal)
+#endif
+#undef PUSH_IID
+
+    return NS_OK;
+oom:
+    while (index)
+        nsMemory::Free(array[--index]);
+    nsMemory::Free(array);
+    *aArray = nsnull;
+    return NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* nsISupports getHelperForLanguage (in PRUint32 language); */
+NS_IMETHODIMP 
+BackstagePass::GetHelperForLanguage(PRUint32 language, 
+                                      nsISupports **retval)
+{
+    *retval = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute string contractID; */
+NS_IMETHODIMP 
+BackstagePass::GetContractID(char * *aContractID)
+{
+    *aContractID = nsnull;
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
+/* readonly attribute string classDescription; */
+NS_IMETHODIMP 
+BackstagePass::GetClassDescription(char * *aClassDescription)
+{
+    static const char classDescription[] = "BackstagePass";
+    *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
+    return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* readonly attribute nsCIDPtr classID; */
+NS_IMETHODIMP 
+BackstagePass::GetClassID(nsCID * *aClassID)
+{
+    *aClassID = nsnull;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 implementationLanguage; */
+NS_IMETHODIMP 
+BackstagePass::GetImplementationLanguage(
+    PRUint32 *aImplementationLanguage)
+{
+    *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+    return NS_OK;
+}
+
+/* readonly attribute PRUint32 flags; */
+NS_IMETHODIMP 
+BackstagePass::GetFlags(PRUint32 *aFlags)
+{
+    *aFlags = nsIClassInfo::THREADSAFE;
+    return NS_OK;
+}
+
+/* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
+NS_IMETHODIMP 
+BackstagePass::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 /*
  * This object holds state that we don't want to lose!
  *
  * The plan is that once created this object never goes away. We do an
  * intentional extra addref at construction to keep it around even if no one
  * is using it.
  */
 
@@ -132,17 +237,24 @@ const uint32 gGCSize = 4L * 1024L * 1024
 NS_IMETHODIMP
 nsJSRuntimeServiceImpl::GetRuntime(JSRuntime **runtime)
 {
     if(!runtime)
         return NS_ERROR_NULL_POINTER;
 
     if(!mRuntime)
     {
-        mRuntime = JS_NewRuntime(gGCSize);
+        char *jsrts = PR_GetEnv("JS_RUNTIME_SIZE");
+        uint32 size = jsrts ? atoi(jsrts) : 0;
+        if (size > 1) {
+            size *= 1024;
+        } else {
+            size = gGCSize;
+        }
+        mRuntime = JS_NewRuntime(size);
         if(!mRuntime)
             return NS_ERROR_OUT_OF_MEMORY;
 
         // Unconstrain the runtime's threshold on nominal heap size, to avoid
         // triggering GC too often if operating continuously near an arbitrary
         // finite threshold (0xffffffff is infinity for uint32 parameters).
         // This leaves the maximum-JS_malloc-bytes threshold still in effect
         // to cause period, and we hope hygienic, last-ditch GCs from within
