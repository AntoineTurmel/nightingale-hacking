Index: js/src/jsgc.c
===================================================================
RCS file: /cvsroot/mozilla/js/src/jsgc.c,v
retrieving revision 3.104.2.8
diff -p -u -1 -0 -r3.104.2.8 jsgc.c
--- js/src/jsgc.c	17 May 2006 16:25:30 -0000	3.104.2.8
+++ js/src/jsgc.c	19 May 2006 01:30:45 -0000
@@ -62,20 +62,24 @@
 #include "jsfun.h"
 #include "jsgc.h"
 #include "jsinterp.h"
 #include "jslock.h"
 #include "jsnum.h"
 #include "jsobj.h"
 #include "jsscope.h"
 #include "jsscript.h"
 #include "jsstr.h"
 
+#ifdef MOZILLA_CLIENT
+#include "nsTraceRefcnt.h"
+#endif
+
 #if JS_HAS_XML_SUPPORT
 #include "jsxml.h"
 #endif
 
 /*
  * GC arena sizing depends on amortizing arena overhead using a large number
  * of things per arena, and on the thing/flags ratio of 8:1 on most platforms.
  *
  * On 64-bit platforms, we would have half as many things per arena because
  * pointers are twice as big, so we double the bytes for things per arena.
@@ -645,20 +649,24 @@ retry:
                 METER(rt->gcStats.retry++);
                 goto retry;
             }
             goto fail;
         }
 
         /* Find the flags pointer given thing's address. */
         flagp = js_GetGCThingFlags(thing);
     }
 
+#if defined(DEBUG_ben) && defined(MOZILLA_CLIENT)
+    NS_LOG_CREATE(thing, "JSGCThing");
+#endif
+
     lrs = cx->localRootStack;
     if (lrs) {
         /*
          * If we're in a local root scope, don't set cx->newborn[type] at all,
          * to avoid entraining garbage from it for an unbounded amount of time
          * on this context.  A caller will leave the local root scope and pop
          * this reference, allowing thing to be GC'd if it has no other refs.
          * See JS_EnterLocalRootScope and related APIs.
          */
         if (js_PushLocalRoot(cx, lrs, (jsval) thing) < 0) {
@@ -1122,20 +1130,21 @@ MARK_GC_THING(JSContext *cx, void *thing
         /*
          * This should happen only if recursive MARK_GC_THING marks flags
          * already stored in the caller's *next_flagp.
          */
         goto out;
     }
 
     *flagp |= GCF_MARK;
 
 #ifdef GC_MARK_DEBUG
+    js_DumpGCHeap = stdout;
     if (js_DumpGCHeap)
         gc_dump_thing(thing, *flagp, arg, js_DumpGCHeap);
 #endif
 
     switch (*flagp & GCF_TYPEMASK) {
       case GCX_OBJECT:
         /* If obj->slots is null, obj must be a newborn. */
         obj = (JSObject *) thing;
         vp = obj->slots;
         if (!vp)
@@ -1701,20 +1710,24 @@ js_GC(JSContext *cx, uintN gcflags)
     js_FlushPropertyCache(cx);
 #ifdef DEBUG_notme
   { extern void js_DumpScopeMeters(JSRuntime *rt);
     js_DumpScopeMeters(rt);
   }
 #endif
 
 restart:
     rt->gcNumber++;
 
+#ifdef DEBUG_ben_off
+    printf("Doing JS GC.\n");
+#endif
+
     /*
      * Mark phase.
      */
     JS_DHashTableEnumerate(&rt->gcRootsHash, gc_root_marker, cx);
     if (rt->gcLocksHash)
         JS_DHashTableEnumerate(rt->gcLocksHash, gc_lock_marker, cx);
     js_MarkAtomState(&rt->atomState, gcflags, gc_mark_atom_key_thing, cx);
     js_MarkWatchPoints(rt);
     js_MarkScriptFilenames(rt, gcflags);
 
@@ -1852,20 +1865,23 @@ restart:
             limit = (JSGCThing *) a->avail;
             for (thing = (JSGCThing *) split; thing < limit; thing += nflags) {
                 if (((jsuword)thing & GC_PAGE_MASK) == 0) {
                     thing = (JSGCThing *) FIRST_THING((jsuword)thing, nbytes);
                     flagp = js_GetGCThingFlags(thing);
                 }
                 flags = *flagp;
                 if (flags & GCF_MARK) {
                     *flagp &= ~GCF_MARK;
                 } else if (!(flags & (GCF_LOCK | GCF_FINAL))) {
+#if defined(DEBUG_ben) && defined(MOZILLA_CLIENT)
+                    NS_LOG_DESTROY(thing, "JSGCThing");
+#endif
                     /* Call the finalizer with GCF_FINAL ORed into flags. */
                     type = flags & GCF_TYPEMASK;
                     finalizer = gc_finalizers[type];
                     if (finalizer) {
                         *flagp = (uint8)(flags | GCF_FINAL);
                         if (type >= GCX_EXTERNAL_STRING)
                             js_PurgeDeflatedStringCache((JSString *)thing);
                         finalizer(cx, thing);
                     }
 
Index: js/src/jsgc.h
===================================================================
RCS file: /cvsroot/mozilla/js/src/jsgc.h,v
retrieving revision 3.33
diff -p -u -1 -0 -r3.33 jsgc.h
--- js/src/jsgc.h	8 Jun 2005 02:13:10 -0000	3.33
+++ js/src/jsgc.h	19 May 2006 01:30:45 -0000
@@ -39,20 +39,24 @@
 
 #ifndef jsgc_h___
 #define jsgc_h___
 /*
  * JS Garbage Collector.
  */
 #include "jsprvtd.h"
 #include "jspubtd.h"
 #include "jsdhash.h"
 
+#ifdef DEBUG_ben_off
+#define GC_MARK_DEBUG
+#endif
+
 JS_BEGIN_EXTERN_C
 
 /* GC thing type indexes. */
 #define GCX_OBJECT              0               /* JSObject */
 #define GCX_STRING              1               /* JSString */
 #define GCX_DOUBLE              2               /* jsdouble */
 #define GCX_MUTABLE_STRING      3               /* JSString that's mutable --
                                                    single-threaded only! */
 #define GCX_PRIVATE             4               /* private (unscanned) data */
 #define GCX_NAMESPACE           5               /* JSXMLNamespace */
@@ -253,17 +257,21 @@ typedef struct JSGCStats {
 
 extern JS_FRIEND_API(void)
 js_DumpGCStats(JSRuntime *rt, FILE *fp);
 
 #endif /* JS_GCMETER */
 
 #ifdef DEBUG_notme
 #define TOO_MUCH_GC 1
 #endif
 
+#ifdef DEBUG_ben_off
+#define TOO_MUCH_GC 1
+#endif
+
 #ifdef WAY_TOO_MUCH_GC
 #define TOO_MUCH_GC 1
 #endif
 
 JS_END_EXTERN_C
 
 #endif /* jsgc_h___ */
