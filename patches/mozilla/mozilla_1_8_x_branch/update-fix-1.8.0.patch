Index: toolkit/xre/nsAppRunner.cpp
===================================================================
RCS file: /cvsroot/mozilla/toolkit/xre/nsAppRunner.cpp,v
retrieving revision 1.113.2.4.2.2
diff -u -8 -p -r1.113.2.4.2.2 nsAppRunner.cpp
--- toolkit/xre/nsAppRunner.cpp	22 Feb 2006 22:40:02 -0000	1.113.2.4.2.2
+++ toolkit/xre/nsAppRunner.cpp	24 Feb 2006 21:14:46 -0000
@@ -19,16 +19,17 @@
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
  *   Benjamin Smedberg <benjamin@smedbergs.us>
  *   Ben Goodger <ben@mozilla.org>
  *   Fredrik Holmqvist <thesuckiestemail@yahoo.se>
+ *   Ben Turner <mozilla@songbirdnest.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -2061,18 +2062,39 @@ XRE_main(int argc, char* argv[], const n
   if (!PR_GetEnv("MOZ_NO_REMOTE")) {
     // Try to remote the entire command line. If this fails, start up normally.
     if (RemoteCommandLine())
       return 0;
   }
 #endif
 
 #if defined(MOZ_UPDATER)
+  // If this is a XULRunner app then the updater needs to know the base
+  // directory that contains the application.ini file. This should be the
+  // parent of the xulrunner directory on Windows/Linux and it should be the
+  // Contents directory on MacOSX. Just in case someone packaged their app
+  // incorrectly we'll pass the directory here.
+  nsCOMPtr<nsIFile> greDir = dirProvider.GetAppDir();
+  NS_ENSURE_TRUE(greDir, 1);
+
+  nsCOMPtr<nsIFile> appDir;
+  PRBool dummy;
+  rv = dirProvider.GetFile("resource:app",
+                           &dummy,
+                           getter_AddRefs(appDir));
+  if (NS_FAILED(rv)) {
+    // This must not be a XULRunner app
+    appDir = greDir;
+  }
+
   // Check for and process any available updates
-  ProcessUpdates(dirProvider.GetAppDir(), gRestartArgc, gRestartArgv);
+  ProcessUpdates(greDir,
+                 appDir,
+                 gRestartArgc,
+                 gRestartArgv);
 #endif
 
   nsCOMPtr<nsIProfileLock> profileLock;
   PRBool startOffline = PR_FALSE;
 
   rv = SelectProfile(getter_AddRefs(profileLock), nativeApp, &startOffline);
   if (rv == NS_ERROR_LAUNCHED_CHILD_PROCESS ||
       rv == NS_ERROR_ABORT) return 0;
Index: toolkit/xre/nsUpdateDriver.cpp
===================================================================
RCS file: /cvsroot/mozilla/toolkit/xre/nsUpdateDriver.cpp,v
retrieving revision 1.11.2.4
diff -u -8 -p -r1.11.2.4 nsUpdateDriver.cpp
--- toolkit/xre/nsUpdateDriver.cpp	8 Nov 2005 15:54:28 -0000	1.11.2.4
+++ toolkit/xre/nsUpdateDriver.cpp	24 Feb 2006 21:14:46 -0000
@@ -16,16 +16,17 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is Google Inc.
  * Portions created by the Initial Developer are Copyright (C) 2005
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *  Darin Fisher <darin@meer.net>
+ *  Ben Turner <mozilla@songbirdnest.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -272,26 +273,26 @@ CopyUpdaterIntoUpdateDir(nsIFile *appDir
   if (NS_FAILED(rv))
     return PR_FALSE;
 #endif
   rv = updater->AppendNative(NS_LITERAL_CSTRING(kUpdaterBin));
   return NS_SUCCEEDED(rv); 
 }
 
 static void
-ApplyUpdate(nsIFile *appDir, nsIFile *updateDir, nsILocalFile *statusFile,
-            int appArgc, char **appArgv)
+ApplyUpdate(nsIFile *greDir, nsIFile *updateDir, nsILocalFile *statusFile,
+            nsIFile *appDir, int appArgc, char **appArgv)
 {
   // Steps:
   //  - mark update as 'applying'
   //  - copy updater into update dir
-  //  - run updater w/ app dir as the current working dir
+  //  - run updater w/ appDir as the current working dir
 
   nsCOMPtr<nsIFile> updater;
-  if (!CopyUpdaterIntoUpdateDir(appDir, updateDir, updater)) {
+  if (!CopyUpdaterIntoUpdateDir(greDir, updateDir, updater)) {
     LOG(("failed copying updater\n"));
     return;
   }
 
   // We need to use the value returned from XRE_GetBinaryPath when attempting
   // to restart the running application.
   nsCOMPtr<nsILocalFile> appFile;
   XRE_GetBinaryPath(appArgv[0], getter_AddRefs(appFile));
@@ -302,32 +303,33 @@ ApplyUpdate(nsIFile *appDir, nsIFile *up
   if (NS_FAILED(rv))
     return;
   
   nsCAutoString updaterPath;
   rv = updater->GetNativePath(updaterPath);
   if (NS_FAILED(rv))
     return;
 
-  nsCAutoString appDirPath;
+  // Get the directory to which the update will be applied. On Mac OSX we need
+  // to apply the update to the Foo.app directory which is the parent of the
+  // parent of the appDir. On other platforms we will just apply to the appDir.
+  nsCAutoString applyToDir;
 #if defined(XP_MACOSX)
-  // On Mac OSX, we need to apply the update to the Contents directory
-  // which is the parent of the parent of the appDir.
   {
     nsCOMPtr<nsIFile> parentDir1, parentDir2;
     rv = appDir->GetParent(getter_AddRefs(parentDir1));
     if (NS_FAILED(rv))
       return;
     rv = parentDir1->GetParent(getter_AddRefs(parentDir2));
     if (NS_FAILED(rv))
       return;
-    rv = parentDir2->GetNativePath(appDirPath);
+    rv = parentDir2->GetNativePath(applyToDir);
   }
 #else
-  rv = appDir->GetNativePath(appDirPath);
+  rv = appDir->GetNativePath(applyToDir);
 #endif
   if (NS_FAILED(rv))
     return;
 
   nsCAutoString updateDirPath;
   rv = updateDir->GetNativePath(updateDirPath);
   if (NS_FAILED(rv))
     return;
@@ -366,52 +368,52 @@ ApplyUpdate(nsIFile *appDir, nsIFile *up
     argv[4 + appArgc] = nsnull;
   } else {
     argv[3] = nsnull;
   }
 
   LOG(("spawning updater process [%s]\n", updaterPath.get()));
 
 #if defined(USE_EXECV)
-  chdir(appDirPath.get());
+  chdir(applyToDir.get());
   execv(updaterPath.get(), argv);
 #elif defined(XP_WIN)
-  _chdir(appDirPath.get());
+  _chdir(applyToDir.get());
 
   if (!WinLaunchChild(updaterPath.get(), appArgc + 4, argv))
     return;
   _exit(0);
 #else
   PRStatus status;
   PRProcessAttr *attr;
   
   attr = PR_NewProcessAttr();
   if (!attr)
     goto end;
 
-  status = PR_ProcessAttrSetCurrentDirectory(attr, appDirPath.get());
+  status = PR_ProcessAttrSetCurrentDirectory(attr, applyToDir.get());
   if (status != PR_SUCCESS)
     goto end;
 
   PR_CreateProcessDetached(updaterPath.get(), argv, nsnull, attr);
   exit(0);
 
 end:
   PR_DestroyProcessAttr(attr); 
   delete[] argv;
 #endif
 }
 
 nsresult
-ProcessUpdates(nsIFile *appDir, int argc, char **argv)
+ProcessUpdates(nsIFile *greDir, nsIFile *appDir, int argc, char **argv)
 {
   nsresult rv;
 
   nsCOMPtr<nsIFile> updatesDir;
-  rv = appDir->Clone(getter_AddRefs(updatesDir));
+  rv = greDir->Clone(getter_AddRefs(updatesDir));
   if (NS_FAILED(rv))
     return rv;
   rv = updatesDir->AppendNative(NS_LITERAL_CSTRING("updates"));
   if (NS_FAILED(rv))
     return rv;
 
   PRBool exists;
   rv = updatesDir->Exists(&exists);
@@ -424,15 +426,15 @@ ProcessUpdates(nsIFile *appDir, int argc
     return rv;
   if (dirEntries.Count() == 0)
     return NS_OK;
 
   // look for the first update subdirectory with a status of pending
   for (int i = 0; i < dirEntries.Count(); ++i) {
     nsCOMPtr<nsILocalFile> statusFile;
     if (GetStatusFile(dirEntries[i], statusFile) && IsPending(statusFile)) {
-      ApplyUpdate(appDir, dirEntries[i], statusFile, argc, argv);
+      ApplyUpdate(greDir, dirEntries[i], statusFile, appDir, argc, argv);
       break;
     }
   }
 
   return NS_OK;
 }
Index: toolkit/xre/nsUpdateDriver.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/xre/nsUpdateDriver.h,v
retrieving revision 1.2
diff -u -8 -p -r1.2 nsUpdateDriver.h
--- toolkit/xre/nsUpdateDriver.h	8 Jun 2005 17:40:38 -0000	1.2
+++ toolkit/xre/nsUpdateDriver.h	24 Feb 2006 21:14:46 -0000
@@ -16,16 +16,17 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is Google Inc.
  * Portions created by the Initial Developer are Copyright (C) 2005
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *  Darin Fisher <darin@meer.net>
+ *  Ben Turner <mozilla@songbirdnest.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -42,16 +43,21 @@
 #include "nscore.h"
 
 class nsIFile;
 
 /**
  * This function processes any available updates.  As part of that process, it
  * may exit the current process and relaunch it at a later time.
  *
+ * Two directories are passed to this function: greDir (where the actual
+ * binary resides) and appDir (which contains application.ini for XULRunner
+ * apps). If this is not a XULRunner app then appDir is identical to greDir.
+ * 
  * The argc and argv passed to this function should be what is needed to
  * relaunch the current process.
  *
- * This function does not modify appDir.
+ * This function does not modify greDir or appDir.
  */
-NS_HIDDEN_(nsresult) ProcessUpdates(nsIFile *appDir, int argc, char **argv);
+NS_HIDDEN_(nsresult) ProcessUpdates(nsIFile *greDir, nsIFile *appDir,
+                                    int argc, char **argv);
 
 #endif  // nsUpdateDriver_h__
