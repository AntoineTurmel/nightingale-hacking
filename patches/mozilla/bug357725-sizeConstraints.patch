Index: layout/xul/base/src/nsResizerFrame.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/xul/base/src/nsResizerFrame.cpp,v
retrieving revision 1.38
diff -u -p -r1.38 nsResizerFrame.cpp
--- layout/xul/base/src/nsResizerFrame.cpp	11 Dec 2007 10:08:35 -0000	1.38
+++ layout/xul/base/src/nsResizerFrame.cpp	1 Feb 2008 18:29:12 -0000
@@ -21,6 +21,7 @@
  *
  * Contributor(s):
  *   Original Author: Eric J. Burley (ericb@neoplanet.com)
+ *   Ben Turner <mozilla@songbirdnest.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
@@ -54,6 +55,7 @@
 #include "nsPIDOMWindow.h"
 #include "nsGUIEvent.h"
 #include "nsEventDispatcher.h"
+#include "nsIPresShell.h"
 
 //
 // NS_NewResizerFrame
@@ -67,7 +69,7 @@ NS_NewResizerFrame(nsIPresShell* aPresSh
 } // NS_NewResizerFrame
 
 nsResizerFrame::nsResizerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
-:nsTitleBarFrame(aPresShell, aContext)
+: nsTitleBarFrame(aPresShell, aContext)
 {
   mDirection = topleft; // by default...
 }
@@ -78,7 +80,12 @@ nsResizerFrame::Init(nsIContent*      aC
                      nsIFrame*        asPrevInFlow)
 {
   nsresult rv = nsTitleBarFrame::Init(aContent, aParent, asPrevInFlow);
-
+  
+  PRBool succeeded;
+  
+  succeeded = GetInitialDirection(mDirection);
+  NS_WARN_IF_FALSE(succeeded, "GetInitialDirection failed!");
+  
   GetInitialDirection(mDirection);
 
   return rv;
@@ -100,9 +107,11 @@ nsResizerFrame::HandleEvent(nsPresContex
            static_cast<nsMouseEvent*>(aEvent)->button ==
              nsMouseEvent::eLeftButton)
        {
-
          nsresult rv = NS_OK;
 
+         // Prevent default processing
+         doDefault = PR_FALSE;
+
          // what direction should we go in? 
          // convert eDirection to horizontal and vertical directions
          static const PRInt8 directions[][2] = {
@@ -111,28 +120,34 @@ nsResizerFrame::HandleEvent(nsPresContex
            {-1,  1}, {0,  1}, {1,  1}
          };
 
-         // ask the widget implementation to begin a resize drag if it can
-         rv = aEvent->widget->BeginResizeDrag(aEvent, 
-             directions[mDirection][0], directions[mDirection][1]);
-
-         if (rv == NS_ERROR_NOT_IMPLEMENTED) {
-           // there's no native resize support, 
-           // we need to window resizing ourselves
-
-           // we're tracking.
-           mTrackingMouseMove = PR_TRUE;
-
-           // start capture.
-           aEvent->widget->CaptureMouse(PR_TRUE);
-           CaptureMouseEvents(aPresContext,PR_TRUE);
-
-           // remember current mouse coordinates.
-           mLastPoint = aEvent->refPoint;
-           aEvent->widget->GetScreenBounds(mWidgetRect);
-         }
+         if (!IsDisabled(aPresContext)) {
 
-         *aEventStatus = nsEventStatus_eConsumeNoDefault;
-         doDefault = PR_FALSE;
+           // ask the widget implementation to begin a resize drag if it can
+           rv = aEvent->widget->BeginResizeDrag(aEvent, 
+               directions[mDirection][0], directions[mDirection][1]);
+ 
+           if (rv == NS_ERROR_NOT_IMPLEMENTED) {
+             // there's no native resize support, 
+             // we need to window resizing ourselves
+
+
+             rv = GetWindowFromPresContext(aPresContext,
+                                           getter_AddRefs(mResizingWindow));
+             NS_ENSURE_SUCCESS(rv, rv);
+ 
+             // we're tracking.
+             mTrackingMouseMove = PR_TRUE;
+ 
+             // start capture.
+             aEvent->widget->CaptureMouse(PR_TRUE);
+             CaptureMouseEvents(aPresContext, PR_TRUE);
+ 
+             // remember current mouse coordinates.
+             mLastPoint = aEvent->refPoint;
+           }
+ 
+           *aEventStatus = nsEventStatus_eConsumeNoDefault;
+         }
        }
      }
      break;
@@ -140,16 +155,23 @@ nsResizerFrame::HandleEvent(nsPresContex
 
    case NS_MOUSE_BUTTON_UP: {
 
-       if(mTrackingMouseMove && aEvent->eventStructType == NS_MOUSE_EVENT &&
-          static_cast<nsMouseEvent*>(aEvent)->button ==
-            nsMouseEvent::eLeftButton)
+       if (mTrackingMouseMove && aEvent->eventStructType == NS_MOUSE_EVENT &&
+           static_cast<nsMouseEvent*>(aEvent)->button ==
+             nsMouseEvent::eLeftButton)
        {
          // we're done tracking.
          mTrackingMouseMove = PR_FALSE;
 
+         // Clear all cached data
+         mResizingWindow = nsnull;
+         mSizeConstraints.minWidth = SizeConstraints::MIN_CONSTRAINT;
+         mSizeConstraints.maxWidth = SizeConstraints::MAX_CONSTRAINT;
+         mSizeConstraints.minHeight = SizeConstraints::MIN_CONSTRAINT;
+         mSizeConstraints.maxHeight = SizeConstraints::MAX_CONSTRAINT;
+         
          // end capture
          aEvent->widget->CaptureMouse(PR_FALSE);
-         CaptureMouseEvents(aPresContext,PR_FALSE);
+         CaptureMouseEvents(aPresContext, PR_FALSE);
 
          *aEventStatus = nsEventStatus_eConsumeNoDefault;
          doDefault = PR_FALSE;
@@ -158,101 +180,141 @@ nsResizerFrame::HandleEvent(nsPresContex
      break;
 
    case NS_MOUSE_MOVE: {
-       if(mTrackingMouseMove)
+       if (mTrackingMouseMove && !IsDisabled(aPresContext))
        {
-         // get the document and the window - should this be cached?
-         nsPIDOMWindow *domWindow =
-           aPresContext->PresShell()->GetDocument()->GetWindow();
-         NS_ENSURE_TRUE(domWindow, NS_ERROR_FAILURE);
-
-         nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
-           do_QueryInterface(domWindow->GetDocShell());
-         NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
-
-         nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
-         docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
+         NS_ENSURE_STATE(mResizingWindow);
 
-         nsCOMPtr<nsIBaseWindow> window(do_QueryInterface(treeOwner));
+         nsPoint moveBy(0,0), sizeBy(0,0);
+         nsPoint beyondMaximum(0,0), beyondMinimum(0,0);
+         nsPoint mouseMove(aEvent->refPoint - mLastPoint);
 
-         if (!window) {
-           return NS_OK;
-         }
-
-         nsPoint nsMoveBy(0,0),nsSizeBy(0,0);
-         nsPoint nsMouseMove(aEvent->refPoint - mLastPoint);
-
-         switch(mDirection)
+         switch (mDirection)
          {
             case topleft:
-              nsMoveBy = nsMouseMove;
-              nsSizeBy -= nsMouseMove;
+              moveBy = mouseMove;
+              sizeBy -= mouseMove;
               break;
             case top:
-              nsMoveBy.y = nsMouseMove.y;
-              nsSizeBy.y = - nsMouseMove.y;
+              moveBy.y = mouseMove.y;
+              sizeBy.y = - mouseMove.y;
               break;
             case topright:
-              nsMoveBy.y = nsMouseMove.y;
-              nsSizeBy.x = nsMouseMove.x;
-              mLastPoint.x += nsMouseMove.x;
-              nsSizeBy.y = -nsMouseMove.y;
+              moveBy.y = mouseMove.y;
+              sizeBy.x = mouseMove.x;
+              mLastPoint.x += mouseMove.x;
+              sizeBy.y = -mouseMove.y;
               break;
             case left:
-              nsMoveBy.x = nsMouseMove.x;
-              nsSizeBy.x = -nsMouseMove.x;
+              moveBy.x = mouseMove.x;
+              sizeBy.x = -mouseMove.x;
               break;
             case right:
-              nsSizeBy.x = nsMouseMove.x;
-              mLastPoint.x += nsMouseMove.x;
+              sizeBy.x = mouseMove.x;
+              mLastPoint.x += mouseMove.x;
               break;
             case bottomleft:
-              nsMoveBy.x = nsMouseMove.x;
-              nsSizeBy.y = nsMouseMove.y;
-              nsSizeBy.x = -nsMouseMove.x;
-              mLastPoint.y += nsMouseMove.y;
+              moveBy.x = mouseMove.x;
+              sizeBy.y = mouseMove.y;
+              sizeBy.x = -mouseMove.x;
+              mLastPoint.y += mouseMove.y;
               break;
             case bottom:
-              nsSizeBy.y = nsMouseMove.y;
-              mLastPoint.y += nsMouseMove.y;
+              sizeBy.y = mouseMove.y;
+              mLastPoint.y += mouseMove.y;
               break;
             case bottomright:
-              nsSizeBy = nsMouseMove;
-              mLastPoint += nsMouseMove;
+              sizeBy = mouseMove;
+              mLastPoint += mouseMove;
               break;
          }
-
-         PRInt32 x,y,cx,cy;
-         window->GetPositionAndSize(&x,&y,&cx,&cy);
-
-         x+=nsMoveBy.x;
-         y+=nsMoveBy.y;
-         cx+=nsSizeBy.x;
-         cy+=nsSizeBy.y;
-
-         window->SetPositionAndSize(x,y,cx,cy,PR_TRUE); // do the repaint.
-
-         /*
-         if(nsSizeBy.x || nsSizeBy.y)
-         {
-          window->ResizeBy(nsSizeBy.x,nsSizeBy.y);
+         
+         // Remember this because sizeBy is about to be changed
+         nsPoint requestedSizeChange(sizeBy);
+         
+         // The current size of the window is needed for these calculations
+         PRInt32 x, y, width, height;
+         mResizingWindow->GetPositionAndSize(&x, &y, &width, &height);
+         
+         // Figure out the size constraints
+         nsresult rv;
+         nsCOMPtr<nsIWidget> mainWidget;
+         rv = mResizingWindow->GetMainWidget(getter_AddRefs(mainWidget));
+         NS_ENSURE_SUCCESS(rv, rv);
+         
+         rv = mainWidget->GetSizeConstraints(&mSizeConstraints.minWidth,
+                                             &mSizeConstraints.maxWidth,
+                                             &mSizeConstraints.minHeight,
+                                             &mSizeConstraints.maxHeight);
+         NS_ENSURE_SUCCESS(rv, rv);
+         
+         // It would be nice to simply pass the new size on to the window but
+         // we have to have a way to keep the window from moving
+         // inappropriately when size constraints are in effect. Also platform
+         // support for size constraints may not exist everywhere, so we go on
+         // and do all the necessary calculations here. This will make resizers
+         // support size constraints even if native window decorations don't.
+	
+         // Check if a width constraint is set
+         PRInt32 newWidth = width + requestedSizeChange.x;
+         if (newWidth < mSizeConstraints.minWidth ||
+             newWidth > mSizeConstraints.maxWidth) {
+           // Always fix the size
+           newWidth = PR_MAX(mSizeConstraints.minWidth,
+                             PR_MIN(mSizeConstraints.maxWidth, newWidth));
+           sizeBy.x = newWidth - width;
+           if (mDirection == topleft || mDirection == left || mDirection == bottomleft) {
+             // Move as far as possible
+             moveBy.x = width - newWidth;
+           }
+           else {
+             // Track the distance beyond the minimum
+             beyondMinimum.x = PR_ABS(newWidth - (width + requestedSizeChange.x));
+             // Don't move at all
+             moveBy.x = 0;
+           }
+         }
+         
+         // Check if a height constraint is set
+         PRInt32 newHeight = height + requestedSizeChange.y;
+         if (newHeight < mSizeConstraints.minHeight ||
+             newHeight > mSizeConstraints.maxHeight) {
+           // Always fix the size
+           newHeight = PR_MAX(mSizeConstraints.minHeight,
+                              PR_MIN(mSizeConstraints.maxHeight, newHeight));
+           sizeBy.y = newHeight - height;
+           if (mDirection == topleft || mDirection == top || mDirection == topright) {
+             // Move as far as possible
+             moveBy.y = height - newHeight;
+           }
+           else {
+             // Track the distance beyond the minimum
+             beyondMinimum.y = PR_ABS(newHeight - (height + requestedSizeChange.y));
+             // Don't move at all
+             moveBy.y = 0;
+           }
          }
+	
+         // Update all the variables
+         x += moveBy.x;
+         y += moveBy.y;
+         width += sizeBy.x;
+         height += sizeBy.y;
 
-         if(nsMoveBy.x || nsMoveBy.y)
-         {
-          window->MoveBy(nsMoveBy.x,nsMoveBy.y);
-         }  */
+         // Update our tracking point
+         mLastPoint += beyondMinimum - beyondMaximum;
 
+         // Do the repaint
+         mResizingWindow->SetPositionAndSize(x, y, width, height, PR_TRUE);
          *aEventStatus = nsEventStatus_eConsumeNoDefault;
-
-         doDefault = PR_FALSE;
        }
+       doDefault = PR_FALSE;
      }
      break;
 
 
 
     case NS_MOUSE_CLICK:
-      if (NS_IS_MOUSE_LEFT_CLICK(aEvent))
+      if (NS_IS_MOUSE_LEFT_CLICK(aEvent) && !IsDisabled(aPresContext))
       {
         MouseClicked(aPresContext, aEvent);
       }
@@ -261,8 +323,8 @@ nsResizerFrame::HandleEvent(nsPresContex
 
   if (doDefault && weakFrame.IsAlive())
     return nsTitleBarFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
-  else
-    return NS_OK;
+
+  return NS_OK;
 }
 
 
@@ -270,7 +332,7 @@ nsResizerFrame::HandleEvent(nsPresContex
 /* returns true if aText represented a valid direction
  */
 PRBool
-nsResizerFrame::EvalDirection(nsAutoString& aText,eDirection& aDir)
+nsResizerFrame::EvalDirection(nsAutoString& aText, eDirection& aDir)
 {
   PRBool aResult = PR_TRUE;
 
@@ -350,7 +412,6 @@ nsResizerFrame::AttributeChanged(PRInt32
 }
 
 
-
 void
 nsResizerFrame::MouseClicked(nsPresContext* aPresContext, nsGUIEvent *aEvent)
 {
@@ -362,3 +423,69 @@ nsResizerFrame::MouseClicked(nsPresConte
 
   nsEventDispatcher::Dispatch(mContent, aPresContext, &event, nsnull, &status);
 }
+
+
+nsresult
+nsResizerFrame::GetWindowFromPresContext(nsPresContext* aPresContext,
+                                         nsIBaseWindow** _retval)
+{
+  NS_ENSURE_ARG_POINTER(aPresContext);
+  NS_ENSURE_ARG_POINTER(_retval);
+
+  nsIPresShell* presShell = aPresContext->PresShell();
+  NS_ENSURE_STATE(presShell);
+
+  nsIDocument* document = presShell->GetDocument();
+  NS_ENSURE_STATE(document);
+
+  nsPIDOMWindow* domWindow = document->GetWindow();
+  NS_ENSURE_STATE(domWindow);
+
+  nsIDocShell* docShell = domWindow->GetDocShell();
+  NS_ENSURE_STATE(docShell);
+
+  nsresult rv;
+  nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
+    do_QueryInterface(docShell, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
+  rv = docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(treeOwner, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  NS_ADDREF(*_retval = baseWindow);
+  return NS_OK;
+}
+
+PRBool
+nsResizerFrame::IsDisabled(nsPresContext* aPresContext)
+{
+  PRBool isDisabled = PR_FALSE;
+  if (GetContent())
+    isDisabled = GetContent()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
+                                           nsGkAtoms::_true, eCaseMatters);
+
+  if (isDisabled)
+    return PR_TRUE;
+
+  // Resizers shouldn't be active if the window is maximized
+  nsresult rv;
+  nsCOMPtr<nsIBaseWindow> baseWindow = mResizingWindow;
+  if (!baseWindow) {
+    rv = GetWindowFromPresContext(aPresContext, getter_AddRefs(baseWindow));
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+  }
+
+  nsCOMPtr<nsIWidget> mainWidget;
+  rv = baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
+  NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+  PRInt32 sizeMode;
+  rv = mainWidget->GetSizeMode(&sizeMode);
+  NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+  return sizeMode == nsSizeMode_Maximized;
+}
Index: layout/xul/base/src/nsResizerFrame.h
===================================================================
RCS file: /cvsroot/mozilla/layout/xul/base/src/nsResizerFrame.h,v
retrieving revision 1.13
diff -u -p -r1.13 nsResizerFrame.h
--- layout/xul/base/src/nsResizerFrame.h	26 Mar 2006 21:30:34 -0000	1.13
+++ layout/xul/base/src/nsResizerFrame.h	1 Feb 2008 18:29:12 -0000
@@ -39,6 +39,10 @@
 #define nsResizerFrame_h___
 
 #include "nsTitleBarFrame.h"
+#include "nsCOMPtr.h"
+
+class nsIBaseWindow;
+class nsPresContext;
 
 class nsResizerFrame : public nsTitleBarFrame 
 {
@@ -47,12 +51,12 @@ protected:
   enum eDirection {
     topleft,
     top,
-	 topright,
-	 left,	 
-	 right,
-	 bottomleft,
-	 bottom,
-	 bottomright
+    topright,
+    left,
+    right,
+    bottomleft,
+    bottom,
+    bottomright
   };
   
 
@@ -76,12 +80,16 @@ public:
   virtual void MouseClicked(nsPresContext* aPresContext, nsGUIEvent *aEvent);
 
 protected:
-	PRBool GetInitialDirection(eDirection& aDirection);
-	PRBool EvalDirection(nsAutoString& aText,eDirection& aResult);
+  PRBool GetInitialDirection(eDirection& aDirection);
+  PRBool EvalDirection(nsAutoString& aText,eDirection& aResult);
+  static nsresult GetWindowFromPresContext(nsPresContext* aPresContext,
+                                           nsIBaseWindow** _retval);
+  PRBool IsDisabled(nsPresContext* aPresContext);
 
 protected:
-	eDirection mDirection;
-	nsRect mWidgetRect;
+  eDirection mDirection;
+  SizeConstraints mSizeConstraints;
+  nsCOMPtr<nsIBaseWindow> mResizingWindow;
 }; // class nsResizerFrame
 
 #endif /* nsResizerFrame_h___ */
 Index: widget/public/nsIWidget.h
 ===================================================================
 RCS file: /cvsroot/mozilla/widget/public/nsIWidget.h,v
 retrieving revision 3.172
 diff -u -8 -r3.172 nsIWidget.h
 --- widget/public/nsIWidget.h	7 May 2008 04:46:37 -0000	3.172
 +++ widget/public/nsIWidget.h	14 May 2008 17:16:45 -0000
 @@ -256,16 +256,48 @@
    nsWindowType mWindowType;
    nsBorderStyle mBorderStyle;
    nsContentType mContentType;  // Exposed so screen readers know what's UI
    PRPackedBool mUnicode;
    nsPopupType mPopupHint;
  };

  /**
 + * Size constraints for a widget
 + * @see nsBaseWidget::SetSizeConstraints()
 + */
 +struct SizeConstraints {
 +  SizeConstraints(PRInt32 aMinWidth,
 +                  PRInt32 aMaxWidth,
 +                  PRInt32 aMinHeight,
 +                  PRInt32 aMaxHeight)
 +  : minWidth(aMinWidth),
 +    maxWidth(aMaxWidth),
 +    minHeight(aMinHeight),
 +    maxHeight(aMaxHeight)
 +  {
 +  }
 +  SizeConstraints()
 +  : minWidth(MIN_CONSTRAINT),
 +    maxWidth(MAX_CONSTRAINT),
 +    minHeight(MIN_CONSTRAINT),
 +    maxHeight(MAX_CONSTRAINT)
 +  {
 +  }
 +
 +  PRInt32 minWidth;
 +  PRInt32 maxWidth;
 +  PRInt32 minHeight;
 +  PRInt32 maxHeight;
 +  
 +  enum { MIN_CONSTRAINT = 0 };
 +  enum { MAX_CONSTRAINT = PR_INT32_MAX };
 +};
 +
 +/**
   * The base class for all the widgets. It provides the interface for
   * all basic and necessary functionality.
   */
  class nsIWidget : public nsISupports {

    public:

      NS_DECLARE_STATIC_IID_ACCESSOR(NS_IWIDGET_IID)
 @@ -468,16 +500,68 @@
       * @return vapid success indication. but see also the parameters.
       *
       **/
      NS_IMETHOD ConstrainPosition(PRBool aAllowSlop,
                                   PRInt32 *aX,
                                   PRInt32 *aY) = 0;

      /**
 +     * Platform-dependent method that uses the OS to ensure that the size of
 +     * widget never exceeds the given minimum or maximum values. Also affects
 +     * the behavior of the <xul:resizer> element.
 +     *
 +     * This is only guaranteed to work on top-level window widgets (i.e.
 +     * widgets created with the 'eWindowType_dialog', 'eWindowType_toplevel',
 +     * or 'eWindowType_invisible' windowTypes that have no parent). Calling
 +     * this function on any other type of window will throw
 +     * NS_ERROR_UNEXPECTED. In contrast, calls to GetSizeConstraints will
 +     * always succeed, but each constraint will be set to -1.
 +     *
 +     * XXXbent All of the following pixel values are supposed to be device
 +     *         pixels, but note that we currently assume device pixels map 1:1
 +     *         to CSS pixels.
 +     *
 +     * @param aMinWidth: the minimum width in device pixels (-1 to ignore)
 +     * @param aMaxWidth: the maximum width in device pixels (-1 to ignore)
 +     * @param aMinHeight: the minimum height in device pixels (-1 to ignore)
 +     * @param aMaxHeight: the maximum height in device pixels (-1 to ignore)
 +     *
 +     * @throws NS_ERROR_UNEXPECTED if called on a non-top-level widget
 +     **/
 +    NS_IMETHOD SetSizeConstraints(PRInt32 aMinWidth,
 +                                  PRInt32 aMaxWidth,
 +                                  PRInt32 aMinHeight,
 +                                  PRInt32 aMaxHeight) = 0;
 +
 +    /**
 +     * Return the size constraints currently observed by the widget.
 +     *
 +     * You can pass nsnull for any of the parameters if you don't care to
 +     * retrieve their value. Constraint values set to -1 by this function
 +     * indicate that that particular constraint is not observed.
 +     *
 +     * Calling this function on non-top-level widgets will succeed, however
 +     * *all* constraints will be reported as -1 (unconstrained).
 +     *
 +     * XXXbent All of the following pixel values are supposed to be device
 +     *         pixels, but note that we currently assume device pixels map 1:1
 +     *         to CSS pixels.
 +     *
 +     * @param aMinWidth: the minimum width of the widget in device pixels
 +     * @param aMaxWidth: the maximum width for the widget in device pixels
 +     * @param aMinHeight: the minimum height for the widget in device pixels
 +     * @param aMaxHeight: the maximum height for the widget in device pixels
 +     **/
 +    NS_IMETHOD GetSizeConstraints(PRInt32* aMinWidth,
 +                                  PRInt32* aMaxWidth,
 +                                  PRInt32* aMinHeight,
 +                                  PRInt32* aMaxHeight) = 0;
 +
 +    /**
       * Move this widget.
       *
       * @param aX the new x position expressed in the parent's coordinate system
       * @param aY the new y position expressed in the parent's coordinate system
       *
       **/
      NS_IMETHOD Move(PRInt32 aX, PRInt32 aY) = 0;

Index: widget/src/windows/nsWindow.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/windows/nsWindow.cpp,v
retrieving revision 3.722
diff -u -p -r3.722 nsWindow.cpp
--- widget/src/windows/nsWindow.cpp	18 Jan 2008 18:39:52 -0000	3.722
+++ widget/src/windows/nsWindow.cpp	1 Feb 2008 18:29:12 -0000
@@ -34,6 +34,7 @@
  *   Dainis Jonitis <Dainis_Jonitis@swh-t.lv>
  *   Christian Biesinger <cbiesinger@web.de>
  *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Ben Turner <mozilla@songbirdnest.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -150,6 +151,10 @@
 #include "prprf.h"
 #include "prmem.h"
 
+// size constraints
+#include "nsIFrame.h"
+#include "nsIView.h"
+
 static const char kMozHeapDumpMessageString[] = "MOZ_HeapDump";
 
 #define kWindowPositionSlop 20
@@ -758,6 +763,15 @@ nsWindow::nsWindow() : nsBaseWidget()
   mOldIMC             = NULL;
   mIMEEnabled         = nsIKBStateControl::IME_STATUS_ENABLED;
 
+  mIsChromeHidden     = PR_FALSE;
+  mIsMaximizing       = PR_FALSE;
+  mWasMaximized       = PR_FALSE;
+
+  mSizeConstraints.minWidth  = SizeConstraints::MIN_CONSTRAINT;
+  mSizeConstraints.maxWidth  = SizeConstraints::MAX_CONSTRAINT;
+  mSizeConstraints.minHeight = SizeConstraints::MIN_CONSTRAINT;
+  mSizeConstraints.maxHeight = SizeConstraints::MAX_CONSTRAINT;
+
   mLeadByte = '\0';
   mBlurEventSuppressionLevel = 0;
 
@@ -2018,6 +2032,118 @@ NS_METHOD nsWindow::ConstrainPosition(PR
   return NS_OK;
 }
 
+NS_IMETHODIMP nsWindow::SetSizeConstraints(PRInt32 aMinWidth,
+                                           PRInt32 aMaxWidth,
+                                           PRInt32 aMinHeight,
+                                           PRInt32 aMaxHeight)
+{
+  // This function is only guaranteed to work with top-level widget windows
+  if (!mIsTopWidgetWindow)
+    return NS_ERROR_UNEXPECTED;
+
+  mSizeConstraints.minWidth =
+    PR_MAX(::GetSystemMetrics(SM_CXMINTRACK), aMinWidth);
+  mSizeConstraints.minHeight =
+    PR_MAX(::GetSystemMetrics(SM_CYMINTRACK), aMinHeight);
+
+  mSizeConstraints.maxWidth = aMaxWidth;
+  mSizeConstraints.maxHeight = aMaxHeight;
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsWindow::GetSizeConstraints(PRInt32* aMinWidth,
+                                           PRInt32* aMaxWidth,
+                                           PRInt32* aMinHeight,
+                                           PRInt32* aMaxHeight)
+{
+  SizeConstraints constraints;
+  
+  // read the constraints from CSS
+  nsresult rv;
+  nsCOMPtr<nsIDeviceContext> devContext = GetDeviceContext();
+  nsCOMPtr<nsIRenderingContext> renderingContext = GetRenderingContext();
+
+  nsIWidget* widget = GetFirstChild();
+  nsIView* view = nsnull;
+  if (widget) {
+    view = nsIView::GetViewFor(widget);
+  }
+  nsIFrame* frame = nsnull;
+  if (view) {
+    /* see nsLayoutUtils, except we can't use it */
+    frame = static_cast<nsIFrame*>(view->GetClientData());
+  }
+  const nsStylePosition* position = nsnull;
+  if (frame) {
+    position = frame->GetStylePosition();
+  }
+  if (position) {
+    PRInt32 appUnitsPerDevPixel = devContext->AppUnitsPerDevPixel();
+    nscoord coordTwips, appUnits;
+
+    nsStyleUnit unit = position->mMinWidth.GetUnit();
+    if (eStyleUnit_Coord != unit) {
+      coordTwips = nscoord_MIN;
+    } else {
+      coordTwips = position->mMinWidth.GetCoordValue();
+    }
+    if (coordTwips != nscoord_MIN) {
+      appUnits = NS_TWIPS_TO_INCHES(coordTwips) * devContext->AppUnitsPerInch();
+      constraints.minWidth = NSAppUnitsToIntPixels(appUnits, appUnitsPerDevPixel);
+    }
+
+    unit = position->mMaxWidth.GetUnit();
+    if (eStyleUnit_Coord != unit) {
+      coordTwips = nscoord_MAX;
+    } else {
+      coordTwips = position->mMaxWidth.GetCoordValue();
+    }
+    if (coordTwips != nscoord_MAX) {
+      appUnits = NS_TWIPS_TO_INCHES(coordTwips) * devContext->AppUnitsPerInch();
+      constraints.maxWidth = NSAppUnitsToIntPixels(appUnits, appUnitsPerDevPixel);
+    }
+
+    unit = position->mMinHeight.GetUnit();
+    if (eStyleUnit_Coord != unit) {
+      coordTwips = nscoord_MIN;
+    } else {
+      coordTwips = position->mMinHeight.GetCoordValue();
+    }
+    if (coordTwips != nscoord_MIN) {
+      appUnits = NS_TWIPS_TO_INCHES(coordTwips) * devContext->AppUnitsPerInch();
+      constraints.minHeight = NSAppUnitsToIntPixels(appUnits, appUnitsPerDevPixel);
+    }
+
+    unit = position->mMaxHeight.GetUnit();
+    if (eStyleUnit_Coord != unit) {
+      coordTwips = nscoord_MIN;
+    } else {
+      coordTwips = position->mMaxHeight.GetCoordValue();
+    }
+    if (coordTwips != nscoord_MAX) {
+      appUnits = NS_TWIPS_TO_INCHES(coordTwips) * devContext->AppUnitsPerInch();
+      constraints.maxHeight = NSAppUnitsToIntPixels(appUnits, appUnitsPerDevPixel);
+    }
+  }
+  
+  // override them with attributes, as usual for XUL
+  constraints.minWidth = PR_MAX(constraints.minWidth, mSizeConstraints.minWidth);
+  constraints.maxWidth = PR_MIN(constraints.maxWidth, mSizeConstraints.maxWidth);
+  constraints.minHeight = PR_MAX(constraints.minHeight, mSizeConstraints.minHeight);
+  constraints.maxHeight = PR_MIN(constraints.maxHeight, mSizeConstraints.maxHeight);
+  
+  if (aMinWidth)
+    *aMinWidth = constraints.minWidth;
+  if (aMaxWidth)
+    *aMaxWidth = constraints.maxWidth;
+  if (aMinHeight)
+    *aMinHeight = constraints.minHeight;
+  if (aMaxHeight)
+    *aMaxHeight = constraints.maxHeight;
+  return NS_OK;
+}
+
 //-------------------------------------------------------------------------
 //
 // Move this component
@@ -2746,6 +2872,8 @@ NS_IMETHODIMP nsWindow::HideWindowChrome
 
   ::SetWindowLongW(hwnd, GWL_STYLE, style);
   ::SetWindowLongW(hwnd, GWL_EXSTYLE, exStyle);
+  
+  mIsChromeHidden = aShouldHide;
 
   return NS_OK;
 }
@@ -4055,6 +4183,12 @@ PRBool nsWindow::ProcessMessage(UINT msg
 #ifndef WINCE
     case WM_DISPLAYCHANGE:
       DispatchStandardEvent(NS_DISPLAYCHANGED);
+
+      // When the window's chrome is hidden and the work area changes, 
+      // the window is not invalidated as it is supposed to
+      if (mIsChromeHidden)
+        Invalidate(PR_TRUE);
+
       break;
 #endif
 
@@ -4621,6 +4755,80 @@ PRBool nsWindow::ProcessMessage(UINT msg
     break;
 #endif
 
+    case WM_GETMINMAXINFO:
+    {
+      PRInt32 minTrackWidth, maxTrackWidth, minTrackHeight, maxTrackHeight;
+      GetSizeConstraints(&minTrackWidth, &maxTrackWidth,
+                         &minTrackHeight, &maxTrackHeight);
+      PRInt32 maxWidth = maxTrackWidth;
+      PRInt32 maxHeight = maxTrackHeight;
+
+      PRInt32 left = -1, top = -1;
+
+      // Restrict the window from covering the taskbar if chrome is hidden
+      // (because the OS doesn't do this for us) and the size mode is set to
+      // maximized (because 'fullscreen' mode still uses nsSizeMode_Normal).
+      if (mIsChromeHidden &&
+          (mSizeMode == nsSizeMode_Maximized || mIsMaximizing)) {
+
+        // Figure out the maximized window's size and position
+        RECT workArea;
+        PRBool hasWorkArea = PR_FALSE;
+        nsCOMPtr<nsIScreenManager> screenmgr = do_GetService(sScreenManagerContractID);
+        if (screenmgr) {
+          nsCOMPtr<nsIScreen> screen;
+          PRInt32 left, top, width, height;
+      
+          // zero size rects confuse the screen manager
+          width = mBounds.width > 0 ? mBounds.width : 1;
+          height = mBounds.height > 0 ? mBounds.height : 1;
+          screenmgr->ScreenForNativeWidget(mWnd, getter_AddRefs(screen));
+          if (screen) {
+            screen->GetAvailRect(&left, &top, &width, &height);
+            workArea.left = left;
+            workArea.right = left+width;
+            workArea.top = top;
+            workArea.bottom = top+height;
+            hasWorkArea = PR_TRUE;
+          }
+        } else {
+          if (::SystemParametersInfo(SPI_GETWORKAREA, 0, &workArea, 0)) {
+            hasWorkArea = PR_TRUE;
+          }
+        }
+        if (hasWorkArea) {
+          PRInt32 workWidth = workArea.right - workArea.left;
+          maxWidth = PR_MIN(workWidth, mSizeConstraints.maxWidth);
+
+          PRInt32 workHeight = workArea.bottom - workArea.top;
+          maxHeight = PR_MIN(workHeight, mSizeConstraints.maxHeight);
+          
+          left = workArea.left;
+          top = workArea.top;
+        }
+      }
+
+      // Set our values
+      MINMAXINFO* mmi = (MINMAXINFO*)lParam;
+      if (minTrackWidth > mmi->ptMinTrackSize.x)
+        mmi->ptMinTrackSize.x = minTrackWidth;
+      if (minTrackHeight > mmi->ptMinTrackSize.y)
+        mmi->ptMinTrackSize.y = minTrackHeight;
+      if (maxTrackWidth < mmi->ptMaxTrackSize.x)
+        mmi->ptMaxTrackSize.x = maxTrackWidth;
+      if (maxTrackHeight < mmi->ptMaxTrackSize.y)
+        mmi->ptMaxTrackSize.y = maxTrackHeight;
+      if (maxWidth < mmi->ptMaxSize.x)
+        mmi->ptMaxSize.x = maxWidth;
+      if (maxHeight < mmi->ptMaxSize.y)
+        mmi->ptMaxSize.y = maxHeight;
+      if (left > mmi->ptMaxPosition.x)
+        mmi->ptMaxPosition.x = left;
+      if (top > mmi->ptMaxPosition.y)
+        mmi->ptMaxPosition.y = top;
+    }
+    break;
+
     case WM_SETFOCUS:
       result = DispatchFocus(NS_GOTFOCUS, PR_TRUE);
       if (gJustGotActivate) {
@@ -4690,6 +4898,11 @@ PRBool nsWindow::ProcessMessage(UINT msg
 
     case WM_WINDOWPOSCHANGED:
     {
+      // Reset our special case flag for maximizing a hidechrome window now
+      // that all sizing is completed
+      if (mIsMaximizing)
+        mIsMaximizing = PR_FALSE;
+
       WINDOWPOS *wp = (LPWINDOWPOS)lParam;
 
       // We only care about a resize, so filter out things like z-order
@@ -4961,10 +5174,41 @@ PRBool nsWindow::ProcessMessage(UINT msg
 
 #ifndef WINCE
     case WM_SYSCOMMAND:
-      // prevent Windows from trimming the working set. bug 76831
-      if (!gTrimOnMinimize && wParam == SC_MINIMIZE) {
-        ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
-        result = PR_TRUE;
+      switch (wParam)
+      {
+        case SC_MINIMIZE:
+        {
+          // prevent Windows from trimming the working set. bug 76831
+          if (!gTrimOnMinimize) {
+            ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
+            result = PR_TRUE;
+          }
+          // Set this flag so that we restore to the proper size
+          if (mIsChromeHidden && mSizeMode == nsSizeMode_Maximized)
+            mWasMaximized = PR_TRUE;
+          break;
+        }
+
+        case SC_MAXIMIZE:
+        {
+          if (mIsChromeHidden) {
+            // Set a flag to properly animate the maximizing of a hidechrome window
+            // that will be handled in WM_GETMINMAXINFO
+            mWasMaximized = PR_FALSE;
+            mIsMaximizing = PR_TRUE;
+          }
+          break;
+        }
+
+        case SC_RESTORE:
+        {
+          if (mWasMaximized) {
+            if (mIsChromeHidden)
+              mIsMaximizing = PR_TRUE;
+            mWasMaximized = PR_FALSE;
+          }
+          break;
+        }
       }
       break;
 #endif
Index: widget/src/windows/nsWindow.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/windows/nsWindow.h,v
retrieving revision 3.246
diff -u -p -r3.246 nsWindow.h
--- widget/src/windows/nsWindow.h	19 Dec 2007 19:40:20 -0000	3.246
+++ widget/src/windows/nsWindow.h	1 Feb 2008 18:29:12 -0000
@@ -57,6 +57,8 @@
 
 #include "nsVoidArray.h"
 
+#include "nsRect.h"
+
 class nsNativeDragTarget;
 class nsIRollupListener;
 
@@ -158,6 +160,10 @@ public:
   NS_IMETHOD              ModalEventFilter(PRBool aRealEvent, void *aEvent, PRBool *aForWindow);
   NS_IMETHOD              CaptureMouse(PRBool aCapture);
   NS_IMETHOD              ConstrainPosition(PRBool aAllowSlop, PRInt32 *aX, PRInt32 *aY);
+  NS_IMETHOD              SetSizeConstraints(PRInt32 aMinWidth, PRInt32 aMaxWidth,
+                                             PRInt32 aMinHeight, PRInt32 aMaxHeight);
+  NS_IMETHOD              GetSizeConstraints(PRInt32* aMinWidth, PRInt32* aMaxWidth,
+                                             PRInt32* aMinHeight, PRInt32* aMaxHeight);
   NS_IMETHOD              Move(PRInt32 aX, PRInt32 aY);
   NS_IMETHOD              Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint);
   NS_IMETHOD              Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint);
@@ -356,6 +362,7 @@ protected:
   void GetTextRangeList(PRUint32* textRangeListLengthResult, nsTextRangeArray* textRangeListResult);
 
   void ConstrainZLevel(HWND *aAfter);
+  void EnsureSizeConstraints(WINDOWPOS* aInfo);
 
   LPARAM lParamToScreen(LPARAM lParam);
   LPARAM lParamToClient(LPARAM lParam);
@@ -430,6 +437,10 @@ protected:
   PRPackedBool  mIsInMouseWheelProcessing;
   PRPackedBool  mUnicodeWidget;
 
+  PRPackedBool  mIsChromeHidden;
+  PRPackedBool  mIsMaximizing;
+  PRPackedBool  mWasMaximized;
+
   PRPackedBool  mPainting;
   char          mLeadByte;
   PRUint32      mBlurEventSuppressionLevel;
@@ -456,6 +467,9 @@ protected:
   // Drag & Drop
   nsNativeDragTarget * mNativeDragTarget;
 
+  // window sizing constraints (see SetSizeContraints, nsIWidget.h)
+  SizeConstraints mSizeConstraints;
+
   // Enumeration of the methods which are accessible on the "main GUI thread"
   // via the CallMethod(...) mechanism...
   // see nsSwitchToUIThread
Index: widget/src/xpwidgets/nsBaseWidget.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/xpwidgets/nsBaseWidget.cpp,v
retrieving revision 1.168
diff -u -p -r1.168 nsBaseWidget.cpp
--- widget/src/xpwidgets/nsBaseWidget.cpp	5 Jan 2008 05:34:00 -0000	1.168
+++ widget/src/xpwidgets/nsBaseWidget.cpp	1 Feb 2008 18:29:12 -0000
@@ -764,6 +764,39 @@ NS_METHOD nsBaseWidget::SetBounds(const 
 }
  
 
+/**
+* 
+*
+**/
+NS_IMETHODIMP nsBaseWidget::SetSizeConstraints(PRInt32 aMinWidth,
+                                               PRInt32 aMaxWidth,
+                                               PRInt32 aMinHeight,
+                                               PRInt32 aMaxHeight)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/**
+*
+*
+**/
+NS_IMETHODIMP nsBaseWidget::GetSizeConstraints(PRInt32* aMinWidth,
+                                               PRInt32* aMaxWidth,
+                                               PRInt32* aMinHeight,
+                                               PRInt32* aMaxHeight)
+{
+  // Returning -1 indicates that no constraints have been set
+  if (aMinWidth)
+    *aMinWidth = SizeConstraints::MIN_CONSTRAINT;
+  if (aMaxWidth)
+    *aMaxWidth = SizeConstraints::MAX_CONSTRAINT;
+  if (aMinHeight)
+    *aMinHeight = SizeConstraints::MIN_CONSTRAINT;
+  if (aMaxHeight)
+    *aMaxHeight = SizeConstraints::MAX_CONSTRAINT;
+  return NS_OK;
+}
+
 
 /**
 * Calculates the border width and height  
Index: widget/src/xpwidgets/nsBaseWidget.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/xpwidgets/nsBaseWidget.h,v
retrieving revision 1.93
diff -u -p -r1.93 nsBaseWidget.h
--- widget/src/xpwidgets/nsBaseWidget.h	5 Jan 2008 05:34:00 -0000	1.93
+++ widget/src/xpwidgets/nsBaseWidget.h	1 Feb 2008 18:29:12 -0000
@@ -137,6 +137,10 @@ public:
   virtual void            ConvertToDeviceCoordinates(nscoord  &aX,nscoord &aY) {}
   virtual void            FreeNativeData(void * data, PRUint32 aDataType) {}
   NS_IMETHOD              BeginResizeDrag(nsGUIEvent* aEvent, PRInt32 aHorizontal, PRInt32 aVertical);
+  NS_IMETHOD              SetSizeConstraints(PRInt32 aMinWidth, PRInt32 aMaxWidth,
+                                             PRInt32 aMinHeight, PRInt32 aMaxHeight);
+  NS_IMETHOD              GetSizeConstraints(PRInt32* aMinWidth, PRInt32* aMaxWidth,
+                                             PRInt32* aMinHeight, PRInt32* aMaxHeight);
 
 protected:
 
Index: xpfe/appshell/src/nsXULWindow.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpfe/appshell/src/nsXULWindow.cpp,v
retrieving revision 1.178
diff -u -p -r1.178 nsXULWindow.cpp
--- xpfe/appshell/src/nsXULWindow.cpp	14 Dec 2007 17:32:41 -0000	1.178
+++ xpfe/appshell/src/nsXULWindow.cpp	1 Feb 2008 18:29:12 -0000
@@ -25,6 +25,7 @@
  *   Travis Bogard <travis@netscape.com>
  *   Dan Rosen <dr@netscape.com>
  *   Ben Goodger <ben@netscape.com>
+ *   Ben Turner <mozilla@songbirdnest.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
@@ -1077,7 +1078,7 @@ PRBool nsXULWindow::LoadPositionFromXUL(
 PRBool nsXULWindow::LoadSizeFromXUL()
 {
   nsresult rv;
-  PRBool   gotSize = PR_FALSE;
+  PRBool gotSize = PR_FALSE;
   
   // if we're the hidden window, don't try to validate our size/position. We're
   // special.
@@ -1119,6 +1120,38 @@ PRBool nsXULWindow::LoadSizeFromXUL()
     }
   }
 
+  rv = windowElement->GetAttribute(NS_LITERAL_STRING("minwidth"), sizeString);
+  if (NS_SUCCEEDED(rv)) {
+    temp = sizeString.ToInteger(&errorCode);
+    if (NS_SUCCEEDED(errorCode) && temp > 0) {
+      mSizeConstraints.minWidth = temp;
+    }
+  }
+
+  rv = windowElement->GetAttribute(NS_LITERAL_STRING("maxwidth"), sizeString);
+  if (NS_SUCCEEDED(rv)) {
+    temp = sizeString.ToInteger(&errorCode);
+    if (NS_SUCCEEDED(errorCode) && temp > 0) {
+      mSizeConstraints.maxWidth = temp;
+    }
+  }
+
+  rv = windowElement->GetAttribute(NS_LITERAL_STRING("minheight"), sizeString);
+  if (NS_SUCCEEDED(rv)) {
+    temp = sizeString.ToInteger(&errorCode);
+    if (NS_SUCCEEDED(errorCode) && temp > 0) {
+      mSizeConstraints.minHeight = temp;
+    }
+  }
+
+  rv = windowElement->GetAttribute(NS_LITERAL_STRING("maxheight"), sizeString);
+  if (NS_SUCCEEDED(rv)) {
+    temp = sizeString.ToInteger(&errorCode);
+    if (NS_SUCCEEDED(errorCode) && temp > 0) {
+      mSizeConstraints.maxHeight = temp;
+    }
+  }
+
   if (gotSize) {
     // constrain to screen size
     nsCOMPtr<nsIDOMWindowInternal> domWindow;
@@ -1143,6 +1176,15 @@ PRBool nsXULWindow::LoadSizeFromXUL()
       SetSize(specWidth, specHeight, PR_FALSE);
   }
 
+  // XXXbent The values loaded from XUL should be in CSS pixels. Those values
+  //         will need to be converted to device pixels here once such a
+  //         conversion is possible.
+  rv = mWindow->SetSizeConstraints(mSizeConstraints.minWidth,
+                                   mSizeConstraints.maxWidth,
+                                   mSizeConstraints.minHeight,
+                                   mSizeConstraints.maxHeight);
+  NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "SetSizeConstraints failed!");
+
   return gotSize;
 }
 
Index: xpfe/appshell/src/nsXULWindow.h
===================================================================
RCS file: /cvsroot/mozilla/xpfe/appshell/src/nsXULWindow.h,v
retrieving revision 1.63
diff -u -p -r1.63 nsXULWindow.h
--- xpfe/appshell/src/nsXULWindow.h	5 Oct 2007 23:37:26 -0000	1.63
+++ xpfe/appshell/src/nsXULWindow.h	1 Feb 2008 18:29:12 -0000
@@ -176,6 +176,7 @@ protected:
    PRUint32                mPersistentAttributesMask;
    PRUint32                mChromeFlags;
    nsString                mTitle;
+   SizeConstraints         mSizeConstraints;
 
    nsCOMArray<nsIWeakReference> mTargetableShells; // targetable shells only
 };
