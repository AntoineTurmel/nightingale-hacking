Index: toolkit/xre/MacApplicationDelegate.mm
===================================================================
RCS file: /cvsroot/mozilla/toolkit/xre/MacApplicationDelegate.mm,v
retrieving revision 1.8
diff -u -8 -r1.8 MacApplicationDelegate.mm
--- toolkit/xre/MacApplicationDelegate.mm	20 Feb 2008 17:34:22 -0000	1.8
+++ toolkit/xre/MacApplicationDelegate.mm	18 Sep 2008 20:52:00 -0000
@@ -54,20 +54,36 @@
 #include "nsComponentManagerUtils.h"
 #include "nsCommandLineServiceMac.h"
 #include "nsServiceManagerUtils.h"
 #include "nsIAppStartup.h"
 #include "nsIObserverService.h"
 #include "nsISupportsPrimitives.h"
 #include "nsObjCExceptions.h"
 
+#define ABOUT_MENUITEM_ID         1
+#define PREFERENCES_MENUTITEM_ID  2
+#define QUIT_MENUITEM_ID          3
+
 @interface MacApplicationDelegate : NSObject
 {
+  BOOL mIsSimulatingModalSession;
+  id   mAppDelegateOverride;
 }
 
+- (void)setAppDelegateOverride:(id)aDelegateOverride;
+
+@end
+
+@interface MacApplicationDelegate (Private)
+
+- (void)onBeginGeckoModalSession:(id)sender;
+- (void)onEndGeckoModalSession:(id)sender;
+- (void)configureAppMenu:(BOOL)inIsModal;
+
 @end
 
 // Something to call from non-objective code.
 
 // This is needed, on relaunch, to force the OS to use the "Cocoa Dock API"
 // instead of the "Carbon Dock API".  For more info see bmo bug 377166.
 void
 EnsureUseCocoaDockAPI()
@@ -94,26 +110,60 @@
   MacApplicationDelegate *delegate = [[MacApplicationDelegate alloc] init];
   [[NSApplication sharedApplication] setDelegate:delegate];
 
   NS_OBJC_END_TRY_ABORT_BLOCK;
 }
 
 @implementation MacApplicationDelegate
 
+- (id)init
+{
+  if ((self = [super init])) {
+    mAppDelegateOverride = nil;
+    [[NSNotificationCenter defaultCenter] addObserver:self 
+                                             selector:@selector(onBeginGeckoModalSession:) 
+                                                 name:@"GeckoStartModal" 
+                                               object:nil];
+    [[NSNotificationCenter defaultCenter] addObserver:self 
+                                             selector:@selector(onEndGeckoModalSession:) 
+                                                 name:@"GeckoEndModal" 
+                                               object:nil];
+  }
+  
+  return self;
+}
+
+- (void)dealloc
+{
+  [[NSNotificationCenter defaultCenter] removeObserver:self];
+  [super dealloc];
+}
+
+- (void)setAppDelegateOverride:(id)aDelegateOverride
+{
+  mAppDelegateOverride = aDelegateOverride;
+}
+
 // Opening the application is handled specially elsewhere,
 // don't define applicationOpenUntitledFile: .
 
 // The method that NSApplication calls upon a request to reopen, such as when
 // the Dock icon is clicked and no windows are open.
 
 // A "visible" window may be miniaturized, so we can't skip
 // nsCocoaNativeReOpen() if 'flag' is 'true'.
 - (BOOL)applicationShouldHandleReopen:(NSApplication*)theApp hasVisibleWindows:(BOOL)flag
 {
+  if (mAppDelegateOverride && 
+      [mAppDelegateOverride respondsToSelector:@selector(applicationShouldHandleReopen:hasVisibleWindows:)])
+  {
+    return [mAppDelegateOverride applicationShouldHandleReopen:theApp hasVisibleWindows:flag];
+  }
+
   nsCOMPtr<nsINativeAppSupport> nas = do_CreateInstance(NS_NATIVEAPPSUPPORT_CONTRACTID);
   NS_ENSURE_TRUE(nas, NO);
 
   // Go to the common Carbon/Cocoa reopen method.
   nsresult rv = nas->ReOpen();
   NS_ENSURE_SUCCESS(rv, NO);
 
   // NO says we don't want NSApplication to do anything else for us.
@@ -199,16 +249,22 @@
 }
 
 // Create the menu that shows up in the Dock.
 
 - (NSMenu*)applicationDockMenu:(NSApplication*)sender
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 
+  if (mAppDelegateOverride &&
+      [mAppDelegateOverride respondsToSelector:@selector(applicationDockMenu:)]) 
+  {
+    return [mAppDelegateOverride applicationDockMenu:sender];
+  }
+
   // Why we're not just using Cocoa to enumerate our windows:
   // The Dock thinks we're a Carbon app, probably because we don't have a
   // blessed Window menu, so we get none of the automatic handling for dock
   // menus that Cocoa apps get. Add in Cocoa being a bit braindead when you hide
   // the app, and we end up having to get our list of windows via XPCOM. Ugh.
 
   // Get the window mediator to do all our lookups.
   nsresult rv;
@@ -231,40 +287,57 @@
   // by window creation date, instead of the z-ordered list because that's what
   // native apps do.
   nsCOMPtr<nsISimpleEnumerator> windowList;
   rv = wm->GetXULWindowEnumerator(nsnull, getter_AddRefs(windowList));
   NS_ENSURE_SUCCESS(rv, nil);
 
   // Iterate through our list of windows to create our menu
   NSMenu *menu = [[[NSMenu alloc] initWithTitle:@""] autorelease];
+  
+  // If we are currently running a gecko modal session, this item 
+  // needs to be disabled.
+  if (mIsSimulatingModalSession) {
+    [menu setAutoenablesItems:NO];
+  }
+  
   PRBool more;
   while (NS_SUCCEEDED(windowList->HasMoreElements(&more)) && more) {
     // Get our native window
     nsCOMPtr<nsISupports> xulWindow;
     rv = windowList->GetNext(getter_AddRefs(xulWindow));
     NS_ENSURE_SUCCESS(rv, nil);
     NSWindow *cocoaWindow = GetCocoaWindowForXULWindow(xulWindow);
     if (!cocoaWindow) continue;
     
+    // Passing in a |nil| string to the |initWithTitle:| method on |NSMenuItem|
+    // will throw an obj-c exception haulting the XPCOM runtime.
+    NSString *windowTitle = [cocoaWindow title];
+    if (!windowTitle)
+      continue;
+    
     // Now, create a menu item, and add it to the menu
     NSMenuItem *menuItem = [[NSMenuItem alloc]
-                              initWithTitle:[cocoaWindow title]
+                              initWithTitle:windowTitle
                                      action:@selector(dockMenuItemSelected:)
                               keyEquivalent:@""];
     [menuItem setTarget:self];
     [menuItem setRepresentedObject:cocoaWindow];
 
     // If this is the foreground window, put a checkmark next to it
     if (SameCOMIdentity(xulWindow, frontWindow))
       [menuItem setState:NSOnState];
+    
+    if (mIsSimulatingModalSession)
+      [menuItem setEnabled:NO];
 
     [menu addItem:menuItem];
     [menuItem release];
   }
+  
   return menu;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 }
 
 // One of our dock menu items was selected
 - (void)dockMenuItemSelected:(id)sender
 {
@@ -305,10 +378,31 @@
   nsCOMPtr<nsIAppStartup> appService =
            do_GetService("@mozilla.org/toolkit/app-startup;1");
   if (appService)
     appService->Quit(nsIAppStartup::eForceQuit);
 
   return NSTerminateNow;
 }
 
+- (void)onBeginGeckoModalSession:(id)sender
+{
+  mIsSimulatingModalSession = YES;
+  [self configureAppMenu:YES];
+}
+
+- (void)onEndGeckoModalSession:(id)sender
+{
+  mIsSimulatingModalSession = NO;
+  [self configureAppMenu:NO];
+}
+
+- (void)configureAppMenu:(BOOL)inIsModal
+{
+  NSMenu *menu = [[[NSApp mainMenu] itemAtIndex:0] submenu];
+  [menu setAutoenablesItems:!inIsModal];
+  [[menu itemWithTag:ABOUT_MENUITEM_ID] setEnabled:!inIsModal];
+  [[menu itemWithTag:PREFERENCES_MENUTITEM_ID] setEnabled:!inIsModal];
+  [[menu itemWithTag:QUIT_MENUITEM_ID] setEnabled:!inIsModal];
+}
+
 @end
 

