Index: toolkit/components/places/public/nsIFaviconService.idl
===================================================================
RCS file: /cvsroot/mozilla/toolkit/components/places/public/nsIFaviconService.idl,v
retrieving revision 1.6
diff -u -p -r1.6 nsIFaviconService.idl
--- toolkit/components/places/public/nsIFaviconService.idl	25 Mar 2007 12:28:30 -0000	1.6
+++ toolkit/components/places/public/nsIFaviconService.idl	7 Jan 2008 17:54:41 -0000
@@ -40,7 +40,7 @@
 
 interface nsIURI;
 
-[scriptable, uuid(91f635a4-2531-4f3d-89ef-81403a685f44)]
+[scriptable, uuid(f6d59e5a-7562-4a51-aa14-ef569f4d5e1e)]
 interface nsIFaviconService : nsISupports
 {
   /**
@@ -96,9 +96,13 @@ interface nsIFaviconService : nsISupport
    *        Unset is normal behavior, we will only try to reload the favicon
    *        if we don't have it or if it has expired from the cache. If set,
    *        it will always try to reload the favicon.
+   * @param aExpiration
+   *        Time in microseconds since the epoch when this favicon expires.
+   *        Until this time, we won't try to load it again.
    */
   void setAndLoadFaviconForPage(in nsIURI aPage, in nsIURI aFavicon,
-                                in boolean aForceReload);
+                                in boolean aForceReload,
+                                [optional] in PRTime aExpiration);
 
   /**
    * Stores the data of a given favicon. You must specify the MIME type
Index: toolkit/components/places/src/nsFaviconService.cpp
===================================================================
RCS file: /cvsroot/mozilla/toolkit/components/places/src/nsFaviconService.cpp,v
retrieving revision 1.17
diff -u -p -r1.17 nsFaviconService.cpp
--- toolkit/components/places/src/nsFaviconService.cpp	22 Nov 2007 00:44:33 -0000	1.17
+++ toolkit/components/places/src/nsFaviconService.cpp	7 Jan 2008 17:54:41 -0000
@@ -83,7 +83,7 @@ class FaviconLoadListener : public nsISt
 public:
   FaviconLoadListener(nsFaviconService* aFaviconService,
                       nsIURI* aPageURI, nsIURI* aFaviconURI,
-                      nsIChannel* aChannel);
+                      nsIChannel* aChannel, PRTime aExpiration);
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIREQUESTOBSERVER
@@ -99,6 +99,8 @@ private:
   nsCOMPtr<nsIURI> mPageURI;
   nsCOMPtr<nsIURI> mFaviconURI;
 
+  PRTime mExpiration;
+
   nsCString mData;
 };
 
@@ -381,7 +383,7 @@ nsFaviconService::SendFaviconNotificatio
 
 NS_IMETHODIMP
 nsFaviconService::SetAndLoadFaviconForPage(nsIURI* aPage, nsIURI* aFavicon,
-                                           PRBool aForceReload)
+                                           PRBool aForceReload, PRTime aExpiration)
 {
   NS_ENSURE_ARG_POINTER(aPage);
   NS_ENSURE_ARG_POINTER(aFavicon);
@@ -390,9 +392,9 @@ nsFaviconService::SetAndLoadFaviconForPa
   nsNavHistory* historyService = nsNavHistory::GetHistoryService();
   NS_ENSURE_TRUE(historyService, NS_ERROR_OUT_OF_MEMORY);
   return historyService->AddLazyLoadFaviconMessage(aPage, aFavicon,
-                                                   aForceReload);
+                                                   aForceReload, aExpiration);
 #else
-  return DoSetAndLoadFaviconForPage(aPage, aFavicon, aForceReload);
+  return DoSetAndLoadFaviconForPage(aPage, aFavicon, aForceReload, aExpiration);
 #endif
 }
 
@@ -401,7 +403,8 @@ nsFaviconService::SetAndLoadFaviconForPa
 
 nsresult
 nsFaviconService::DoSetAndLoadFaviconForPage(nsIURI* aPage, nsIURI* aFavicon,
-                                             PRBool aForceReload)
+                                             PRBool aForceReload,
+                                             PRTime aExpiration)
 {
   nsCOMPtr<nsIURI> page(aPage);
 
@@ -525,7 +528,7 @@ nsFaviconService::DoSetAndLoadFaviconFor
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIStreamListener> listener =
-    new FaviconLoadListener(this, page, aFavicon, channel);
+    new FaviconLoadListener(this, page, aFavicon, channel, aExpiration);
   NS_ENSURE_TRUE(listener, NS_ERROR_OUT_OF_MEMORY);
   nsCOMPtr<nsIInterfaceRequestor> listenerRequestor =
     do_QueryInterface(listener, &rv);
@@ -810,11 +813,12 @@ NS_IMPL_ISUPPORTS4(FaviconLoadListener,
 
 FaviconLoadListener::FaviconLoadListener(nsFaviconService* aFaviconService,
                                          nsIURI* aPageURI, nsIURI* aFaviconURI,
-                                         nsIChannel* aChannel) :
+                                         nsIChannel* aChannel, PRTime aExpiration) :
   mFaviconService(aFaviconService),
   mChannel(aChannel),
   mPageURI(aPageURI),
-  mFaviconURI(aFaviconURI)
+  mFaviconURI(aFaviconURI),
+  mExpiration(aExpiration)
 {
 }
 
@@ -891,26 +895,28 @@ FaviconLoadListener::OnStopRequest(nsIRe
     return NS_OK;
   }
 
-  // Expire this favicon in one day. An old version of this actually extracted
-  // the expiration time from the cache. But what if people (especially web
-  // developers) get a bad favicon or change it? The problem is that we're not
-  // aware when the icon has been reloaded in the cache or cleared. This way
-  // we'll always pick up any changes in the cache after a day. In most cases
-  // re-set favicons will come from the cache anyway and reloading them is not
-  // very expensive.
-  PRTime expiration = PR_Now() +
-                      (PRInt64)(24 * 60 * 60) * (PRInt64)PR_USEC_PER_SEC;
+  if (!mExpiration) {
+    // Expire this favicon in one day. An old version of this actually extracted
+    // the expiration time from the cache. But what if people (especially web
+    // developers) get a bad favicon or change it? The problem is that we're not
+    // aware when the icon has been reloaded in the cache or cleared. This way
+    // we'll always pick up any changes in the cache after a day. In most cases
+    // re-set favicons will come from the cache anyway and reloading them is not
+    // very expensive.
+    mExpiration = PR_Now() +
+                  (PRInt64)(24 * 60 * 60) * (PRInt64)PR_USEC_PER_SEC;
+  }
 
   // save the favicon data
   rv = mFaviconService->SetFaviconData(mFaviconURI,
                reinterpret_cast<PRUint8*>(const_cast<char*>(mData.get())),
-               mData.Length(), mimeType, expiration);
+               mData.Length(), mimeType, mExpiration);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // set the favicon for the page
   PRBool hasData;
   rv = mFaviconService->SetFaviconUrlForPageInternal(mPageURI, mFaviconURI,
-                                                     &hasData, &expiration);
+                                                     &hasData, &mExpiration);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mFaviconService->SendFaviconNotifications(mPageURI, mFaviconURI);
Index: toolkit/components/places/src/nsFaviconService.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/components/places/src/nsFaviconService.h,v
retrieving revision 1.7
diff -u -p -r1.7 nsFaviconService.h
--- toolkit/components/places/src/nsFaviconService.h	5 Jun 2007 23:18:47 -0000	1.7
+++ toolkit/components/places/src/nsFaviconService.h	7 Jan 2008 17:54:42 -0000
@@ -81,7 +81,7 @@ public:
 
   // internal version called by history when done lazily
   nsresult DoSetAndLoadFaviconForPage(nsIURI* aPage, nsIURI* aFavicon,
-                                      PRBool aForceReload);
+                                      PRBool aForceReload, PRTime aExpiration);
 
   // addition to API for strings to prevent excessive parsing of URIs
   nsresult GetFaviconLinkForIconString(const nsCString& aIcon, nsIURI** aOutput);
Index: toolkit/components/places/src/nsNavHistory.cpp
===================================================================
RCS file: /cvsroot/mozilla/toolkit/components/places/src/nsNavHistory.cpp,v
retrieving revision 1.223
diff -u -p -r1.223 nsNavHistory.cpp
--- toolkit/components/places/src/nsNavHistory.cpp	5 Jan 2008 05:16:27 -0000	1.223
+++ toolkit/components/places/src/nsNavHistory.cpp	7 Jan 2008 17:54:45 -0000
@@ -3600,7 +3600,8 @@ nsNavHistory::Observe(nsISupports *aSubj
 
 nsresult
 nsNavHistory::AddLazyLoadFaviconMessage(nsIURI* aPage, nsIURI* aFavicon,
-                                        PRBool aForceReload)
+                                        PRBool aForceReload,
+                                        PRTime aExpiration)
 {
   LazyMessage message;
   nsresult rv = message.Init(LazyMessage::Type_Favicon, aPage);
@@ -3608,6 +3609,7 @@ nsNavHistory::AddLazyLoadFaviconMessage(
   rv = aFavicon->Clone(getter_AddRefs(message.favicon));
   NS_ENSURE_SUCCESS(rv, rv);
   message.alwaysLoadFavicon = aForceReload;
+  message.expirationTime = aExpiration;
   return AddLazyMessage(message);
 }
 
@@ -3695,7 +3697,8 @@ nsNavHistory::CommitLazyMessages()
           message.uri->GetSpec(spec);
           faviconService->DoSetAndLoadFaviconForPage(message.uri,
                                                      message.favicon,
-                                                     message.alwaysLoadFavicon);
+                                                     message.alwaysLoadFavicon,
+                                                     message.expirationTime);
         }
         break;
       }
Index: toolkit/components/places/src/nsNavHistory.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/components/places/src/nsNavHistory.h,v
retrieving revision 1.119
diff -u -p -r1.119 nsNavHistory.h
--- toolkit/components/places/src/nsNavHistory.h	5 Jan 2008 05:16:27 -0000	1.119
+++ toolkit/components/places/src/nsNavHistory.h	7 Jan 2008 17:54:48 -0000
@@ -167,7 +167,7 @@ public:
    * that favicons are handled lazily just like page adds.
    */
   nsresult AddLazyLoadFaviconMessage(nsIURI* aPage, nsIURI* aFavicon,
-                                     PRBool aForceReload);
+                                     PRBool aForceReload, PRTime aExpiration);
 #endif
 
   /**
@@ -440,6 +440,7 @@ protected:
       isToplevel = PR_FALSE;
       time = 0;
       alwaysLoadFavicon = PR_FALSE;
+      expirationTime = 0;
     }
 
     // call this with common parms to initialize. Caller is responsible for
@@ -470,6 +471,7 @@ protected:
     // valid when type == LAZY_FAVICON
     nsCOMPtr<nsIURI> favicon;
     PRBool alwaysLoadFavicon;
+    PRTime expirationTime;
   };
   nsTArray<LazyMessage> mLazyMessages;
   nsCOMPtr<nsITimer> mLazyTimer;
