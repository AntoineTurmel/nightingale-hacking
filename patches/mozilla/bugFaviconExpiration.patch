Index: toolkit/components/places/public/nsIFaviconService.idl
===================================================================
RCS file: /cvsroot/mozilla/toolkit/components/places/public/nsIFaviconService.idl,v
retrieving revision 1.8
diff -u -8 -r1.8 nsIFaviconService.idl
--- toolkit/components/places/public/nsIFaviconService.idl	8 May 2008 16:36:54 -0000	1.8
+++ toolkit/components/places/public/nsIFaviconService.idl	14 May 2008 17:43:35 -0000
@@ -35,17 +35,17 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 
 interface nsIURI;
 
-[scriptable, uuid(91f635a4-2531-4f3d-89ef-81403a685f44)]
+[scriptable, uuid(f6d59e5a-7562-4a51-aa14-ef569f4d5e1e)]
 interface nsIFaviconService : nsISupports
 {
   /**
    * Declares that a given page uses a favicon with the given URI.
    *
    * You needn't have specified any data at this point. An entry linking the
    * favicon with the page will be create with no data. You can populate it
    * later with SetFaviconData.  However, any favicons not associated with a
@@ -92,19 +92,23 @@
    * @param aPageURI
    *        URI of the page whose favicon is being set.
    * @param aFaviconURI
    *        URI of the favicon to associate with the page.
    * @param aForceReload
    *        Unset is normal behavior, we will only try to reload the favicon
    *        if we don't have it or if it has expired from the cache. If set,
    *        it will always try to reload the favicon.
+   * @param aExpiration
+   *        Time in microseconds since the epoch when this favicon expires.
+   *        Until this time, we don't try to load it again.
    */
   void setAndLoadFaviconForPage(in nsIURI aPageURI, in nsIURI aFaviconURI,
-                                in boolean aForceReload);
+                                in boolean aForceReload,
+                                [optional] in PRTime aExpiration);
 
   /**
    * Stores the data of a given favicon. You must specify the MIME type
    * unless you're clearing the data.
    *
    * You can set the data even if you haven't called SetFaviconUrlForPage
    * yet. It will be stored but will not be associated with any page.
    * However, any favicons not associated with a visited web page, bookmark,
Index: toolkit/components/places/src/nsFaviconService.cpp
===================================================================
RCS file: /cvsroot/mozilla/toolkit/components/places/src/nsFaviconService.cpp,v
retrieving revision 1.27
diff -u -8 -r1.27 nsFaviconService.cpp
--- toolkit/components/places/src/nsFaviconService.cpp	9 May 2008 07:25:29 -0000	1.27
+++ toolkit/components/places/src/nsFaviconService.cpp	14 May 2008 17:38:58 -0000
@@ -77,32 +77,34 @@

 class FaviconLoadListener : public nsIStreamListener,
                             public nsIInterfaceRequestor,
                             public nsIChannelEventSink
 {
 public:
   FaviconLoadListener(nsFaviconService* aFaviconService,
                       nsIURI* aPageURI, nsIURI* aFaviconURI,
-                      nsIChannel* aChannel);
+                      nsIChannel* aChannel, PRTime aExpiration);

   NS_DECL_ISUPPORTS
   NS_DECL_NSIREQUESTOBSERVER
   NS_DECL_NSISTREAMLISTENER
   NS_DECL_NSIINTERFACEREQUESTOR
   NS_DECL_NSICHANNELEVENTSINK

 private:
   ~FaviconLoadListener();

   nsCOMPtr<nsFaviconService> mFaviconService;
   nsCOMPtr<nsIChannel> mChannel;
   nsCOMPtr<nsIURI> mPageURI;
   nsCOMPtr<nsIURI> mFaviconURI;

+  PRTime mExpiration;
+
   nsCString mData;
 };


 nsFaviconService* nsFaviconService::gFaviconService;

 NS_IMPL_ISUPPORTS1(nsFaviconService, nsIFaviconService)

@@ -397,39 +399,42 @@
 }


 // nsFaviconService::SetAndLoadFaviconForPage

 NS_IMETHODIMP
 nsFaviconService::SetAndLoadFaviconForPage(nsIURI* aPageURI,
                                            nsIURI* aFaviconURI,
-                                           PRBool aForceReload)
+                                           PRBool aForceReload,
+                                           PRTime aExpiration)
 {
   NS_ENSURE_ARG_POINTER(aPageURI);
   NS_ENSURE_ARG_POINTER(aFaviconURI);

 #ifdef LAZY_ADD
   nsNavHistory* historyService = nsNavHistory::GetHistoryService();
   NS_ENSURE_TRUE(historyService, NS_ERROR_OUT_OF_MEMORY);
   return historyService->AddLazyLoadFaviconMessage(aPageURI,
                                                    aFaviconURI,
-                                                   aForceReload);
+                                                   aForceReload,
+                                                   aExpiration);
 #else
-  return DoSetAndLoadFaviconForPage(aPageURI, aFaviconURI, aForceReload);
+  return DoSetAndLoadFaviconForPage(aPageURI, aFaviconURI, aForceReload, aExpiration);
 #endif
 }


 // nsFaviconService::DoSetAndLoadFaviconForPage

 nsresult
 nsFaviconService::DoSetAndLoadFaviconForPage(nsIURI* aPageURI,
                                              nsIURI* aFaviconURI,
-                                             PRBool aForceReload)
+                                             PRBool aForceReload,
+                                             PRTime aExpiration)
 {
   nsCOMPtr<nsIURI> page(aPageURI);

   // don't load favicons when history is disabled
   nsNavHistory* history = nsNavHistory::GetHistoryService();
   NS_ENSURE_TRUE(history, NS_ERROR_FAILURE);
   if (history->IsHistoryDisabled()) {
     // history is disabled - check to see if this favicon could be for a
@@ -545,17 +550,17 @@
   nsCOMPtr<nsIIOService> ioservice = do_GetIOService(&rv);
   NS_ENSURE_SUCCESS(rv, rv);

   nsCOMPtr<nsIChannel> channel;
   rv = ioservice->NewChannelFromURI(aFaviconURI, getter_AddRefs(channel));
   NS_ENSURE_SUCCESS(rv, rv);

   nsCOMPtr<nsIStreamListener> listener =
-    new FaviconLoadListener(this, page, aFaviconURI, channel);
+    new FaviconLoadListener(this, page, aFaviconURI, channel, aExpiration);
   NS_ENSURE_TRUE(listener, NS_ERROR_OUT_OF_MEMORY);
   nsCOMPtr<nsIInterfaceRequestor> listenerRequestor =
     do_QueryInterface(listener, &rv);
   NS_ENSURE_SUCCESS(rv, rv);

   rv = channel->SetNotificationCallbacks(listenerRequestor);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = channel->AsyncOpen(listener, nsnull);
@@ -888,21 +893,22 @@
                    nsIStreamListener,
                    nsIInterfaceRequestor,
                    nsIChannelEventSink)

 // FaviconLoadListener::FaviconLoadListener

 FaviconLoadListener::FaviconLoadListener(nsFaviconService* aFaviconService,
                                          nsIURI* aPageURI, nsIURI* aFaviconURI,
-                                         nsIChannel* aChannel) :
+                                         nsIChannel* aChannel, PRTime aExpiration) :
   mFaviconService(aFaviconService),
   mChannel(aChannel),
   mPageURI(aPageURI),
-  mFaviconURI(aFaviconURI)
+  mFaviconURI(aFaviconURI),
+  mExpiration(aExpiration)
 {
 }


 // FaviconLoadListener::~FaviconLoadListener

 FaviconLoadListener::~FaviconLoadListener()
 {
@@ -967,36 +973,38 @@
   }

   if (mimeType.IsEmpty()) {
     // we can not handle favicons that do not have a recognisable MIME type
     mFaviconService->AddFailedFavicon(mFaviconURI);
     return NS_OK;
   }

-  // Expire this favicon in one day. An old version of this actually extracted
-  // the expiration time from the cache. But what if people (especially web
-  // developers) get a bad favicon or change it? The problem is that we're not
-  // aware when the icon has been reloaded in the cache or cleared. This way
-  // we'll always pick up any changes in the cache after a day. In most cases
-  // re-set favicons will come from the cache anyway and reloading them is not
-  // very expensive.
-  PRTime expiration = PR_Now() +
-                      (PRInt64)(24 * 60 * 60) * (PRInt64)PR_USEC_PER_SEC;
+  if (!mExpiration) {
+    // Expire this favicon in one day. An old version of this actually extracted
+    // the expiration time from the cache. But what if people (especially web
+    // developers) get a bad favicon or change it? The problem is that we're not
+    // aware when the icon has been reloaded in the cache or cleared. This way
+    // we'll always pick up any changes in the cache after a day. In most cases
+    // re-set favicons will come from the cache anyway and reloading them is not
+    // very expensive.
+    mExpiration = PR_Now() +
+                  (PRInt64)(24 * 60 * 60) * (PRInt64)PR_USEC_PER_SEC;
+  }

   // save the favicon data
   rv = mFaviconService->SetFaviconData(mFaviconURI,
                reinterpret_cast<PRUint8*>(const_cast<char*>(mData.get())),
-               mData.Length(), mimeType, expiration);
+               mData.Length(), mimeType, mExpiration);
   NS_ENSURE_SUCCESS(rv, rv);

   // set the favicon for the page
   PRBool hasData;
   rv = mFaviconService->SetFaviconUrlForPageInternal(mPageURI, mFaviconURI,
-                                                     &hasData, &expiration);
+                                                     &hasData, &mExpiration);
   NS_ENSURE_SUCCESS(rv, rv);

   mFaviconService->SendFaviconNotifications(mPageURI, mFaviconURI);
   mFaviconService->UpdateBookmarkRedirectFavicon(mPageURI, mFaviconURI);
   return NS_OK;
 }


Index: toolkit/components/places/src/nsFaviconService.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/components/places/src/nsFaviconService.h,v
retrieving revision 1.10
diff -u -p -r1.10 nsFaviconService.h
--- toolkit/components/places/src/nsFaviconService.h	20 Jan 2008 06:48:07 -0000	1.10
+++ toolkit/components/places/src/nsFaviconService.h	1 Feb 2008 18:39:03 -0000
@@ -81,7 +81,7 @@ public:
 
   // internal version called by history when done lazily
   nsresult DoSetAndLoadFaviconForPage(nsIURI* aPage, nsIURI* aFavicon,
-                                      PRBool aForceReload);
+                                      PRBool aForceReload, PRTime aExpiration);
 
   // addition to API for strings to prevent excessive parsing of URIs
   nsresult GetFaviconLinkForIconString(const nsCString& aIcon, nsIURI** aOutput);
Index: toolkit/components/places/src/nsNavHistory.cpp
===================================================================
RCS file: /cvsroot/mozilla/toolkit/components/places/src/nsNavHistory.cpp,v
retrieving revision 1.231
diff -u -p -r1.231 nsNavHistory.cpp
--- toolkit/components/places/src/nsNavHistory.cpp	25 Jan 2008 17:11:14 -0000	1.231
+++ toolkit/components/places/src/nsNavHistory.cpp	1 Feb 2008 18:39:03 -0000
@@ -4011,7 +4011,8 @@ nsNavHistory::Observe(nsISupports *aSubj
 
 nsresult
 nsNavHistory::AddLazyLoadFaviconMessage(nsIURI* aPage, nsIURI* aFavicon,
-                                        PRBool aForceReload)
+                                        PRBool aForceReload,
+                                        PRTime aExpiration)
 {
   LazyMessage message;
   nsresult rv = message.Init(LazyMessage::Type_Favicon, aPage);
@@ -4019,6 +4020,7 @@ nsNavHistory::AddLazyLoadFaviconMessage(
   rv = aFavicon->Clone(getter_AddRefs(message.favicon));
   NS_ENSURE_SUCCESS(rv, rv);
   message.alwaysLoadFavicon = aForceReload;
+  message.expirationTime = aExpiration;
   return AddLazyMessage(message);
 }
 
@@ -4106,7 +4108,8 @@ nsNavHistory::CommitLazyMessages()
           message.uri->GetSpec(spec);
           faviconService->DoSetAndLoadFaviconForPage(message.uri,
                                                      message.favicon,
-                                                     message.alwaysLoadFavicon);
+                                                     message.alwaysLoadFavicon,
+                                                     message.expirationTime);
         }
         break;
       }
Index: toolkit/components/places/src/nsNavHistory.h
===================================================================
RCS file: /cvsroot/mozilla/toolkit/components/places/src/nsNavHistory.h,v
retrieving revision 1.123
diff -u -p -r1.123 nsNavHistory.h
--- toolkit/components/places/src/nsNavHistory.h	25 Jan 2008 17:11:14 -0000	1.123
+++ toolkit/components/places/src/nsNavHistory.h	1 Feb 2008 18:39:03 -0000
@@ -175,7 +175,7 @@ public:
    * that favicons are handled lazily just like page adds.
    */
   nsresult AddLazyLoadFaviconMessage(nsIURI* aPage, nsIURI* aFavicon,
-                                     PRBool aForceReload);
+                                     PRBool aForceReload, PRTime aExpiration);
 #endif
 
   /**
@@ -469,6 +469,7 @@ protected:
       isToplevel = PR_FALSE;
       time = 0;
       alwaysLoadFavicon = PR_FALSE;
+      expirationTime = 0;
     }
 
     // call this with common parms to initialize. Caller is responsible for
@@ -499,6 +500,7 @@ protected:
     // valid when type == LAZY_FAVICON
     nsCOMPtr<nsIURI> favicon;
     PRBool alwaysLoadFavicon;
+    PRTime expirationTime;
   };
   nsTArray<LazyMessage> mLazyMessages;
   nsCOMPtr<nsITimer> mLazyTimer;
