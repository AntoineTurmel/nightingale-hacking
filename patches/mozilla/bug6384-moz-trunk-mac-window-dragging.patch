? .cvsignore
? compiled
? extensions/inspector/resources/content/tasksOverlay-songbird.xul
Index: widget/src/cocoa/nsChildView.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsChildView.h,v
retrieving revision 1.77
diff -u -8 -p -r1.77 nsChildView.h
--- widget/src/cocoa/nsChildView.h	26 Nov 2007 18:09:38 -0000	1.77
+++ widget/src/cocoa/nsChildView.h	19 Dec 2007 02:18:59 -0000
@@ -86,16 +86,19 @@ union nsPluginPort;
   nsChildView* mGeckoChild;
     
   // tag for our mouse enter/exit tracking rect
   NSTrackingRectTag mMouseEnterExitTag;
 
   // Whether we're a plugin view.
   BOOL mIsPluginView;
 
+  // Whether we're in nsChildView::SetFocus()
+  int mInSetFocusLevel;
+
   NSEvent* mCurKeyEvent;   // only valid during a keyDown
   PRBool mKeyDownHandled;
   
   // needed for NSTextInput implementation
   NSRange mMarkedRange;
   NSRange mSelectedRange;
   BOOL mIgnoreDoCommand;
 
Index: widget/src/cocoa/nsChildView.mm
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsChildView.mm,v
retrieving revision 1.285
diff -u -8 -p -r1.285 nsChildView.mm
--- widget/src/cocoa/nsChildView.mm	5 Dec 2007 23:17:08 -0000	1.285
+++ widget/src/cocoa/nsChildView.mm	19 Dec 2007 02:18:59 -0000
@@ -713,21 +713,74 @@ NS_IMETHODIMP nsChildView::IsEnabled(PRB
 {
   // unimplemented
   if (aState)
    *aState = PR_TRUE;
   return NS_OK;
 }
 
 
+class nsAutoSetInSetFocus {
+  public:
+    nsAutoSetInSetFocus(NSView *aView)
+    {
+      if ([aView isKindOfClass:[ChildView class]]) {
+        mChildView = (ChildView *) [aView retain];
+        [mChildView setInSetFocus:PR_TRUE];
+      } else {
+        mChildView = nil;
+      }
+    }
+    ~nsAutoSetInSetFocus()
+    {
+      if (mChildView) {
+        [mChildView setInSetFocus:PR_FALSE];
+        [mChildView release];
+      }
+    }
+
+  private:
+    ChildView *mChildView;  // [STRONG]
+};
+
+
 NS_IMETHODIMP nsChildView::SetFocus(PRBool aRaise)
 {
   NSWindow* window = [mView window];
-  if (window)
-    [window makeFirstResponder:mView];
+  if (window) {
+    // For reasons that aren't yet clear, focus changes within a window (as
+    // opposed to those between windows or between apps) should only trigger
+    // NS_LOSTFOCUS and NS_GOTFOCUS messages (to Gecko) in the context of a
+    // call to nsChildView::SetFocus() (or nsCocoaWindow::SetFocus(), which
+    // in any case re-routes to nsChildView::SetFocus()).  If we send these
+    // messages on every intra-window focus change (on every call to
+    // [ChildView becomeFirstResponder:] or [ChildView resignFirstResponder:]),
+    // the result will be strange focus bugs (like bmo bugs 399471, 403232
+    // and 404433).
+    nsAutoSetInSetFocus setInSetFocus(mView);
+    NSResponder* firstResponder = [window firstResponder];
+    if ([mView isEqual:firstResponder]) {
+      // Sometimes SetFocus() is called on an nsChildView object that's
+      // already focused.  If we simply call [NSWindow makeFirstResponder:],
+      // neither [ChildView becomeFirstResponder:] nor [ChildView
+      // resignFirstResponder:] will get called, and no NS_LOSTFOCUS or
+      // NS_GOTFOCUS messages will be sent.  But in this case we sometimes
+      // get text-input cursors blinking in more than one text field.  So we
+      // need to guarantee that the code in nsEventStateManager::
+      // PreHandleEvent() which handles NS_LOSTFOCUS messages (and calls
+      // SetContentCaretVisible(... PR_FALSE)) gets invoked on every call to
+      // nsChildView::SetFocus().
+      if ([mView isKindOfClass:[ChildView class]]) {
+        [(ChildView *)mView sendFocusEvent:NS_LOSTFOCUS];
+        [(ChildView *)mView sendFocusEvent:NS_GOTFOCUS];
+      }
+    } else {
+      [window makeFirstResponder:mView];
+    }
+  }
   return NS_OK;
 }
 
 
 // Set the colormap of the window
 NS_IMETHODIMP nsChildView::SetColorMap(nsColorMap *aColorMap)
 {
   return NS_OK;
@@ -1758,16 +1811,17 @@ NSEvent* gLastDragEvent = nil;
 
 // initWithFrame:geckoChild:
 - (id)initWithFrame:(NSRect)inFrame geckoChild:(nsChildView*)inChild
 {
   if ((self = [super initWithFrame:inFrame])) {
     mWindow = nil;
     mGeckoChild = inChild;
     mIsPluginView = NO;
+    mInSetFocusLevel = 0;
     mCurKeyEvent = nil;
     mKeyDownHandled = PR_FALSE;
     
     // initialization for NSTextInput
     mMarkedRange.location = NSNotFound;
     mMarkedRange.length = 0;
     mSelectedRange.location = NSNotFound;
     mSelectedRange.length = 0;
@@ -2069,16 +2123,34 @@ NSEvent* gLastDragEvent = nil;
     if ([subview respondsToSelector:@selector(isPluginView)] && [subview isPluginView])
       return YES;
   }
   
   return NO;
 }
 
 
+-(void)setInSetFocus:(BOOL)aInSetFocus
+{
+  if (aInSetFocus) {
+    ++mInSetFocusLevel;
+  } else if (mInSetFocusLevel > 0) {
+    --mInSetFocusLevel;
+  } else {
+    NS_WARNING("ChildView setInFocus: inSetFocus already false");
+  }
+}
+
+
+-(BOOL)inSetFocus
+{
+  return mInSetFocusLevel > 0;
+}
+
+
 - (void)sendFocusEvent:(PRUint32)eventType
 {
   if (!mGeckoChild)
     return;
 
   nsEventStatus status = nsEventStatus_eIgnore;
   nsGUIEvent focusGuiEvent(PR_TRUE, eventType, mGeckoChild);
   focusGuiEvent.time = PR_IntervalNow();
@@ -2314,112 +2386,82 @@ NSEvent* gLastDragEvent = nil;
                                                 clickCount:[theEvent clickCount]
                                                   pressure:[theEvent pressure]];
     [self rightMouseDown:clickHoldEvent];
   }
 }
 #endif
 
 
-// Events should always go to the window that is directly under the point where
-// the event happened, with one exception. If there is no window under the event,
-// mouse moved events should go to the rollup widget if it exists. The return value
-// of this method indicates whether or not the event was supposed to be sent to this
-// view. If the return value is YES, then this view should continue to process the
-// event. If the return value is NO, the event was rerouted and this view should not
-// process the event.
+// We sometimes need to reroute events when there is a rollup widget and the
+// event isn't targeted at it.
 //
 // Rerouting may be needed when the user tries to navigate a context menu while
 // keeping the mouse-button down (left or right mouse button) -- the OS thinks this
 // is a dragging operation, so it sends events (mouseMoved and mouseUp) to the
 // window where the dragging operation started (the parent of the context
 // menu window).  It also works around a bizarre Apple bug - if (while a context
 // menu is open) you move the mouse over another app's window and then back over
 // the context menu, mouseMoved events will be sent to the window underneath the
 // context menu.
 - (BOOL)ensureCorrectMouseEventTarget:(NSEvent*)anEvent
 {
-  NSWindow* windowUnderMouse = nsCocoaUtils::FindWindowUnderPoint(nsCocoaUtils::ScreenLocationForEvent(anEvent));
+  // If there is no rollup widget we assume the OS routed the event correctly.
+  if (!gRollupWidget)
+    return YES;
 
-  if (windowUnderMouse == mWindow)
+  // If this is the rollup widget and the event is not a mouse move then trust the OS routing.  
+  // The reason for this trust is complicated.
+  //
+  // There are three types of mouse events that can legitimately need to be targeted at a window
+  // that they are not over. Mouse moves, mouse drags, and mouse ups. Anything else our app wouldn't
+  // handle (if the mouse was not over any window) or it would go to the appropriate window.
+  //
+  // We need to do manual event rerouting for mouse moves because we know that in some cases, like
+  // when there is a submenu opened from a popup window, the OS will route mouse move events to the
+  // submenu even if the mouse is over the parent. Mouse move events are never tied to a particular
+  // window because of some originating action like the starting point of a drag for drag events or
+  // a mouse down event for mouse up events, so it is always safe to do our own routing on them here.
+  //
+  // As for mouse drags and mouse ups, they have originating actions that tie them to windows they
+  // may no longer be over. If there is a rollup window present when one of these events is getting
+  // processed but we are not it, we are probably the window where the action originated, and that
+  // action must have caused the rollup window to come into existence. In that case, we might need
+  // to reroute the event if it is over the rollup window. That is why if we're not the rollup window
+  // we don't return YES here.
+  NSWindow* rollupWindow = (NSWindow*)gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
+  if (mWindow == rollupWindow && [anEvent type] != NSMouseMoved)
     return YES;
 
-  if (!windowUnderMouse) {
-    if ([anEvent type] == NSMouseMoved) {
-      if (gRollupWidget) {
-        // If a mouse moved event is not over any window and there is a rollup widget, the event
-        // should go to the rollup widget.
-        NSWindow* rollupWindow = (NSWindow*)gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
-        if (mWindow == rollupWindow)
-          return YES;
-        else
-          windowUnderMouse = rollupWindow;
-      }
-      else {
-        // If the event is not over a window and is a mouse moved event but there is no rollup widget,
-        // then we don't want it to get handled. Essentially, reroute it to nowhere.
-        return NO;
-      }
-    }
-    else {
-      // If the event is not over a window and is not a mouse moved event, then we don't
-      // want it to get handled. Essentially, reroute it to nowhere.
-      return NO;
-    }
-  }
+  // Find the window that the event is over.
+  NSWindow* targetWindow = nsCocoaUtils::FindWindowUnderPoint(nsCocoaUtils::ScreenLocationForEvent(anEvent));
 
-  NSEventType type = [anEvent type];
-  NSPoint newWindowLocation = nsCocoaUtils::EventLocationForWindow(anEvent, windowUnderMouse);
-  NSEvent *newEvent = nil;
-
-  // If anEvent is a mouseUp event, send an extra mouseDown event before
-  // sending a mouseUp event -- this is needed to support selection by
-  // dragging the mouse to a menu item and then releasing it.  We retain
-  // the window in case it gets destroyed as a result of the extra
-  // mouseDown (and release it below).
-  if (type == NSLeftMouseUp || type == NSRightMouseUp) {
-    [windowUnderMouse retain];
-    NSEventType extraEventType;
-    switch (type) {
-      case NSLeftMouseUp:
-        extraEventType = NSLeftMouseDown;
-        break;
-      case NSRightMouseUp:
-        extraEventType = NSRightMouseDown;
-        break;
-      default:
-        extraEventType = (NSEventType) 0;
-        break;
-    }
-    newEvent = [NSEvent mouseEventWithType:extraEventType
-                                  location:newWindowLocation
-                             modifierFlags:[anEvent modifierFlags]
-                                 timestamp:GetCurrentEventTime()
-                              windowNumber:[windowUnderMouse windowNumber]
-                                   context:nil
-                               eventNumber:0
-                                clickCount:1
-                                  pressure:0.0];
-    [windowUnderMouse sendEvent:newEvent];
-  }
-
-  newEvent = [NSEvent mouseEventWithType:type
-                                location:newWindowLocation
-                           modifierFlags:[anEvent modifierFlags]
-                               timestamp:GetCurrentEventTime()
-                            windowNumber:[windowUnderMouse windowNumber]
-                                 context:nil
-                             eventNumber:0
-                              clickCount:1
-                                pressure:0.0];
-  [windowUnderMouse sendEvent:newEvent];
+  // If the event was not over any window, send it to the rollup window.
+  if (!targetWindow)
+    targetWindow = rollupWindow;
+
+  // At this point we've resolved a target window, if we are it then just return
+  // yes so we handle it. No need to redirect.
+  if (targetWindow == mWindow)
+    return YES;
 
-  if (type == NSLeftMouseUp || type == NSRightMouseUp)
-    [windowUnderMouse release];
+  // Send the event to its new destination.
+  NSPoint newWindowLocation = nsCocoaUtils::EventLocationForWindow(anEvent, targetWindow);
+  NSEvent *newEvent = [NSEvent mouseEventWithType:[anEvent type]
+                                         location:newWindowLocation
+                                    modifierFlags:[anEvent modifierFlags]
+                                        timestamp:GetCurrentEventTime()
+                                     windowNumber:[targetWindow windowNumber]
+                                          context:nil
+                                      eventNumber:0
+                                       clickCount:1
+                                         pressure:0.0];
+  [targetWindow sendEvent:newEvent];
 
+  // Return NO because we just sent the event somewhere else.
   return NO;
 }
 
 
 // If we've just created a non-native context menu, we need to mark it as
 // such and let the OS (and other programs) know when it opens and closes
 // (this is how the OS knows to close other programs' context menus when
 // ours open).  We send the initial notification here, but others are sent
@@ -4111,30 +4153,37 @@ static BOOL keyUpAlreadySentKeyDown = NO
 
 
 // This method is called when we are about to be focused.
 - (BOOL)becomeFirstResponder
 {
   if (!mGeckoChild)
     return NO;
 
-  [self sendFocusEvent:NS_GOTFOCUS];
+  // Focus events should only be sent to Gecko here in the context of a call
+  // to nsChildView::SetFocus().  For more info see nsChildView::SetFocus()
+  // above.
+  if ([self inSetFocus])
+    [self sendFocusEvent:NS_GOTFOCUS];
 
   return [super becomeFirstResponder];
 }
 
 
 // This method is called when are are about to lose focus.
 // We must always call through to our superclass, even when mGeckoChild is
 // nil -- otherwise the keyboard focus can end up in the wrong NSView.
 - (BOOL)resignFirstResponder
 {
   nsTSMManager::CommitIME();
 
-  if (mGeckoChild)
+  // Focus events should only be sent to Gecko here in the context of a call
+  // to nsChildView::SetFocus().  For more info see nsChildView::SetFocus()
+  // above.
+  if (mGeckoChild && [self inSetFocus])
     [self sendFocusEvent:NS_LOSTFOCUS];
 
   return [super resignFirstResponder];
 }
 
 
 - (void)viewsWindowDidBecomeKey
 {
Index: widget/src/cocoa/nsCocoaWindow.mm
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsCocoaWindow.mm,v
retrieving revision 1.125
diff -u -8 -p -r1.125 nsCocoaWindow.mm
--- widget/src/cocoa/nsCocoaWindow.mm	5 Dec 2007 23:17:08 -0000	1.125
+++ widget/src/cocoa/nsCocoaWindow.mm	19 Dec 2007 02:18:59 -0000
@@ -1706,68 +1706,73 @@ void patternDraw(void* aInfo, CGContextR
 
 // The OS treats our custom popup windows very strangely -- many mouse events
 // sent to them never reach their target NSView objects.  (That these windows
 // are borderless and of level NSPopUpMenuWindowLevel may have something to do
 // with it.)  The best solution is to pre-empt the OS, as follows.  (All
 // events for a given NSWindow object go through its sendEvent: method.)
 - (void)sendEvent:(NSEvent *)anEvent
 {
-  NSView *target = nil, *contentView = nil;
+  NSView *target = nil;
+  NSView *contentView = nil;
   NSEventType type = [anEvent type];
   NSPoint windowLocation = NSZeroPoint;
   switch (type) {
     case NSScrollWheel:
     case NSLeftMouseDown:
     case NSLeftMouseUp:
     case NSRightMouseDown:
     case NSRightMouseUp:
     case NSOtherMouseDown:
     case NSOtherMouseUp:
     case NSMouseMoved:
     case NSLeftMouseDragged:
     case NSRightMouseDragged:
     case NSOtherMouseDragged:
-      if ((contentView = [self contentView]) != nil) {
+      if ((contentView = [self contentView])) {
         // Since [anEvent window] might not be us, we can't use [anEvent locationInWindow].
         windowLocation = nsCocoaUtils::EventLocationForWindow(anEvent, self);
         target = [contentView hitTest:[contentView convertPoint:windowLocation fromView:nil]];
+        // If the hit test failed, the event is targeted here but is not over the window.
+        // Target it at the first responder.
+        if (!target)
+          target = (NSView*)[self firstResponder];
       }
       break;
     default:
       break;
   }
   if (target) {
     switch (type) {
       case NSScrollWheel:
         [target scrollWheel:anEvent];
         break;
       case NSLeftMouseDown:
         [target mouseDown:anEvent];
         // If we're in a context menu we don't want the OS to send the coming
-        // leftMouseUp event to NSApp via the window server, but we do want
-        // our ChildView to receive a leftMouseUp event (and to send a Gecko
+        // NSLeftMouseUp event to NSApp via the window server, but we do want
+        // our ChildView to receive an NSLeftMouseUp event (and to send a Gecko
         // NS_MOUSE_BUTTON_UP event to the corresponding nsChildView object).
         // If our NSApp isn't active (i.e. if we're in a context menu raised
-        // by a rightMouseDown event) when it receives the coming leftMouseUp
-        // via the window server, our browser will (in effect) become partially
+        // by a right mouse down event) when it receives the coming NSLeftMouseUp
+        // via the window server, our app will (in effect) become partially
         // activated, which has strange side effects:  For example, if another
         // app's window had the focus, that window will lose the focus and the
         // other app's main menu will be completely disabled (though it will
         // continue to be displayed).
-        // A side effect of not allowing the coming leftMouseUp event to be
+        // A side effect of not allowing the coming NSLeftMouseUp event to be
         // sent to NSApp via the window server is that our custom context
         // menus will roll up whenever the user left-clicks on them, whether
         // or not the left-click hit an active menu item.  This is how native
         // context menus behave, but wasn't how our custom context menus
         // behaved previously (on the trunk or e.g. in Firefox 2.0.0.4).
         // If our ChildView's corresponding nsChildView object doesn't
         // dispatch an NS_MOUSE_BUTTON_UP event, none of our active menu items
-        // will "work" on a leftMouseDown.
-        if (mIsContextMenu) {
+        // will "work" on an NSLeftMouseUp.
+        if (mIsContextMenu && ![NSApp isActive]) {
           NSEvent *newEvent = [NSEvent mouseEventWithType:NSLeftMouseUp
                                                  location:windowLocation
                                             modifierFlags:[anEvent modifierFlags]
                                                 timestamp:GetCurrentEventTime()
                                              windowNumber:[self windowNumber]
                                                   context:nil
                                               eventNumber:0
                                                clickCount:1
@@ -1803,34 +1808,16 @@ void patternDraw(void* aInfo, CGContextR
       case NSOtherMouseDragged:
         [target otherMouseDragged:anEvent];
         break;
       default:
         [super sendEvent:anEvent];
         break;
     }
   } else {
-    // Sometimes more than one popup window can be visible at the same time
-    // (e.g. nested non-native context menus, or the test case (attachment
-    // 276885) for bmo bug 392389, which displays a non-native combo-box in
-    // a non-native popup window).  In these cases the "active" popup window
-    // (the one that corresponds to the current gRollupWidget) should receive
-    // all mouse events that happen over it.  So if anEvent wasn't processed
-    // here, if there's a current gRollupWidget, and if its NSWindow object
-    // isn't us, we send anEvent to the gRollupWidget's NSWindow object, then
-    // return.  Other code (in nsChildView.mm's ChildView class) will redirect
-    // events that happen over us but should be redirected to the current
-    // gRollupWidget.
-    if (gRollupWidget) {
-      NSWindow *rollupWindow = (NSWindow*)gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
-      if (rollupWindow && ![rollupWindow isEqual:self]) {
-        [rollupWindow sendEvent:anEvent];
-        return;
-      }
-    }
     [super sendEvent:anEvent];
   }
 }
 
 
 - (id)initWithContentRect:(NSRect)contentRect styleMask:(unsigned int)styleMask
       backing:(NSBackingStoreType)bufferingType defer:(BOOL)deferCreation
 {
