Index: widget/src/cocoa/nsChildView.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsChildView.h,v
retrieving revision 1.93.4.1
diff -u -8 -r1.93.4.1 nsChildView.h
--- widget/src/cocoa/nsChildView.h	30 May 2008 14:53:46 -0000	1.93.4.1
+++ widget/src/cocoa/nsChildView.h	16 Jul 2008 00:31:29 -0000
@@ -118,16 +118,21 @@
   
   // rects that were invalidated during a draw, so have pending drawing
   NSMutableArray* mPendingDirtyRects;
   BOOL mPendingFullDisplay;
 
   // All views are always opaque (non-transparent). The only exception is when we're
   // the content view in a transparent XUL window.
   BOOL mIsTransparent;
+  
+  // Since the native modal event loop can not be used with the gecko modal
+  // loop, we have to simulate the event ourselves. In order to accomplish this
+  // this view must disable click through to prevent window ordering.
+  BOOL mDisableView;
 
   // Holds our drag service across multiple drag calls. The reference to the
   // service is obtained when the mouse enters the view and is released when
   // the mouse exits or there is a drop. This prevents us from having to
   // re-establish the connection to the service manager many times per second
   // when handling |draggingUpdated:| messages.
   nsIDragService* mDragService;
   
@@ -139,16 +144,18 @@
 - (void)viewsWindowDidResignKey;
 
 // Stop NSView hierarchy being changed during [ChildView drawRect:]
 - (void)delayedTearDown;
 
 - (void)setTransparent:(BOOL)transparent;
 
 - (void)sendFocusEvent:(PRUint32)eventType;
+
+- (void)setViewDisabled:(BOOL)inIsDisabled;
 @end
 
 
 
 //-------------------------------------------------------------------------
 //
 // nsTSMManager
 //
Index: widget/src/cocoa/nsChildView.mm
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsChildView.mm,v
retrieving revision 1.357.2.1
diff -u -8 -r1.357.2.1 nsChildView.mm
--- widget/src/cocoa/nsChildView.mm	30 May 2008 14:53:46 -0000	1.357.2.1
+++ widget/src/cocoa/nsChildView.mm	16 Jul 2008 00:31:29 -0000
@@ -2938,19 +2938,75 @@
   }
 
   return retVal;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 }
 
 
+- (void)setViewDisabled:(BOOL)inIsDisabled
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+  
+  mDisableView = inIsDisabled;
+  
+  NSEnumerator *subviewsEnum = [[self subviews] objectEnumerator];
+  id curSubview = nil;
+  while ((curSubview = [subviewsEnum nextObject])) {
+    if ([curSubview isKindOfClass:[ChildView class]]) {
+      [(ChildView *)curSubview setViewDisabled:inIsDisabled]; 
+    }
+  }
+  
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
+
+- (BOOL)shouldDelayWindowOrderingForEvent:(NSEvent *)theEvent
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
+  
+  if (mDisableView) {
+    // If the app is not active, re-activate the application here.
+    if (![NSApp isActive]) {
+      [NSApp activateIgnoringOtherApps:YES];
+      [NSApp arrangeInFront:nil];
+    }
+    
+    return YES;
+  }
+  
+  return [super shouldDelayWindowOrderingForEvent:theEvent];
+  
+  NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
+}
+
+
+- (BOOL)acceptsFirstMouse:(NSEvent *)theEvent
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
+  
+  if (mDisableView)
+    return YES;
+  
+  return [super acceptsFirstMouse:theEvent];
+  
+  NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
+}
+
+
 - (void)mouseDown:(NSEvent*)theEvent
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+ 
+  if (mDisableView) {
+    [NSApp preventWindowOrdering];
+    return;
+  }
 
   // If we've already seen this event due to direct dispatch from menuForEvent:
   // just bail; if not, remember it.
   if (mLastMouseDownEvent == theEvent) {
     [mLastMouseDownEvent release];
     mLastMouseDownEvent = nil;
     return;
   }
Index: widget/src/cocoa/nsCocoaWindow.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsCocoaWindow.h,v
retrieving revision 1.50
diff -u -8 -r1.50 nsCocoaWindow.h
--- widget/src/cocoa/nsCocoaWindow.h	2 May 2008 11:32:52 -0000	1.50
+++ widget/src/cocoa/nsCocoaWindow.h	16 Jul 2008 00:31:29 -0000
@@ -69,16 +69,23 @@
 // If we set the window's stylemask to be textured, the corners on the bottom of
 // the window are rounded by default. We use this private method to make
 // the corners square again, a la Safari.
 - (void)setBottomCornerRounded:(BOOL)rounded;
 
 @end
 
 
+@interface NSWindow (Resizer)
+
+- (BOOL)usesNativeResizer;
+
+@end
+
+
 @interface PopupWindow : NSWindow
 {
 @private
   BOOL mIsContextMenu;
 }
 
 - (id)initWithContentRect:(NSRect)contentRect styleMask:(unsigned int)styleMask
       backing:(NSBackingStoreType)bufferingType defer:(BOOL)deferCreation;
@@ -89,17 +96,21 @@
 
 
 @interface BorderlessWindow : NSWindow
 {
 }
 
 - (BOOL)canBecomeKeyWindow;
 - (BOOL)canBecomeMainWindow;
+@end
 
+
+@interface SongbirdWindow : BorderlessWindow 
+{}
 @end
 
 
 @interface WindowDelegate : NSObject
 {
   nsCocoaWindow* mGeckoWindow; // [WEAK] (we are owned by the window)
   // Used to avoid duplication when we send NS_ACTIVATE/NS_GOTFOCUS and
   // NS_DEACTIVATE/NS_LOSTFOCUS to Gecko for toplevel widgets.  Starts out
@@ -243,16 +254,18 @@
     NS_IMETHOD GetPreferredSize(PRInt32& aWidth, PRInt32& aHeight) { return NS_OK; }
     NS_IMETHOD SetPreferredSize(PRInt32 aWidth, PRInt32 aHeight) { return NS_OK; }
     NS_IMETHOD DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus) ;
     NS_IMETHOD CaptureRollupEvents(nsIRollupListener * aListener, PRBool aDoCapture, PRBool aConsumeRollupEvent);
     NS_IMETHOD GetAttention(PRInt32 aCycleCount);
     NS_IMETHOD GetHasTransparentBackground(PRBool& aTransparent);
     NS_IMETHOD SetHasTransparentBackground(PRBool aTransparent);
     NS_IMETHOD SetWindowTitlebarColor(nscolor aColor, PRBool aActive);
+  
+    NS_IMETHOD SetModalLockWindow(NSWindow *aWindow, PRBool aShouldLock);
 
     virtual gfxASurface* GetThebesSurface();
 
     // be notified that a some form of drag event needs to go into Gecko
     virtual PRBool DragEvent(unsigned int aMessage, Point aMouseGlobal, UInt16 aKeyModifiers);
 
     // Helpers to prevent recursive resizing during live-resize
     PRBool IsResizing () const { return mIsResizing; }
Index: widget/src/cocoa/nsCocoaWindow.mm
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsCocoaWindow.mm,v
retrieving revision 1.148
diff -u -8 -r1.148 nsCocoaWindow.mm
--- widget/src/cocoa/nsCocoaWindow.mm	7 May 2008 21:15:57 -0000	1.148
+++ widget/src/cocoa/nsCocoaWindow.mm	16 Jul 2008 00:31:29 -0000
@@ -248,17 +248,30 @@
             case eBorderStyle_all:
               features |= NSClosableWindowMask;
               features |= NSTitledWindowMask;
               features |= NSResizableWindowMask;
               features |= NSMiniaturizableWindowMask;
               break;
             default:
               if (aInitData->mBorderStyle & eBorderStyle_title) {
-                features |= NSTitledWindowMask;
+                
+                // SONGBIRD HACK:
+                // For feathers that are using the songbird-global-package
+                // and do not use operating system chrome, we don't want to
+                // add the |NSTitledWindowMask| to the dialog.
+                char *showChrome = nsnull;
+                prefs->GetCharPref("songbird.accessibility.enabled", &showChrome);
+                if (showChrome != nsnull) {
+                  if (strcmp(showChrome, "0")) {
+                    features |= NSTitledWindowMask; 
+                  }
+                  NS_Free(showChrome);
+                }
+                
                 features |= NSMiniaturizableWindowMask;
               }
               if (aInitData->mBorderStyle & eBorderStyle_resizeh)
                 features |= NSResizableWindowMask;
               if (aInitData->mBorderStyle & eBorderStyle_close)
                 features |= NSClosableWindowMask;
               break;
           }
@@ -347,20 +360,34 @@
     // Note that we need to check the window type because we mark sheets sheets as 
     // having titlebars.
     if (mWindowType == eWindowType_toplevel &&
         (features & NSTitledWindowMask))
       windowClass = [ToolbarWindow class];
     // If we're a popup window we need to use the PopupWindow class.
     else if (mWindowType == eWindowType_popup)
       windowClass = [PopupWindow class];
-    // If we're a non-popup borderless window we need to use the
-    // BorderlessWindow class.
-    else if (features == NSBorderlessWindowMask)
-      windowClass = [BorderlessWindow class];
+
+    // XXXmatt: If we use a borderless window the OS makes
+    // assumptions about what the window should be able to do.
+    // What we really want is a normal window in which
+    // the XUL takes responsibility for drawing the titlebar
+    // and resizer.
+    else if (features == NSBorderlessWindowMask) {
+      windowClass = [SongbirdWindow class];
+      features |= NSClosableWindowMask;
+      features |= NSTitledWindowMask;
+      features |= NSMiniaturizableWindowMask;
+      
+      // If the window was opened with resizable=yes, then 
+      // enable to OS resizer.
+      if (aInitData->mBorderStyle & eBorderStyle_resizeh) {
+        features |= NSResizableWindowMask;
+      }
+    }
 
     // Create the window
     mWindow = [[windowClass alloc] initWithContentRect:rect styleMask:features 
                                    backing:NSBackingStoreBuffered defer:YES];
     
     if (mWindowType == eWindowType_popup) {
       [mWindow setAlphaValue:POPUP_DEFAULT_TRANSPARENCY];
       [mWindow setLevel:NSPopUpMenuWindowLevel];
@@ -379,17 +406,21 @@
         [mWindow setContentView:newContentView];
       }
     }
     else if (mWindowType == eWindowType_invisible) {
       [mWindow setLevel:kCGDesktopWindowLevelKey];
     }
 
     [mWindow setBackgroundColor:[NSColor whiteColor]];
-    [mWindow setContentMinSize:NSMakeSize(60, 60)];
+    
+    // XXXmatt: Modifying the arbitrary min size so that it 
+    // doesn't interfere with the Songbird miniplayer.
+    [mWindow setContentMinSize:NSMakeSize(60, 20)];
+    
     [mWindow setReleasedWhenClosed:NO];
 
     // setup our notification delegate. Note that setDelegate: does NOT retain.
     mDelegate = [[WindowDelegate alloc] initWithGeckoWindow:this];
     [mWindow setDelegate:mDelegate];
     
     mWindowMadeHere = PR_TRUE;
   }
@@ -508,58 +539,69 @@
     // methods) that's incompatible with the modal event loop in nsXULWindow::
     // ShowModal() (each of these event loops is "exclusive", and can't run at
     // the same time as other (similar) event loops).
     if (mWindowType != eWindowType_sheet) {
       while (aParent) {
         if (aParent->mNumModalDescendents++ == 0) {
           NSWindow *aWindow = aParent->GetCocoaWindow();
           if (aParent->mWindowType != eWindowType_invisible) {
-            [[aWindow standardWindowButton:NSWindowCloseButton] setEnabled:NO];
-            [[aWindow standardWindowButton:NSWindowMiniaturizeButton] setEnabled:NO];
-            [[aWindow standardWindowButton:NSWindowZoomButton] setEnabled:NO];
+            SetModalLockWindow(aWindow, PR_TRUE);
           }
         }
         aParent = static_cast<nsCocoaWindow*>(aParent->mParent);
       }
-      [mWindow setLevel:NSModalPanelWindowLevel];
+      // Despite the fact this window will be opened as a "modal" dialog, the
+      // flag should still be set as |NSNormalWindowLevel| to prevent it from
+      // floating on top of every other window in the OS. 
+      [mWindow setLevel:NSNormalWindowLevel];
+      [[mWindow standardWindowButton:NSWindowMiniaturizeButton] setEnabled:NO];
+      [[mWindow standardWindowButton:NSWindowZoomButton] setEnabled:NO];
+      
       nsCocoaWindowList *windowList = new nsCocoaWindowList;
       if (windowList) {
         windowList->window = this; // Don't ADDREF
         windowList->prev = gAppModalWindowList;
         gAppModalWindowList = windowList;
       }
+      
+      // Since the |[NSApp delegate]| builds and populates the dock window menu,
+      // it needs to be informed that a gecko modal session is about to begin.
+      [[NSNotificationCenter defaultCenter] postNotificationName:@"GeckoStartModal" 
+                                                          object:nil];
     }
   }
   else {
     --gXULModalLevel;
     NS_ASSERTION(gXULModalLevel >= 0, "Mismatched call to nsCocoaWindow::SetModal(PR_FALSE)!");
     if (mWindowType != eWindowType_sheet) {
       while (aParent) {
         if (--aParent->mNumModalDescendents == 0) {
           NSWindow *aWindow = aParent->GetCocoaWindow();
           if (aParent->mWindowType != eWindowType_invisible) {
-            [[aWindow standardWindowButton:NSWindowCloseButton] setEnabled:YES];
-            [[aWindow standardWindowButton:NSWindowMiniaturizeButton] setEnabled:YES];
-            [[aWindow standardWindowButton:NSWindowZoomButton] setEnabled:YES];
+            SetModalLockWindow(aWindow, PR_FALSE);
           }
         }
         NS_ASSERTION(aParent->mNumModalDescendents >= 0, "Widget hierarchy changed while modal!");
         aParent = static_cast<nsCocoaWindow*>(aParent->mParent);
       }
       if (gAppModalWindowList) {
         NS_ASSERTION(gAppModalWindowList->window == this, "Widget hierarchy changed while modal!");
         nsCocoaWindowList *saved = gAppModalWindowList;
         gAppModalWindowList = gAppModalWindowList->prev;
         delete saved; // "window" not ADDREFed
       }
       if (mWindowType == eWindowType_popup)
         [mWindow setLevel:NSPopUpMenuWindowLevel];
       else
         [mWindow setLevel:NSNormalWindowLevel];
+      
+      // Inform the |[NSApp delegate]| that the modal session has ended.
+      [[NSNotificationCenter defaultCenter] postNotificationName:@"GeckoEndModal" 
+                                                          object:nil];
     }
   }
   return NS_OK;
 }
 
 
 // Hide or show this window
 NS_IMETHODIMP nsCocoaWindow::Show(PRBool bState)
@@ -1352,16 +1394,44 @@
                               forActiveWindow:(BOOL)aActive];
   }
   return NS_OK;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
 
+NS_IMETHODIMP
+nsCocoaWindow::SetModalLockWindow(NSWindow *aWindow, PRBool aShouldLock)
+{
+  [[aWindow standardWindowButton:NSWindowCloseButton] setEnabled:!aShouldLock];
+  [[aWindow standardWindowButton:NSWindowMiniaturizeButton] setEnabled:!aShouldLock];
+  [[aWindow standardWindowButton:NSWindowZoomButton] setEnabled:!aShouldLock];
+  
+  // If the window isn't already using the native resizer, it should be hidden
+  // to try and prevent the user from clicking on it to rearrange windows.
+  BOOL hideResizer = YES;
+  if ([aWindow respondsToSelector:@selector(usesNativeResizer)]) 
+    hideResizer = [aWindow usesNativeResizer];
+  
+  if (hideResizer)
+    [aWindow setShowsResizeIndicator:!aShouldLock];
+
+  NSEnumerator *subviewsEnum = [[[aWindow contentView] subviews] objectEnumerator];
+  id curSubview = nil;
+  while ((curSubview = [subviewsEnum nextObject])) {
+    if ([curSubview isKindOfClass:[ChildView class]]) {
+      [(ChildView *)curSubview setViewDisabled:aShouldLock];
+    }
+  }
+  
+  return NS_OK;
+}
+
+
 gfxASurface* nsCocoaWindow::GetThebesSurface()
 {
   if (mPopupContentView)
     return mPopupContentView->GetThebesSurface();
   return nsnull;
 }
 
 
@@ -1665,16 +1735,17 @@
 // 3) We set the background color to a custom NSColor subclass that knows how tall the window is.
 //    When -set is called on it, it sets a pattern (with a draw callback) as the fill. In that callback,
 //    it paints the the titlebar and background colrs in the correct areas of the context its given,
 //    which will fill the entire window (CG will tile it horizontally for us).
 //
 // This class also provides us with a pill button to show/hide the toolbar.
 @implementation ToolbarWindow
 
+
 - (id)initWithContentRect:(NSRect)aContentRect styleMask:(unsigned int)aStyle backing:(NSBackingStoreType)aBufferingType defer:(BOOL)aFlag
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 
   aStyle = aStyle | NSTexturedBackgroundWindowMask;
   if ((self = [super initWithContentRect:aContentRect styleMask:aStyle backing:aBufferingType defer:aFlag])) {
     mColor = [[TitlebarAndBackgroundColor alloc] initWithActiveTitlebarColor:nil
                                                        inactiveTitlebarColor:nil
@@ -1800,19 +1871,23 @@
   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 }
 
 - (void)sendEvent:(NSEvent *)anEvent
 {
   NSEventType type = [anEvent type];
   
   switch (type) {
-    case NSScrollWheel:
     case NSLeftMouseDown:
     case NSLeftMouseUp:
+      // These events should always be sent to make sure that the subviews
+      // can cancel the click through to prevent window re-ordering during 
+      // a Gecko-Cocoa modal session.
+      break;
+    case NSScrollWheel:
     case NSRightMouseDown:
     case NSRightMouseUp:
     case NSOtherMouseDown:
     case NSOtherMouseUp:
     case NSMouseMoved:
     case NSLeftMouseDragged:
     case NSRightMouseDragged:
     case NSOtherMouseDragged:
@@ -1834,16 +1909,22 @@
     }
     default:
       break;
   }
 
   [super sendEvent:anEvent];
 }
 
+- (BOOL)usesNativeResizer
+{
+  return YES;
+}
+
+
 @end
 
 
 // Custom NSColor subclass where most of the work takes place for drawing in
 // the titlebar area.
 @implementation TitlebarAndBackgroundColor
 
 - (id)initWithActiveTitlebarColor:(NSColor*)aActiveTitlebarColor
@@ -2364,19 +2445,20 @@
 }
 
 
 - (void)sendEvent:(NSEvent *)anEvent
 {
   NSEventType type = [anEvent type];
   
   switch (type) {
-    case NSScrollWheel:
     case NSLeftMouseDown:
     case NSLeftMouseUp:
+      break;
+    case NSScrollWheel:
     case NSRightMouseDown:
     case NSRightMouseUp:
     case NSOtherMouseDown:
     case NSOtherMouseUp:
     case NSMouseMoved:
     case NSLeftMouseDragged:
     case NSRightMouseDragged:
     case NSOtherMouseDragged:
@@ -2431,8 +2513,241 @@
   BOOL retval = [super performKeyEquivalent:theEvent];
   [nativeWindow release];
   return retval;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 }
 
 @end
+
+/*************************************************************************
+ * BEGIN SONGBIRD HACK
+ *
+ * If you want to draw your own window decorations like iPhoto or
+ * Aperature, you have to use the unsupported NSThemeFrame view.
+ *
+ * See http://andymatuschak.org/articles/2006/01/11/ for gory details.
+ *
+ * In Songbird we like to draw all window decorations using XUL, so we
+ * subclass NSThemeFrame and make the content area 100% of the window. 
+ * BorderlessWindow would work, but causes the OS to make assumptions
+ * about things like resizing and zooming.
+ *
+ *************************************************************************/
+
+@class NSDocumentDragButton, NSButton, NSCell, NSImage, NSString;
+
+@interface NSFrameView : NSView
+{
+  unsigned int styleMask;
+  NSString *_title;
+  NSCell *titleCell;
+  NSButton *closeButton;
+  NSButton *zoomButton;
+  NSButton *minimizeButton;
+  char resizeByIncrement;
+  char frameNeedsDisplay;
+  unsigned char tabViewCount;
+  struct _NSSize resizeParameter;
+  int shadowState; 
+}
+
+- (id)initWithFrame:(struct _NSRect)fp8 styleMask:(unsigned int)fp24 owner:(id)fp28;
+- (id)initWithFrame:(struct _NSRect)fp8;
+
+@end
+
+@interface NSTitledFrame : NSFrameView
+{
+  int resizeFlags;
+  id fileButton;    
+  struct _NSSize titleCellSize;
+}
+
+- (id)initWithFrame:(struct _NSRect)fp8 styleMask:(unsigned int)fp24 owner:(id)fp28;
+- (float)_titlebarHeight;
++ (float)_titlebarHeight:(unsigned int)fp8;
+- (int)_numberOfTitlebarLines;
++ (float)_windowTitlebarTitleMinHeight:(unsigned int)fp8;
+- (float)_windowTitlebarTitleMinHeight;
+
+@end
+
+@interface NSThemeFrame : NSTitledFrame
+{
+  NSButton *toolbarButton;
+  int toolbarVisibleStatus;
+  NSImage *showToolbarTransitionImage;
+  struct _NSSize showToolbarPreWindowSize;
+  NSButton *modeButton;
+  int leftGroupTrackingTagNum;
+  int rightGroupTrackingTagNum;
+  char mouseInsideLeftGroup;
+  char mouseInsideRightGroup;
+  int widgetState;
+  NSString *displayName; 
+}
+
+- (id)initWithFrame:(struct _NSRect)fp8 styleMask:(unsigned int)fp24 owner:(id)fp28;
+- (float)_titlebarHeight;
++ (float)_titlebarHeight:(unsigned int)fp8;
+- (float)_windowTitlebarTitleMinHeight;
++ (float)_windowTitlebarTitleMinHeight:(unsigned int)fp8;
+
+@end
+
+
+// A ThemeFrame with no titlebar or resize indicator,
+
+@interface SongbirdThemeFrame : NSThemeFrame {}
+@end
+
+@implementation SongbirdThemeFrame
+
+- initWithFrame:(NSRect)frame styleMask:(int)sm owner:owner
+{
+  self = [super initWithFrame:frame styleMask:sm owner:owner];
+
+  if (self) {
+    NSWindow *window = [self window];
+    
+    // Turn off the standard window controls
+    [[window standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];
+    [[window standardWindowButton:NSWindowZoomButton] setHidden:YES];
+    [[window standardWindowButton:NSWindowCloseButton] setHidden:YES];
+
+    // Let the window paint its own resize indicator.
+    // Note that we are suppressing the graphic, and
+    // the resizer may still be functional.
+    [window setShowsResizeIndicator:NO];
+
+    [window setHasShadow:YES];
+  }
+  return self;
+}
+
+// Crush the titlebar, since the window will paint its own
+
++ (float)_windowTitlebarTitleMinHeight:(unsigned int)fp8 
+{
+  return 0;
+}
+
+- (int)titlebarHeight
+{
+  return 0;
+}
+
+- (float)_titlebarHeight
+{
+  return 0.0;
+}
+
+- (int)_numberOfTitlebarLines 
+{
+  return 0;
+}
+
+@end
+
+
+// Create a window that uses our special frame
+
+@interface NSWindow (Private)
++ (Class)frameViewClassForStyleMask:(unsigned int)mask;
+@end
+
+@implementation SongbirdWindow
+
++ (Class)frameViewClassForStyleMask:(unsigned int)styleMask
+{
+  return [SongbirdThemeFrame class];
+}
+
+- (id)initWithContentRect:(NSRect)contentRect 
+                styleMask:(unsigned int)aStyle 
+                  backing:(NSBackingStoreType)bufferingType 
+                    defer:(BOOL)flag
+{
+  if ((self = [super initWithContentRect:contentRect 
+                               styleMask:aStyle 
+                                 backing:bufferingType 
+                                   defer:flag])) 
+  {
+    [[NSNotificationCenter defaultCenter] addObserver:self 
+                                             selector:@selector(windowDidMove:)
+                                                 name:NSWindowDidMoveNotification 
+                                               object:self];
+    [[NSNotificationCenter defaultCenter] addObserver:self 
+                                             selector:@selector(windowDidBecomeMain:)
+                                                 name:NSWindowDidBecomeMainNotification 
+                                               object:self];
+    [[NSNotificationCenter defaultCenter] addObserver:self 
+                                             selector:@selector(windowDidResignMain:)
+                                                 name:NSWindowDidResignMainNotification 
+                                               object:self];
+  }
+  
+  return self;
+}
+
+- (void)dealloc
+{
+  [[NSNotificationCenter defaultCenter] removeObserver:self
+                                                  name:NSWindowDidMoveNotification
+                                                object:self];
+  [[NSNotificationCenter defaultCenter] removeObserver:self
+                                                  name:NSWindowDidBecomeMainNotification
+                                                object:self];
+  [[NSNotificationCenter defaultCenter] removeObserver:self
+                                                  name:NSWindowDidResignMainNotification
+                                                object:self];
+  [super dealloc];
+}
+
+- (BOOL)usesNativeResizer
+{
+  return NO;
+}
+
+- (void)windowDidMove:(NSNotification *)notification
+{
+  NSRect newFrame = [self frame];
+  NSRect screenFrame = [[NSScreen mainScreen] visibleFrame];
+  
+  // Prevent the window from going under the menubar:
+  if ((newFrame.origin.y + newFrame.size.height) > 
+      (screenFrame.origin.y + screenFrame.size.height))
+  {
+    newFrame.origin.y = 
+      screenFrame.origin.y + (screenFrame.size.height - newFrame.size.height);
+    [self setFrameOrigin:newFrame.origin];
+  }
+}
+
+// This is the un-documented function that enables any window to display the 
+// normal drop shadow to it. All borderless-windows (like |SongbirdWindow|) 
+// will never return |YES| here unless we override it.
+- (BOOL)_hasDarkShadow
+{
+  return YES;
+}
+
+- (void)windowDidBecomeMain:(NSNotification *)notification
+{
+  // since we are a borderless window - we need to send this event ourselves
+  // so that our shadow is updated correctly.
+  [self display];
+}
+ 
+- (void)windowDidResignMain:(NSNotification *)notification
+{
+  // since we are a borderless window - we need to send this event ourselves
+  // so that our shadow is updated correctly.
+  [self display];
+}
+
+@end
+
+/*************************************************************************
+ * END SONGBIRD HACK
+ ************************************************************************/
