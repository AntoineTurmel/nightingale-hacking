? bug307204-updated-translucent-window.patch
? bug386826-xreonly-vistanorestartupdate.patch
? sanity.diff
Index: widget/public/nsIWidget.h
===================================================================
RCS file: /cvsroot/mozilla/widget/public/nsIWidget.h,v
retrieving revision 3.164
diff -p -u -4 -r3.164 nsIWidget.h
--- widget/public/nsIWidget.h	9 Nov 2007 17:38:33 -0000	3.164
+++ widget/public/nsIWidget.h	27 Nov 2007 00:50:11 -0000
@@ -99,9 +99,9 @@ typedef nsEventStatus (*PR_CALLBACK EVEN
 { 0x3B4E560A, 0x11E6, 0x4EBD, \
   { 0xB9, 0x87, 0x35, 0x38, 0x56, 0x24, 0x97, 0x0D } }
 
 // Hide the native window systems real window type so as to avoid
-// including native window system types and api's. This is necessary
+// including native window system types and APIs. This is necessary
 // to ensure cross-platform code.
 typedef void* nsNativeWidget;
 
 /**
@@ -680,19 +680,8 @@ class nsIWidget : public nsISupports {
      *   transparent pixels
      */
     NS_IMETHOD GetWindowTranslucency(PRBool& aTranslucent) = 0;
 
-    /**
-     * Update the alpha channel for some pixels of the top-level window
-     * that contains this widget.
-     * The window must have been made translucent using SetWindowTranslucency.
-     * Pixel RGB color values are already premultiplied with alpha channel values.
-     * @param aRect the rect to update
-     * @param aAlphas the alpha values, in w x h array, row-major order,
-     * in units of 1/255. nsBlender::GetAlphas is a good way to compute this array.
-     */
-    NS_IMETHOD UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas) = 0;
-
     /** 
      * Hide window chrome (borders, buttons) for this widget.
      *
      */
Index: widget/src/cocoa/nsChildView.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsChildView.h,v
retrieving revision 1.77
diff -p -u -4 -r1.77 nsChildView.h
--- widget/src/cocoa/nsChildView.h	26 Nov 2007 18:09:38 -0000	1.77
+++ widget/src/cocoa/nsChildView.h	27 Nov 2007 00:50:11 -0000
@@ -110,8 +110,12 @@ union nsPluginPort;
   // rects that were invalidated during a draw, so have pending drawing
   NSMutableArray* mPendingDirtyRects;
   BOOL mPendingFullDisplay;
 
+  // All views are always opaque (non-transparent). The only exception is when we're
+  // the content view in a transparent XUL window.
+  BOOL isTransparent;
+
   // Holds our drag service across multiple drag calls. The reference to the
   // service is obtained when the mouse enters the view and is released when
   // the mouse exits or there is a drop. This prevents us from having to
   // re-establish the connection to the service manager many times per second
@@ -126,8 +130,9 @@ union nsPluginPort;
 - (void)viewsWindowDidResignKey;
 
 // Stop NSView hierarchy being changed during [ChildView drawRect:]
 - (void)delayedTearDown;
+- (void)setTransparent:(BOOL)transparent;
 @end
 
 
 
@@ -291,14 +296,18 @@ public:
   NS_IMETHOD        GetPluginClipRect(nsRect& outClipRect, nsPoint& outOrigin, PRBool& outWidgetVisible);
   NS_IMETHOD        StartDrawPlugin();
   NS_IMETHOD        EndDrawPlugin();
   
+  // translucency
+  NS_IMETHOD        GetWindowTranslucency(PRBool& aTranslucent);
+  NS_IMETHOD        SetWindowTranslucency(PRBool aTranslucent);
+  
   // Mac specific methods
   virtual PRBool    PointInWidget(Point aThePoint);
   
   virtual PRBool    DispatchWindowEvent(nsGUIEvent& event);
-  virtual void      AcceptFocusOnClick(PRBool aBool) { mAcceptFocusOnClick = aBool;};
-  PRBool            AcceptFocusOnClick() { return mAcceptFocusOnClick;};
+  virtual void      AcceptFocusOnClick(PRBool aBool) { mAcceptFocusOnClick = aBool; }
+  PRBool            AcceptFocusOnClick() { return mAcceptFocusOnClick; }
   
   void              LiveResizeStarted();
   void              LiveResizeEnded();
   
Index: widget/src/cocoa/nsChildView.mm
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsChildView.mm,v
retrieving revision 1.279
diff -p -u -4 -r1.279 nsChildView.mm
--- widget/src/cocoa/nsChildView.mm	26 Nov 2007 23:19:04 -0000	1.279
+++ widget/src/cocoa/nsChildView.mm	27 Nov 2007 00:50:11 -0000
@@ -45,9 +45,8 @@
 #include "nsCocoaWindow.h"
 
 #include "nsCOMPtr.h"
 #include "nsToolkit.h"
-#include "prmem.h"
 #include "nsCRT.h"
 #include "nsplugindefs.h"
 #include "nsThreadUtils.h"
 #include "nsIPrefService.h"
@@ -149,10 +148,8 @@ nsIWidget         * gRollupWidget   = ns
 - (BOOL)isPluginView;
 
 - (BOOL)childViewHasPlugin;
 
-- (BOOL)isRectObscuredBySubview:(NSRect)inRect;
-
 - (void)processPendingRedraws;
 
 - (BOOL)ensureCorrectMouseEventTarget:(NSEvent *)anEvent;
 
@@ -656,10 +653,36 @@ void* nsChildView::GetNativeData(PRUint3
 }
 
 #pragma mark -
 
+NS_IMETHODIMP nsChildView::GetWindowTranslucency(PRBool& aTranslucent)
+{
+  aTranslucent = ![mView isOpaque];
+  return NS_OK;
+}
+
+// This is called by nsContainerFrame on the root widget for all window types
+// except popup windows (when nsCocoaWindow::SetWindowTranslucency is used instead).
+NS_IMETHODIMP nsChildView::SetWindowTranslucency(PRBool aTranslucent)
+{
+  BOOL currentTranslucency = ![[mView nativeWindow] isOpaque];
+  nsresult rv = NS_OK;
+  if (aTranslucent != currentTranslucency) {
+    // Find out if this is a window we created by seeing if the delegate is WindowDelegate. If it is,
+    // let the nsCocoaWindow take care of changing the window's translucency.
+    id windowDelegate = [[mView nativeWindow] delegate];
+    if (windowDelegate && [windowDelegate isKindOfClass:[WindowDelegate class]]) {
+      nsCocoaWindow *widget = [(WindowDelegate *)windowDelegate geckoWidget];
+      if (widget) {
+        widget->MakeWindowTranslucent(aTranslucent);
+        [mView setTransparent:aTranslucent];
+      }
+    }
+  }
+  return rv;
+}
+
 
-// Return PR_TRUE if the whether the component is visible, PR_FALSE otherwise
 NS_IMETHODIMP nsChildView::IsVisible(PRBool& outState)
 {
   if (!mVisible) {
     outState = mVisible;
@@ -2042,12 +2065,19 @@ NSEvent* gLastDragEvent = nil;
   return YES;
 }
 
 
+- (void)setTransparent:(BOOL)transparent
+{
+  if (isTransparent != transparent) {
+    isTransparent = transparent;
+  }
+}
+
+
 - (BOOL)isOpaque
 {
-  // this will be NO when we can do transparent windows/views
-  return YES;
+  return !isTransparent;
 }
 
 
 -(void)setIsPluginView:(BOOL)aIsPlugin
@@ -2171,13 +2201,8 @@ NSEvent* gLastDragEvent = nil;
 {
   PRBool isVisible;
   if (!mGeckoChild || NS_FAILED(mGeckoChild->IsVisible(isVisible)) || !isVisible)
     return;
-  
-  // Workaround for the fact that NSQuickDrawViews can't be opaque; see if the rect
-  // being drawn is covered by a subview, and, if so, just bail.
-  if ([self isRectObscuredBySubview:aRect])
-    return;
 
   CGContextRef cgContext = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
 
   nsRect geckoBounds;
@@ -2262,24 +2287,8 @@ NSEvent* gLastDragEvent = nil;
 #endif
 }
 
 
-- (BOOL)isRectObscuredBySubview:(NSRect)inRect
-{
-  unsigned int numSubviews = [[self subviews] count];
-  for (unsigned int i = 0; i < numSubviews; i++) {
-    NSView* view = (NSView*)[[self subviews] objectAtIndex:i];
-    if (![view isHidden]) {
-      NSRect subviewFrame = [view frame];
-      if (NSContainsRect(subviewFrame, inRect))
-        return YES;
-    }
-  }
-  
-  return NO;
-}
-
-
 // Allows us to turn off setting up the clip region
 // before each drawRect. We already clip within gecko.
 - (BOOL)wantsDefaultClipping
 {
@@ -2643,9 +2652,9 @@ static nsEventStatus SendGeckoMouseEnter
 }
 
 
 - (void)mouseMoved:(NSEvent*)theEvent
-{
+{ 
   NSPoint windowEventLocation = [theEvent locationInWindow];
   NSPoint screenEventLocation = [mWindow convertBaseToScreen:windowEventLocation];
   NSPoint viewEventLocation = [self convertPoint:windowEventLocation fromView:nil];
 
Index: widget/src/cocoa/nsCocoaWindow.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsCocoaWindow.h,v
retrieving revision 1.44
diff -p -u -4 -r1.44 nsCocoaWindow.h
--- widget/src/cocoa/nsCocoaWindow.h	27 Nov 2007 00:24:13 -0000	1.44
+++ widget/src/cocoa/nsCocoaWindow.h	27 Nov 2007 00:50:11 -0000
@@ -236,8 +236,10 @@ public:
     NS_IMETHOD SetPreferredSize(PRInt32 aWidth, PRInt32 aHeight) { return NS_OK; }
     NS_IMETHOD DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus) ;
     NS_IMETHOD CaptureRollupEvents(nsIRollupListener * aListener, PRBool aDoCapture, PRBool aConsumeRollupEvent);
     NS_IMETHOD GetAttention(PRInt32 aCycleCount);
+    NS_IMETHOD GetWindowTranslucency(PRBool& aTranslucent);
+    NS_IMETHOD SetWindowTranslucency(PRBool aTranslucent);
     NS_IMETHOD SetWindowTitlebarColor(nscolor aColor);
 
     virtual gfxASurface* GetThebesSurface();
 
@@ -250,8 +252,10 @@ public:
     void StopResizing () { mIsResizing = PR_FALSE; }
     
     // nsIKBStateControl interface
     NS_IMETHOD ResetInputState();
+    
+    void MakeWindowTranslucent(PRBool aTranslucency);
 
     NS_IMETHOD BeginSecureKeyboardInput();
     NS_IMETHOD EndSecureKeyboardInput();
 
Index: widget/src/cocoa/nsCocoaWindow.mm
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsCocoaWindow.mm,v
retrieving revision 1.118
diff -p -u -4 -r1.118 nsCocoaWindow.mm
--- widget/src/cocoa/nsCocoaWindow.mm	27 Nov 2007 00:24:13 -0000	1.118
+++ widget/src/cocoa/nsCocoaWindow.mm	27 Nov 2007 00:50:11 -0000
@@ -1,5 +1,5 @@
-/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* -*- Mode: Objective-C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
@@ -65,8 +65,10 @@ extern nsIWidget         * gRollupWidget
 extern BOOL                gSomeMenuBarPainted;
 
 #define NS_APPSHELLSERVICE_CONTRACTID "@mozilla.org/appshell/appShellService;1"
 
+#define POPUP_DEFAULT_TRANSPARENCY 0.95
+
 NS_IMPL_ISUPPORTS_INHERITED1(nsCocoaWindow, Inherited, nsPIWidgetCocoa)
 
 
 // A note on testing to see if your object is a sheet...
@@ -312,8 +314,9 @@ nsresult nsCocoaWindow::StandardCreate(n
     NSRect newWindowFrame = [NSWindow frameRectForContentRect:rect styleMask:features];
 
     rect.origin.y -= (newWindowFrame.size.height - rect.size.height);
     
+    // XXXhakan: this should only be done on the screen showing the menubar
     if (mWindowType != eWindowType_popup)
       rect.origin.y -= ::GetMBarHeight();
 
     // NSLog(@"Top-level window being created at Cocoa rect: %f, %f, %f, %f\n",
@@ -339,9 +342,9 @@ nsresult nsCocoaWindow::StandardCreate(n
     mWindow = [[windowClass alloc] initWithContentRect:rect styleMask:features 
                                    backing:NSBackingStoreBuffered defer:NO];
     
     if (mWindowType == eWindowType_popup) {
-      [mWindow setAlphaValue:0.95];
+      [mWindow setAlphaValue:POPUP_DEFAULT_TRANSPARENCY];
       [mWindow setLevel:NSPopUpMenuWindowLevel];
       [mWindow setHasShadow:YES];
 
       // we need to make our content view a ChildView
@@ -646,8 +649,46 @@ NS_IMETHODIMP nsCocoaWindow::Show(PRBool
 
   return NS_OK;
 }
 
+void nsCocoaWindow::MakeWindowTranslucent(PRBool aTranslucent)
+{
+  BOOL currentTranslucency = ![mWindow isOpaque];
+  if (aTranslucent != currentTranslucency) {
+    // Popups have an alpha value we need to toggle.
+    if (mWindowType == eWindowType_popup) {
+      [mWindow setAlphaValue:(aTranslucent ? 1.0 : POPUP_DEFAULT_TRANSPARENCY)];
+    }
+    [mWindow setOpaque:!aTranslucent];
+    [mWindow setBackgroundColor:(aTranslucent ? [NSColor clearColor] : [NSColor whiteColor])];
+    [mWindow setHasShadow:!aTranslucent];
+  }
+}
+
+NS_IMETHODIMP nsCocoaWindow::GetWindowTranslucency(PRBool& aTranslucent)
+{
+  aTranslucent = ![mWindow isOpaque];   
+  return NS_OK;
+}
+
+// This is called from nsMenuPopupFrame when making a popup translucent.
+// For other window types, nsChildView::SetWindowTranslucency is used.
+NS_IMETHODIMP nsCocoaWindow::SetWindowTranslucency(PRBool aTranslucent)
+{
+  BOOL currentTranslucency = ![mWindow isOpaque];
+  if (aTranslucent != currentTranslucency) {
+    // Take care of window translucency
+    MakeWindowTranslucent(aTranslucent);
+    // Make sure our content view is also translucent
+    if (mPopupContentView) {
+      ChildView *childView = (ChildView*)mPopupContentView->GetNativeData(NS_NATIVE_WIDGET);
+      if (childView) {
+        [childView setTransparent:aTranslucent];
+      }
+    }
+  }
+  return NS_OK;
+}
 
 NS_METHOD nsCocoaWindow::AddMouseListener(nsIMouseListener * aListener)
 {
   nsBaseWidget::AddMouseListener(aListener);
Index: widget/src/gtk2/nsWindow.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/gtk2/nsWindow.cpp,v
retrieving revision 1.237
diff -p -u -4 -r1.237 nsWindow.cpp
--- widget/src/gtk2/nsWindow.cpp	23 Nov 2007 01:38:40 -0000	1.237
+++ widget/src/gtk2/nsWindow.cpp	27 Nov 2007 00:50:12 -0000
@@ -3607,14 +3607,8 @@ nsWindow::UpdateTranslucentWindowAlphaIn
     }
     return NS_OK;
 }
 
-NS_IMETHODIMP
-nsWindow::UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas)
-{
-    return UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aRect.width);
-}
-
 void
 nsWindow::GrabPointer(void)
 {
     LOG(("GrabPointer %d\n", mRetryPointerGrab));
Index: widget/src/gtk2/nsWindow.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/gtk2/nsWindow.h,v
retrieving revision 1.79
diff -p -u -4 -r1.79 nsWindow.h
--- widget/src/gtk2/nsWindow.h	13 Nov 2007 16:12:12 -0000	1.79
+++ widget/src/gtk2/nsWindow.h	27 Nov 2007 00:50:12 -0000
@@ -344,9 +344,8 @@ public:
    NS_IMETHOD          SetWindowTranslucency(PRBool aTransparent);
    NS_IMETHOD          GetWindowTranslucency(PRBool& aTransparent);
    nsresult            UpdateTranslucentWindowAlphaInternal(const nsRect& aRect,
                                                             PRUint8* aAlphas, PRInt32 aStride);
-   NS_IMETHOD          UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas);
 
     gfxASurface       *GetThebesSurface();
 
 #ifdef ACCESSIBILITY
Index: widget/src/xpwidgets/nsBaseWidget.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/xpwidgets/nsBaseWidget.cpp,v
retrieving revision 1.164
diff -p -u -4 -r1.164 nsBaseWidget.cpp
--- widget/src/xpwidgets/nsBaseWidget.cpp	9 Nov 2007 17:38:33 -0000	1.164
+++ widget/src/xpwidgets/nsBaseWidget.cpp	27 Nov 2007 00:50:12 -0000
@@ -524,13 +524,8 @@ NS_IMETHODIMP nsBaseWidget::GetWindowTra
   aTranslucent = PR_FALSE;
   return NS_OK;
 }
 
-NS_IMETHODIMP nsBaseWidget::UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas) {
-  NS_ASSERTION(PR_FALSE, "Window is not translucent");
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
 //-------------------------------------------------------------------------
 //
 // Hide window borders/decorations for this widget
 //
Index: widget/src/xpwidgets/nsBaseWidget.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/xpwidgets/nsBaseWidget.h,v
retrieving revision 1.89
diff -p -u -4 -r1.89 nsBaseWidget.h
--- widget/src/xpwidgets/nsBaseWidget.h	9 Nov 2007 17:38:33 -0000	1.89
+++ widget/src/xpwidgets/nsBaseWidget.h	27 Nov 2007 00:50:12 -0000
@@ -100,9 +100,8 @@ public:
   NS_IMETHOD              GetWindowType(nsWindowType& aWindowType);
   NS_IMETHOD              SetWindowType(nsWindowType aWindowType);
   NS_IMETHOD              SetWindowTranslucency(PRBool aTranslucent);
   NS_IMETHOD              GetWindowTranslucency(PRBool& aTranslucent);
-  NS_IMETHOD              UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas);
   NS_IMETHOD              HideWindowChrome(PRBool aShouldHide);
   NS_IMETHOD              MakeFullScreen(PRBool aFullScreen);
   nsresult                MakeFullScreenInternal(PRBool aFullScreen);
   virtual nsIRenderingContext* GetRenderingContext();
