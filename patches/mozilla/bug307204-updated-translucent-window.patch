Index: widget/public/nsIWidget.h
===================================================================
RCS file: /cvsroot/mozilla/widget/public/nsIWidget.h,v
retrieving revision 3.164
diff -u -p -r3.164 nsIWidget.h
--- widget/public/nsIWidget.h	9 Nov 2007 17:38:33 -0000	3.164
+++ widget/public/nsIWidget.h	16 Nov 2007 18:15:16 -0000
@@ -100,7 +100,7 @@ typedef nsEventStatus (*PR_CALLBACK EVEN
   { 0xB9, 0x87, 0x35, 0x38, 0x56, 0x24, 0x97, 0x0D } }
 
 // Hide the native window systems real window type so as to avoid
-// including native window system types and api's. This is necessary
+// including native window system types and APIs. This is necessary
 // to ensure cross-platform code.
 typedef void* nsNativeWidget;
 
@@ -681,17 +681,6 @@ class nsIWidget : public nsISupports {
      */
     NS_IMETHOD GetWindowTranslucency(PRBool& aTranslucent) = 0;
 
-    /**
-     * Update the alpha channel for some pixels of the top-level window
-     * that contains this widget.
-     * The window must have been made translucent using SetWindowTranslucency.
-     * Pixel RGB color values are already premultiplied with alpha channel values.
-     * @param aRect the rect to update
-     * @param aAlphas the alpha values, in w x h array, row-major order,
-     * in units of 1/255. nsBlender::GetAlphas is a good way to compute this array.
-     */
-    NS_IMETHOD UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas) = 0;
-
     /** 
      * Hide window chrome (borders, buttons) for this widget.
      *
Index: widget/src/cocoa/nsChildView.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsChildView.h,v
retrieving revision 1.76
diff -u -p -r1.76 nsChildView.h
--- widget/src/cocoa/nsChildView.h	7 Nov 2007 07:36:10 -0000	1.76
+++ widget/src/cocoa/nsChildView.h	16 Nov 2007 18:15:16 -0000
@@ -111,6 +111,10 @@ union nsPluginPort;
   NSMutableArray* mPendingDirtyRects;
   BOOL mPendingFullDisplay;
 
+  // All views are always opaque (non-transparent). The only exception is when we're
+  // the content view in a transparent XUL window.
+  BOOL isTransparent;
+
   // Holds our drag service across multiple drag calls. The reference to the
   // service is obtained when the mouse enters the view and is released when
   // the mouse exits or there is a drop. This prevents us from having to
@@ -127,6 +131,7 @@ union nsPluginPort;
 
 // Stop NSView hierarchy being changed during [ChildView drawRect:]
 - (void)delayedTearDown;
+- (void)setTransparent:(BOOL)transparent;
 @end
 
 
@@ -292,12 +297,16 @@ public:
   NS_IMETHOD        StartDrawPlugin();
   NS_IMETHOD        EndDrawPlugin();
   
+  // translucency
+  NS_IMETHOD        GetWindowTranslucency(PRBool& aTranslucent);
+  NS_IMETHOD        SetWindowTranslucency(PRBool aTranslucent);
+  
   // Mac specific methods
   virtual PRBool    PointInWidget(Point aThePoint);
   
   virtual PRBool    DispatchWindowEvent(nsGUIEvent& event);
-  virtual void      AcceptFocusOnClick(PRBool aBool) { mAcceptFocusOnClick = aBool;};
-  PRBool            AcceptFocusOnClick() { return mAcceptFocusOnClick;};
+  virtual void      AcceptFocusOnClick(PRBool aBool) { mAcceptFocusOnClick = aBool; }
+  PRBool            AcceptFocusOnClick() { return mAcceptFocusOnClick; }
   
   void              LiveResizeStarted();
   void              LiveResizeEnded();
Index: widget/src/cocoa/nsChildView.mm
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsChildView.mm,v
retrieving revision 1.277
diff -u -p -r1.277 nsChildView.mm
--- widget/src/cocoa/nsChildView.mm	12 Nov 2007 17:16:15 -0000	1.277
+++ widget/src/cocoa/nsChildView.mm	16 Nov 2007 18:15:16 -0000
@@ -46,7 +46,6 @@
 
 #include "nsCOMPtr.h"
 #include "nsToolkit.h"
-#include "prmem.h"
 #include "nsCRT.h"
 #include "nsplugindefs.h"
 #include "nsThreadUtils.h"
@@ -149,8 +148,6 @@ nsIWidget         * gRollupWidget   = ns
 
 - (BOOL)childViewHasPlugin;
 
-- (BOOL)isRectObscuredBySubview:(NSRect)inRect;
-
 - (void)processPendingRedraws;
 
 - (BOOL)ensureCorrectMouseEventTarget:(NSEvent *)anEvent;
@@ -656,8 +653,34 @@ void* nsChildView::GetNativeData(PRUint3
 
 #pragma mark -
 
+NS_IMETHODIMP nsChildView::GetWindowTranslucency(PRBool& aTranslucent)
+{
+  aTranslucent = ![mView isOpaque];
+  return NS_OK;
+}
+
+// This is called by nsContainerFrame on the root widget for all window types
+// except popup windows (when nsCocoaWindow::SetWindowTranslucency is used instead).
+NS_IMETHODIMP nsChildView::SetWindowTranslucency(PRBool aTranslucent)
+{
+  BOOL currentTranslucency = ![[mView nativeWindow] isOpaque];
+  nsresult rv = NS_OK;
+  if (aTranslucent != currentTranslucency) {
+    // Find out if this is a window we created by seeing if the delegate is WindowDelegate. If it is,
+    // let the nsCocoaWindow take care of changing the window's translucency.
+    id windowDelegate = [[mView nativeWindow] delegate];
+    if (windowDelegate && [windowDelegate isKindOfClass:[WindowDelegate class]]) {
+      nsCocoaWindow *widget = [(WindowDelegate *)windowDelegate geckoWidget];
+      if (widget) {
+        widget->MakeWindowTranslucent(aTranslucent);
+        [mView setTransparent:aTranslucent];
+      }
+    }
+  }
+  return rv;
+}
+
 
-// Return PR_TRUE if the whether the component is visible, PR_FALSE otherwise
 NS_IMETHODIMP nsChildView::IsVisible(PRBool& outState)
 {
   if (!mVisible) {
@@ -2042,10 +2065,17 @@ NSEvent* gLastDragEvent = nil;
 }
 
 
+- (void)setTransparent:(BOOL)transparent
+{
+  if (isTransparent != transparent) {
+    isTransparent = transparent;
+  }
+}
+
+
 - (BOOL)isOpaque
 {
-  // this will be NO when we can do transparent windows/views
-  return YES;
+  return !isTransparent;
 }
 
 
@@ -2171,11 +2201,6 @@ NSEvent* gLastDragEvent = nil;
   PRBool isVisible;
   if (!mGeckoChild || NS_FAILED(mGeckoChild->IsVisible(isVisible)) || !isVisible)
     return;
-  
-  // Workaround for the fact that NSQuickDrawViews can't be opaque; see if the rect
-  // being drawn is covered by a subview, and, if so, just bail.
-  if ([self isRectObscuredBySubview:aRect])
-    return;
 
   CGContextRef cgContext = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
 
@@ -2262,22 +2287,6 @@ NSEvent* gLastDragEvent = nil;
 }
 
 
-- (BOOL)isRectObscuredBySubview:(NSRect)inRect
-{
-  unsigned int numSubviews = [[self subviews] count];
-  for (unsigned int i = 0; i < numSubviews; i++) {
-    NSView* view = (NSView*)[[self subviews] objectAtIndex:i];
-    if (![view isHidden]) {
-      NSRect subviewFrame = [view frame];
-      if (NSContainsRect(subviewFrame, inRect))
-        return YES;
-    }
-  }
-  
-  return NO;
-}
-
-
 // Allows us to turn off setting up the clip region
 // before each drawRect. We already clip within gecko.
 - (BOOL)wantsDefaultClipping
@@ -2605,7 +2614,7 @@ static nsEventStatus SendGeckoMouseEnter
 
 
 - (void)mouseMoved:(NSEvent*)theEvent
-{
+{ 
   NSPoint windowEventLocation = [theEvent locationInWindow];
   NSPoint screenEventLocation = [mWindow convertBaseToScreen:windowEventLocation];
   NSPoint viewEventLocation = [self convertPoint:windowEventLocation fromView:nil];
Index: widget/src/cocoa/nsCocoaWindow.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsCocoaWindow.h,v
retrieving revision 1.43
diff -u -p -r1.43 nsCocoaWindow.h
--- widget/src/cocoa/nsCocoaWindow.h	30 Oct 2007 04:03:43 -0000	1.43
+++ widget/src/cocoa/nsCocoaWindow.h	16 Nov 2007 18:15:16 -0000
@@ -237,6 +237,8 @@ public:
     NS_IMETHOD DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus) ;
     NS_IMETHOD CaptureRollupEvents(nsIRollupListener * aListener, PRBool aDoCapture, PRBool aConsumeRollupEvent);
     NS_IMETHOD GetAttention(PRInt32 aCycleCount);
+    NS_IMETHOD GetWindowTranslucency(PRBool& aTranslucent);
+    NS_IMETHOD SetWindowTranslucency(PRBool aTranslucent);
     NS_IMETHOD SetWindowTitlebarColor(nscolor aColor);
 
     virtual gfxASurface* GetThebesSurface();
@@ -251,6 +253,8 @@ public:
     
     // nsIKBStateControl interface
     NS_IMETHOD ResetInputState();
+    
+    void MakeWindowTranslucent(PRBool aTranslucency);
 
     NS_IMETHOD BeginSecureKeyboardInput();
     NS_IMETHOD EndSecureKeyboardInput();
Index: widget/src/cocoa/nsCocoaWindow.mm
===================================================================
RCS file: /cvsroot/mozilla/widget/src/cocoa/nsCocoaWindow.mm,v
retrieving revision 1.116
diff -u -p -r1.116 nsCocoaWindow.mm
--- widget/src/cocoa/nsCocoaWindow.mm	16 Nov 2007 02:54:00 -0000	1.116
+++ widget/src/cocoa/nsCocoaWindow.mm	16 Nov 2007 18:15:16 -0000
@@ -1,4 +1,4 @@
-/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* -*- Mode: Objective-C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
@@ -66,6 +66,8 @@ extern BOOL                gSomeMenuBarP
 
 #define NS_APPSHELLSERVICE_CONTRACTID "@mozilla.org/appshell/appShellService;1"
 
+#define POPUP_DEFAULT_TRANSPARENCY 0.95
+
 NS_IMPL_ISUPPORTS_INHERITED1(nsCocoaWindow, Inherited, nsPIWidgetCocoa)
 
 
@@ -313,6 +315,7 @@ nsresult nsCocoaWindow::StandardCreate(n
 
     rect.origin.y -= (newWindowFrame.size.height - rect.size.height);
     
+    // XXXhakan: this should only be done on the screen showing the menubar
     if (mWindowType != eWindowType_popup)
       rect.origin.y -= ::GetMBarHeight();
 
@@ -339,7 +342,7 @@ nsresult nsCocoaWindow::StandardCreate(n
                                    backing:NSBackingStoreBuffered defer:NO];
     
     if (mWindowType == eWindowType_popup) {
-      [mWindow setAlphaValue:0.95];
+      [mWindow setAlphaValue:POPUP_DEFAULT_TRANSPARENCY];
       [mWindow setLevel:NSPopUpMenuWindowLevel];
       [mWindow setHasShadow:YES];
 
@@ -646,6 +649,44 @@ NS_IMETHODIMP nsCocoaWindow::Show(PRBool
   return NS_OK;
 }
 
+void nsCocoaWindow::MakeWindowTranslucent(PRBool aTranslucent)
+{
+  BOOL currentTranslucency = ![mWindow isOpaque];
+  if (aTranslucent != currentTranslucency) {
+    // Popups have an alpha value we need to toggle.
+    if (mWindowType == eWindowType_popup) {
+      [mWindow setAlphaValue:(aTranslucent ? 1.0 : POPUP_DEFAULT_TRANSPARENCY)];
+    }
+    [mWindow setOpaque:!aTranslucent];
+    [mWindow setBackgroundColor:(aTranslucent ? [NSColor clearColor] : [NSColor whiteColor])];
+    [mWindow setHasShadow:!aTranslucent];
+  }
+}
+
+NS_IMETHODIMP nsCocoaWindow::GetWindowTranslucency(PRBool& aTranslucent)
+{
+  aTranslucent = ![mWindow isOpaque];   
+  return NS_OK;
+}
+
+// This is called from nsMenuPopupFrame when making a popup translucent.
+// For other window types, nsChildView::SetWindowTranslucency is used.
+NS_IMETHODIMP nsCocoaWindow::SetWindowTranslucency(PRBool aTranslucent)
+{
+  BOOL currentTranslucency = ![mWindow isOpaque];
+  if (aTranslucent != currentTranslucency) {
+    // Take care of window translucency
+    MakeWindowTranslucent(aTranslucent);
+    // Make sure our content view is also translucent
+    if (mPopupContentView) {
+      ChildView *childView = (ChildView*)mPopupContentView->GetNativeData(NS_NATIVE_WIDGET);
+      if (childView) {
+        [childView setTransparent:aTranslucent];
+      }
+    }
+  }
+  return NS_OK;
+}
 
 NS_METHOD nsCocoaWindow::AddMouseListener(nsIMouseListener * aListener)
 {
Index: widget/src/gtk2/nsWindow.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/gtk2/nsWindow.cpp,v
retrieving revision 1.236
diff -u -p -r1.236 nsWindow.cpp
--- widget/src/gtk2/nsWindow.cpp	13 Nov 2007 16:12:12 -0000	1.236
+++ widget/src/gtk2/nsWindow.cpp	16 Nov 2007 18:15:16 -0000
@@ -3547,12 +3547,6 @@ nsWindow::UpdateTranslucentWindowAlphaIn
     return NS_OK;
 }
 
-NS_IMETHODIMP
-nsWindow::UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas)
-{
-    return UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aRect.width);
-}
-
 void
 nsWindow::GrabPointer(void)
 {
Index: widget/src/gtk2/nsWindow.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/gtk2/nsWindow.h,v
retrieving revision 1.79
diff -u -p -r1.79 nsWindow.h
--- widget/src/gtk2/nsWindow.h	13 Nov 2007 16:12:12 -0000	1.79
+++ widget/src/gtk2/nsWindow.h	16 Nov 2007 18:15:16 -0000
@@ -345,7 +345,6 @@ public:
    NS_IMETHOD          GetWindowTranslucency(PRBool& aTransparent);
    nsresult            UpdateTranslucentWindowAlphaInternal(const nsRect& aRect,
                                                             PRUint8* aAlphas, PRInt32 aStride);
-   NS_IMETHOD          UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas);
 
     gfxASurface       *GetThebesSurface();
 
Index: widget/src/xpwidgets/nsBaseWidget.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/xpwidgets/nsBaseWidget.cpp,v
retrieving revision 1.164
diff -u -p -r1.164 nsBaseWidget.cpp
--- widget/src/xpwidgets/nsBaseWidget.cpp	9 Nov 2007 17:38:33 -0000	1.164
+++ widget/src/xpwidgets/nsBaseWidget.cpp	16 Nov 2007 18:15:16 -0000
@@ -525,11 +525,6 @@ NS_IMETHODIMP nsBaseWidget::GetWindowTra
   return NS_OK;
 }
 
-NS_IMETHODIMP nsBaseWidget::UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas) {
-  NS_ASSERTION(PR_FALSE, "Window is not translucent");
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
 //-------------------------------------------------------------------------
 //
 // Hide window borders/decorations for this widget
Index: widget/src/xpwidgets/nsBaseWidget.h
===================================================================
RCS file: /cvsroot/mozilla/widget/src/xpwidgets/nsBaseWidget.h,v
retrieving revision 1.89
diff -u -p -r1.89 nsBaseWidget.h
--- widget/src/xpwidgets/nsBaseWidget.h	9 Nov 2007 17:38:33 -0000	1.89
+++ widget/src/xpwidgets/nsBaseWidget.h	16 Nov 2007 18:15:16 -0000
@@ -101,7 +101,6 @@ public:
   NS_IMETHOD              SetWindowType(nsWindowType aWindowType);
   NS_IMETHOD              SetWindowTranslucency(PRBool aTranslucent);
   NS_IMETHOD              GetWindowTranslucency(PRBool& aTranslucent);
-  NS_IMETHOD              UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas);
   NS_IMETHOD              HideWindowChrome(PRBool aShouldHide);
   NS_IMETHOD              MakeFullScreen(PRBool aFullScreen);
   nsresult                MakeFullScreenInternal(PRBool aFullScreen);
