/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
*/

/**
 * \file sbIMediaLibrary.idl
 * \brief Media library interfaces.
 *
 * sbIMediaLibrary
 *
 * sbIMediaScanCallback
 *
 * sbIMediaScanQuery
 *
 * sbIMediaScan
 * 
 * \sa sbIDatabaseQuery.idl, DatabaseQuery.h, sbIPlaylist.idl
 */

#include "nsISupports.idl"

/**
 * \interface sbIMediaScanCallback 
 * \brief The callback to the sbIMediaScanQuery interface
 *
 * This interface is meant to be implemented by user code.
 *
 * Create one of these objects to be informed of the progress of the media
 * scan.
 *
 * NOTE: This object's methods are called from the media scan thread.  Not
 * necessarily safe for javascript!
 *
 * \sa sbIMediaScanQuery, sbIMediaScan, MediaScan.h
 */
[scriptable, uuid(0F75EA33-A1FD-4bf6-8D13-DBAC96CAA668)]
interface sbIMediaScanCallback : nsISupports
{
  /**
   * \brief The media scan is starting
   *
   * \sa onMediaScanFile, onMediaScanEnd, sbIMediaScanQuery, sbIMediaScan
   */
  void onMediaScanStart(); /**/

  /**
   * \brief The media scan has found (yet another) file
   *
   * \param filePath The path to the file
   * \param fileCount The number of files found so far
   * \sa onMediaScanStart, onMediaScanEnd, sbIMediaScanQuery, sbIMediaScan
   */
  void onMediaScanFile(in AString filePath, 
    in PRInt32 fileCount); /**/

  /**
   * \brief The media scan is complete
   *
   * \sa onMediaScanStart, onMediaScanFile, sbIMediaScanQuery, sbIMediaScan
   */
  void onMediaScanEnd(); /**/
};

/**
 * \interface sbIMediaScanQuery 
 * \brief An object to scan through the files of a folder (and optionally subfolders)
 *
 * This object is used to rapidly gather a list of all the files found under a
 * given directory path.  It runs from a separate thread.
 *
 * User code may call getCurrentScanPath() and getLastFileFound() from the main 
 * thread to get a periodic snapshot of the current progress of the scan.
 *
 * Execute a scan by creating a scan query, filling it out, and passing it to
 * the sbIMediaScan interface for processing:
\verbatim
function ScanBeneathADirectory(aPath) {
  // Create the objects
  var aMediaScan = Components.classes["@songbirdnest.com/Songbird/MediaScan;1"]
    .createInstance(Components.interfaces.sbIMediaScan);
  var aMediaScanQuery = Components.classes["@songbirdnest.com/Songbird/MediaScanQuery;1"]
    .createInstance(Components.interfaces.sbIMediaScanQuery);

  // Setup the query
  aMediaScanQuery.setDirectory(aPath);
  aMediaScanQuery.setRecurse(true);
          
  // Execute the query
  aMediaScan.submitQuery(aMediaScanQuery);
  return aMediaScanQuery;
}
\endverbatim
 *
 * \sa sbIMediaScanCallback, sbIMediaScan, MediaScan.h
 */
[scriptable, uuid(62A3F4B6-542D-4bd1-87E2-E00C72B0AACE)]
interface sbIMediaScanQuery : nsISupports
{
  attribute boolean searchHidden;

  /**
   * \brief Set the directory to scan
   *
   * \param strDirectory The directory to scan
   * \sa getDirectory, setRecurse, getRecurse
   */
  void setDirectory(in AString strDirectory); /**/

  /**
   * \brief Get the directory to scan
   *
   * \return The directory to scan
   * \sa setDirectory, setRecurse, getRecurse
   */
  AString getDirectory(); /**/

  /**
   * \brief Set the scan to run recursively under the given directory
   *
   * \param bRecurse If true, scan subdirectories
   * \sa setDirectory, getDirectory, getRecurse
   */
  void setRecurse(in PRBool bRecurse); /**/

  /**
   * \brief Whether or not the scan will run recursively
   *
   * \return If true, scan subdirectories
   * \sa setDirectory, getDirectory, setRecurse
   */
  PRBool getRecurse(); /**/

  void addFileExtension(in AString strExtension);

  /**
   * \brief Set the callback object for the scan
   *
   * \param pCallback The callback object
   * \sa sbIMediaScanCallback, getCallback
   */
  void setCallback(in sbIMediaScanCallback pCallback); /**/

  /**
   * \brief Get the callback object for the scan
   *
   * \return The callback object
   * \sa sbIMediaScanCallback, setCallback
   */
  sbIMediaScanCallback getCallback(); /**/

  /**
   * \brief Get the number of files found
   *
   * \return The number of files found
   * \sa getFilePath
   */
  PRUint32 getFileCount(); /**/

  /**
   * \brief USER CODE SHOULD NOT REFERENCE THIS METHOD
   */
  void addFilePath(in AString strFilePath); /**/

  /**
   * \brief Get the N'th file from the results of the scan
   *
   * Don't call this while isScanning() is true.
   *
   * \param nIndex The index of the files array to retrieve
   * \sa getFileCount
   */
  AString getFilePath(in PRUint32 nIndex); /**/

  /**
   * \brief Whether or not the scan operation is executing
   *
   * \return True, if the scan is executing
   * \sa sbIDatabaseQuery
   */
  PRBool isScanning();

  /**
   * \brief USER CODE SHOULD NOT REFERENCE THIS METHOD
   */
  void setIsScanning(in PRBool bIsScanning);

  /**
   * \brief Returns the most recent file found by the scan
   *
   * This method may be called while the scan is executing to provide a 
   * periodic snapshot of the scan results.
   *
   * \return The path to the last file found
   * \sa getCurrentScanPath
   */
  AString getLastFileFound();

  /**
   * \brief Returns the most recent directory scanned
   *
   * This method may be called while the scan is executing to provide a 
   * periodic snapshot of the scan results.
   *
   * \return The path to the last file found
   * \sa getLastFileFound, setCurrentScanPath
   */
  AString getCurrentScanPath();

  /**
   * \brief USER CODE SHOULD NOT REFERENCE THIS METHOD
   */
  void setCurrentScanPath(in AString strScanPath);

  /**
   * \brief Cancel the current scanning loop
   */
  void cancel();

  /**
   * \brief USER CODE SHOULD NOT REFERENCE THIS METHOD
   */
  PRBool isCancelled();
};

/**
 * \interface sbIMediaScan
 * \brief The engine in which to execute sbIMediaScanQuery objects
 *
 * Create a sbIMediaScanQuery object, fill out its methods, create one of
 * these and pass the query to the scanner to begin executing.
 *
 * Optionally, you may skip the use of a sbIMediaScanQuery object and just
 * handle the scan directly by calling scanDirectory() with your own
 * sbIMediaScanCallback object.
 *
 * \sa sbIMediaScanCallback, sbIMediaScanQuery
 */
[scriptable, uuid(12BC75D3-8FD4-4b19-8F5B-CEF353E5168D)]
interface sbIMediaScan : nsISupports
{ 
  /**
   * \brief Execute a sbIMediaScanQuery object
   *
   * \param pQuery The query object to execute
   * \sa scanDirectory
   */
  void submitQuery(in sbIMediaScanQuery pQuery);
  
  /**
   * \brief Execute a scan directly to a sbIMediaScanCallback instance
   *
   * \param strDirectory The directory to scan
   * \param bRecurse Whether or not to recurse
   * \param pCallback The callback used to process the scan
   * \sa submitQuery
   */
  PRInt32 scanDirectory(in AString strDirectory, 
    in PRBool bRecurse, 
    in sbIMediaScanCallback pCallback);
};
