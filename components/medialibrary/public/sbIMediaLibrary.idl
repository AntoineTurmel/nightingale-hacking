/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2006 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
*/

/**
 * \file sbIMediaLibrary.idl
 * \brief Media library interfaces.
 *
 * sbIMediaLibrary
 *
 * sbIMediaScanCallback
 *
 * sbIMediaScanQuery
 *
 * sbIMediaScan
 * 
 * \sa sbIDatabaseQuery.idl, DatabaseQuery.h, sbIPlaylist.idl
 */

#include "nsISupports.idl"

interface sbIDatabaseQuery;

/**
 * \interface sbIMediaLibrary 
 * \brief The media library object constructs SQL queries designed to reference the library of a database
 *
 * The media library is a "database-helper" object.  Its purpose is to 
 * translate common library-centric activities into the SQL queries 
 * required to make it happen.
 *
 * \sa sbIDatabaseQuery, DatabaseQuery.h, sbIPlaylist, sbIPlaylistManager
 */
[scriptable, uuid(ca5c9b2c-e061-4c98-8333-9c839efc0d7f)]
interface sbIMediaLibrary : nsISupports
{
  /**
   * \brief Set the database query object that the library will use to make 
   * queries to the database
   *
   * \param queryObj Database query object you wish to use with this library.
   * \sa sbIDatabaseQuery
   */
  void setQueryObject(in sbIDatabaseQuery queryObj); /**/

  /**
   * \brief Get the database query object that is being used by the library to
   * make database queries.
   *
   * \return The database query object that the library uses.
   * \sa sbIDatabaseQuery
   */
  sbIDatabaseQuery getQueryObject(); /**/

  /**
   * \brief Create the library table with default metadata columns
   *
   * This method will synchronously execute the query required to create the
   * default library in the given database.
   *
   * \sa sbMediaLibrary.js
   */
  void createDefaultLibrary(); /**/

  /**
   * \brief Add a new piece of media to the library
   *
   * This method constructs the SQL query required to insert a new track into
   * the library.  If the checkForUniqueFilename parameter is true, the code
   * will first see if the mediaURL exists and, if so, update that track with
   * the given metadata information and return that GUID rather than create a
   * new row in the database.
   *
   * Metadata is passed along with the track to fill columns in the database
   * based upon a pair of string arrays.  The metaColumnNames and metaValues
   * should have an equal number of members - each index corresponds to each
   * column-value pair set into the database.
   *
   * \param mediaURL The URL to the media to add
   * \param metaColumnCount The number of items in the metaColumnNames parameter
   * \param metaColumnNames An array of strings identifying columns to be fill with metadata (matching the metaValues array)
   * \param metaValueCount The number of items in the metaValues parameter
   * \param metaValues An array of strings identifying metadata values to be inserted (matching the metaColumnNames array)
   * \param checkForUniqueFilename If true, see if the file already exists.  If so, return the GUID found.
   * \param willRunQueryLater If false, execute the query before returning
   * \return The GUID for the track added (or found)
   * \sa removeMediaByURL, removeMediaByGUID, findByGUID, findByURL
   */
  AString addMedia(in AString mediaURL, 
    in PRUint32 metaColumnCount, 
    [array, size_is (metaColumnCount)] in wstring metaColumnNames, 
    in PRUint32 metaValueCount, 
    [array, size_is (metaValueCount)] in wstring metaValues, 
    in PRBool checkForUniqueFilename, 
    in PRBool willRunQueryLater); /**/

  /**
   * \brief Remove a track from the library
   *
   * \param mediaURL The URL of the track to remove
   * \param willRunQueryLater If false, execute the query before returning
   * \return True, if the query was successfully added
   * \sa removeMediaByGUID, addMedia
   */
  PRBool removeMediaByURL(in AString mediaURL, 
    in PRBool willRunQueryLater); /**/

  /**
   * \brief Remove a track from the library
   *
   * \param mediaGUID The GUID of the track to remove
   * \param willRunQueryLater If false, execute the query before returning
   * \return True, if the query was successfully added
   * \sa removeMediaByGUID, addMedia
   */
  PRBool removeMediaByGUID(in AString mediaGUID, 
    in PRBool willRunQueryLater); /**/

  /**
   * \brief Remove all tracks from the library
   *
   * \param willRunQueryLater If false, execute the query before returning
   * \return True, if the query was successfully added
   * \sa removeMediaByGUID, addMedia
   */
  PRBool purgeDefaultLibrary(in PRBool willRunQueryLater); /**/

  /**
   * \brief Get a track's URL from its GUID
   *
   * \param mediaGUID The GUID of the track to find
   * \return The URL of the track
   * \sa findByURL
   */
  AString findByGUID(in AString mediaGUID); /**/

  /**
   * \brief Get a track's GUID from its URL
   *
   * This will find the first track matching the URL if there are more than one.
   *
   * \param mediaURL The URL of the track to find
   * \return The GUID of the track
   * \sa findByGUID
   */
  AString findByURL(in AString mediaURL); /**/

  /**
   * \brief Add a column to the library table
   *
   * \param columnName The name of the new column (not human readable -- internal name)
   * \param columnType The type of the new column
   * \sa deleteColumn, getColumnInfo, setColumnInfo, getMetadataColumns
   */
  void addColumn(in AString columnName, 
    in AString columnType); /**/
  
  /**
   * \brief Remove a column from the library table
   *
   * \todo deleteColumn is not yet implemented
   * \param columnName The name of the column to delete
   * \sa addColumn, getColumnInfo, setColumnInfo, getMetadataColumns
   */
  void deleteColumn(in AString columnName); /**/

  /**
   * \brief Load the column info for the table into the resultset.
   *
   * Column Info is kept in a separate table with the following columns:
   *
\verbatim 
  column_name TEXT UNIQUE, // The column name in the library
  readable_name TEXT, // The human readable name displayed in the UI
  is_visible INTEGER(0, 1) DEFAULT 0, // If the column may ever be displayed
  default_visibility INTEGER(0, 1) DEFAULT 0, // If the column defaults visible
  is_metadata INTEGER(0, 1) DEFAULT 0, // If the column holds metadata (vs service info)
  sort_weight INTEGER DEFAULT 0, // The default ordering of columns in the UI
  width INTEGER DEFAULT -1, // The default relative width
  type TEXT DEFAULT 'text', // The type of column
  readonly INTEGER(0,1) DEFAULT 0 // If the column may be edited by the user
\endverbatim 
   *
   * For instance, to get all of the human readable names of the columns:
   *
\verbatim
function GetColumnNames(aLibrary) {
  // Create the objects
  var medialib = Components.classes["@songbirdnest.com/Songbird/MediaLibrary;1"]
    .createInstance(Components.interfaces.sbIMediaLibrary);
  var query = Components.classes["@songbirdnest.com/Songbird/DatabaseQuery;1"]
    .createInstance(Components.interfaces.sbIDatabaseQuery);

  // Setup the objects
  query.setDatabaseGUID(aLibrary)
  medialib.setQueryObject(query);

  // Get the column info
  medialib.getColumnInfo();
  var resultset = query.getResultObject();

  // Parse the resultset
  var column_names = "";
  for (var i = 0; i < resultset.getRowCount(); i++) {
    column_names += resultset.getRowCellByColumn(i, "column_name") + " ";
  }
  return column_names;
}
\endverbatim 
   * \sa sbIDatabaseQuery, addColumn, deleteColumn, setColumnInfo, getMetadataColumns
   */
  void getColumnInfo(); /**/

  /**
   * \brief Update the Column Info table with new data
   *
   * \param columnName The column to be changed
   * \param columnReadableName The new readable name
   * \param isColumnEverVisible The new global visibility bit
   * \param isColumnVisibleByDefault The new default visibility bit
   * \param isMetadataColumn The new is metadata bit
   * \param columnSortWeight The new sort weight
   * \param columnDefaultWidth The new default width
   * \param columnDataType The new type
   * \param isColumnReadOnly The new readonly bit
   * \param willRunQueryLater If false, execute the query before returning
   * \sa addColumn, deleteColumn, getColumnInfo, getMetadataColumns
   */
  void setColumnInfo(in AString columnName, 
    in AString columnReadableName, 
    in PRBool isColumnEverVisible, 
    in PRBool isColumnVisibleByDefault, 
    in PRBool isMetadataColumn, 
    in PRInt32 columnSortWeight,
    in PRInt32 columnDefaultUIWidth,
    in AString columnDataType,
    in PRBool isColumnReadOnly,
    in PRBool willRunQueryLater); /**/

  /**
   * \brief Get the array of metadata column names in the Column Info table
   *
   * \param metaColumnCount The number of items in the array
   * \param metaColumnNames The array of metadata column names
   * \sa addColumn, deleteColumn, getColumnInfo, setColumnInfo
   */
  /*getMetadataFields*/
/* This doesn't exist
  void getMetadataColumns(out PRUint32 metaColumnCount, 
    [array, size_is (metaColumnCount), retval] out wstring metaColumnNames); /**/

  /**
   * \brief 
   *
   * \param columnName
   * \param columnType
   * \param willRunQueryLater
   * \sa addColumn, deleteColumn, getColumnInfo, getMetadataColumns, setColumnInfo
   */
  /*addMetadataField*/
/* This doesn't exist
  void addMetadataColumn(in AString columnName, 
    in AString columnType, 
    in PRBool willRunQueryLater); /**/

  /**
   * \brief 
   *
   * \param columnName
   * \param willRunQueryLater
   * \sa addColumn, deleteColumn, getColumnInfo, getMetadataColumns, setColumnInfo
   */
  /*deleteMetadataField*/
  /* This doesn't exist
  PRBool deleteMetadataColumn(in AString columnName, 
    in PRBool willRunQueryLater); /**/

  /*
  PRBool AddTagByIndex();
  PRBool AddTagByGUID();



  PRBool DeleteTag
  GetUniqueTags();
  GetUniqueTagsCount();
  */

  /**
   * \brief Get the Unique list of values across the library for the column
   *
   * Essentially equivalent to the list in a filterlist UI element.
   *
   * \param columnName The column for which to retrieve values
   * \param columnUniqueValCount The number of items in the array
   * \param columnUniqueValues The array of unique values
   * \sa setValueByIndex, setValueByGUID, setValuesByIndex, setValuesByGUID, getValueByIndex, getValueByGUID, getValuesByIndex, getValuesByGUID
   */
  void getUniqueValuesByColumn(in AString columnName, 
    out PRUint32 columnUniqueValCount, 
    [array, size_is (columnUniqueValCount), retval] out wstring columnUniqueValues); /**/

  /**
   * \brief Set cell a value into the library table
   *
   * \todo This won't work, it tries to use row number as ID.
   * \param mediaIndex The row number of the cell to set
   * \param columnName The name of the column for the cell to set
   * \param columnValue The value of the cell to be set
   * \param willRunQueryLater If false, execute the query before returning
   * \return True if the query was properly loaded/executed
   * \sa getUniqueValuesByColumn, setValueByGUID, setValuesByIndex, setValuesByGUID, getValueByIndex, getValueByGUID, getValuesByIndex, getValuesByGUID
   */
  PRBool setValueByIndex(in PRInt32 mediaIndex, 
    in AString columnName, 
    in AString columnValue, 
    in PRBool willRunQueryLater); /**/
  
  /**
   * \brief Set multiple values into a single database row
   *
   * \todo This won't work, it tries to use row number as ID.
   * \param mediaIndex The row number of the cell to set
   * \param metaColumnCount The number of items in the array
   * \param metaColumnNames The array of columns to set
   * \param metaValueCount The number of items in the array
   * \param metaValues The array of values to be set
   * \param willRunQueryLater If false, execute the query before returning
   * \return True if the query was properly loaded/executed
   * \sa getUniqueValuesByColumn, setValueByIndex, setValueByGUID, setValuesByGUID, getValueByIndex, getValueByGUID, getValuesByIndex, getValuesByGUID
   */
  PRBool setValuesByIndex(in PRInt32 mediaIndex, 
    in PRUint32 metaColumnCount, 
    [array, size_is(metaColumnCount)] in wstring metaColumnNames, 
    in PRUint32 metaValueCount, 
    [array, size_is(metaValueCount)] in wstring metaValues, 
    in PRBool willRunQueryLater); /**/

  /**
   * \brief Get cell a value from the library table
   *
   * \todo This won't work, it tries to use row number as ID.
   * \param mediaIndex The row number of the cell to get
   * \param columnName The name of the column for the cell to get
   * \return The value of the cell
   * \sa getUniqueValuesByColumn, setValueByIndex, setValueByGUID, setValuesByIndex, setValuesByGUID, getValueByGUID, getValuesByIndex, getValuesByGUID
   */
  AString getValueByIndex(in PRInt32 mediaIndex, 
    in AString columnName); /**/
  
  /**
   * \brief Get multiple values from a single database row
   *
   * \todo This won't work, it tries to use row number as ID.
   * \param mediaIndex The row number of the cell to get
   * \param metaColumnCount The number of items in the array
   * \param metaColumnNames The array of columns to get
   * \param metaValueCount The number of items in the array
   * \param metaValues The array of values retrieved
   * \sa getUniqueValuesByColumn, setValueByIndex, setValueByGUID, setValuesByIndex, setValuesByGUID, getValueByIndex, getValueByGUID, getValuesByGUID
   */
  void getValuesByIndex(in PRInt32 mediaIndex, 
    in PRUint32 metaColumnCount, 
    [array, size_is(metaColumnCount)] in wstring metaColumnNames, 
    out PRUint32 metaValueCount, 
    [array, size_is (metaValueCount), retval] out wstring metaValues); /**/
  
  /**
   * \brief Set cell a value into the library table
   *
   * \param mediaGUID The guid of the cell to get, where media library row GUID equals mediaGUID
   * \param columnName The name of the column for the cell to set
   * \param columnValue The value of the cell to be set
   * \param willRunQueryLater If false, execute the query before returning
   * \return 
   * \sa getUniqueValuesByColumn, setValueByIndex, setValuesByIndex, setValuesByGUID, getValueByIndex, getValueByGUID, getValuesByIndex, getValuesByGUID
   */
  PRBool setValueByGUID(in AString mediaGUID, 
    in AString columnName, 
    in AString columnValue, 
    in PRBool willRunQueryLater); /**/
  
  /**
   * \brief Set multiple values into a single database row
   *
   * \param mediaGUID The guid of the cell to get, where media library row GUID equals mediaGUID
   * \param metaColumnCount The number of items in the array
   * \param metaColumnNames The array of columns to set
   * \param metaValueCount The number of items in the array
   * \param metaValues The array of values to be set
   * \param willRunQueryLater If false, execute the query before returning
   * \return
   * \sa getUniqueValuesByColumn, setValueByIndex, setValueByGUID, setValuesByIndex, getValueByIndex, getValueByGUID, getValuesByIndex, getValuesByGUID
   */
  PRBool setValuesByGUID(in AString mediaGUID, 
    in PRUint32 metaColumnCount, 
    [array, size_is(metaColumnCount)] in wstring metaColumnNames, 
    in PRUint32 metaValueCount, 
    [array, size_is(metaValueCount)] in wstring metaValues, 
    in PRBool willRunQueryLater); /**/

  /**
   * \brief Get cell a value from the library table
   *
   * \param mediaGUID The guid of the cell to get, where media library row GUID equals mediaGUID
   * \param columnName The name of the column for the cell to get
   * \return The value of the cell
   * \sa getUniqueValuesByColumn, setValueByIndex, setValueByGUID, setValuesByIndex, setValuesByGUID, getValueByIndex, getValuesByIndex, getValuesByGUID
   */
  AString getValueByGUID(in AString mediaGUID, 
    in AString columnName); /**/
  
  /**
   * \brief Get multiple values from a single database row
   *
   * \param mediaGUID The guid of the cell to get, where media library row GUID equals mediaGUID
   * \param metaColumnCount The number of items in the array
   * \param metaColumnNames The array of columns to get
   * \param metaValueCount The number of items in the array
   * \param metaValues The array of values retrieved
   * \sa getUniqueValuesByColumn, setValueByIndex, setValueByGUID, setValuesByIndex, setValuesByGUID, getValueByIndex, getValueByGUID, getValuesByIndex
   */
  void getValuesByGUID(in AString mediaGUID, 
    in PRUint32 metaColumnCount, 
    [array, size_is (metaColumnCount)] in wstring metaColumnNames, 
    out PRUint32 metaValueCount, 
    [array, size_is (metaValueCount), retval] out wstring metaValues); /**/
};

/**
 * \interface sbIMediaScanCallback 
 * \brief The callback to the sbIMediaScanQuery interface
 *
 * This interface is meant to be implemented by user code.
 *
 * Create one of these objects to be informed of the progress of the media
 * scan.
 *
 * NOTE: This object's methods are called from the media scan thread.  Not
 * necessarily safe for javascript!
 *
 * \sa sbIMediaScanQuery, sbIMediaScan, MediaScan.h
 */
[scriptable, uuid(0F75EA33-A1FD-4bf6-8D13-DBAC96CAA668)]
interface sbIMediaScanCallback : nsISupports
{
  /**
   * \brief The media scan is starting
   *
   * \sa onMediaScanFile, onMediaScanEnd, sbIMediaScanQuery, sbIMediaScan
   */
  void onMediaScanStart(); /**/

  /**
   * \brief The media scan has found (yet another) file
   *
   * \param filePath The path to the file
   * \param fileCount The number of files found so far
   * \sa onMediaScanStart, onMediaScanEnd, sbIMediaScanQuery, sbIMediaScan
   */
  void onMediaScanFile(in AString filePath, 
    in PRInt32 fileCount); /**/

  /**
   * \brief The media scan is complete
   *
   * \sa onMediaScanStart, onMediaScanFile, sbIMediaScanQuery, sbIMediaScan
   */
  void onMediaScanEnd(); /**/
};

/**
 * \interface sbIMediaScanQuery 
 * \brief An object to scan through the files of a folder (and optionally subfolders)
 *
 * This object is used to rapidly gather a list of all the files found under a
 * given directory path.  It runs from a separate thread.
 *
 * User code may call getCurrentScanPath() and getLastFileFound() from the main 
 * thread to get a periodic snapshot of the current progress of the scan.
 *
 * Execute a scan by creating a scan query, filling it out, and passing it to
 * the sbIMediaScan interface for processing:
\verbatim
function ScanBeneathADirectory(aPath) {
  // Create the objects
  var aMediaScan = Components.classes["@songbirdnest.com/Songbird/MediaScan;1"]
    .createInstance(Components.interfaces.sbIMediaScan);
  var aMediaScanQuery = Components.classes["@songbirdnest.com/Songbird/MediaScanQuery;1"]
    .createInstance(Components.interfaces.sbIMediaScanQuery);

  // Setup the query
  aMediaScanQuery.setDirectory(aPath);
  aMediaScanQuery.setRecurse(true);
          
  // Execute the query
  aMediaScan.submitQuery(aMediaScanQuery);
  return aMediaScanQuery;
}
\endverbatim
 *
 * \sa sbIMediaScanCallback, sbIMediaScan, MediaScan.h
 */
[scriptable, uuid(62A3F4B6-542D-4bd1-87E2-E00C72B0AACE)]
interface sbIMediaScanQuery : nsISupports
{
  /**
   * \brief Set the directory to scan
   *
   * \param strDirectory The directory to scan
   * \sa getDirectory, setRecurse, getRecurse
   */
  void setDirectory(in AString strDirectory); /**/

  /**
   * \brief Get the directory to scan
   *
   * \return The directory to scan
   * \sa setDirectory, setRecurse, getRecurse
   */
  AString getDirectory(); /**/

  /**
   * \brief Set the scan to run recursively under the given directory
   *
   * \param bRecurse If true, scan subdirectories
   * \sa setDirectory, getDirectory, getRecurse
   */
  void setRecurse(in PRBool bRecurse); /**/

  /**
   * \brief Whether or not the scan will run recursively
   *
   * \return If true, scan subdirectories
   * \sa setDirectory, getDirectory, setRecurse
   */
  PRBool getRecurse(); /**/

  /**
   * \brief Set the callback object for the scan
   *
   * \param pCallback The callback object
   * \sa sbIMediaScanCallback, getCallback
   */
  void setCallback(in sbIMediaScanCallback pCallback); /**/

  /**
   * \brief Get the callback object for the scan
   *
   * \return The callback object
   * \sa sbIMediaScanCallback, setCallback
   */
  sbIMediaScanCallback getCallback(); /**/

  /**
   * \brief Get the number of files found
   *
   * \return The number of files found
   * \sa getFilePath
   */
  PRUint32 getFileCount(); /**/

  /**
   * \brief USER CODE SHOULD NOT REFERENCE THIS METHOD
   */
  void addFilePath(in AString strFilePath); /**/

  /**
   * \brief Get the N'th file from the results of the scan
   *
   * Don't call this while isScanning() is true.
   *
   * \param nIndex The index of the files array to retrieve
   * \sa getFileCount
   */
  AString getFilePath(in PRUint32 nIndex); /**/

  /**
   * \brief Whether or not the scan operation is executing
   *
   * \return True, if the scan is executing
   * \sa sbIDatabaseQuery
   */
  PRBool isScanning();

  /**
   * \brief USER CODE SHOULD NOT REFERENCE THIS METHOD
   */
  void setIsScanning(in PRBool bIsScanning);

  /**
   * \brief Returns the most recent file found by the scan
   *
   * This method may be called while the scan is executing to provide a 
   * periodic snapshot of the scan results.
   *
   * \return The path to the last file found
   * \sa getCurrentScanPath
   */
  AString getLastFileFound();

  /**
   * \brief Returns the most recent directory scanned
   *
   * This method may be called while the scan is executing to provide a 
   * periodic snapshot of the scan results.
   *
   * \return The path to the last file found
   * \sa getLastFileFound, setCurrentScanPath
   */
  AString getCurrentScanPath();

  /**
   * \brief USER CODE SHOULD NOT REFERENCE THIS METHOD
   */
  void setCurrentScanPath(in AString strScanPath);

  /**
   * \brief Cancel the current scanning loop
   */
  void cancel();

  /**
   * \brief USER CODE SHOULD NOT REFERENCE THIS METHOD
   */
  PRBool isCancelled();
};

/**
 * \interface sbIMediaScan
 * \brief The engine in which to execute sbIMediaScanQuery objects
 *
 * Create a sbIMediaScanQuery object, fill out its methods, create one of
 * these and pass the query to the scanner to begin executing.
 *
 * Optionally, you may skip the use of a sbIMediaScanQuery object and just
 * handle the scan directly by calling scanDirectory() with your own
 * sbIMediaScanCallback object.
 *
 * \sa sbIMediaScanCallback, sbIMediaScanQuery
 */
[scriptable, uuid(12BC75D3-8FD4-4b19-8F5B-CEF353E5168D)]
interface sbIMediaScan : nsISupports
{ 
  /**
   * \brief Execute a sbIMediaScanQuery object
   *
   * \param pQuery The query object to execute
   * \sa scanDirectory
   */
  void submitQuery(in sbIMediaScanQuery pQuery);
  
  /**
   * \brief Execute a scan directly to a sbIMediaScanCallback instance
   *
   * \param strDirectory The directory to scan
   * \param bRecurse Whether or not to recurse
   * \param pCallback The callback used to process the scan
   * \sa submitQuery
   */
  PRInt32 scanDirectory(in AString strDirectory, 
    in PRBool bRecurse, 
    in sbIMediaScanCallback pCallback);
};
