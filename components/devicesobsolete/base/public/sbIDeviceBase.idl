/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */

/**
 * \file sbIDeviceBase.idl
 *
 * \brief The IDL for sbIDeviceBase.
 */

#include "nsISupports.idl"

/**
 * \interface sbIDeviceBaseCallback
 *
 * \brief <TODO:Brief>.
 * 
 * <TODO:Detail>.
 *
 */
[scriptable, uuid(d38c86bc-67da-442b-95ed-fdc1d21a6594)]
interface sbIDeviceBaseCallback : nsISupports
{
  /**
   * \brief <TODO:Brief>.
   *
   * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] A string that describes the device.
   */
  void onDeviceConnect(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
   * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] A string that describes the device.
   */
  void onDeviceDisconnect(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
   * <TODO:Detail>.
   *
   * \param aSourceURL [in AString] <TODO>.
   * \param aDestinationURL [in AString] <TODO>.
   */
  void onTransferStart(in AString aSourceURL,
                       in AString aDestinationURL);

  /**
   * \brief <TODO:Brief>.
   *
   * <TODO:Detail>.
   *
   * \param aSourceURL [in AString] <TODO>.
   * \param aDestinationURL [in AString] <TODO>.
   * \param aStatus [in PRInt32] <TODO>.
   */
  void onTransferComplete(in AString aSourceURL,
                          in AString aDestinationURL,
                          in PRInt32 aStatus);
};


// XXXben These are left here for the time being so the world doesn't break

%{ C++
// File format constants
#define kSB_DEVICE_FILE_FORMAT_UNDEFINED  -1
#define kSB_DEVICE_FILE_FORMAT_WAV        0
#define kSB_DEVICE_FILE_FORMAT_MP3        1
#define kSB_DEVICE_FILE_FORMAT_WMA        2

// Device State constants
#define kSB_DEVICE_STATE_IDLE             0
#define kSB_DEVICE_STATE_BUSY             1
#define kSB_DEVICE_STATE_DOWNLOADING      2
#define kSB_DEVICE_STATE_UPLOADING        3
#define kSB_DEVICE_STATE_DOWNLOAD_PAUSED  4
#define kSB_DEVICE_STATE_UPLOAD_PAUSED    5
#define kSB_DEVICE_STATE_DELETING         6

%}

/**
 * \interface sbIDeviceBase
 * \brief <TODO:Brief>.
 *
 * Base interface for all supported devices. The supported devices can be CD,
 * Windows Media Device, iPod, etc., and even a download device for downloading
 * and uploading files.
 *
 * All devices implement this base interface to perform the basic operations
 * such as enumerating tracks (media files) and perform supported I/O
 * operations.
 *
 * In addition, a device class instance, not to be confused with a device
 * instance, can provide extended information about a device, for example
 * recording speed for a CD drive.
 *
 * "Device Category" is used in identifying device class instances (using
 * sbIDeviceManager) and "Device String" is for identifying a device. For
 * instance "Songbird CD Device" is the Device Category and "D:\" is the Device
 * String.
 */
[scriptable, uuid(ba25e1d1-bb6d-43db-b2f1-f5d3d1a41792)]
interface sbIDeviceBase : nsISupports
{
  /**
   * File format constants
   *
   * XXXben We have an explicit -1 here but later we have PRUint32 as a param
   *        for get/set Upload and Download FileType. Also, should these be
   *        renamed to FILE_TYPE_XXX or should we change the other funcs to use
   *        FileFormat?
   */
  const PRUint32 FILE_FORMAT_UNDEFINED = 9999;
  const PRUint32 FILE_FORMAT_WAV       = 0;
  const PRUint32 FILE_FORMAT_MP3       = 1;
  const PRUint32 FILE_FORMAT_WMA       = 2;

  /**
   * Device State constants
   *
   * Generally speaking I/O commands can be issued to a device if device state
   * is STATE_IDLE for the device. But if STATE_DOWNLOADING then it can be
   * asked to transfer more tracks, and the same applies to STATE_UPLOADING and
   * STATE_DELETING. STATE_TRANSFERRING_PAUSED indicates a paused transfer.
   *
   * XXXben STATE_TRANSFERRING_PAUSED no longer exists
   */
  const PRUint32 STATE_IDLE            = 0;
  const PRUint32 STATE_BUSY            = 1;
  const PRUint32 STATE_DOWNLOADING     = 2;
  const PRUint32 STATE_UPLOADING       = 3;
  const PRUint32 STATE_DOWNLOAD_PAUSED = 4;
  const PRUint32 STATE_UPLOAD_PAUSED   = 5;
  const PRUint32 STATE_DELETING        = 6;

  /**
   * \brief <TODO:Brief>.
   *
   * <TODO:Detail>.
   */
	attribute AString name;

  /**
   * \brief <TODO:Brief>.
   *
   * <TODO:Detail>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool initialize();

  /**
   * \brief <TODO:Brief>.
   *
   * <TODO:Detail>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool finalize();

  /**
   * \brief <TODO:Brief>.
   *
   * <TODO:Detail>.
   *
   * \param aCallback [in sbIDeviceBaseCallback] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool addCallback(in sbIDeviceBaseCallback aCallback);

  /**
   * \brief <TODO:Brief>.
   *
   * <TODO:Detail>.
   *
   * \param aCallback [in sbIDeviceBaseCallback] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool removeCallback(in sbIDeviceBaseCallback aCallback);

  /**
   * \brief <TODO:Brief>.
   *
   * Device category name for this class of devices
   *
   * \return [AString] <TODO>.
   */
	readonly attribute AString deviceCategory;

  /**
   * \brief <TODO:Brief>.
   *
	 * Device identifying string for a device at index
   *
   * \param aIndex [in PRUint32] <TODO>.
   *
   * \return [AString] <TODO>.
   */
	AString getDeviceStringByIndex(in PRUint32 aIndex);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \return [PRUint32] <TODO>.
   */
	readonly attribute PRUint32 deviceCount;

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRUint32] <TODO>.
   */
	PRUint32 getDestinationCount(in AString aDeviceString); 

  /**
   * \brief <TODO:Brief>.
   *
	 * To get the database context for a device
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [AString] <TODO>.
   */
	AString getContext(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRUint32] <TODO>.
   */
  PRUint32 getDeviceState(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
   * If calling downloadTable() or uploadTable() then makeTransferTable() can
   * be called to create a transfer table. Or autoDownloadTable() and
   * autoUploadTable() can be called to create transfer table and begin
   * transfer right away.
   *
   * \param aDeviceString [in AString] <TODO>.
   * \param aContextInput [in AString] <TODO>.
   * \param aTableName [in AString] <TODO>.
   * \param aFilterColumn [in AString] <TODO>.
   * \param aFilterCount [in PRUint32] <TODO>.
   * \param aFilterValues [in wstring[]] <TODO>.
   * \param aSourcePath [in AString] <TODO>.
   * \param aDestPath [in AString] <TODO>.
   * \param aDownloading [in PRBool] <TODO>.
   * \param aTransferTable [out AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
	PRBool makeTransferTable(in AString aDeviceString,
                           in AString aContextInput,
                           in AString aTableName,
                           in AString aFilterColumn,
                           in PRUint32 aFilterCount,
                           [array, size_is(aFilterCount)] in wstring aFilterValues,
                           in AString aSourcePath,
                           in AString aDestPath,
                           in PRBool aDownloading,
                           out AString aTransferTable);
  
  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   * \param aTableName [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool downloadTable(in AString aDeviceString,
                       in AString aTableName);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   * \param aTableName [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool uploadTable(in AString aDeviceString,
                     in AString aTableName);
	
  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   * \param aContextInput [in AString] <TODO>.
   * \param aTableName [in AString] <TODO>.
   * \param aFilterColumn [in AString] <TODO>.
   * \param aFilterCount [in PRUint32] <TODO>.
   * \param aFilterValues [in wstring[]] <TODO>.
   * \param aSourcePath [in AString] <TODO>.
   * \param aDestPath [in AString] <TODO>.
   * \param aTransferTable [out AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool autoDownloadTable(in AString aDeviceString,
                           in AString aContextInput,
                           in AString aTableName,
                           in AString aFilterColumn,
                           in PRUint32 aFilterCount,
                           [array, size_is(aFilterCount)] in wstring aFilterValues,
                           in AString aSourcePath,
                           in AString aDestPath,
                           out AString aTransferTable);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   * \param aContextInput [in AString] <TODO>.
   * \param aTableName [in AString] <TODO>.
   * \param aFilterColumn [in AString] <TODO>.
   * \param aFilterCount [in PRUint32] <TODO>.
   * \param aFilterValues [in wstring[]] <TODO>.
   * \param aSourcePath [in AString] <TODO>.
   * \param aDestPath [in AString] <TODO>.
   * \param aTransferTable [out AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool autoUploadTable(in AString aDeviceString,
                         in AString aContextInput,
                         in AString aTableName,
                         in AString aFilterColumn,
                         in PRUint32 aFilterCount,
                         [array, size_is(aFilterCount)] in wstring aFilterValues,
                         in AString aSourcePath,
                         in AString aDestPath,
                         out AString aTransferTable);
	
  // XXXben seems like we should be able to turn these all into attributes if
  //        we can get rid of the parameter...

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [AString] <TODO>.
   */
  AString getDownloadTable(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [AString] <TODO>.
   */
  AString getUploadTable(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRUint32] <TODO>.
   */
  PRUint32 getDownloadFileType(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   * \param aFileType [in PRUint32] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool setDownloadFileType(in AString aDeviceString,
                             in PRUint32 aFileType);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRUint32] <TODO>.
   */
  PRUint32 getUploadFileType(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   * \param aFileType [in PRUint32] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool setUploadFileType(in AString aDeviceString,
                           in PRUint32 aFileType);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRUint32] <TODO>.
   */
  PRUint32 getUsedSpace(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRUint32] <TODO>.
   */
	PRUint32 getAvailableSpace(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
   * Get all tracks
   *
   * \param aDeviceString [in AString] <TODO>.
   * \param aDBContext [out AString] <TODO>.
   * \param aTableName [out AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool getTrackTable(in AString aDeviceString,
                       out AString aDBContext,
                       out AString aTableName);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   * \param aIndex [in PRUint32] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool removeTranferTracks(in AString aDeviceString,
                             in PRUint32 aIndex);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
	PRBool abortTransfer(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool suspendTransfer(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool resumeTransfer(in AString aDeviceString);

  // XXXben Again possible to become attributes?

  /**
   * \brief <TODO:Brief>.
   *
	 * Download is to copy a track from the device to the host
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
	PRBool isDownloadSupported(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
   * Upload is to copy a track from host to the device
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
	PRBool isUploadSupported(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
	PRBool isTransfering(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
   * This could be the codecs installed on the device
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRUint32] <TODO>.
   */
	PRUint32 getSupportedFormats(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
	PRBool isDeleteSupported(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   * \param aDBContext [in AString] <TODO>.
   * \param aTableName [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
	PRBool deleteTable(in AString aDeviceString,
                     in AString aDBContext,
                     in AString aTableName);
	
  /**
   * \brief <TODO:Brief>.
   *
	 * This method could be used for updating tracks on a device
	 * or applying CDDB match for a CD.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
	PRBool isUpdateSupported(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   * \param aTableName [in AString] <TODO>.
   *
   * \return [PRBool] <TODO>.
   */
  PRBool updateTable(in AString aDeviceString,
                     in AString aTableName);
	
  /**
   * \brief <TODO:Brief>.
   *
	 * <TODO:Detail>.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRBool] PR_FALSE if eject is not supported.
   */
	PRBool isEjectSupported(in AString aDeviceString);

  /**
   * \brief <TODO:Brief>.
   *
	 * This method could be used for updating tracks on a device
	 * or applying CDDB match for a CD.
   *
   * \param aDeviceString [in AString] <TODO>.
   *
   * \return [PRBool] PR_FALSE if eject is not supported.
   */
  PRBool ejectDevice(in AString aDeviceString);
};
