/**
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL aPRInt32 with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */

/**
 * \file sbIPlaylistPlayback.js
 * \brief Contains the interface definition for sbIPlaylistPlayback
 * Contains the definition of the sbIPlaylistPlayback interface. This interface
 *   contains methods that provide the ability to play media. Interaction with
 *   the various playback cores happens through this interace.
 * \sa sbICoreWrapper.idl sbPlaylistPlayback.js
 */

#include "nsISupports.idl"
#include "nsIObserver.idl"
#include "nsIStringEnumerator.idl"

interface sbIPlaylist;
interface sbICoreWrapper;
interface sbIMediaListView;

/**
 * \interface sbIPlaylistPlayback
 * \brief Defines standard media player playback functionality.
 * This interface defines the interface for managing playback cores (adding
 *   selecting and removing)  and for controlling the playback of media in
 *   the cores (play, stop, pause, etc). Objects wishing to control playback
 *   should get an instance of this class via Components.Classes() and call
 *   these methods on that object.
 *
 * \sa sbICoreWrapper sbIPlaylist
 * An interface that describes the PlaylistPlayback Service
 */
[scriptable, uuid(3bc03c4c-7432-429d-96dd-7aad81a7fcdf)]
interface sbIPlaylistPlayback : nsIObserver
{
  // --------------------------------------------------------------------------
  // Constants for repeat state - this must match the implementation's
  // --------------------------------------------------------------------------

  /** \brief No repeat.
   */
  const short REPEAT_MODE_OFF = 0;

  /** \brief Repeat the current track (again and again and... ).
   */
  const short REPEAT_MODE_ONE = 1;

  /** \brief Play through all tracks and then do it again.
   */
  const short REPEAT_MODE_ALL = 2;


  // --------------------------------------------------------------------------
  // Attributes reflecting state of the playback core:
  // --------------------------------------------------------------------------

  /**
   * \brief The current core responsible for playback.
   * This object is the wrapper around the actual playback engine. All calls to
   *   the playback engine go through this wrapper. This may be only one of
   *   several available playback cores, but it is the current core controlling
   *   playback.
   */
  attribute sbICoreWrapper core;

  /**
   * \brief The volume.
   * The volume as reported by the core, or set upon the core.
   */
  attribute short volume;

  /**
   * \brief The mute state.
   * The mute state as reported by the core, or set upon the core.
   */
  attribute boolean mute;

  /**
   * \brief The position within the current track.
   * The number of milliseconds from the start of the current track as reported
   *   by or set upon the core.
   */
  attribute PRInt64 position;

  /**
   * /brief The length of the current track.
   * Reported by the core.
   */
  readonly attribute PRInt64 length;

  /**
   * /brief The pause state of the core.
   * If paused, playback will continue from the current position.
   * \sa playing
   */
  readonly attribute boolean paused;

  /**
   * \brief The playing state of the core.
   * Seperate from pause state. A paused track is playing, a stopped track
   *   is not playing AND not paused. A
   * \sa paused 
   */
  readonly attribute boolean playing;


  // --------------------------------------------------------------------------
  // Attributes reflecting Songbird playback state:
  // --------------------------------------------------------------------------

  /**
   * \brief Repeat state.
   * This has 3 possible states the are reflected in the constants
   * \sa  REPEAT_MODE_NONE
   * \sa  REPEAT_MODE_ALL
   * \sa  REPEAT_MODE_ONE
   */
  attribute short repeat;

  /**
   *\brief Shuffle state.
   */
  attribute boolean shuffle;

  /**
   * \brief Number of items in the current playlist.
   * As reported by the playlistsource.
   */
  readonly attribute PRInt32 itemCount;

  /**
   * \brief The GUID for the current track in the playback core.
   */
  readonly attribute AString currentGUID;

  /**
   * \brief The URL for the current track in the playback core.
   */
  readonly attribute AString currentURL;

  /**
   * \brief Has playback started.
   * This is mainly used internally. This does not check the state of the player.
   *
   * \TODO Does this really need to be exposed through an interface?
   */
  readonly attribute boolean started;


  // --------------------------------------------------------------------------
  // Methods for Mutli-core manipulation
  // --------------------------------------------------------------------------

  /**
   * \brief Add a playback core.
   * Add a playback core to the collection of cores available for media
   *   playback. If the core already exists it doesn't get added again but
   *   will be selected if aSelect is true.
   *
   * \param aCore - The Core wrapper that interfaces with the core implementation
   * \param aSelect - A boolean to indicate if the core should be selected as
   *            the current playback core.
   * \return void
   */
  void addCore(in sbICoreWrapper aCore, in boolean aSelect);

  /**
   * \brief Take a core out of the collection of available playback cores.
   * 
   * \param aCore - the core to remove
   * \return void
   */
  void removeCore(in sbICoreWrapper aCore);

  /**
   * \brief Select the core passed in as the current core.
   * If the core passed in doesn't already exist in the collection it gets
   *   added first. Then it is selected as the current playback core.
   * 
   * \param aCore - the core to add.
   * \return void
   */
  void selectCore(in sbICoreWrapper aCore);


  // --------------------------------------------------------------------------
  // "Standard" player controls
  // --------------------------------------------------------------------------

  /**
   * \brief Begin playback.
   * If previously paused playback will start at the same position. If stopped
   *   playback will begin at the beginning of the track. Paused playback will
   *   start from the same point.
   *
   * \throw NS_ERROR_NOT_INITIALIZED if no core has been set.
   * \return true
   */
  boolean play();

  /**
   * \brief Halt playback
   * This maintains the position in the track and halts the playback.
   *
   * \throw NS_ERROR_NOT_INITIALIZED if no core has been set.
   * \return true
   */
  boolean pause();

  /**
   * \brief Halt playback
   * Stops the playback of the current track. Restarting the playback after
   *  this call casuses it to start from the beginning of the track.
   * 
   * \throw NS_ERROR_NOT_INITIALIZED if no core has been set.
   * \return true
   */
  boolean stop();

  /**
   * \brief Advance playback to the next track
   *
   * \throw NS_ERROR_NOT_INITIALIZED if no core has been set.
   * \return the index of the currently playing track
   */
  PRInt32 next();

  /**
   * \brief Set playback to the track before the current one in play order
   *
   * \throw NS_ERROR_NOT_INITIALIZED if no core has been set.
   * \return the index of the currently playing track
   */
  PRInt32 previous();

  /**
   * \brief Get the index of the current track.
   *
   * \throw NS_ERROR_NOT_INITIALIZED if no core has been set.
   * \return the index of the currently playing track
   */
  PRInt32 current();

  /**
   * \brief Make the playback take the full screen.
   * This only makes sense for video playback.
   *
   * \throw NS_ERROR_NOT_INITIALIZED if no core has been set.
   * \return true
   */
  void goFullscreen();


  // --------------------------------------------------------------------------
  // Various ways of passing in content to play
  // --------------------------------------------------------------------------

  /**
   * \brief Play a particular track from a source.
   *
   * \param aSourceRef - A valid table reference in the library
   * \param aIndex - The index for the row corresponding to the track to play.
   * \throw NS_ERROR_INVALID_ARG if aSourceRef or aIndex is null or if aIndex
   *        is negative.
   * \throw NS_ERROR_NOT_INITIALIZED if the core has not been set.
   * \return true if playback is successful
   * \return false if playback is not successful
   */
  boolean playRef(in AString aSourceRef, in PRInt32 aIndex);

  /**
   * \brief Play a particular track from a source.
   *
   * \param aSourceRef - A valid table reference in the libary
   * \param aRowID - The ID for the row corresponding to the track to play.
   * \throw NS_ERROR_INVALID_ARG if aSourceRef or aRowID is null or if aRowID
   *        is negative.
   * \throw NS_ERROR_NOT_INITIALIZED if the core has not been set.
   * \return true if playback is successful
   * \return false if playback is not successful
   */
  boolean playRefByID(in AString aSourceRef, in PRInt32 aRowID);

  /**
   * \brief Play a particular track from a source.
   *
   * \param aSourceRef - A valid table reference in the library
   * \param aMediaUUID - the UUID for the track to play
   * \throw NS_ERROR_INVALID_ARG if aSourceRef or aMediaUUID is null
   * \throw NS_ERROR_NOT_INITIALIZED if the core has not been set.
   * \return true if playback is successful
   * \return false if playback is not successful
   */
  boolean playRefByUUID(in AString aSourceRef, in AString aMediaUUID);

  /**
   * \brief Play a particular track from a source.
   *
   * \param aSourceRef - A valid table reference in the library
   * \param aURL - the url of the track to play
   * \throw NS_ERROR_INVALID_ARG if aSourceRef or aURL is empty
   * \throw NS_ERROR_NOT_INITIALIZED if the core has not been set.
   * \return true if playback is successful
   * \return false if playback is not successful
   */
  boolean playRefByURL(in AString aSourceRef, in AString aURL);

  /**
   * \brief Play a table, starting at the index provided
   *
   * \param aDatabaseID - An identifier to a database
   * \param aTable - A table in the database referenced by the id
   * \param aIndex - The index at which to start playback.
   * \throw NS_ERROR_INVALID_ARG if aDatabaseID or aTable is empty or if aURL
   *        isn't contained in the table.
   * \throw NS_ERROR_NOT_INITIALIZED if the core has not been set.
   * \return true if playback is successful
   * \return false if playback is not successful
   */
  boolean playTable(in AString aDatabaseID, in AString aTable, in PRInt32 aIndex);

  /**
   * \brief Play a table, starting at the url provided.
   *
   * \param aDatabaseID - An identifier to a database
   * \param aTable - A table in the database referenced by the id
   * \param aURL - The URL of the track within to the table to start playing
   * \throw NS_ERROR_INVALID_ARG if aDatabaseID or aTable is empty or if aURL
   *        isn't contained in the table.
   * \throw NS_ERROR_NOT_INITIALIZED if the core has not been set.
   * \return true if playback is successful
   * \return false if playback is not successful
   */
  boolean playTableByURL(in AString aDatabaseID, in AString aTable, in AString aURL);

  /**
   * \brief Play a table, starting at the ID provided.
   *
   * \param aDatabaseID - An identifier to a database
   * \param aTable - A table in the database referenced by the id
   * \param aRowID - The ID of the row at which to start playback.
   * \throw NS_ERROR_INVALID_ARG if aDatabaseID or aTable is empty or if aRowID
   *        isn't a valid row.
   * \throw NS_ERROR_NOT_INITIALIZED if the core has not been set.
   * \return true if playback is successful
   * \return false if playback is not successful
   */
  boolean playTableByID(in AString aDatabaseID, in AString aTable, in PRInt32 aRowID);

  /**
   * \brief Play a table, starting at the UUID provided
   *
   * \param aDatabaseID - An identifier to a database
   * \param aTable - A table in the database referenced by the id
   * \param aMediaUUID - The UUID of the row at which to start playback.
   * \throw NS_ERROR_INVALID_ARG if aDatabaseID or aTable is empty or if 
   *        aMediaUUID isn't a valid row.
   * \throw NS_ERROR_NOT_INITIALIZED if the core has not been set.
   * \return true if playback is successful
   * \return false if playback is not successful
   */
  boolean playTableByUUID(in AString aDatabaseID, in AString aTable, in AString aMediaUUID);

  /**
   * \brief Play an item in a playlist
   *
   * \param aPlaylist - a valid playlist to play from.
   * \param aIndex - the index of the track to play
   * \throw NS_ERROR_INVALID_ARG if the playlist or index is null or if the
   *        playlist does not have ref.
   * \throw NS_ERROR_NOT_INITIALIZED if the core has not been set.
   * \return
   */
  boolean playObject(in sbIPlaylist aPlaylist, in PRInt32 aIndex);

  /**
   * \brief Play a piece of media directly via URL
   *
   * \param aURL - the URL of the media to play.
   * \throw NS_ERROR_NOT_INITIALIZED if the core has not been set.
   * \return true if playback is successfull
   * \return false if playback was not successful
   */
  boolean playURL(in AString aURL);

  /**
   * \brief Add the track to the library and play it.
   *
   * \param aURL - the URL to the media
   * \return true if import and playback was successful
   * \return false if import or playback was not successful
   */
  boolean playAndImportURL(in AString aURL);

  boolean playView(in sbIMediaListView aView, in PRInt32 aIndex);

  /**
   * \brief Adds a piece of media to the library.
   *
   * \param aURL - the URL of the media to add.
   * \return the row of the media in the library.
   */
  PRInt32 importURL(in AString aURL);


  // --------------------------------------------------------------------------
  // Metadata methods
  // --------------------------------------------------------------------------
 
  /**
   * \brief Return metadata metadata.
   * Return the number of fields supported and their identifiers
   * \todo - implement getMetadataFields, currently sets out params to 0 and ""
   * 
   * \param aFieldCount - the number of metadata fields supported
   * \param aMetaFields - An array of metadata identifiers.
   * \throw NS_ERROR_NOT_INITIALIZED if the core has not been set.
   * \return void
   */
  void getMetadataFields(out PRUint32 aFieldCount,
                         [array, size_is(aFieldCount), retval] out wstring aMetaFields);
 
  /**
   * \brief Give the value of the metadata field specified
   * \todo - implement getCurrentValue - currently returns ""
   * 
   * \param aField - the metadata for which we return the value
   * \return the value of the metadata
   */
  AString getCurrentValue(in AString aField);
 
  /**
   * \brief Set the value of the metadata specified
   * \todo - implement setCurrentValue - current does nothing.
   * 
   * \param aField - the metadata for which to set the data
   * \param aValue - the value to set the metadata to.
   * \return void
   */
  void setCurrentValue(in AString aField, in AString aValue);
 
  /**
   * \brief Get the values of multiple metadata fields.
   * \todo implement getCurrentValues - currently sets out paramst to 0 and ""
   * 
   * \param aFieldCount - the number of metadata fields to retrieve
   * \param aMetaFields - the identifiers for the metadata fields
   * \param aValueCount - the number of metadata values returned
   * \param aMetaValues - The values of the metadata requested.
   * \return void
   */
  void getCurrentValues(in PRUint32 aFieldCount,
                        [array, size_is(aFieldCount)] in wstring aMetaFields,
                        out PRUint32 aValueCount,
                        [array, size_is(aValueCount), retval] out wstring aMetaValues);
 
  /**
   * \brief Set the values of multiple metadata fields.
   * \todo implement setCurrentValues - currently does nothing.
   * 
   * \param aFieldCount - the number of metadata fields to set
   * \param aMetaFields - the identifiers for the metadata fields
   * \param aValueCount - the number of metadata values
   * \param aMetaValues - The values of the metadata to set.
   * \throw
   * \return
   */
  void setCurrentValues(in PRUint32 aFieldCount,
                        [array, size_is(aFieldCount)] in wstring aMetaFields, 
                        in PRUint32 aValueCount,
                        [array, size_is(aValueCount)] in wstring aMetaValues);


  // --------------------------------------------------------------------------
  // URL checking
  // --------------------------------------------------------------------------
 
  /**
   * \brief Check to see if an url points to media content
   * This checks for a number of known file extensions and prefixes to see
   *   if the URL contains them and is therefore media.
   * 
   * \param aURL - the URL to check
   * \return true if the URL points to media content
   * \return false if the URL does not point to media content
   */
  boolean isMediaURL(in AString aURL);
 
  /**
   * \brief Check to see if an url points to video content
   * This checks for a number of known file extensions to see
   *   if the URL contains them and is therefore video.
   * 
   * \param aURL - the URL to check
   * \return true if the URL points to video content
   * \return false if the URL does not point to video content
   */
  boolean isVideoURL(in AString aURL);
 
  /**
   * \brief Check to see if an url points to a playlist
   * This checks for a number of known file extensions to see
   *   if the URL contains them and is therefore a playlist.
   * 
   * \param aURL - the URL to check
   * \return true if the URL points to a playlist
   * \return false if the URL does not point a playlist
   */
  boolean isPlaylistURL(in AString aURL);

  /**
   * \brief Return an enumeration of the file extensions that are supported
   *        for playback
   *
   * \return an nsIStringEnumerator containting the list of extensions
   */
  nsIStringEnumerator getSupportedFileExtensions();

  // --------------------------------------------------------------------------
  // String twiddling
  // --------------------------------------------------------------------------
 
  /**
   * \brief Removes the hours from the string passed in.
   * 
   * \param aTimeString - a string in the format HH:MM:SS
   * \return - The string with the HH:
   */
  AString stripHoursFromTimeString(in AString aTimeString);
 
  /**
   * \brief Convert an integer into a time duration
   * 
   * \param aSeconds - an integer representing the number of seconds
   * \return A time string in the format HH:MM:SS
   * \return "Error" if hours is greater than 50
   */
  AString emitSecondsToTimeString(in AString aSeconds);
 
  /**
   * \brief Un-Escape a URL and find the leaf name
   * 
   * \param aURL - the URL to convert
   * \return The URL passed in if it does not decode properly
   * \return The text after the last '\' or '//' in the URL
   */
  AString convertURLToDisplayName(in AString aURL);
 
  /**
   * \brief Unescape a URL and find the "basename"
   * 
   * \param aURL - the URL to convert
   * \return The URL passed in if it does not decode properly
   * \return The text before the last '\' or '//' in the URL
   */
  AString convertURLToFolder(in AString aURL);

};

