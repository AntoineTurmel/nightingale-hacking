/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */

/**
* \file sbIPlaylistsource.idl
* \brief The internal RDF Data Source that sends playlist data to the UI.
* \sa playlist.xml
*/
#include "nsISupports.idl"
#include "nsIRDFDataSource.idl"

interface nsIDOMNode;
interface nsIDOMEvent;
interface sbIDatabaseResult;

/**
* \interface sbIPlaylistCommands sbIPlaylistsource.h
* \brief An interface that represents the set of command buttons and context menu items available on a displayed playlist.
*
* This interface is meant to be implemented by user code.
*
* Implementors that create their own specific database libraries and playlists
* (eg: sbIDeviceBase) may also specify a commands object to be shown when the
* tables are displayed in a <playlist> element.  This object's purpose is to
* return abstract information that can be used by the playlist element to
* autogenerate its xul button and menuitm elements.
*
* These objects ought to be created in javascript.  When a new playlist is
* created, it will query sbIPlaylistsource for a commands object, and the
* playlist source will call duplicate() on the object it has stored and
* return the newly duplicated object.
*
* The duplicate() method should be implemented like so:
*
* \code
duplicate: function() {
  var obj = {};
  for ( var i in this )
    obj[ i ] = this[ i ];
  return obj;
},
* \endcode
* 
* \sa playlist.xml, playlist_test.xul
*/
[scriptable, uuid(7a630e7f-ad12-4bee-ae24-aa9a491c4807)]
interface sbIPlaylistCommands : nsISupports 
{
  /**
  * \brief Be informed when a set of commands are attached to a playlist element.
  *
  * When a playlist element is about to use an sbIPlaylistCommands instance,
  * after it has been duplicated, the element will pass itself as the param
  * to this method.  The implementor may save the playlist object for later
  * reference and use.
  *
  * \param node The playlist object
  */
  void setMediaList( in nsIDOMNode aNode );

  /**
  * \brief Return the number of command elements to be displayed.
  *
  * The implementor should return the number of commands to be created
  *
  * The other functions will be called in turn with the index value that
  * represents each specific command element
  *
  * \param submenu The submenu for which the data is being requested
  * \param aHost The type of object hosting the command
  * \return The number of commands to be created
  */
  PRInt32 getNumCommands( in AString aSubMenu, in AString aHost );

  /**
  * \brief Return the type of the requested command element index
  *
  * Each command id has a type, these can be 'action', 'separator', 
  * 'value', and 'submenu'.
  *
  * \param submenu The submenu for which the data is being requested
  * \param index The index of the element for which the data is being requested
  * \param aHost The type of object hosting the command
  * \return The string for the command id
  */
  AString getCommandType( in AString aSubMenu, in PRInt32 aIndex, in AString aHost );

  /**
  * \brief Return the id string for the requested command element index
  *
  * Each command id should be unique within this commands object.  The
  * visual style of the command can be set in the CSS.
  *
  * Some id strings are parsed to create different objects:
  *
  * "*separator*" - Create a menuseparator or an empty box
  *
  * \param submenu The submenu for which the data is being requested
  * \param index The index of the element for which the data is being requested
  * \param aHost The type of object hosting the command
  * \return The string for the command id
  */
  AString getCommandId( in AString aSubMenu, in PRInt32 aIndex, in AString aHost );

  /**
  * \brief Return the human readable text for the requested command element index
  *
  * If the string begins with an "&" character, the remaining portion of the
  * string will be used as an index into the current localization's properties
  * file.
  *
  * \param submenu The submenu for which the data is being requested
  * \param index The index of the element for which the data is being requested
  * \param aHost The type of object hosting the command
  * \return The string for the displayed text
  */
  AString getCommandText( in AString aSubMenu, in PRInt32 aIndex, in AString aHost );

  /**
  * \brief Return the flex value for the requested command element index
  *
  * For instance, you can make your "*separator*" element have a flex of 1 and
  * then right-justify all the command buttons after it.  By default, command
  * buttons will adjust their width to the width of their human readable text.
  *
  * \param submenu The submenu for which the data is being requested
  * \param index The index of the element for which the data is being requested
  * \param aHost The type of object hosting the command
  * \return The value for the flex
  */
  PRInt32 getCommandFlex( in AString aSubMenu, in PRInt32 aIndex, in AString aHost );

  /**
  * \brief Return the human readable text for the requested command element's tooltip
  *
  * If the string begins with an "&" character, the remaining portion of the
  * string will be used as an index into the current localization's properties
  * file.
  *
  * \param submenu The submenu for which the data is being requested
  * \todo The tooltip functionality is disabled because mozilla will crash if you delete an element currently displaying a tooltip.
  * \param index The index of the element for which the data is being requested
  * \param aHost The type of object hosting the command
  * \return The string for the tooltip
  */
  AString getCommandToolTipText(in AString aSubMenu, in PRInt32 aIndex, in AString aHost );

  /**
  * \brief Return the enabled state for the requested command element index
  *
  * When the selection of the playlist changes state, or the tree is rebuilt,
  * this method will be called to allow the code to enable or disable commands
  * based upon the state of the playlist.
  *
  * \param submenu The submenu for which the data is being requested
  * \param index The index of the element for which the data is being requested
  * \param aHost The type of object hosting the command
  * \return True if the command should display as enabled
  */
  PRBool getCommandEnabled(in AString aSubMenu, in PRInt32 aIndex, in AString aHost );

  /**
  * \brief Return the visible state for the requested command element index
  *
  * \param submenu The submenu for which the data is being requested
  * \param index The index of the element for which the data is being requested
  * \param aHost The type of object hosting the command
  * \return True if the command should be visible
  */
  PRBool getCommandVisible(in AString aSubMenu, in PRInt32 aIndex, in AString aHost );

  /**
  * \brief Return the value of the flag for the requested command element index
  *
  * The requested elements are always of type 'flag'

  * \param submenu The submenu for which the data is being requested
  * \param index The index of the element for which the data is being requested
  * \param aHost The type of object hosting the command
  * \return The value for the flag
  */
  PRBool getCommandFlag( in AString aSubMenu, in PRInt32 aIndex, in AString aHost );

  /**
  * \brief Return the value of the requested command element index
  *
  * The requested elements are always of type 'value'

  * \param submenu The submenu for which the data is being requested
  * \param index The index of the element for which the data is being requested
  * \param aHost The type of object hosting the command
  * \return The value for the command
  */
  AString getCommandValue( in AString aSubMenu, in PRInt32 aIndex, in AString aHost );

  /**
  * \brief Return the selected item for choice list of the requested command element index
  *
  * The requested elements are always of type 'choice'

  * \param submenu The submenu for which the data is being requested
  * \param index The index of the element for which the data is being requested
  * \param aHost The type of object hosting the command
  * \return The id of the choice item
  */
  AString getCommandChoiceItem( in AString aChoiceMenu, in AString aHost );
  
  /**
  * \brief Instantiate the custom element associated with the requested command
  *
  * \param aID The id of the custom command whose instantiation is being requested
  * \param aHost The command host type that made the request
  */
  nsIDOMNode instantiateCustomCommand( in AString aID, in AString aHost );

  /**
  * \brief Refresh the custom element associated with the requested command
  *
  * \param aID The id of the custom command element whose refreshing is being requested
  * \param aHost The command host type that made the request
  */
  void refreshCustomCommand( in nsIDOMNode aCustomCommandElement, in AString aId, in AString aHost );

  /**
  * \brief Handle the fact that a command was activated
  *
  * When the user activates the command button or menuitem, this method will
  * be called with the event generated.
  *
  * \param event The event generated by the user's action
  * \param aHost The type of object hosting the command
  */
  void onCommand( in AString id, in AString value, in AString aHost );

  /**
  * \brief Duplicate the command object
  *
  * When a command object is to be given to a playlist, the object registered
  * with sbIPlaylistsource will have this method called.  The method should be
  * implemented like this:
  *
  * \code
  duplicate: function() {
    var obj = {};
    for ( var i in this )
      obj[ i ] = this[ i ];
    return obj;
  },
  * \endcode
  *
  * It creates a new object instance and copies the methods over to it.
  *
  * \return A new copy of this object
  */
  sbIPlaylistCommands duplicate( );
};

/**
* \interface sbIPlaylistsource sbIPlaylistsource.h
* \brief The internal RDF Data Source that sends playlist data to the UI
*
* sbIPlaylistsource acts as the intermediary between the database table that
* represents a library or a playlist and the display of that info into a
* <playlist> UI element.
*
* When a playlist element is told to bind to a specific database table, the
* playlist asks sbIPlaylistsource to create a new RDF ref that can properly
* feed data to its internal xul tree (see: feedPlaylist(), executeFeed()).
* A table may be fed and made available to this interface without involving a
* playlist element by calling forceGetTargets() for that RefName.
*
* The RefName param passed to feedPlaylist() is used from then on to identify
* each specific source for further modification or information.  If you would
* like to obtain specific information about the data currently displayed in a
* playlist object, use that object's .ref property as the RefName parameter to
* these methods.
*
* sbIPlaylistsource provides methods to implement various modifications to
* the underlying SQL queries that drive the display of a playlist table.
* Filters may be specified that feed a dependent RDF source and are used by
* the <filterlist> UI element when displaying a standard libaray (see:
* setFilter(), getNumFilters(), removeFilter(), getFilter(), getFilterRef())
* and an override string may be specified to support a direct search feature
* (see: setSearchString(), getSearchString()).
*
* This interface also allows direct access to the underlying data returned
* by the database, avoiding additional queries (see: getRefRowCount(),
* getRefColumnCount(), getRefRowCellByColumn(), getRefRowByColumnValue())
* and can also return the table and guid of the query (see: getRefGUID(),
* getRefTable()).
*
* Lastly, it acts as a centralized storehouse for sbIPlaylistCommands
* implementations.  Registering a custom commands object into this interface
* will specify rules to be used to determine if those commands should be shown
* in any specific playlist element's display (see: registerPlaylistCommands(),
* getPlaylistCommands()).
* 
* \sa playlist.xml
*/
[scriptable, uuid(e49a5c32-1945-49c3-876d-08e6b44144ff)]
interface sbIPlaylistsource : nsIRDFDataSource
{
  /**
  * \brief Determine whether or not a ref value is already loaded in the system.
  *
  * \param aRefName The unique identifier for the datasource 
  * \return True, if the ref exists in the system.
  */
  PRBool refExists( in AString aRefName );


  /**
  * \brief Prepare a database table to be made available to the UI as an RDFDataSource
  *
  * This method is called with the guid and table of a playlist and a string
  * to be used as the ref="XXXXXX" param for the tree.  The string must begin
  * with "NC:" (don't look at me, that's what moz demands).
  *
  * The string passed to this method will then be used as a reference to the
  * underlying data source in all the other methods on this interface.
  *
  * The datasource is not actually published until executeFeed() is called.
  * This allows the coder to setup filters with setFilter() first.
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aContextGUID The database identifier string
  * \param aTableName The playlist table name
  */
  void feedPlaylist( in AString aRefName, in AString aContextGUID, in AString aTableName );

  /**
  * \brief [DEPRECATED]
  *
  * \param aRefName The unique identifier for the datasource 
  */
  void clearPlaylist( in AString aRefName );

  /**
  * \brief Prepare and execute the SQL queries required for a datasource to make the playlist available to the UI
  *
  * After calling feedPlaylist() and optionally calling setFilter(), call this
  * method to launch the SQL queries and present the data to whomever is
  * observing the feed.
  *
  * \param aRefName The unique identifier for the datasource 
  */
  PRInt32 executeFeed( in AString aRefName );
  
  /**
  * \brief Set a filter to act upon a datasource
  *
  * This method is used to set or modify a filter on the datasource output.
  *
  * A datasource may have a number of hierarchical column filters applied to
  * it.  These feed the filterlist elements in a library display.
  *
  * Each filter creates its own datasource to feed a filterlist element, with
  * its own unique FilterRefName (usually just the playlist RefName plus the
  * FilterColumn string).  It also must begin with "NC:" or it won't work.
  *
  * The Index parameter specifies the hierarchy of the filters.  Filters with
  * lower indices will act upon the output of ones with higher indices.  While
  * any int values may be passed as indices, the getFilter() function must be
  * called with that value to retrieve the filter.  If they are not contiguous
  * values, you cannot iterate them using getNumFilters().
  *
  * The FilterString parameter is a semicolon delimited list of values that
  * are matched via OR to the playlist itself.  A blank string is analogous
  * to the "All" selection in the filterlist element.
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aIndex The hierarchical level of the filter to be set
  * \param aFilterString A semicolon list of values to filter against 
  * \param aFilterRefName The unique identifier for the filter datasource
  * \param aFilterColumn The column name to filter against
  */
  void setFilter( in AString aRefName, in PRInt32 aIndex, in AString aFilterString, in AString aFilterRefName, in AString aFilterColumn  );
  
  /**
  * \brief Return the count of filters on a datasource
  *
  * This value can only be used for enumeration if setFilter() was properly
  * called with its indices in order from 0
  *
  * \param aRefName The unique identifier for the datasource 
  */
  PRInt32 getNumFilters( in AString aRefName );
  
  /**
  * \brief Remove a filter (entirely) from a datasource
  *
  * This method entirely removes a filter from being bound to a playlist.
  * Set aFilterString to blank ("") if you want to make the filter have no
  * current filtering value.
  *
  * This value can only be used for enumeration if setFilter() was properly
  * called with its indices in order from 0
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aIndex The index value of the filter to be referenced
  * \sa setFilter()
  */
  void removeFilter( in AString aRefName, in PRInt32 aIndex);
  
  /**
  * \brief Get the filter string from a datasource's filter
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aIndex The index value of the filter to be referenced
  * \return The filter string
  */
  AString getFilter( in AString aRefName, in PRInt32 aIndex ); 

  /**
  * \brief Get the filter column from a datasource's filter
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aIndex The index value of the filter to be referenced
  * \return The filter column string
  */
  AString getFilterColumn( in AString aRefName, in PRInt32 aIndex ); 
  
  /**
  * \brief Get the ref for the filter's published RDF datasource
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aIndex The index value of the filter to be referenced
  * \return The filter's ref string
  */
  AString getFilterRef( in AString aRefName, in PRInt32 aIndex );

  /**
  * \brief Set the search string on a datasource
  *
  * The syntax of the string should be a space-delimited list search terms.
  * The results will only be items that match all the terms in displayed 
  * columns.
  *
  * Pass a blank string to clear this value.
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aSearchString The string defining the search
  * \param aResetFilters If true, setting this string will also reset the filters.
  */
  void setSearchString( in AString aRefName, in AString aSearchString, in PRBool aResetFilters );
  
  /**
  * \brief Get the search string on a datasource
  *
  * \param aRefName The unique identifier for the datasource 
  * \return The search string
  */
  AString getSearchString( in AString aRefName );

  /**
  * \brief Set the sort order on a datasource
  *
  * The sort order should be the name of an existing column.
  * The results will be sorted using that column data
  *
  * Pass a blank string to reset to a default order.
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aSearchString The column name on which to perform sorting
  */
  void setOrder( in AString aRefName, in AString aColumnName );

  /**
  * \brief Get the sort order from a datasource
  *
  * \param aRefName The unique identifier for the datasource 
  * \return The column on which sorting is being performed
  */
  AString getOrder( in AString aRefName );

  /**
  * \brief Get the database guid string on a datasource
  *
  * \param aRefName The unique identifier for the datasource 
  * \return The guid string
  */
  AString getRefGUID( in AString aRefName );
  
  /**
  * \brief Get the database table string on a datasource
  *
  * \param aRefName The unique identifier for the datasource 
  * \return The table string
  */
  AString getRefTable( in AString aRefName ); 
  
  /**
  * \brief Get the row count on a datasource
  *
  * \param aRefName The unique identifier for the datasource 
  * \return The row count
  */
  PRInt32 getRefRowCount( in AString aRefName );
  
  /**
  * \brief Get the column count on a datasource
  *
  * \param aRefName The unique identifier for the datasource 
  * \return The column count
  */
  PRInt32 getRefColumnCount( in AString aRefName );
  
  /**
  * \brief Get the value of a cell on a datasource
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aRow The row index of the cell 
  * \param aColumn The column name of the cell 
  * \return The cell value
  */
  AString getRefRowCellByColumn( in AString aRefName, in PRInt32 aRow, in AString aColumn );
  
  /**
  * \brief Calculate the row index of a cell based upon the value of a column
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aColumn The column name of the cell 
  * \param aValue The value to test against
  * \return The row index, or -1
  */
  PRInt32 getRefRowByColumnValue( in AString aRefName, in AString aColumn, in AString aValue );

  /**
  * \brief Extract the value of a column based on the cell row
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aColumn The column name on which to get the value
  * \param aRow The row for which to extract column values
  * \return The value (or undefined if the row is invalid)
  */
  AString getRefColumnValueByRow( in AString aRefName, in AString aColumn, in PRUint32 aRow);
  
  /**
  * \brief Calculate the row indices of an array of cells based upon their values for a column
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aColumn The column name on which to perform the search
  * \param aValueCount The number of values passed in the array
  * \param aValues The array of values to test against
  * \param aRowCount The number of rows returned in the array
  * \return The array of row indices (items for values that were not found are set to -1)
  */
  void getRefRowsByColumnValues( in AString aRefName, in AString aColumn, in PRUint32 aValueCount, [array, size_is(aValueCount)] in wstring aValues, out PRUint32 aRowCount, [array, size_is (aRowCount), retval] out PRUint32 aRows);
  
  /**
  * \brief Extract the values of a column based on the rows for an array of cells
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aColumn The column name on which to perform the extraction
  * \param aRowCount The number of rows passed in the array
  * \param aRows The array of rows for which to extract column values
  * \param aValueCount The number of values extracted and returned in the array
  * \return The array of values (items for rows that were invalid are set to undefined)
  */
  void getRefColumnValuesByRows( in AString aRefName, in AString aColumn, in PRUint32 aRowCount, [array, size_is(aRowCount)] in PRUint32 aRows, out PRUint32 aValueCount, [array, size_is (aValueCount), retval] out wstring aValues);
  
  /**
  * \brief Determine if a datasource is currently executing its internal queries
  *
  * \param aRefName The unique identifier for the datasource 
  * \return True, if the query is executing
  */
  PRBool isQueryExecuting( in AString aRefName );

  /**
  * \brief Wait the main thread until the ref is completely updated
  *
  * \param aRefName The unique identifier for the datasource 
  * \return The last error of the query
  */
  PRInt32 waitForQueryCompletion( in AString aRefName );

  /**
  * \brief Force the nsIRDFDataSource::GetTargets() method to be called
  *
  * At times, it may be convenient to feed a playlist, without actually
  * displaying the playlist (for instance, sbIPlaylistPlayback operates
  * upon datasources).
  *
  * This method forces the internal RDF method called by the consumers of its
  * data in RDF format, and properly constructs the internal structures
  * necessary to properly query this interface for its information.
  *
  * \todo I'm pretty sure this is broken right now
  * \param aRefName The unique identifier for the datasource 
  * \param isPermanent If True, preserve the forceGetTargets state.
  */
  void forceGetTargets( in AString aRefName, in PRBool isPermanent );

  /**
  * \brief Hint to the interface that an observer is about to be attached.
  *
  * Because the nsIRDFObserver interface does not include information about
  * the observing object, this method may be called before setting the
  * datasources and ref attributes on a xul element to scope updates to
  * the element's observer to a particular RefName string.
  *
  * If code does not call this method, the accepted observer will be told to
  * update for all changes to all refs published by this object.  That's
  * probably ugly and definitely a performance drain.
  *
  * \param aRefName The unique identifier for the datasource 
  * \param aObject The object acting as the observer 
  */
  void incomingObserver( in AString aRefName, in nsIDOMNode aObject );

  /**
  * \brief Register sbIPlaylistCommands objects to be shown for specific playlists
  *
  * The sbIPlaylistCommands interface is used to algorithmically define a set
  * of commands to be rendered arbitrarily by a playlist ui object (currently,
  * playlist.xml).
  *
  * Commands can be registered for an entire database (by setting ContextGUID
  * and leaving TableName null), or for any "type" characteristic.
  *
  * \todo Currently, new registrations overwrite previous registrations.  BAD.  Make them save and return an array.  Please don't overwrite our standard commands.
  * \param aContextGUID The guid string for the database to register against
  * \param aTableName The name of the table to register against
  * \param aPlaylistType The arbitrary type string to register against
  * \param aCommandObj The command object instance to be used for these playlists
  * \sa sbIPlaylistCommands, unregisterPlaylistCommands, playlist.xml
  */
  void registerPlaylistCommands( in AString aContextGUID, in AString aTableName, in AString aPlaylistType, in sbIPlaylistCommands aCommandObj );
  
  /**
  * \brief Unregister sbIPlaylistCommands that was previously registered
  *
  * \param aContextGUID The guid that was used to register the sbIPlaylistCommand
  * \param aTableName The name of the table that was used to register the sbIPlaylistCommand
  * \param aPlaylistType The type string that was used to register the sbIPlaylistCommand
  * \param aCommandObj The command object that was registered
  * \sa sbIPlaylistCommands, registerPlaylistCommands, playlist.xml
  */
  void unregisterPlaylistCommands( in AString aContextGUID, in AString aTableName, in AString aPlaylistType, in sbIPlaylistCommands aCommandObj );
  
  /**
  * \brief Retrieve the sbIPlaylistCommands object to be shown for a specific playlist
  *
  * Given the guid, table, and type strings, return a duplicate instance of
  * the sbIPlaylistCommands object registered.
  *
  * The "type" string has precedence over the "guid"/"table" pair.
  *
  * This method is only called by the playlist UI object, in playlist.xml
  *
  * \todo Currently, new registrations overwrite previous registrations.  BAD.  Make them save and return an array.  Please don't overwrite our standard commands.
  * \param aContextGUID The guid string for the playlist
  * \param aTableName The name of the playlist
  * \param aPlaylistType The type of the playlist
  * \return A simple enumerator of newly duplicated command object instances to be used for this playlist
  * \sa sbIPlaylistCommands, playlist.xml
  */
  nsISimpleEnumerator getPlaylistCommands( in AString aContextGUID, in AString aTableName, in AString aPlaylistType );

  /**
  * \brief Calculate the unique identifier for a playlist based on a guid and a table
  *
  * Given a guid and table, calculate the unique identifier of a playlist and return it. 
  *
  * This function should only be used for normal playlists
  *
  * \param aGuidContextGUID The guid string for the playlist
  * \param aTableName The name of the playlist
  * \return The unique identifier for the playlist
  */
  AString calculateRef( in AString aContextGUID, in AString aTableName );
};
