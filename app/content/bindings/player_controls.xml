<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright© 2006 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the “GPL”).
// 
// Software distributed under the License is distributed 
// on an “AS IS” basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE window SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">


  
  
  <!-- VOLUME CONTROL -->

  
  
  
  <binding id="volume" extends="chrome://songbird/content/bindings/progress_slider.xml#progress_slider">

   <handlers>
     <handler event="progressSliderChange" action="this.onTrackVolume();"/>
     <handler event="progressSliderRelease" action="this.onReleaseVolume();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);
 
        // observer for DataRemote 
        const on_remote_volume_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onRemoteVolumeChange(); } 
        };
        on_remote_volume_change._that = this;

        // Create and bind data remotes
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_lastVolume = SB_NewDataRemote("faceplate.volume.last", null );
        this.remote_volume.bindObserver(on_remote_volume_change, true);

        this.maxpos = 255;
        this.value = this.remote_volume.intValue;
        this.trackingVolume = false;
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.remote_volume) {
          this.remote_volume.unbind();
          this.remote_volume = null;
        }
      ]]>
    </destructor>
    
    <method name="onTrackVolume">
      <body>
        <![CDATA[
          // prevent this volume control from being updated while it is being
          //   moved (but other volume controls are updated with our motion)
          this.trackingVolume = true; 
          this.gPPS.volume = this.value;
          this.remote_volume.intValue = this.value;
          if (this.value == 0) {
            // set mute when we bring the volume to 0
            this.gPPS.mute = true;
          }
          else {
            // otherwise reset it, and record the last volume
            this.gPPS.mute = false;
          }
        ]]>
      </body>
    </method>

    <method name="onReleaseVolume">
      <body>
        <![CDATA[
          this.trackingVolume = false;
          this.gPPS.volume = this.value;
          if (this.value != 0) {
            this.remote_lastVolume.intValue = this.value;
          }
        ]]>
      </body>
    </method>

    <method name="onRemoteVolumeChange">
      <body>
        <![CDATA[
          try {
            if (this.trackingVolume) // if volume is being actively changed, wait until release
              return; 
            this.value = this.remote_volume.intValue;
          } catch (err) {
            dump("player_controls.xml - onRemoteVolumeChange - " + err + "\n");
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- MUTE CONTROL -->




  <binding id="mute">
  
   <content>
     <xul:stack xbl:inherits="class=class" >
       <xul:button sbid="mute_off" xbl:inherits="class=class,id=muteoffid" oncommand="onMute( );" tooltiptext="&tooltip.control.mute;"/>
       <xul:button sbid="mute_on"  xbl:inherits="class=class,id=muteonid" oncommand="onMute( );" tooltiptext="&tooltip.control.mute;"/>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind the data remotes
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_lastVolume = SB_NewDataRemote( "faceplate.volume.last", null );
        this.remote_mute = SB_NewDataRemote( "faceplate.mute", null );
        this.bindmuteon = SBDataBindElementAttribute( "faceplate.mute", this.mute_on, "hidden", true, true );
        this.bindmuteoff = SBDataBindElementAttribute( "faceplate.mute", this.mute_off, "hidden", true );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("player_controls.js", "mute binding destructor");
        if (this.bindmuteon) {
          this.bindmuteon.unbind();
          this.bindmuteon = null;
        }
        if (this.bindmuteoff) {
          this.bindmuteoff.unbind();
          this.bindmuteoff = null;
        }
      ]]>
    </destructor>

    <field name="mute_on">document.getAnonymousElementByAttribute(this, 'sbid', 'mute_on');</field>
    <field name="mute_off">document.getAnonymousElementByAttribute(this, 'sbid', 'mute_off');</field>

    <method name="onMute">
      <body>
        <![CDATA[
          var newmute = !this.gPPS.mute; 
          this.gPPS.mute = newmute;
          if (!newmute) {
            // restore last volume when coming back from mute state
            this.gPPS.volume = this.remote_lastVolume.intValue;
          } 
          else {
            this.gPPS.volume = 0;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  

  <!-- FORWARD BUTTON-->

  
  
  
  <binding id="forward" extends="chrome://global/content/bindings/button.xml#button-base">

   <handlers>
     <handler event="mousedown" action="this.onFwdMouseDown();"/>
     <handler event="mouseup" action="this.onFwdMouseUp();"/>
     <handler event="mouseout" action="this.onFwdMouseOut();"/>
     <handler event="mouseover" action="this.onFwdMouseOver();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
    </destructor>
    
    <method name="onFwdMouseDown">
      <body>
        <![CDATA[
          this.seen_skip = false;
          if ( this.gPPS.playing )
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOut">
      <body>
        <![CDATA[
           if (this.skip_interval) {
             clearInterval( this.skip_interval );
             this.skip_interval = null;
           }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOver">
      <body>
        <![CDATA[
           if (this.skip && !this.skip_interval ) {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
           }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseUp">
      <body>
        <![CDATA[
          this.skip = false;
          this.onFwdCommand();
        ]]>
      </body>
    </method>

    <method name="onFwdCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.gPPS.next();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          if ( _this.skip )
          {
            _this.seen_skip = true;
            _this.gPPS.position = _this.gPPS.position + 15000;
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- BACK BUTTON-->

  
  
  
  <binding id="back" extends="chrome://global/content/bindings/button.xml#button-base">

   <handlers>
     <handler event="mousedown" action="this.onBackMouseDown();"/>
     <handler event="mouseup" action="this.onBackMouseUp();"/>
     <handler event="mouseout" action="this.onBackMouseOut();"/>
     <handler event="mouseover" action="this.onBackMouseOver();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
    </destructor>
    
    <method name="onBackMouseDown">
      <body>
        <![CDATA[
          this.seen_skip = false;
          if ( this.gPPS.playing )
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onBackMouseUp">
      <body>
        <![CDATA[
          this.skip = false;
          this.onBackCommand();
        ]]>
      </body>
    </method>

    <method name="onBackMouseOut">
      <body>
        <![CDATA[
           if (this.skip_interval) {
             clearInterval( this.skip_interval );
             this.skip_interval = null;
           }
        ]]>
      </body>
    </method>

    <method name="onBackMouseOver">
      <body>
        <![CDATA[
           if (this.skip && !this.skip_interval ) {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
           }
        ]]>
      </body>
    </method>

    <method name="onBackCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.gPPS.previous();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          if ( _this.skip )
          {
            _this.seen_skip = true;
            _this.gPPS.position = _this.gPPS.position - 15000;
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- REPEAT CONTROL -->




  <binding id="repeat">
  
   <content>
     <xul:stack xbl:inherits="class=class" >
       <xul:button sbid="repeat_none" xbl:inherits="class=class,id=repid" oncommand="onRepeat( );" tooltiptext="&menu.control.repx;"/>
       <xul:button sbid="repeat_1" xbl:inherits="class=class,id=rep1id" oncommand="onRepeat( );" tooltiptext="&menu.control.rep1;"/>
       <xul:button sbid="repeat_all" xbl:inherits="class=class,id=repallid" oncommand="onRepeat( );" tooltiptext="&menu.control.repa;"/>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_repeat = SB_NewDataRemote( "playlist.repeat", null );
        this.repnonebinding = SBDataBindElementAttribute( "playlist.repeat", this.repeat_none, "hidden", true, false, "parseInt( value ) != 0" );
        this.rep1binding = SBDataBindElementAttribute( "playlist.repeat", this.repeat_1, "hidden", true, false, "parseInt( value ) != 1" );
        this.repallbinding = SBDataBindElementAttribute( "playlist.repeat", this.repeat_all, "hidden", true, false, "parseInt( value ) != 2" );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("player_controls.js", "repeat binding destructor");
        if (this.repnonebinding) {
          this.repnonebinding.unbind();
          this.repnonebinding = null;
        }
        if (this.rep1binding) {
          this.rep1binding.unbind();
          this.rep1binding = null;
        }
        if (this.repallbinding) {
          this.repallbinding.unbind();
          this.repallbinding = null;
        }
      ]]>
    </destructor>

    <field name="repeat_none">document.getAnonymousElementByAttribute(this, 'sbid', 'repeat_none');</field>
    <field name="repeat_1">document.getAnonymousElementByAttribute(this, 'sbid', 'repeat_1');</field>
    <field name="repeat_all">document.getAnonymousElementByAttribute(this, 'sbid', 'repeat_all');</field>
    
    <method name="onRepeat">
      <body>
        <![CDATA[
          // Rob decided to change the order.  Woo.
          var value = 0;
          switch ( this.remote_repeat.intValue )
          {
            case 0:
              value = 2;
              break;
            case 1:
              value = 0;
              break;
            case 2:
              value = 1;
              break;
          }
          this.remote_repeat.intValue = value;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- SHUFFLE CONTROL -->




  <binding id="shuffle">
  
   <content>
     <xul:stack xbl:inherits="class=class" >
       <xul:button sbid="shuffle_off" xbl:inherits="class=class,id=shuffleoffid" oncommand="onShuffle( );" tooltiptext="&tooltip.control.shuf_off;"/>
       <xul:button sbid="shuffle_on" xbl:inherits="class=class,id=shuffleonid" oncommand="onShuffle( );" tooltiptext="&tooltip.control.shuffle;"/>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_shuffle = SB_NewDataRemote( "playlist.shuffle", null );
        this.bindshuffleoff = SBDataBindElementAttribute( "playlist.shuffle", this.shuffle_off, "hidden", true );
        this.bindshuffleon = SBDataBindElementAttribute( "playlist.shuffle", this.shuffle_on, "hidden", true, true );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("player_controls.js", "shuffle binding destructor");
        if (this.bindshuffleoff) {
          this.bindshuffleoff.unbind()
          this.bindshuffleoff = null;
        }
        if (this.bindshuffleon) {
          this.bindshuffleon.unbind()
          this.bindshuffleon = null;
        }
      ]]>
    </destructor>

    <field name="shuffle_off">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_off');</field>
    <field name="shuffle_on">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_on');</field>
    
    <method name="onShuffle">
      <body>
        <![CDATA[
          this.remote_shuffle.boolValue = !this.remote_shuffle.boolValue;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- SEEK CONTROL -->

  
  
  
  <binding id="seekbar" extends="chrome://songbird/content/bindings/progress_slider.xml#progress_slider">

   <handlers>
     <handler event="progressSliderChange" action="this.onTrackSeekbar();"/>
     <handler event="progressSliderRelease" action="this.onReleaseSeekbar();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // observer for DataRemote 
        const on_remote_position_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onRemotePositionChange(); } 
        };
        on_remote_position_change._that = this;

        // Create and bind data remotes
        this.remote_position = SB_NewDataRemote( "metadata.position", null );
        this.remote_position.bindObserver(on_remote_position_change, true);
        this.remote_length = SBDataBindElementAttribute( "metadata.length", this, "maxpos" );
       
        this.trackingPosition = 0;
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("player_controls.js", "seekbar binding destructor");
        if (this.remote_position) {
          this.remote_position.unbind();
          this.remote_position = null;
        }
        if (this.remote_length) {
          this.remote_length.unbind();
          this.remote_length = null;
        }
      ]]>
    </destructor>
    
    <method name="onTrackSeekbar">
      <body>
        <![CDATA[
          this.trackingPosition = 1;
        ]]>
      </body>
    </method>

    <method name="onReleaseSeekbar">
      <body>
        this.gPPS.position = this.value;
        this.trackingPosition = 0;
      </body>
    </method>

    <method name="onRemotePositionChange">
      <body>
        <![CDATA[
          try {
            if (this.trackingPosition) return; // we are the control changing the position, ignore this callback
            this.value = gPPS.position;
          } catch (e) {
            alert("player_controls.xml - onRemotePositionChange - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- TOTALTIME CONTROL -->




  <binding id="totaltime">
  
   <content>
     <xul:label sbid="timelabel" xbl:inherits="id=id,class=class,align=align,crop=crop,disabled=disabled,flex=flex" onmousedown="onTotalDown();"/> 
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remote
        this.remote_showRemaining = SB_NewDataRemote( "faceplate.showremainingtime", null );
        this.bindtotaltime = SBDataBindElementAttribute( "metadata.length.str", this.label, "value" );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("player_controls.js", "totaltime binding destructor");
        if (this.bindtotaltime) {
          this.bindtotaltime.unbind();
          this.bindtotaltime = null;
        }
      ]]>
    </destructor>

    <field name="label">document.getAnonymousElementByAttribute(this, 'sbid', 'timelabel');</field>
    
    <method name="onTotalDown">
      <body>
        <![CDATA[
          var len = gPPS.length;
          if ( len > 0 )
            this.remote_showRemaining.boolValue = !this.remote_showRemaining.boolValue;
          // If you try to toggle it while it is zero, you lose the state.
          else
            this.remote_showRemaining.boolValue = false;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>




  <!-- PLAY/PAUSE CONTROL -->




  <binding id="playpause">
  
   <content>
     <xul:stack xbl:inherits="id=id,class=class" flex="1">
       <xul:button sbid="play" xbl:inherits="id=playid,class=class" oncommand="onPlay( );" tooltiptext="&tooltip.control.play;" />
       <xul:button sbid="pause" xbl:inherits="id=pauseid,class=class" oncommand="onPause( );" tooltiptext="&tooltip.control.play;" />
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_seenPlaying = SB_NewDataRemote( "faceplate.seenplaying", null );
        this.remote_playingRef =  SB_NewDataRemote( "playing.ref", null ); 
        this.remote_playlistIndex =  SB_NewDataRemote( "playlist.index", null ); 

        // Bind to the hidden attribute for each field
        this.playbinding = SBDataBindElementAttribute( "faceplate.play", this.play, "hidden", true, true );
        this.pausebinding = SBDataBindElementAttribute( "faceplate.play", this.pause, "hidden", true );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("player_controls.js", "playpause binding destructor");
        if (this.pausebinding) {
          this.pausebinding.unbind();
          this.pausebinding = null;
        }
        if (this.playbinding) {
          this.playbinding.unbind();
          this.playbinding = null;
        }
      ]]>
    </destructor>

    <field name="play">document.getAnonymousElementByAttribute(this, 'sbid', 'play');</field>
    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>
    
    <method name="onPlay">
      <body>
        <![CDATA[
          var ref = "";
          if (this.gPPS.started) {
            if (this.gPPS.paused) {
              gPPS.play();
            } else {
              // player is buffering, because the play button is visible (not started) yet pause is not set and the player is started
              // start the playlist again at the current spot
              this.gPPS.playRef( this.remote_playingRef.stringValue, this.remote_playlistIndex.intValue );
            }
          } else {
            var ref = "";
            var playlist = this.getCurrentPlaylist();
            if (playlist) {
              ref = playlist.ref;
            } 
            if (ref == "") {
              this.loadLibrary();
              this.gPPS.play(); // let gpps handle default playback.
            } else {
              this.gPPS.playRef(ref, -1);
            }
          }
        ]]>
      </body>
    </method>

    <method name="onPause">
      <body>
        <![CDATA[
          if ( this.remote_seenPlaying.boolValue ) {
            this.gPPS.pause();
          }
        ]]>
      </body>
    </method>

    <method name="loadLibrary">
      <body>
        <![CDATA[
          // optional connection
          var theServiceTree = document.getElementById( 'frame_servicetree' );
          if (theServiceTree) theServiceTree.launchServiceURL( "chrome://songbird/content/xul/main_pane.xul?library" );
        ]]>
      </body>
    </method>

    <method name="getCurrentPlaylist">
      <body>
        <![CDATA[
          var pl = document.__CURRENTPLAYLIST__;
          if (!pl) pl = document.__CURRENTWEBPLAYLIST__;
          if (!pl) return null;
          if ( pl.wrappedJSObject )
            pl = pl.wrappedJSObject;
          return pl;
        ]]>
      </body>
    </method>
    

   </implementation>
 
  </binding>





  <!-- ARTIST DISPLAY -->




  <binding id="artist" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.artist";
    </constructor>

   </implementation>
 
  </binding>




  <!-- TITLE DISPLAY -->




  <binding id="title" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.data  = "metadata.title";
        this.autotip = this.getAttribute("autotip");
        if (this.autotip) {
          // observer for DataRemote 
          const on_remote_artist_album_change = { 
            _that: null, 
            observe: function( aSubject, aTopic, aData ) { this._that.rebuildTip(); } 
          };
          on_remote_artist_album_change._that = this;

          // Create and bind data remotes
          this.remote_artist = SB_NewDataRemote( "metadata.artist", null );
          this.remote_album = SB_NewDataRemote( "metadata.album", null );
          this.remote_artist.bindObserver(on_remote_artist_album_change, true);
          this.remote_album.bindObserver(on_remote_artist_album_change, true);

          this.rebuildTip();
      }
      ]]>
    </constructor>

    <destructor>
      <![CDATA[
        if (this.remote_album) {
          this.remote_album.unbind();
          this.remote_album = null;
        }
        if (this.remote_artist) {
          this.remote_artist.unbind();
          this.remote_artist = null
        }
      ]]>
    </destructor>

    <method name="rebuildTip">
      <body>
        <![CDATA[
          try {
            var tip = "";
            if ( this.remote_artist.stringValue &&
                 this.remote_artist.stringValue.length ) {
              tip = this.remote_artist.stringValue;
            }
            if ( this.remote_album.stringValue &&
                 this.remote_album.stringValue.length ) {
              if (tip.length > 0) tip += " / ";
              tip += this.remote_album.stringValue;
            }
            this.label.setAttribute("tooltiptext", tip);
          } catch (e) {
            alert("player_controls.xml - rebuildTip - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>




  <!-- ALBUM DISPLAY -->




  <binding id="album" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.album";
    </constructor>

   </implementation>
 
  </binding>




  <!-- TIME ELAPSED DISPLAY -->




  <binding id="timeelapsed" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.position.str";
    </constructor>

   </implementation>
 
  </binding>




  <!-- GENRE DISPLAY -->




  <binding id="genre" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.genre";
    </constructor>

   </implementation>
 
  </binding>




  <!-- NUM PLAYLIST ITEMS DISPLAY -->




  <binding id="numplaylistitems" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      this.data  = "playlist.numitems";
    </constructor>

   </implementation>
 
  </binding>




  <!-- PLAYER SCANNING DISPLAY -->




  <binding id="scanning" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.data  = "backscan.status";

        // Create and bind data remote
        this.bindvisible = SBDataBindElementAttribute( "backscan.status", this.label, "hidden", true, false, "value == ''" );

        this.setAttribute("onmousedown", "SBDataSetIntValue('backscan.paused', SBDataGetIntValue('backscan.paused') == 0 );");
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("player_controls.js", "scanning binding destructor");
        if (this.bindvisible) {
          this.bindvisible.unbind();
          this.bindvisible = null;
        }
      ]]>
    </destructor>

   </implementation>
 
  </binding>

</bindings>

