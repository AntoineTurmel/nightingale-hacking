<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2008 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE bindings SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="conditions">

    <content>
      <xul:sb-multi-drawer
          sbid="drawer" 
          header="false" 
          flex="1" 
          xbl:inherits="maxvisibleitems">
        <xul:hbox
            class="smart-condition-item-box"
            align="center"
            flex="1"
            oninput="document.getBindingParent(document.getBindingParent(this)).onInput(this, event);"
            drawer-prop-map="useunits=useunits,interval=interval"
        >
          <!-- List of properties -->
          <xul:menulist 
              id="propertypopup" 
              class="smart-condition-list" 
              value="artist" 
              drawer-prop-map="value=metadata,gotuserinput1=gotuserinput1,gotuserinput2=gotuserinput2" 
              sizetopopup="none">
            <xul:menupopup class="smart-condition-popup">
            </xul:menupopup>
          </xul:menulist>
          <!-- List of operators for the selected property -->
          <xul:menulist id="operatorpopup" 
              class="smart-condition-list" 
              drawer-prop-map="value=condition" 
              sizetopopup="none">
            <xul:menupopup class="smart-condition-popup">
            </xul:menupopup>
          </xul:menulist>
          <xul:hbox flex="1">
            <xul:hbox 
                id="textconditionbox"
                drawer-prop-map-set="hidden=!textfield" 
                flex="1" 
                width="0"
                hidden="true">
              <!-- Text comparison field 1 -->
              <xul:textbox
                  id="conditiontext1"
                  sbid="conditionvalue1"
                  class="smart-condition-value dialog_textbox"
                  type="autocomplete"
                  drawer-prop-map="value=value"
                  drawer-attr-map="invalid=invalid"
                  drawer-attr-map-set="range=interval,units=useunits"
                  flex="1" 
                  width="0"
              />
              <!-- Range separator -->
              <xul:label 
                  id="textrangeseparator"
                  value="&smart.to;" 
                  hidden="true" 
                  drawer-prop-map-set="hidden=!interval"
                  class="smart_condition_rangeseparator"
              />
              <!-- Text comparison field 2 -->
              <xul:textbox
                  id="conditiontext2"
                  sbid="conditionvalue2"
                  class="smart-condition-value dialog_textbox"
                  type="autocomplete"
                  drawer-prop-map-set="hidden=!interval"
                  drawer-prop-map="value=value2"
                  drawer-attr-map="invalid=invalid2"
                  drawer-attr-map-set="units=useunits"
                  range="true"
                  hidden="true"
                  flex="1" 
                  width="0"
              />
            </xul:hbox>
            <xul:hbox 
                drawer-prop-map-set="hidden=!ratingfield" 
                hidden="true" 
                flex="1">
              <!-- Rating comparison field 1 -->
              <xul:sb-rating
                  id="conditionrating1"
                  sbid="conditionvalue1"
                  class="smart-condition-value"
                  drawer-prop-map="value=value"
                  drawer-attr-map="invalid=invalid"
                  drawer-attr-map-set="range=interval,units=useunits"
              />
              <!-- Range separator -->
              <xul:label 
                  id="ratingrangeseparator"
                  value="&smart.to;" 
                  hidden="true" 
                  drawer-prop-map-set="hidden=!interval"
                  class="smart_condition_rangeseparator"
              />
              <!-- Rating comparison field 2 -->
              <xul:sb-rating 
                  id="conditionrating2"
                  sbid="conditionvalue2"
                  class="smart-condition-value"
                  drawer-prop-map-set="hidden=!interval"
                  drawer-prop-map="value=value2"
                  drawer-attr-map="invalid=invalid2"
                  drawer-attr-map-set="units=useunits"
                  range="true"
              />
            </xul:hbox>
            <!-- List of available units -->
            <xul:menulist 
                id="unitspopup" 
                class="smart-condition-list"
                hidden="true"
                drawer-prop-map="value=unit" 
                drawer-prop-map-set="hidden=!useunits" 
                sizetopopup="none">
              <xul:menupopup class="smart-condition-popup">
              </xul:menupopup>
            </xul:menulist>
          </xul:hbox>
          <xul:button label="-" 
              class="smart-condition-minus" 
              sbtype="remove-drawer-item"/>
          <xul:button 
              label="+" class="smart-condition-plus" 
              sbtype="add-drawer-item"/>
        </xul:hbox>
      </xul:sb-multi-drawer>
    </content>

    <handlers>
      <handler event="select" action="onSelect(event);"/>
      <handler event="blur" action="onBlur(event);"/>
    </handlers>

    <implementation>

      <constructor>
      <![CDATA[
        this._refreshingUI = 0;
        // Load properties module
        if (typeof(SBProperties) == "undefined") {
          Components.utils.import("resource://app/jsmodules/sbProperties.jsm");
          if (!SBProperties)
            throw new Error("Import of sbProperties module failed");
        }
        // Load property manager
        this._pm = 
          this._Cc["@songbirdnest.com/Songbird/Properties/PropertyManager;1"]
              .getService(this._Ci.sbIPropertyManager);

        // Scan the metadata and fill the metadata popup with appropriate items
        this.fillMetadata();
      ]]>
      </constructor>
      
      <destructor>
      </destructor>

      <!-- The drawer item, which clones the smart-condition-item-box as many
           times as there are conditions -->
      <field name="drawer">
        document.getAnonymousElementByAttribute(this, "sbid", "drawer");
      </field>
      <!-- The property manager -->
      <field name="_pm">null</field>
      <!-- Convenience consts -->
      <field name="_Cc" readonly="true">Components.classes</field>
      <field name="_Ci" readonly="true">Components.interfaces</field>
      <field name="_Cr" readonly="true">Components.results</field>

      <!-- Set and get the state of all conditions. This is used by the window
           that instantiated us to mirror the sbILocalDatabaseSmartMediaList-
           Condition objects -->
      <property name="conditions">
        <getter>
          // First get the drawer item state
          var state = this.drawer.getState();
          
          // Then apply unit conversions from UI to native
          this._applyStateConversionsFromUI(state);
          
          // And return the tweaked state
          return state;
        </getter>
        <setter>
          this._refreshingUI++;
          // Read the state and determine widgets visibility
          this._updateUIStates(val);
          
          // Convert the units from native to UI
          this._applyStateConversionsToUI(val);
          
          // Set the drawer item state, objects are showing/hiding automatically
          this.drawer.setState(val);

          // Record the unit for the metadata in each condition item
          this._setMetadataMaps(val);

          this._refreshingUI--;
          
          // Validate the values
          this._doAllValidations();
        </setter>
      </property>
      <property name="isValid">
        <getter>
        <![CDATA[
          var valid = true;
          this.conditions.forEach(function(condition) {
            // conditions array will not contain the invalid2 property
            // if the second edit field is hidden, so it is safe to
            // just check if it's equal to "true" without regards to
            // the operator the condition used
            if (condition.invalid == "true" ||
                condition.invalid2 == "true")
              valid = false;
          });
          return valid;
        ]]>
        </getter>
      </property>

      <!-- Create a brand new condition, this clones smart-condition-item-box
           along with its children -->
      <method name="newCondition">
        <body>
          this.drawer.addItem();
        </body>
      </method>
      
      <!-- Create items for a menu based on a name/value array, and perform
           localization of partial entities. Note that the stringBundleUrl
           parameter is optional, the default songbird stringbundle will
           be used if none was provided. -->
      <method name="_generateMenuPopup">
        <parameter name="aParent"/>
        <parameter name="aMenuitemArray"/>
        <parameter name="stringBundleUrl"/>
        <body>
          <![CDATA[
            // Clear the current set of menuitems
            aParent.removeAllItems();
          
            // And generate a new set of menuitem children
            for ( var index = 0; index < aMenuitemArray.length; index++ ) {
              var obj = aMenuitemArray[ index ];
              var name;
              
              // We accept either {name, value} array or string array
              if ( obj.name ) {
                name = obj.name;
              } else {
                name = "" + obj;
                obj = {};
              }
              
              var stringBundle;
              if (stringBundleUrl) {
                stringBundle = this._Cc["@mozilla.org/intl/stringbundle;1"]
                  .getService(this._Ci.nsIStringBundleService)
                  .createBundle(stringBundleUrl);
              }
              // Cook out the translated value if requested
              if ( name[0] == "&" ) {
                name = SBString( name.substr( 1, name.length ), name, stringBundle );
              }
              
              // And append the menutitem to the list (and make it pretty)
              aParent.appendItem( name, ( obj.value ) ? obj.value : index )
                     .setAttribute( "class", "smart-condition-item" );              
            }
          ]]>
        </body>
      </method>
      
      <!-- Fill the metadata menulist, this happen before any item is created by
           the drawer code, so we won't have to fill it for every item, since
           each new item will have its list already filled -->
      <method name="fillMetadata">
        <body>
        <![CDATA[
          var metadata = [];

          var ids = this._pm.propertyIDs;
          
          // todo: use whitelist
          while (ids.hasMore()) {
            var info = this._pm.getPropertyInfo(ids.getNext());
            if (this._isMetadataIncluded(info.id))
              metadata.push({ name: info.displayName, value: info.id });
          }
          
          function sortEntry(a, b) {
            if (a.name < b.name) return -1;
            if (a.name > b.name) return 1;
            return 0;
          }
          
          metadata.sort(sortEntry);

          var popup = document.getAnonymousElementByAttribute(this,
                                                              "id",
                                                              "propertypopup");
          this._generateMenuPopup(popup, metadata);
        ]]>
        </body>
      </method>
      
      <!-- Dispatch menulist selection events -->
      <method name="onSelect">
        <parameter name="event"/>
        <body>
        <![CDATA[
          if (event.originalTarget.getAttribute("id") == "propertypopup")
            this.onSelectProperty(event.originalTarget);
          else if (event.originalTarget.getAttribute("id") == "operatorpopup")
            this.onSelectOperator(event.originalTarget);
          else if (event.originalTarget.getAttribute("id") == "unitspopup")
            this.onSelectUnit(event.originalTarget);
        ]]>
        </body>
      </method>

      <!-- When the user selects a new property in the list, update the UI for
           this condition with new operators, completion and unit, and then
           perform a validation -->
      <method name="onSelectProperty">
        <parameter name="propertypopup"/>
        <body>
          var oldRefreshValue = this._refreshingUI;
          try {
            this._refreshingUI++;
            var condition = this.drawer.getItem(propertypopup);
            var operatorpopup = 
              this.drawer.getItemElementByAttribute(condition, 
                                                    "id", 
                                                    "operatorpopup");
            var list = this._getOperators(propertypopup.value);
            this._generateMenuPopup(operatorpopup, list);
            this._selectDefaultOperator(condition,
                                        operatorpopup, 
                                        list, 
                                        propertypopup.value);
            this._generateUnitPopup(condition, propertypopup.value);
            var unitspopup = 
              this.drawer.getItemElementByAttribute(condition, 
                                                    "id", 
                                                    "unitspopup");
            this._refreshingUI--;
            this._updateUI(condition);
            // setAutoComplete and prefill only after the rest of the ui has been updated
            this._setAutoComplete(condition, propertypopup.value);
            this._doPrefill(condition, 
                            propertypopup, 
                            propertypopup.value, 
                            operatorpopup.value, 
                            unitspopup.hidden ? null : unitspopup.value);
            this._doValidation(this.drawer.getItem(propertypopup));
          } catch (e) {
            this._refreshingUI = oldRefreshValue;
            Components.utils.reportError(e);
          }
        </body>
      </method>
      
      <method name="_getOperators">
        <parameter name="metadata"/>
        <body>
          var info = this._pm.getPropertyInfo(metadata);
          var ops = info.operators;
          var list = [];

          while (ops.hasMoreElements()) {
            var op = ops.getNext()
                        .QueryInterface(this._Ci.sbIPropertyOperator);
            if (info.type == "boolean") {
              if (op.operator == info.OPERATOR_EQUALS) continue;
              if (op.operator == info.OPERATOR_NOTEQUALS) continue;
            }
            list.push({ name: op.operatorReadable, value: op.operator });
          }

          return list;
        </body>
      </method>
      
      <!-- Fills up the unit popup with the available options for a given
           property, and select the default one. -->
      <method name="_generateUnitPopup">
        <parameter name="condition"/>
        <parameter name="metadata"/>
        <body>
          <![CDATA[
            var unitspopup = 
              this.drawer.getItemElementByAttribute(condition, 
                                                    "id", 
                                                    "unitspopup");
            var list = [];
            var info = this._pm.getPropertyInfo(metadata);
            var converter;
            var uselong = false;
            if (info.type == "datetime") {
              // datetime has no unit conversion that makes sense, unless we
              // are using the inthelast/notinthelast operators, in which case
              // we need to use the duration unit converter
              converter = this._pm.getPropertyInfo(SBProperties.duration)
                                  .unitConverter;
              // And use the long unit format (ie. "Weeks", and not "w")
              uselong = true;
            } else {
              converter = info.unitConverter;
            }
            if (converter) {
              var units = converter.units;
              while (units.hasMoreElements()) {
                var unit = units.getNext();
                unit = unit.QueryInterface(this._Ci.sbIPropertyUnit)
                var u = {};
                u.name = uselong ? unit.name : unit.shortName;
                u.value = unit.id;
                list.push(u);
              }
            }
            if (list.length == 0) {
              // no units for this property
              return;
            }
            this._generateMenuPopup(unitspopup, 
                                    list, 
                                    converter ? converter.stringBundle : null);
            this._selectUnit(condition, unitspopup);
          ]]>
        </body>
      </method>
      
      <method name="_selectUnit">
        <parameter name="condition"/>
        <parameter name="unitspopup"/>
        <body>
          if (!unitspopup) 
            unitspopup = 
              this.drawer.getItemElementByAttribute(condition, 
                                                    "id", 
                                                    "unitspopup");
          var property = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "propertypopup");
          // retrieve saved unit
          var unit = this._getMetadataMap("units", condition, property.value);
          // if we haven't got a saved unit, use the default one
          if (!unit || unit == "") {
            unit = this._getDefaultUnit(property.value);
          }
          if (!unit || unit == "") {
            // no default ? use the first available unit
            unitspopup.selectedIndex = 0;
          } else {
            // select appropriate unit
            unitspopup.value = unit;
          }
        </body>
      </method>

      <!-- Returns the default UI unit to use for a given property -->
      <method name="_getDefaultUnit">
        <parameter name="metadata"/>
        <body>
          <![CDATA[
            var info = this._pm.getPropertyInfo(metadata);
            var def;
            // these two switches together should cover all cases where we
            // allow the units popup to show
            switch (info.type) {
              case "datetime":
                return "w";
              case "duration":
                return "min";
            }
            switch(metadata) {
              case SBProperties.contentLength:
                return "mb";
              case SBProperties.sampleRate:
                return "khz";
              case SBProperties.bitRate:
                return "kbps";
            }
            // Default unit does not apply
            return null;
          ]]>
        </body>
      </method>

      <!-- Sets autocompletion on the textbox fields if appropriate, or
           remove it otherwise -->
      <method name="_setAutoComplete">
        <parameter name="condition"/>
        <parameter name="property"/>
        <body>
        <![CDATA[
          var libraryManager =
            this._Cc["@songbirdnest.com/Songbird/library/Manager;1"]
                .getService(this._Ci.sbILibraryManager);

          var library = libraryManager.mainLibrary;
          var libraryGuid = library.guid;
          
          var textbox1 = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "conditiontext1");
          var textbox2 = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "conditiontext2");
          
          var dodistinct;

          // These are the properties we autocomplete on          
          switch (property) {
            case SBProperties.artistName:
            case SBProperties.albumName:
            case SBProperties.albumArtistName:
            case SBProperties.trackName:
            case SBProperties.composerName:
            case SBProperties.genre:
            case SBProperties.year:
            case SBProperties.bpm:
            case SBProperties.bitRate:
            case SBProperties.sampleRate:
              dodistinct = true;
              break;
            default:
              dodistinct = false;
              break;
          }
          
          if (dodistinct) {
            var unitspopup = 
              this.drawer.getItemElementByAttribute(condition, 
                                                    "id", 
                                                    "unitspopup");
            var unit;
            if (!unitspopup.hidden)
              unit = unitspopup.value;
            textbox1.setAttribute("autocompletesearch", 
                                  "library-distinct-properties");
            textbox1.setAttribute("autocompletesearchparam", 
                                  property + ";" + 
                                  libraryGuid + ";;" + 
                                  (unit ? unit : ""));
            textbox2.setAttribute("autocompletesearch", 
                                  "library-distinct-properties");
            textbox2.setAttribute("autocompletesearchparam", 
                                  property + ";" + 
                                  libraryGuid + ";;" + 
                                  (unit ? unit : ""));
          } else {
            textbox1.removeAttribute("autocompletesearch");
            textbox1.removeAttribute("autocompletesearchparam");
            textbox2.removeAttribute("autocompletesearch");
            textbox2.removeAttribute("autocompletesearchparam");
          }
          ]]>
        </body>
      </method>

      <!-- Select the default operator for a given property -->
      <method name="_selectDefaultOperator">
        <parameter name="condition"/>
        <parameter name="aParent"/>
        <parameter name="metadataArray"/>
        <parameter name="property"/>
        <body>
        <![CDATA[
          var def = this._getMetadataMap("operators", 
                                         condition, 
                                         property);
          if (!def || def == "") {
            var info = this._pm.getPropertyInfo(property);
            switch (info.type) {
              case "boolean": 
                def = info.OPERATOR_ISTRUE; 
                break;
              case "datetime":
                def = info.OPERATOR_INTHELAST;
                break;
              case "uri": 
              case "text": 
                def = info.OPERATOR_CONTAINS; 
                break;
              case "duration":
                def = info.OPERATOR_GREATER;
                break;
              case "number":
              case "rating":
              default:
                def = info.OPERATOR_EQUALS;
                break;
            }
          }
          for (var i=0;i<metadataArray.length;i++) {
            if (metadataArray[i].value == def) {
              aParent.selectedIndex = i;
              return;
            }
          }
          // Write a debug message since this is not supposed to happen
          Components.utils.
            reportError("Default for property type " + 
                        info.type + " (" + 
                        def + 
                        ") not found, using first operator instead");
          aParent.selectedIndex = 0;
        ]]>
        </body>
      </method>

      <!-- When the user selects an operator, update the widgets visibility, so
           that we show the second value field, or hide it as needed. Once that
           is done, perform the validation again, because there may be a new
           field to validate -->
      <method name="onSelectOperator">
        <parameter name="menu"/>
        <body>
          if (this._refreshingUI) {
            return;
          }
          var condition = this.drawer.getItem(menu);
          this._updateUI(condition);
          this._selectUnit(condition);
          var propertypopup = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "propertypopup");
          this._setMetadataMap("operators", 
                               condition, 
                               propertypopup.value,
                               menu.value);

          var operatorpopup = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "operatorpopup");

          var unitspopup = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "unitspopup");
          
          this._doPrefill(condition, 
                          propertypopup, 
                          propertypopup.value, 
                          operatorpopup.value, 
                          unitspopup.hidden ? null : unitspopup.value);
          this._doValidation(condition);
        </body>
      </method>
      
      <method name="_doPrefill">
        <parameter name="condition"/>
        <parameter name="propertypopup"/>
        <parameter name="property"/>
        <parameter name="operator"/>
        <parameter name="unit"/>
        <body>
          <![CDATA[
            // note that the prefill value should is in native units, always.
            // also, it should always be a string.
            var prefillValue;

            // get property info for this metadata
            var info = this._pm.getPropertyInfo(property);
            
            // first try to find a prefill value per property type
            switch (info.type) {
              case "datetime":
                // default prefill on date depends on operator
                switch (operator) {
                  case info.OPERATOR_EQUALS:
                  case info.OPERATOR_NOTEQUALS:
                  case info.OPERATOR_GREATER:
                  case info.OPERATOR_GREATEREQUAL:
                  case info.OPERATOR_LESS:
                  case info.OPERATOR_LESSEQUAL:
                  case info.OPERATOR_BETWEEN:
                    var d = new Date();
                    prefillValue = ""+d.getTime();
                    break;
                  case info.OPERATOR_INTHELAST:
                  case info.OPERATOR_NOTINTHELAST:
                    prefillValue = "1";
                    break;
                }
                break;
              case "rating":
                prefillValue = "5";
                break;
            }
            // then based on the property itself
            switch (property) {
              case SBProperties.bitRate:
                prefillValue = "128";
                break;
              case SBProperties.bpm:
                prefillValue = "60";
                break;
              case SBProperties.discNumber:
              case SBProperties.trackNumber:
                prefillValue = "1";
                break;
              case SBProperties.skipCount:
              case SBProperties.playCount:
                prefillValue = "0";
                break;
              case SBProperties.sampleRate:
                prefillValue = "44100";
                break;
              case SBProperties.contentLength:
                prefillValue = "0";
                break;
              case SBProperties.duration:
                prefillValue = "0";
                break;
              case SBProperties.year:
                var d = new Date;
                prefillValue = d.getFullYear();
                break;
            }
            if (!prefillValue)
              return;

            // if we are using units, we need to convert from native
            var nativeUnitId;
            if (unit) {
              // get the appropriate unit converter
              if (info.type == "datetime") {
                // datetime has no unit conversion that makes sense, unless we
                // are using the inthelast/notinthelast operators, in which case
                // we need to use the duration unit converter
                var converter = 
                  this._pm.getPropertyInfo(SBProperties.duration)
                          .unitConverter;
                nativeUnitId = converter.nativeUnitId;
              } else {
                nativeUnitId = info.unitConverter.nativeUnitId;
              }
            }
            
            // format from the native unit
            var formattedPrefill = this._convertToUI(property, 
                                                     operator, 
                                                     prefillValue, 
                                                     nativeUnitId);

            // do not replace the user's input
            if (!propertypopup.gotuserinput1) {
              var value1 = 
                this.drawer.getItemElementByAttribute(condition, 
                                                      "sbid", 
                                                      "conditionvalue1", 
                                                      true); // get the visible one
              if (value1)
                value1.value = formattedPrefill;
            }
            if (!propertypopup.gotuserinput2) {
              var value2 = 
                this.drawer.getItemElementByAttribute(condition, 
                                                      "sbid", 
                                                      "conditionvalue2", 
                                                      true); // get the visible one
              if (value2)
                value2.value = formattedPrefill;
            }
              
          ]]>
        </body>
      </method>
      
      <!-- This takes the drawer item state and feeds it to the updateUIState
           function. Like at initialization, that function will set drawer state
           properties to true or false based on what the user is currently
           editing. Once that is done, we send the updated state back to the
           drawer item, which shows and hides the appropriate widgets via the
           mappings --> 
      <method name="_updateUI">
        <parameter name="condition"/>
        <body>
          if (this._refreshingUI) 
            return;
          var state = {};
          // read the drawer item state
          this.drawer.getItemState(condition, state);
          // apply UI logic
          this._updateUIState(state);
          // send the state back to the drawer item
          this.drawer.setItemState(condition, state);
        </body>
      </method>

      <!-- Whenever the user edits one of the fields, perform validation -->
      <method name="onInput">
        <parameter name="condition"/>
        <parameter name="event"/>
        <body>
          if (this._refreshingUI)
            return;
          var condition = this.drawer.getItem(condition);

          var value1 = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "sbid", 
                                                  "conditionvalue1", 
                                                  true); // get the visible one
          if (this._isDeepChild(event.originalTarget, value1, condition)) {
            var propertypopup = 
              this.drawer.getItemElementByAttribute(condition, 
                                                    "id", 
                                                    "propertypopup");
            propertypopup.gotuserinput1 = true;
          } else {
            var value2 = 
              this.drawer.getItemElementByAttribute(condition, 
                                                    "sbid", 
                                                    "conditionvalue2", 
                                                    true); // get the visible one
            if (this._isDeepChild(event.originalTarget, value2, condition)) {
              var propertypopup = 
                this.drawer.getItemElementByAttribute(condition, 
                                                      "id", 
                                                      "propertypopup");
              propertypopup.gotuserinput2 = true;
            }
          }

          this._doValidation(condition);
        </body>
      </method>

      <!-- Perform validations on all edit fields for all condition items -->
      <method name="_doAllValidations">
        <body>
          <![CDATA[
          // get all drawer items
          var items = this.drawer.items;
          // and validate them
          for (var i=0;i<items.length;i++)
            this._doValidation(items[i]);
          ]]>
        </body>
      </method>

      <!-- Perform user input validation -->
      <method name="_doValidation">
        <parameter name="condition"/>
        <body>
          <![CDATA[
          if (this._refreshingUI)
            return;

          // we need to read a bunch of things off of the UI
          var value1 = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "sbid", 
                                                  "conditionvalue1", 
                                                  true); // get the visible one
          var value2 = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "sbid", 
                                                  "conditionvalue2", 
                                                  true); // get the visible one
          var property = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "propertypopup");
          var operator = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "operatorpopup");
          var unitspopup = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "unitspopup");
          
          // if the popup is hidden, no unit conversion applies
          var units = unitspopup.hidden ? null : unitspopup.value;
          
          // get property info for this metadata
          var info = this._pm.getPropertyInfo(property.value);

          // force validation to succeed when doing a substring match, because
          // otherwise URI substring will fail to validate (since they are not
          // valid URIs). This will not interfere with non-text matches, because
          // these do not implement the CONTAINS operator.
          var forcevalid = false;
          if (v && v != "" && operator.value == info.OPERATOR_CONTAINS) {
            forcevalid = true;
          }
          
          // Before validating value1, first convert it from UI units/format
          // into native units/format
          var v = value1.value;
          v = this._convertFromUI(property.value, operator.value, v, units);
          
          // Then validate and set the invalid attribute accordingly
          if (!v || 
              v == "" || 
              (!forcevalid && 
               !info.validate(v)
              )
             ) {
            value1.setAttribute("invalid", "true");
          } else {
            value1.setAttribute("invalid", "false");
          }

          // If the second user input widget is visible, validate it too
          if (value2 && !value2.hidden) {

            // same check for whether we need to force validation to true as
            // with value1
            forcevalid = false;
            if (v && v != "" && operator.value == info.OPERATOR_CONTAINS) {
              forcevalid = true;
            }
            
            // Before validating value2, first convert it from UI units/format
            // into native units/format
            v = value2.value;
            v = this._convertFromUI(property.value, operator.value, v, units);
          
            // Then validate and set the invalid attribute accordingly
            if (!v || 
                v == "" || 
                (!forcevalid && 
                 !info.validate(v)
                )
               ) {
              value2.setAttribute("invalid", "true");
            } else {
              value2.setAttribute("invalid", "false");
            }
          }
          
          // The invalid attribute is mapped to a drawer item state property,
          // there is nothing we have to do extra in order to forward the
          // invalid state down to the window. The event that caused this
          // validation to occur will also cause the window to read our isValid
          // binding property thus reading the drawer item state back, and will
          // disable its ok button if needed.
          
          ]]>
        </body>
      </method>
      
      <!-- Update the state variables for all condition items -->
      <method name="_updateUIStates">
        <parameter name="states"/>
        <body>
          <![CDATA[
            states.forEach(function(state) {
                this._updateUIState(state);
              }, this);
          ]]>
        </body>
      </method>

      <!-- Update the state variables that turn UI widgets on and off. Upon
           sending the state object to the drawer item, the widgets will
           automatically show and hide based on their property and attribute
           mappings -->
      <method name="_updateUIState">
        <parameter name="state"/>
        <body>
          <![CDATA[
            var info = this._pm.getPropertyInfo(state.metadata);
            state.interval = (state.condition == info.OPERATOR_BETWEEN);

            switch (info.type) {
              case "boolean": 
                // if current operator is istrue or isfalse, hide the input
                // object.
                if (state.condition == info.OPERATOR_ISTRUE ||
                    state.condition == info.OPERATOR_ISFALSE) {
                  state.textfield = false;
                } else {
                  // We actually disable the other operators, but it doesn't
                  // hurt to be thorough, in case they got reenabled somehow,
                  // enable the input field so the user may compare the boolean
                  // value to something
                  state.textfield = true;
                }
                // hide the ratings input fields
                state.ratingfield = false;
                break;
              case "number":
              case "uri": 
              case "text": 
              case "datetime":
              case "duration":
                // Show the text input fields
                state.textfield = true;
                // Hide the ratings input fields
                state.ratingfield = false;
                break;
              case "rating":
                // Hide the text input fields
                state.textfield = false;
                // Show the ratings input fields
                state.ratingfield = true;
                break;
              default:
                // Don't know what to show, use text input field i guess, and 
                // write a debug message, since this is not supposed to happen.
                Components.utils.
                  reportError("Don't know the " + 
                              info.type + 
                              " property type, using default text field");
                state.textfield = true;
                state.ratingfield = false;
                break;
            }
            switch (state.metadata) {
              case SBProperties.contentLength:
              case SBProperties.sampleRate:
              case SBProperties.bitRate:
                // Show units popup
                state.useunits = true;
                break;
              default:
                switch (info.type) {
                  // If using the datetime inthelast/notinthelast operators,
                  // show the units popup, it will be filled with duration
                  // units, so we can compare the date value to the last
                  // x weeks/months/years/etc
                  case "datetime":
                    if (state.condition == info.OPERATOR_INTHELAST ||
                        state.condition == info.OPERATOR_NOTINTHELAST) {
                      state.useunits = true;
                    } else {
                      // unit do not apply to other datetime operators, hide em
                      state.useunits = false;
                    }
                    break;
                  default:
                    // Hide units popup
                    state.useunits = false;
                    break;
                }
                break;
            }
          ]]>
        </body>
      </method>
      
      <!-- Convert from a displayed value to a native value, by either
           performing a convertion from UI units to native, or by parsing a
           formatted field -->
      <method name="_convertFromUI">
        <parameter name="metadata"/>
        <parameter name="operator"/>
        <parameter name="value"/>
        <parameter name="unit"/>
        <body>
          <![CDATA[
            if (!unit || unit == "") {
              return this._convertFromUIFormat(metadata, value);
            } else {
              return this._convertFromUIUnit(metadata, value, unit);
            }
          ]]>
        </body>
      </method>
      
      <!-- Convert from a native value to a displayed value, by either
           performing a convertion from native to UI units, or by formatting
           the field -->
      <method name="_convertToUI">
        <parameter name="metadata"/>
        <parameter name="operator"/>
        <parameter name="value"/>
        <parameter name="unit"/>
        <body>
          <![CDATA[
            if (!unit || unit == "") {
              return this._convertToUIFormat(metadata, value);
            } else {
              return this._convertToUIUnit(metadata, value, unit);
            }
          ]]>
        </body>
      </method>
      
      <!-- Perform unit conversions from UI to native -->
      <method name="_convertFromUIUnit">
        <parameter name="metadata"/>
        <parameter name="value"/>
        <parameter name="unit"/>
        <body>
          <![CDATA[
            // if no unit or not value, bail out
            if (!unit || unit == "") return value;
            if (!value || value == "") return value;

            // var inputValue = value; // for debug

            // parse as number, because conversion requires one. if parsing
            // fails, return null, which will cause the field to be invalid.
            value = value.replace(/\s/g, "");
            // match a number, from n to +n.nE+n
            if (value.match(/^([+-]?\d+(?:\.\d+)?(?:e[+-]?\d+)?)/i)) {
              var leftover = RegExp.rightContext;
              if (leftover && leftover != "") 
                return null;
              value = RegExp.$1;
            } else {
              return null;
            }

            // get property info for this metadata
            var info = this._pm.getPropertyInfo(metadata);

            // get the appropriate unit converter
            var converter;
            if (info.type == "datetime") {
              // datetime has no unit conversion that makes sense, unless we
              // are using the inthelast/notinthelast operators, in which case
              // we need to use the duration unit converter
              converter = 
                this._pm.getPropertyInfo(SBProperties.duration)
                        .unitConverter;
            } else {
              converter = info.unitConverter;
            }
            // try to perform the conversion, this may throw an exception if
            // the value fails to parse into a number, but that should not
            // happen since we already made sure that it actually is a number.
            // still try/catch, just in case.
            try {
              if (converter) {
                if (unit != converter.nativeUnitId) {
                  // parse the result as an int, because we are converting
                  // *from* ui units, and the native unit is integer.
                  // this will need to change once we allow number properties to
                  // hold floating point values, we'll then have to check
                  // whether that is the case for this particular property, and
                  // avoid the parseInt in this case.
                  value = parseInt(converter.convert(value, 
                                                     unit, 
                                                     converter.nativeUnitId));
                }
              }
            } catch (e) {
              // Write a debug message, since this is not supposed to happen.
              Components.utils.reportError("Failed to convert " + 
                                           value + " from " +
                                           unit);
              value = null;
            }
            // debug
            // Components.utils.reportError("converting " + 
            //                              inputValue + 
            //                              " from " + 
            //                              unit + " = " + value + 
            //                              " (" + metadata + ")");
            return value;
          ]]>
        </body>
      </method>
      
      <!-- Perform unit conversions from native to UI -->
      <method name="_convertToUIUnit">
        <parameter name="metadata"/>
        <parameter name="value"/>
        <parameter name="unit"/>
        <body>
          <![CDATA[
            // if no unit or not value, bail out
            if (!unit || unit == "") return value;
            if (!value || value == "") return value;
            
            // var inputValue = value; // for debug
            
            // get property info for this metadata
            var info = this._pm.getPropertyInfo(metadata);

            // get the appropriate unit converter
            var converter;
            if (info.type == "datetime") {
              // datetime has no unit conversion that makes sense, unless we are
              // using the inthelast/notinthelast operators, in which case we
              // need to use the duration unit converter
              converter = 
                this._pm.getPropertyInfo(SBProperties.duration)
                        .unitConverter;
            } else {
              converter = info.unitConverter;
            }
            // try to perform the conversion, this may throw an exception if
            // the value fails to parse into a number. normally this should not
            // happen because the value we are converting is supposed to be in
            // native units, which should always parse, but it may still happen
            // if the smart playlist fed us a bad value.
            try {
              if (converter) {
                if (unit != converter.nativeUnitId)
                  value = converter.convert(value, 
                                            converter.nativeUnitId, 
                                            unit);
              }
            } catch (e) {
              // Write a debug message since this is not supposed to happen
              Components.utils.reportError("Failed to convert " + 
                                           value + " to " +
                                           unit);
              value = null;
            }
            // debug
            // Components.utils.reportError("converting " + 
            //                              inputValue + 
            //                              " to " +
            //                              unit + " = " + value + 
            //                              " (" + metadata + ")");
            return value;
          ]]>
        </body>
      </method>

      <!-- convert to human readable form. See note in _convertToUIFormat. -->      
      <method name="_convertFromUIFormat">
        <parameter name="metadata"/>
        <parameter name="value"/>
        <body>
          <![CDATA[
            // if no value to convert, bail out
            if (!value) return null;
            
            // get property info for this metadata
            var info = this._pm.getPropertyInfo(metadata);
            
            // do the parsing according to type
            switch (info.type) {
              case "datetime":
                value = Date.parse(value);
                break;
              case "duration":
                var years=0,months=0,days=0,hours=0,
                    minutes=0,seconds=0,milliseconds=0;
                
                // Note: we reverse the string because we want a reverse
                // precedence in the regexp matching, because 10:05 means
                // 10min5s, and not 10y5s, and because we do not want to force
                // the user to *have* to use different letters as separators for
                // every field. Yes, it's a bit crazy, but it works great. If
                // there is a way to do this that I don't know of, please do
                // change this code, but let's not settle for a less powerful
                // regexp just because it isn't reversed (for instance by
                // forcing the user to use different letters as separator, or to
                // enter all the fields, or by changing what the default is when
                // a simple number is on the field [should be seconds], and so
                // on)
                
                function strrev(s) { return s.split("").reverse().join(""); }
                
                // strip spaces because they do not participate in the regexp
                // rule, and only complicate it
                value = value.replace(/\s/g, "");
                
                // reverse the string
                var rev = strrev(value);
                
                // try to match a duration, using a reverse rule
                if (rev.match(/(?:(?:SM)?(\d+)\.)?(?:(?:CES|S)?(\d+))?(?:(?:(?:NM|NIM)|[:M])(\d+))?(?:[H:](\d+))?(?:[D,:](\d+))?(?:[M,:](\d+))?(?:[Y,:](\d+))?/i)) {
                
                  // read the parsed fields
                  if (RegExp.$7) years = parseInt(strrev(RegExp.$7), 10);
                  if (RegExp.$6) months = parseInt(strrev(RegExp.$6), 10);
                  if (RegExp.$5) days = parseInt(strrev(RegExp.$5), 10);
                  if (RegExp.$4) hours = parseInt(strrev(RegExp.$4), 10);
                  if (RegExp.$3) minutes = parseInt(strrev(RegExp.$3), 10);
                  if (RegExp.$2) seconds = parseInt(strrev(RegExp.$2), 10);
                  if (RegExp.$1) milliseconds = parseInt(strrev(RegExp.$1), 10);
                  
                  // read the leftover portion
                  var leftover = RegExp.rightContext;
                  
                  // debug
                  // Components.utils.reportError(years + "y " + 
                  //                              months + "m " + 
                  //                              days + "d " + 
                  //                              hours + "h " + 
                  //                              minutes + "min " + 
                  //                              seconds + "s " + 
                  //                              milliseconds + "ms");
                  // Components.utils.reportError("leftover = " + leftover);
                  
                  // if there was anything left over, cause parsing to fail
                  if (leftover && leftover != "") {
                    value = null;
                  } else {
                    // otherwise, compute a datetime value for this duration
                    var d = new Date(0);
                    d.setUTCFullYear(years + 1970);
                    d.setUTCMonth(months);
                    d.setUTCDate(days+1);
                    d.setUTCHours(hours);
                    d.setUTCMinutes(minutes);
                    d.setUTCSeconds(seconds);
                    d.setUTCMilliseconds(milliseconds);
                    value = d.getTime() * 1000;
                  }
                } else {
                  value = null;
                }
                break;
            }
            return value;
          ]]>
        </body>
      </method>
      
      <!-- convert from human readable form. See note below. -->
      <method name="_convertToUIFormat">
        <parameter name="metadata"/>
        <parameter name="value"/>
        <body>
          <![CDATA[
            // if there is no value to convert, bail out
            if (!value || value == "") 
              return value;

            // get property info for this metadata
            var info = this._pm.getPropertyInfo(metadata);
            try {
              // and format the field
              value = info.format(value);
            } catch (e) {
            }
            return value;
          ]]>
        </body>
      </method>
      
      
      <!-- Convert the values for all conditions from their UI unit to the
           native unit. This is used when exporting the condition's state -->
      <method name="_applyStateConversionsFromUI">
        <parameter name="states"/>
        <body>
          <![CDATA[
            states.forEach(function(state) {
                this._applyStateConversionFromUI(state);
              }, this);
          ]]>
        </body>
      </method>

      <!-- Convert values for all conditions from the native unit to their UI
           unit. This is used when importing the condition's state -->
      <method name="_applyStateConversionsToUI">
        <parameter name="states"/>
        <body>
          <![CDATA[
            states.forEach(function(state) {
                this._applyStateConversionToUI(state);
              }, this);
          ]]>
        </body>
      </method>
      
      <!-- Convert values from their UI unit to the native unit.
           This is used when exporting the condition's state -->
      <method name="_applyStateConversionFromUI">
        <parameter name="state"/>
        <body>
          <![CDATA[
            state.value = this._convertFromUI(state.metadata, 
                                              state.operator, 
                                              state.value, 
                                              state.unit);
            if (state.interval) 
              state.value2 = this._convertFromUI(state.metadata, 
                                                 state.operator, 
                                                 state.value2, 
                                                 state.unit);
          ]]>
        </body>
      </method>

      <!-- Convert values from the native unit to the UI unit.
           This is used when importing the condition's state -->
      <method name="_applyStateConversionToUI">
        <parameter name="state"/>
        <body>
          <![CDATA[
            state.value = this._convertToUI(state.metadata, 
                                            state.operator, 
                                            state.value, 
                                            state.unit);
            // check whether the conversion produced a bad value. this should
            // not happen normally, but still could if the smart playlist fed
            // us a bad value to start with. don't show NaN, show empty.
            if (""+state.value == "NaN") 
              state.value = "";
              
            if (state.value != "" && state.value != null)
              state.gotuserinput1 = true;
              
            if (state.interval) {
              state.value2 = 
                this._convertToUI(state.metadata, 
                                  state.operator, 
                                  state.value2, 
                                  state.unit);
              // same check as for value1
              if (""+state.value2 == "NaN") 
                state.value2 = "";

              if (state.value2 != "" && state.value2 != null)
                state.gotuserinput2 = true;
            }
          ]]>
        </body>
      </method>

      <!-- Called when a new unit has been selected by the user in the unit 
           popup -->
      <method name="onSelectUnit">
        <parameter name="menu"/>
        <body>
          <![CDATA[
            if (this._refreshingUI)
              return;

            var condition = this.drawer.getItem(menu)
            
            // Update the autocomplete to reflect the newly selected unit,
            // because autocomplete may perform unit conversion of the suggested
            // values
            var propertypopup = 
              this.drawer.getItemElementByAttribute(condition, 
                                                    "id", 
                                                    "propertypopup");
            this._setAutoComplete(condition, propertypopup.value);

            // When the unit changes, we need to validate again, because 
            // although 0.5kB is okay, 0.5bytes is not.
            this._doValidation(condition);
            
            if (menu.value && menu.value != "") {
              // Record that this is the unit we want for this property
              // so that going back to this property later will reselect the
              // same unit again (though only for this condition)
              var property = 
                this.drawer.getItemElementByAttribute(condition, 
                                                      "id",
                                                      "propertypopup");
              this._setMetadataMap("units", condition, property.value, menu.value);
            }
          ]]>
        </body>
      </method>
      
      <!-- For each condition item, record the UI unit associated with its
           metadata, so that switching back to these properties will reselect
           these units by default -->
      <method name="_setMetadataMaps">
        <parameter name="state"/>
        <body>
        <![CDATA[
          var items = this.drawer.items;
          for (var i=0;i<items.length;i++) {
            this._setMetadataMap("units", 
                                 items[i], 
                                 state[i].metadata, 
                                 state[i].unit);
            this._setMetadataMap("operators", 
                                 items[i], 
                                 state[i].metadata, 
                                 state[i].condition);
          }
        ]]>
        </body>
      </method>

      <!-- Store the UI unit used by this condition in a map that we attach to
           the metadata popup, so that we can later restore it when the user
           switches back to that metadata -->
      <method name="_setMetadataMap">
        <parameter name="key"/>
        <parameter name="condition"/>
        <parameter name="metadata"/>
        <parameter name="value"/>
        <body>
          <![CDATA[
            var property = 
              this.drawer.getItemElementByAttribute(condition, 
                                                    "id", 
                                                    "propertypopup");
            if (!property[key]) { 
              property[key] = {} 
            }
            property[key][metadata] = value;
          ]]>
        </body>
      </method>

      <!-- Return the default UI unit to use for a metadata -->
      <method name="_getMetadataMap">
        <parameter name="key"/>
        <parameter name="condition"/>
        <parameter name="metadata"/>
        <body>
          <![CDATA[
            var property = 
              this.drawer.getItemElementByAttribute(condition, 
                                                    "id", 
                                                    "propertypopup");
            var value;
            if (property[key]) {
              // if something was saved, return it
              if (typeof(property[key][metadata]) != undefined) {
                value = property[key][metadata];
              }
            }
            return value;
          ]]>
        </body>
      </method>
      
      <!-- When a text input field loses focus, run a parse+format run on its
           content, so that the user sees exactly what we've understood of what
           he typed. For instance, this will convert a duration value of "50"
           into "0:50" -->
      <method name="onBlur">
        <parameter name="event"/>
        <body>
          <![CDATA[
            // get the drawer item that generated this event
            var condition = this.drawer.getItem(event.originalTarget);
            
            // check if the blur event was caused by the conditiontext1 field
            var textbox1 = 
              this.drawer.getItemElementByAttribute(condition, 
                                                    "id", 
                                                    "conditiontext1");
            if (this._isDeepChild(event.originalTarget, textbox1, condition)) {
              // do the parse+format run on it, but only if it is containing
              // a valid value
              if (textbox1.getAttribute("invalid") != "true")
                this._reformatTextbox(condition, textbox1);
            } else {
              // check if the blur event was caused by the conditiontext2 field
              var textbox2 = 
                this.drawer.getItemElementByAttribute(condition, 
                                                      "id", 
                                                      "conditiontext2");
              if (this._isDeepChild(event.originalTarget, 
                                    textbox2, 
                                    condition)) {
                // do the parse+format run on it, but only if it is containing
                // a valid value
                if (textbox2.getAttribute("invalid") != "true")
                  this._reformatTextbox(condition, textbox2);
                }
            }
          ]]>
        </body>
      </method>

      <!-- Returns true if child is a child, or grandchild, or grandgrandchild
           (etc) of parent. -->
      <method name="_isDeepChild">
        <parameter name="child"/>
        <parameter name="parent"/>
        <parameter name="limit"/>
        <body>
          <![CDATA[
            var element = child;
            while (element &&
                   element != limit) {
              if (element == parent)
                return true;
              element = element.parentNode;
            }
            return false;
          ]]>
        </body>
      </method>
      
      <!-- Get a value from a checkbox, parsing it and format it according to
           what property/operator we're using, and send the result back into
           the textbox. For instance this will turn a duration value of "50"
           into "0:50" -->
      <method name="_reformatTextbox">
        <parameter name="condition"/>
        <parameter name="textbox"/>
        <body>
          <![CDATA[
          // read ui for which property, operator and unit we're parsing and
          // formatting for
          var property = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "propertypopup");
          var operator = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "operatorpopup");
          var unitspopup = 
            this.drawer.getItemElementByAttribute(condition, 
                                                  "id", 
                                                  "unitspopup");
          var units = unitspopup.hidden ? null : unitspopup.value;
          
          // parse
          var value = this._convertFromUI(property.value, 
                                          operator.value, 
                                          textbox.value, 
                                          units);
          
          // format
          value = this._convertToUI(property.value, 
                                    operator.value, 
                                    value, 
                                    units);
          
          // do not send the result back to the textbox if we end up with a bad
          // value; this will be the case if the value fails to parse (eg.
          // a text value for a number field)
          if (""+value != "NaN") textbox.value = value;
          ]]>
        </body>
      </method>
      
      <method name="_isMetadataIncluded">
        <parameter name="id"/>
        <body>
          <![CDATA[
            var info = this._pm.getPropertyInfo(id);
            
            // if the property is not visible by the user, discard it from
            // the list
            if (!info.userViewable) 
              return false;
            
            // if the property is of a type that we don't know about,
            // discard it as well
            switch (info.type) {
              case "datetime":
              case "number":
              case "boolean":
              case "duration":
              case "text":
              case "uri":
                break;
              default:
                return false;
            }

            // if the user said he wants everything, give him everything we
            // can support
            var enableAll = Application.prefs.getValue(
                           "songbird.smartplaylisteditor.enableAllProperties", false);
            
            if (enableAll) 
              return true;
            
            // otherwise, discard more properties, based on design reqs
            switch (id) {
              // the following don't really make sense to search on, or maybe
              // they could for some, but we don't want them anyway.
              case SBProperties.ordinal:
              case SBProperties.hash:
              case SBProperties.copyright:
              case SBProperties.copyrightURL:
              case SBProperties.destination:
              case SBProperties.downloadDetails:
              case SBProperties.softwareVendor:
              case SBProperties.key:
              case SBProperties.lyrics:
              case SBProperties.metadataUUID:
              case SBProperties.mediaListName:
              case SBProperties.subtitle:
              case SBProperties.totalDiscs:
              case SBProperties.totalTracks:
              
              // and these six get no love because we can't edit them in the
              // track editor, and apparently, that's reason enough to prevent
              // the user from making smart playlists based on their content
              case SBProperties.isPartOfCompilation:
              case SBProperties.conductorName:
              case SBProperties.language:
              case SBProperties.lyricistName:
              case SBProperties.producerName:
              case SBProperties.recordLabelName:
                
                return false;
            }
            
            // the rest gets in
            return true;
          ]]>
        </body>
      </method>

      </implementation>

  </binding>

</bindings>

