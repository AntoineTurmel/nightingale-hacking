<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE window SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">


  
  
  <!-- VOLUME CONTROL -->

  
  
  
  <binding id="volume-slider" extends="chrome://songbird/content/bindings/progressSlider.xml#progress-slider">

   <handlers>
     <handler event="progressSliderChange" action="this.onTrackVolume();"/>
     <handler event="progressSliderRelease" action="this.onReleaseVolume();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);
 
        // observer for DataRemote 
        const on_remote_volume_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onRemoteVolumeChange(); } 
        };
        on_remote_volume_change._that = this;

        // Create and bind data remotes
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_lastVolume = SB_NewDataRemote("faceplate.volume.last", null );
        this.remote_volume.bindObserver(on_remote_volume_change, true);

        this.maxpos = 255;
        this.value = this.remote_volume.intValue;
        this.trackingVolume = false;
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.remote_volume) {
          this.remote_volume.unbind();
          this.remote_volume = null;
        }
        if (this.remote_lastVolume) {
          this.remote_lastVolume = null;
        }
      ]]>
    </destructor>
    
    <method name="onTrackVolume">
      <body>
        <![CDATA[
          // prevent this volume control from being updated while it is being
          //   moved (but other volume controls are updated with our motion)
          this.trackingVolume = true; 
          this.gPPS.volume = this.value;
          this.remote_volume.intValue = this.value;
          if (this.value == 0) {
            // set mute when we bring the volume to 0
            this.gPPS.mute = true;
          }
          else {
            // otherwise reset it, and record the last volume
            this.gPPS.mute = false;
          }
        ]]>
      </body>
    </method>

    <method name="onReleaseVolume">
      <body>
        <![CDATA[
          this.trackingVolume = false;
          this.gPPS.volume = this.value;
          if (this.value != 0) {
            this.remote_lastVolume.intValue = this.value;
          }
        ]]>
      </body>
    </method>

    <method name="onRemoteVolumeChange">
      <body>
        <![CDATA[
          try {
            if (this.trackingVolume) // if volume is being actively changed, wait until release
              return; 
            this.value = this.remote_volume.intValue;
          } catch (err) {
            dump("playerControls.xml - onRemoteVolumeChange - " + err + "\n");
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- MUTE CONTROL -->




  <binding id="mute">
  
   <content>
     <xul:stack xbl:inherits="class=class" >
       <xul:button sbid="mute_off" xbl:inherits="class=class,id=muteoffid" oncommand="onMute( );" tooltiptext="&tooltip.control.mute;"/>
       <xul:button sbid="mute_on"  xbl:inherits="class=class,id=muteonid" oncommand="onMute( );" tooltiptext="&tooltip.control.mute;"/>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind the data remotes
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_lastVolume = SB_NewDataRemote( "faceplate.volume.last", null );
        this.remote_mute = SB_NewDataRemote( "faceplate.mute", null );
        this.bindmuteon = SBDataBindElementAttribute( "faceplate.mute", this.mute_on, "hidden", true, true );
        this.bindmuteoff = SBDataBindElementAttribute( "faceplate.mute", this.mute_off, "hidden", true );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "mute binding destructor");
        if (this.bindmuteon) {
          this.bindmuteon.unbind();
          this.bindmuteon = null;
        }
        if (this.bindmuteoff) {
          this.bindmuteoff.unbind();
          this.bindmuteoff = null;
        }
      ]]>
    </destructor>

    <field name="mute_on">document.getAnonymousElementByAttribute(this, 'sbid', 'mute_on');</field>
    <field name="mute_off">document.getAnonymousElementByAttribute(this, 'sbid', 'mute_off');</field>

    <method name="onMute">
      <body>
        <![CDATA[
          var newmute = !this.gPPS.mute; 
          this.gPPS.mute = newmute;
          if (!newmute) {
            // restore last volume when coming back from mute state
            this.gPPS.volume = this.remote_lastVolume.intValue;
          } 
          else {
            this.remote_lastVolume.intValue = this.remote_volume.intValue;
            this.gPPS.volume = 0;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  

  <!-- FORWARD BUTTON-->

  
  
  
  <binding id="forward" extends="chrome://global/content/bindings/button.xml#button">

   <handlers>
     <handler event="mousedown" action="this.onFwdMouseDown();"/>
     <handler event="mouseup" action="this.onFwdMouseUp();"/>
     <handler event="mouseout" action="this.onFwdMouseOut();"/>
     <handler event="mouseover" action="this.onFwdMouseOver();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
    </destructor>
    
    <method name="onFwdMouseDown">
      <body>
        <![CDATA[
          this.seen_skip = false;
          if ( this.gPPS.playing )
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOut">
      <body>
        <![CDATA[
           if (this.skip_interval) {
             clearInterval( this.skip_interval );
             this.skip_interval = null;
           }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOver">
      <body>
        <![CDATA[
           if (this.skip && !this.skip_interval ) {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
           }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseUp">
      <body>
        <![CDATA[
          this.skip = false;
          this.onFwdCommand();
        ]]>
      </body>
    </method>

    <method name="onFwdCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.gPPS.next();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          if ( _this.skip )
          {
            _this.seen_skip = true;
            _this.gPPS.position = _this.gPPS.position + 15000;
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- BACK BUTTON-->

  
  
  
  <binding id="back" extends="chrome://global/content/bindings/button.xml#button">

   <handlers>
     <handler event="mousedown" action="this.onBackMouseDown();"/>
     <handler event="mouseup" action="this.onBackMouseUp();"/>
     <handler event="mouseout" action="this.onBackMouseOut();"/>
     <handler event="mouseover" action="this.onBackMouseOver();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
    </destructor>
    
    <method name="onBackMouseDown">
      <body>
        <![CDATA[
          this.seen_skip = false;
          if ( this.gPPS.playing )
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onBackMouseUp">
      <body>
        <![CDATA[
          this.skip = false;
          this.onBackCommand();
        ]]>
      </body>
    </method>

    <method name="onBackMouseOut">
      <body>
        <![CDATA[
           if (this.skip_interval) {
             clearInterval( this.skip_interval );
             this.skip_interval = null;
           }
        ]]>
      </body>
    </method>

    <method name="onBackMouseOver">
      <body>
        <![CDATA[
           if (this.skip && !this.skip_interval ) {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
           }
        ]]>
      </body>
    </method>

    <method name="onBackCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.gPPS.previous();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          if ( _this.skip )
          {
            _this.seen_skip = true;
            _this.gPPS.position = _this.gPPS.position - 15000;
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- REPEAT CONTROL -->




  <binding id="repeat">
  
   <content>
     <xul:stack xbl:inherits="class=class" >
       <xul:button sbid="repeat_none" xbl:inherits="class=class,id=repid" oncommand="onRepeat( );" tooltiptext="&menu.control.repx;"/>
       <xul:button sbid="repeat_1" xbl:inherits="class=class,id=rep1id" oncommand="onRepeat( );" tooltiptext="&menu.control.rep1;"/>
       <xul:button sbid="repeat_all" xbl:inherits="class=class,id=repallid" oncommand="onRepeat( );" tooltiptext="&menu.control.repa;"/>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_repeat = SB_NewDataRemote( "playlist.repeat", null );
        this.repnonebinding = SBDataBindElementAttribute( "playlist.repeat", this.repeat_none, "hidden", true, false, "parseInt( value ) != 0" );
        this.rep1binding = SBDataBindElementAttribute( "playlist.repeat", this.repeat_1, "hidden", true, false, "parseInt( value ) != 1" );
        this.repallbinding = SBDataBindElementAttribute( "playlist.repeat", this.repeat_all, "hidden", true, false, "parseInt( value ) != 2" );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "repeat binding destructor");
        if (this.repnonebinding) {
          this.repnonebinding.unbind();
          this.repnonebinding = null;
        }
        if (this.rep1binding) {
          this.rep1binding.unbind();
          this.rep1binding = null;
        }
        if (this.repallbinding) {
          this.repallbinding.unbind();
          this.repallbinding = null;
        }
      ]]>
    </destructor>

    <field name="repeat_none">document.getAnonymousElementByAttribute(this, 'sbid', 'repeat_none');</field>
    <field name="repeat_1">document.getAnonymousElementByAttribute(this, 'sbid', 'repeat_1');</field>
    <field name="repeat_all">document.getAnonymousElementByAttribute(this, 'sbid', 'repeat_all');</field>
    
    <method name="onRepeat">
      <body>
        <![CDATA[
          // Rob decided to change the order.  Woo.
          var value = 0;
          switch ( this.remote_repeat.intValue )
          {
            case 0:
              value = 2;
              break;
            case 1:
              value = 0;
              break;
            case 2:
              value = 1;
              break;
          }
          this.remote_repeat.intValue = value;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- SHUFFLE CONTROL -->




  <binding id="shuffle">
  
   <content>
     <xul:stack xbl:inherits="class=class" >
       <xul:button sbid="shuffle_off" xbl:inherits="class=class,id=shuffleoffid" oncommand="onShuffle( );" tooltiptext="&tooltip.control.shuf_off;"/>
       <xul:button sbid="shuffle_on" xbl:inherits="class=class,id=shuffleonid" oncommand="onShuffle( );" tooltiptext="&tooltip.control.shuffle;"/>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_shuffle = SB_NewDataRemote( "playlist.shuffle", null );
        this.bindshuffleoff = SBDataBindElementAttribute( "playlist.shuffle", this.shuffle_off, "hidden", true );
        this.bindshuffleon = SBDataBindElementAttribute( "playlist.shuffle", this.shuffle_on, "hidden", true, true );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "shuffle binding destructor");
        if (this.bindshuffleoff) {
          this.bindshuffleoff.unbind()
          this.bindshuffleoff = null;
        }
        if (this.bindshuffleon) {
          this.bindshuffleon.unbind()
          this.bindshuffleon = null;
        }
      ]]>
    </destructor>

    <field name="shuffle_off">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_off');</field>
    <field name="shuffle_on">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_on');</field>
    
    <method name="onShuffle">
      <body>
        <![CDATA[
          this.remote_shuffle.boolValue = !this.remote_shuffle.boolValue;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- SEEK CONTROL -->

  
  
  
  <binding id="seek-slider" extends="chrome://songbird/content/bindings/progressSlider.xml#progress-slider">

   <handlers>
     <handler event="progressSliderChange" action="this.onTrackSeekbar();"/>
     <handler event="progressSliderRelease" action="this.onReleaseSeekbar();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // observer for DataRemote 
        const on_remote_position_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onRemotePositionChange(); } 
        };
        on_remote_position_change._that = this;

        // Create and bind data remotes
        this.remote_position = SB_NewDataRemote( "metadata.position", null );
        this.remote_position.bindObserver(on_remote_position_change, true);
        this.remote_length = SBDataBindElementProperty( "metadata.length", this, "maxpos" );
       
        this.trackingPosition = 0;
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "seek-slider binding destructor");
        if (this.remote_position) {
          this.remote_position.unbind();
          this.remote_position = null;
        }
        if (this.remote_length) {
          this.remote_length.unbind();
          this.remote_length = null;
        }
      ]]>
    </destructor>

    <method name="onTrackSeekbar">
      <body>
        <![CDATA[
          this.trackingPosition = 1;
        ]]>
      </body>
    </method>

    <method name="onReleaseSeekbar">
      <body>
        this.gPPS.position = this.value;
        this.trackingPosition = 0;
      </body>
    </method>

    <method name="onRemotePositionChange">
      <body>
        <![CDATA[
          try {
            if (this.trackingPosition) return; // we are the control changing the position, ignore this callback
            this.value = gPPS.position;
          } catch (e) {
            alert("playerControls.xml - onRemotePositionChange - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- TOTALTIME CONTROL -->




  <binding id="totaltime">
  
   <content>
     <xul:label sbid="timelabel" xbl:inherits="id=id,class=class,align=align,crop=crop,disabled=disabled,flex=flex" onmousedown="onTotalDown();"/> 
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remote
        this.remote_showRemaining = SB_NewDataRemote( "faceplate.showremainingtime", null );
        this.bindtotaltime = SBDataBindElementAttribute( "metadata.length.str", this.label, "value" );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "totaltime binding destructor");
        if (this.bindtotaltime) {
          this.bindtotaltime.unbind();
          this.bindtotaltime = null;
        }
      ]]>
    </destructor>

    <field name="label">document.getAnonymousElementByAttribute(this, 'sbid', 'timelabel');</field>
    
    <method name="onTotalDown">
      <body>
        <![CDATA[
          var len = gPPS.length;
          if ( len > 0 )
            this.remote_showRemaining.boolValue = !this.remote_showRemaining.boolValue;
          // If you try to toggle it while it is zero, you lose the state.
          else
            this.remote_showRemaining.boolValue = false;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>




  <!-- PLAY/PAUSE CONTROL -->




  <binding id="playpause">
  
   <content>
     <xul:stack xbl:inherits="class=class,flex=flex">
       <xul:button sbid="play" xbl:inherits="id=playid,class=class" oncommand="onPlay( );" tooltiptext="&tooltip.control.play;" />
       <xul:button sbid="pause" xbl:inherits="id=pauseid,class=class" oncommand="onPause( );" tooltiptext="&tooltip.control.play;" />
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_seenPlaying = SB_NewDataRemote( "faceplate.seenplaying", null );
        this.remote_playingRef =  SB_NewDataRemote( "playing.ref", null ); 
        this.remote_playlistIndex =  SB_NewDataRemote( "playlist.index", null ); 

        // Bind to the hidden attribute for each field
        this.playbinding = SBDataBindElementAttribute( "faceplate.play", this.play, "hidden", true, true );
        this.pausebinding = SBDataBindElementAttribute( "faceplate.play", this.pause, "hidden", true );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "playpause binding destructor");
        if (this.pausebinding) {
          this.pausebinding.unbind();
          this.pausebinding = null;
        }
        if (this.playbinding) {
          this.playbinding.unbind();
          this.playbinding = null;
        }
      ]]>
    </destructor>

    <field name="play">document.getAnonymousElementByAttribute(this, 'sbid', 'play');</field>
    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>
    
    <method name="onPlay">
      <body>
        <![CDATA[
          var ref = "";
          if (this.gPPS.started ||
               (this.remote_playingRef.stringValue != "" &&
                this.remote_playlistIndex.stringValue != "") ) {
            if (this.gPPS.paused) {
              gPPS.play();
            } else {
              // player is buffering (or stopped!), because the play button is visible (not started) yet 
              // pause is not set and the player is started.  start the playlist again at the current spot
              this.gPPS.playRef( this.remote_playingRef.stringValue, this.remote_playlistIndex.intValue );
            }
          } else {
            var ref = "";
            var playlist = this.getCurrentPlaylist();
            if (playlist) {
              ref = playlist.ref;
            } 
            if (ref == "") {
              this.loadLibrary();
              this.gPPS.play(); // let gpps handle default playback.
            } else {
              this.gPPS.playRef(ref, -1);
            }
          }
        ]]>
      </body>
    </method>

    <method name="onPause">
      <body>
        <![CDATA[
          if ( this.remote_seenPlaying.boolValue ) {
            this.gPPS.pause();
          }
        ]]>
      </body>
    </method>

    <method name="loadLibrary">
      <body>
        <![CDATA[
          // optional connection
          var theServiceTree = document.getElementById( 'frame_servicetree' );
          if (theServiceTree) theServiceTree.launchServiceURL( "chrome://songbird/content/xul/playlist_test.xul?library" );
        ]]>
      </body>
    </method>

    <method name="getCurrentPlaylist">
      <body>
        <![CDATA[
          var pl = document.__CURRENTPLAYLIST__;
          if (!pl) pl = document.__CURRENTWEBPLAYLIST__;
          if (!pl) return null;
          if ( pl.wrappedJSObject )
            pl = pl.wrappedJSObject;
          return pl;
        ]]>
      </body>
    </method>
    

   </implementation>
 
  </binding>





  <!-- ARTIST DISPLAY -->




  <binding id="artist" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.artist";
    </constructor>

   </implementation>
 
  </binding>




  <!-- TITLE DISPLAY -->




  <binding id="title" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.data  = "metadata.title";
        this.autotip = this.getAttribute("autotip");
        if (this.autotip) {
          // observer for DataRemote 
          const on_remote_artist_album_change = { 
            _that: null, 
            observe: function( aSubject, aTopic, aData ) { this._that.rebuildTip(); } 
          };
          on_remote_artist_album_change._that = this;

          // Create and bind data remotes
          this.remote_artist = SB_NewDataRemote( "metadata.artist", null );
          this.remote_album = SB_NewDataRemote( "metadata.album", null );
          this.remote_artist.bindObserver(on_remote_artist_album_change, true);
          this.remote_album.bindObserver(on_remote_artist_album_change, true);

          this.rebuildTip();
      }
      ]]>
    </constructor>

    <destructor>
      <![CDATA[
        if (this.remote_album) {
          this.remote_album.unbind();
          this.remote_album = null;
        }
        if (this.remote_artist) {
          this.remote_artist.unbind();
          this.remote_artist = null
        }
      ]]>
    </destructor>

    <method name="rebuildTip">
      <body>
        <![CDATA[
          try {
            var tip = "";
            if ( this.remote_artist.stringValue &&
                 this.remote_artist.stringValue.length ) {
              tip = this.remote_artist.stringValue;
            }
            if ( this.remote_album.stringValue &&
                 this.remote_album.stringValue.length ) {
              if (tip.length > 0) tip += " / ";
              tip += this.remote_album.stringValue;
            }
            this.label.setAttribute("tooltiptext", tip);
          } catch (e) {
            alert("playerControls.xml - rebuildTip - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>




  <!-- ALBUM DISPLAY -->




  <binding id="album" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.album";
    </constructor>

   </implementation>
 
  </binding>




  <!-- TIME ELAPSED DISPLAY -->




  <binding id="timeelapsed" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.position.str";
    </constructor>

   </implementation>
 
  </binding>




  <!-- GENRE DISPLAY -->




  <binding id="genre" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.genre";
    </constructor>

   </implementation>
 
  </binding>




  <!-- NUM PLAYLIST ITEMS DISPLAY -->




  <binding id="numplaylistitems" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      this.data  = "playlist.numitems";
    </constructor>

   </implementation>
 
  </binding>




  <!-- PLAYER SCANNING DISPLAY -->




  <binding id="scanning" extends="chrome://songbird/content/bindings/remote_label.xml#remote_label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.data  = "backscan.status";

        // Create and bind data remote
        this._visibilityBinding = SBDataBindElementAttribute( "backscan.status", this.label, "hidden", true, false, "value == ''" );

        this.setAttribute("onmousedown", "SBDataSetIntValue('backscan.paused', SBDataGetIntValue('backscan.paused') == 0 );");
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "scanning binding destructor");
        if (this._visibilityBinding) {
          this._visibilityBinding.unbind();
          this._visibilityBinding = null;
        }
      ]]>
    </destructor>

   </implementation>
 
  </binding>


<!-- SYSBTNS -->
<!-- TODO:
            1 - wait for matt to finish migrating overlays to be pulled into the document.
            2 - wrap all of the items into a single titlebar that properly centers the title on mac.
            3 - create a similar dialog titlebar that uses a value attribute on a label for the title.
-->            
  <binding id="sb-sys-maximize-button" extends="chrome://global/content/bindings/checkbox.xml#checkbox-baseline">
    <handlers>
      <!-- Grrr, apparently you use "CheckboxStateChange" instead of "command" from inside an XBL.  Of course.  Obviously. -->
      <handler event="CheckboxStateChange" action="onMaximize();"/>
    </handlers>
    <implementation>
      <constructor>
        this.setAttribute("tooltiptext", "&tooltip.maximize;")
        if ( this.getAttribute("hidden") != "true" ) // not hidden already
          this._visibilityBinding = SBDataBindElementAttribute( "accessibility.enabled", this, "hidden", true );
      </constructor>
      <destructor>
        <![CDATA[
          if (this._visibilityBinding) {
            this._visibilityBinding.unbind();
            this._visibilityBinding = null;
          }
        ]]>
      </destructor>
    </implementation>
  </binding>

  <binding id="sb-sys-minimize-button" extends="chrome://global/content/bindings/button.xml#button">
    <handlers>
      <handler event="command" action="onMinimize();"/>
    </handlers>
    <implementation>
      <constructor>
        this.setAttribute("tooltiptext", "&tooltip.minimize;")
        if ( this.getAttribute("hidden") != "true" ) // not hidden already
          this._visibilityBinding = SBDataBindElementAttribute( "accessibility.enabled", this, "hidden", true );
      </constructor>
      <destructor>
        <![CDATA[
          if (this._visibilityBinding) {
            this._visibilityBinding.unbind();
            this._visibilityBinding = null;
          }
        ]]>
      </destructor>
    </implementation>
  </binding>

  <binding id="sb-sys-close-button" extends="chrome://global/content/bindings/button.xml#button">
    <handlers>
      <!-- Close the window or close the app -->
      <handler event="command" action="( event.target.getAttribute('type') == 'dialog' ) ? onExit() : quitApp();"/>
    </handlers>
    <implementation>
      <constructor>
        this.setAttribute("tooltiptext", "&tooltip.exit;")
        if ( this.getAttribute("hidden") != "true" ) // not hidden already
          this._visibilityBinding = SBDataBindElementAttribute( "accessibility.enabled", this, "hidden", true );
      </constructor>
      <destructor>
        <![CDATA[
          if (this._visibilityBinding) {
            this._visibilityBinding.unbind();
            this._visibilityBinding = null;
          }
        ]]>
      </destructor>
    </implementation>
  </binding>

  <binding id="sb-sys-buttons">
    <content>
      <xul:sb-sys-minimize-button sbid="mini"/>
      <xul:sb-sys-maximize-button sbid="maxi"/>
      <xul:sb-sys-close-button sbid="close" xbl:inherits="type"/>
    </content>
    <implementation>
      <constructor>
        <![CDATA[
          var sysInfo = Components.classes["@mozilla.org/system-info;1"]
                        .getService(Components.interfaces.nsIPropertyBag2);
          if ( sysInfo.getProperty("name") == "Darwin" )
            // Hidden on Mac
            this.setAttribute( "hidden", "true" ); 
          else
            // Hidden when "Plucked" ("accessibility.enabled" == "1")
            this._visibilityBinding = SBDataBindElementAttribute( "accessibility.enabled", this, "hidden", true );

          if ( this.getAttribute( "type" ) == "dialog" ) {
            // Hidden if we only want to show the close.
            document.getAnonymousElementByAttribute(this, 'sbid', 'mini').setAttribute( "hidden", "true" );
            document.getAnonymousElementByAttribute(this, 'sbid', 'maxi').setAttribute( "hidden", "true" );
          }
        ]]>
      </constructor>
      <destructor>
        <![CDATA[
          if (this._visibilityBinding) {
            this._visibilityBinding.unbind();
            this._visibilityBinding = null;
          }
        ]]>
      </destructor>
    </implementation>
  </binding>

  <binding id="sb-sys-osx-buttons">
    <content>
      <xul:sb-sys-close-button sbid="close" xbl:inherits="type"/>
      <xul:sb-sys-minimize-button sbid="mini"/>
      <xul:sb-sys-maximize-button sbid="maxi"/>
    </content>
    <implementation>
      <constructor>
        <![CDATA[
          var sysInfo = Components.classes["@mozilla.org/system-info;1"]
                        .getService(Components.interfaces.nsIPropertyBag2);
          if ( sysInfo.getProperty("name") != "Darwin" )
            // Hidden on all but Mac
            this.setAttribute( "hidden", "true" ); 
          else
            // Hidden when "Plucked" ("accessibility.enabled" == "1")
            this._visibilityBinding = SBDataBindElementAttribute( "accessibility.enabled", this, "hidden", true );
            
          if ( this.getAttribute( "type" ) == "dialog" ) {
            // Hidden if we only want to show the close.
            document.getAnonymousElementByAttribute(this, 'sbid', 'mini').setAttribute( "hidden", "true" );
            document.getAnonymousElementByAttribute(this, 'sbid', 'maxi').setAttribute( "hidden", "true" );
          }
        ]]>
      </constructor>
      <destructor>
        <![CDATA[
          if (this._visibilityBinding) {
            this._visibilityBinding.unbind();
            this._visibilityBinding = null;
          }
        ]]>
      </destructor>
    </implementation>
  </binding>

  <binding id="sb-sys-icon" extends="chrome://global/content/bindings/button.xml#button">
    <handlers>
      <handler event="dblclick" action="quitApp();"/>
    </handlers>
    <implementation>
      <constructor>
        <![CDATA[
          var sysInfo = Components.classes["@mozilla.org/system-info;1"]
                        .getService(Components.interfaces.nsIPropertyBag2);
          if ( sysInfo.getProperty("name") == "Darwin" )
            // Hidden on Mac
            this.setAttribute( "hidden", "true" ); 
          else
            // Hidden when "Plucked" ("accessibility.enabled" == "1")
            this._visibilityBinding = SBDataBindElementAttribute( "accessibility.enabled", this, "hidden", true );
        ]]>
      </constructor>
      <destructor>
        <![CDATA[
          if (this._visibilityBinding) {
            this._visibilityBinding.unbind();
            this._visibilityBinding = null;
          }
        ]]>
      </destructor>
    </implementation>
  </binding>

  <binding id="sb-sys-title">
    <content>
      <xul:label sbid="title" xbl:inherits="value"/> 
    </content>
    <implementation>
      <constructor>
        <![CDATA[
          // Hidden when "Plucked" ("accessibility.enabled" == "1")
          this._visibilityBinding = SBDataBindElementAttribute( "accessibility.enabled", this, "hidden", true );
          
          // If there's no value attribute,
          var value = "" + this.getAttribute( "value" );
          if ( value.length == 0 )
          {
            // Then set us to the title of the window.          
            document.getAnonymousElementByAttribute(this, 'sbid', 'title').setAttribute( "value", window.title ); 
            // TODO: Watch the title attribute and reflect it here?
          }
        ]]>
      </constructor>
      <destructor>
        <![CDATA[
          if (this._visibilityBinding) {
            this._visibilityBinding.unbind();
            this._visibilityBinding = null;
          }
        ]]>
      </destructor>
    </implementation>
  </binding>

  <binding id="sb-sys-dialog-titlebar">
    <content>
      <xul:stack flex="1">
        <xul:hbox sbid="show_mac" pack="center">
          <xul:sb-sys-title xbl:inherits="value"/> 
        </xul:hbox>
        <xul:hbox>
          <xul:sb-sys-osx-buttons type="dialog"/>
          <xul:sb-sys-title sbid="hide_mac" xbl:inherits="value"/> 
          <xul:menubar/>
          <xul:spacer flex="1"/>
          <xul:sb-sys-buttons type="dialog"/>
        </xul:hbox>
      </xul:stack>
    </content>
    <implementation>
      <constructor>
        <![CDATA[
          var sysInfo = Components.classes["@mozilla.org/system-info;1"]
                        .getService(Components.interfaces.nsIPropertyBag2);
          if ( sysInfo.getProperty("name") == "Darwin" )
            // Hidden on Mac
            document.getAnonymousElementByAttribute(this, 'sbid', 'hide_mac').setAttribute( "hidden", "true" ); 
          else
            // Hidden on all but Mac
            document.getAnonymousElementByAttribute(this, 'sbid', 'show_mac').setAttribute( "hidden", "true" ); 
          
          // Hidden when "Plucked" ("accessibility.enabled" == "1")
          this._visibilityBinding = SBDataBindElementAttribute( "accessibility.enabled", this, "hidden", true );
          
          // This whole kaboodle is always draggable
          this.setAttribute( "drag_window", "true" );
        ]]>
      </constructor>
      <destructor>
        <![CDATA[
          if (this._visibilityBinding) {
            this._visibilityBinding.unbind();
            this._visibilityBinding = null;
          }
        ]]>
      </destructor>
    </implementation>
  </binding>

  <binding id="sb-sys-titlebar">
    <content>
      <xul:stack flex="1">
        <xul:hbox sbid="show_mac" pack="center">
          <xul:sb-sys-title xbl:inherits="value"/> 
        </xul:hbox>
        <xul:hbox>
          <xul:sb-sys-osx-buttons/>
          <xul:sb-sys-icon/>
          <xul:sb-sys-title sbid="hide_mac" xbl:inherits="value"/> 
          <xul:sb-sys-menubar/>
          <xul:spacer flex="1"/>
          <xul:sb-sys-buttons/>
        </xul:hbox>
      </xul:stack>
    </content>
    <implementation>
      <constructor>
        <![CDATA[
          var sysInfo = Components.classes["@mozilla.org/system-info;1"]
                        .getService(Components.interfaces.nsIPropertyBag2);
          if ( sysInfo.getProperty("name") == "Darwin" )
            // Hidden on Mac
            document.getAnonymousElementByAttribute(this, 'sbid', 'hide_mac').setAttribute( "hidden", "true" ); 
          else
            // Hidden on all but Mac
            document.getAnonymousElementByAttribute(this, 'sbid', 'show_mac').setAttribute( "hidden", "true" ); 
          
          // This whole kaboodle is always draggable
          this.setAttribute( "drag_window", "true" );

          // Note:  Doesn't disappear in "plucked" mode -- essentially it becomes the Menubar.
        ]]>
      </constructor>
    </implementation>
  </binding>

  <binding id="sb-sys-outer-frame">
    <content>
      <xul:stack flex="1">

        <xul:vbox flex="1">
          <xul:hbox>
              <xul:image class="chrome_nw"/>
              <xul:image class="chrome_n" flex="1"/>
              <xul:image class="chrome_ne"/>
          </xul:hbox>
          <xul:hbox flex="1">
              <xul:image class="chrome_w"/>
              <xul:spacer flex="1"/>
              <xul:image class="chrome_e"/>
          </xul:hbox>
          <xul:hbox>
              <xul:image class="chrome_sw"/>
              <xul:image class="chrome_s" flex="1"/>
              <xul:image class="chrome_se"/>
          </xul:hbox>
        </xul:vbox>
        
        <xul:vbox flex="1">
          <xul:hbox>
            <xul:resizer hidden="true" sbid="r1" oncommand="onWindowResizeComplete()" class="frame_resize_to" dir="topleft" style="cursor: nw-resize;"/>
            <xul:xresizer hidden="true" sbid="x1" oncommand="onWindowResizeComplete()" class="frame_resize_to" dir="topleft"/>
            <xul:resizer hidden="true" sbid="r2" oncommand="onWindowResizeComplete()" class="frame_resize_t" dir="top" style="cursor: n-resize;" flex="1"/>
            <xul:xresizer hidden="true" sbid="x2" oncommand="onWindowResizeComplete()" class="frame_resize_t" dir="top" flex="1"/>
            <xul:resizer hidden="true" sbid="r3" oncommand="onWindowResizeComplete()" class="frame_resize_to" dir="topright" style="cursor: ne-resize;"/>
            <xul:xresizer hidden="true" sbid="x3" oncommand="onWindowResizeComplete()" class="frame_resize_to" dir="topright"/>
          </xul:hbox>
          <xul:hbox flex="1">
            <xul:vbox>
              <xul:resizer hidden="true" sbid="r4" oncommand="onWindowResizeComplete()" class="frame_resize_mo" dir="topleft" style="cursor: nw-resize;"/>
              <xul:xresizer hidden="true" sbid="x4" oncommand="onWindowResizeComplete()" class="frame_resize_mo" dir="topleft"/>
              <xul:resizer hidden="true" sbid="r5" oncommand="onWindowResizeComplete()" class="frame_resize_m" dir="left" style="cursor: w-resize;" flex="1"/>
              <xul:xresizer hidden="true" sbid="x5" oncommand="onWindowResizeComplete()" class="frame_resize_m" dir="left" flex="1"/>
              <xul:resizer hidden="true" sbid="r6" oncommand="onWindowResizeComplete()" class="frame_resize_mo" dir="bottomleft" style="cursor: sw-resize;"/>
              <xul:xresizer hidden="true" sbid="x6" oncommand="onWindowResizeComplete()" class="frame_resize_mo" dir="bottomleft"/>
            </xul:vbox>

            <children/>
                  
            <xul:vbox>
              <xul:resizer hidden="true" sbid="r7" oncommand="onWindowResizeComplete()" class="frame_resize_mo" dir="topright" style="cursor: ne-resize;"/>
              <xul:xresizer hidden="true" sbid="x7" oncommand="onWindowResizeComplete()" class="frame_resize_mo" dir="topright"/>
              <xul:resizer hidden="true" sbid="r8" oncommand="onWindowResizeComplete()" class="frame_resize_m" dir="right" style="cursor: e-resize;" flex="1"/>
              <xul:xresizer hidden="true" sbid="x8" oncommand="onWindowResizeComplete()" class="frame_resize_m" dir="right" flex="1"/>
              <xul:resizer hidden="true" sbid="r9" oncommand="onWindowResizeComplete()" class="frame_resize_mo" dir="bottomright" style="cursor: se-resize;"/>
              <xul:xresizer hidden="true" sbid="x9" oncommand="onWindowResizeComplete()" class="frame_resize_mo" dir="bottomright"/>
            </xul:vbox>
          </xul:hbox>
          <xul:hbox>
            <xul:resizer hidden="true" sbid="r10" oncommand="onWindowResizeComplete()" class="frame_resize_to" dir="bottomleft" style="cursor: sw-resize;"/>
            <xul:xresizer hidden="true" sbid="x10" oncommand="onWindowResizeComplete()" class="frame_resize_to" dir="bottomleft"/>
            <xul:resizer hidden="true" sbid="r11" oncommand="onWindowResizeComplete()" class="frame_resize_t" dir="bottom" style="cursor: s-resize;" flex="1"/>
            <xul:xresizer hidden="true" sbid="x11" oncommand="onWindowResizeComplete()" class="frame_resize_t" dir="bottom" flex="1"/>
            <xul:resizer hidden="true" sbid="r12" oncommand="onWindowResizeComplete()" class="frame_resize_to" dir="bottomright" style="cursor: se-resize;"/>
            <xul:xresizer hidden="true" sbid="x12" oncommand="onWindowResizeComplete()" class="frame_resize_to" dir="bottomright"/>
          </xul:hbox>
        </xul:vbox>

      </xul:stack>
              
    </content>
    <implementation>
      <constructor>
        <![CDATA[
          var sysInfo = Components.classes["@mozilla.org/system-info;1"]
                        .getService(Components.interfaces.nsIPropertyBag2);
          var plucked = SBDataGetBoolValue( "accessibility.enabled" );
          if ( plucked )
            // If plucked, everything stays hidden.
            hideFrame();
          else if ( sysInfo.getProperty("name") == "Darwin" )
            // If mac, do magic stuff to just the bottom-right
            this.enableMac();
          else
            // Otherwise, fix yer frame, mate!
            this.enableResizers();
        ]]>
      </constructor>
      
      <destructor>
        <![CDATA[
        ]]>
      </destructor>
      
      <method name="hideFrame">
        <body>
          <![CDATA[
            // This is actually the default state, but let's be thorough
            for ( var i = 1; i <= 12; i++ ) {
              document.getAnonymousElementByAttribute(this, 'sbid', 'r' + i ).setAttribute( "hidden", "true" ); 
              document.getAnonymousElementByAttribute(this, 'sbid', 'x' + i ).setAttribute( "hidden", "true" ); 
            }
          ]]>
        </body>
      </method>

      <method name="enableMac">
        <body>
          <![CDATA[
            // We want to disable all but one of the bottom right resizers (#12)
            this.disableResizers();
            
            // And then mess with it, if we need to.
            var resizers = this.getAttribute( "resizers" );
            if ( resizers != "none" )
            {
              // Enable it
              this.enableResizer( 12 );
              
              // Set it to a mac attribute for skinning
              var r12 = document.getAnonymousElementByAttribute( this, 'sbid', 'r12' ); 
              r12.setAttribute( "mac", "true" );
              
              // And constrain its direction if required to do so
              if ( resizers == "vert" ) {
                r12.setAttribute( "dir", "bottom" );
                r12.setAttribute( "style", "cursor: s-resize;" );
              }
              if ( resizers == "horiz" ) {
                r12.setAttribute( "dir", "right" );
                r12.setAttribute( "style", "cursor: e-resize;" );
              }
            }
          ]]>
        </body>
      </method>

      <method name="enableResizers">
        <body>
          <![CDATA[
            switch ( this.getAttribute("resizers") ) {
              case "none":
                this.disableResizers();
                break;
              case "vert":
                this.disableResizers();
                this.enableResizer(1);
                this.enableResizer(2);
                this.enableResizer(3);
                this.enableResizer(10);
                this.enableResizer(11);
                this.enableResizer(12);
                break;
              case "horiz":
                this.disableResizers();
                this.enableResizer(4);
                this.enableResizer(5);
                this.enableResizer(6);
                this.enableResizer(7);
                this.enableResizer(8);
                this.enableResizer(9);
                break;
              default:
                for ( var i = 1; i <= 12; i++ ) {
                  this.enableResizer(i);
                }
            }
          ]]>
        </body>
      </method>

      <method name="disableResizers">
        <body>
          <![CDATA[
            for ( var i = 1; i <= 12; i++ ) {
              this.disableResizer(i);
            }
          ]]>
        </body>
      </method>

      <method name="enableResizer">
        <parameter name="aIndex"/>
        <body>
          <![CDATA[
            document.getAnonymousElementByAttribute(this, 'sbid', 'r' + aIndex ).setAttribute( "hidden", "false" ); 
            document.getAnonymousElementByAttribute(this, 'sbid', 'x' + aIndex ).setAttribute( "hidden", "true" ); 
          ]]>
        </body>
      </method>

      <method name="disableResizer">
        <parameter name="aIndex"/>
        <body>
          <![CDATA[
            document.getAnonymousElementByAttribute(this, 'sbid', 'r' + aIndex ).setAttribute( "hidden", "true" ); 
            document.getAnonymousElementByAttribute(this, 'sbid', 'x' + aIndex ).setAttribute( "hidden", "false" ); 
          ]]>
        </body>
      </method>


    </implementation>
  </binding>


<!-- EOF -->
</bindings>
