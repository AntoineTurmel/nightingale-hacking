<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE bindings SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">


  
  
  <!-- VOLUME CONTROL -->

  
  
  
  <binding id="volume-slider" extends="chrome://songbird/content/bindings/progressSlider.xml#progress-slider">

   <handlers>
     <handler event="progressSliderChange" action="this.onTrackVolume();"/>
     <handler event="progressSliderRelease" action="this.onReleaseVolume();"/>
   </handlers>

  <implementation>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.volume;")
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);
 
        // observer for DataRemote 
        const on_remote_volume_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onRemoteVolumeChange(); } 
        };
        on_remote_volume_change._that = this;

        // Create and bind data remotes
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_lastVolume = SB_NewDataRemote("faceplate.volume.last", null );
        this.remote_volume.bindObserver(on_remote_volume_change, true);

        this.maxpos = 255;
        this.value = this.remote_volume.intValue;
        this.trackingVolume = false;
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.remote_volume) {
          this.remote_volume.unbind();
          this.remote_volume = null;
        }
        if (this.remote_lastVolume) {
          this.remote_lastVolume = null;
        }
      ]]>
    </destructor>
    
    <method name="onTrackVolume">
      <body>
        <![CDATA[
          // prevent this volume control from being updated while it is being
          //   moved (but other volume controls are updated with our motion)
          this.trackingVolume = true; 
          this.gPPS.volume = this.value;
          this.remote_volume.intValue = this.value;
          if (this.value == 0) {
            // set mute when we bring the volume to 0
            this.gPPS.mute = true;
          }
          else {
            // otherwise reset it, and record the last volume
            this.gPPS.mute = false;
          }
        ]]>
      </body>
    </method>

    <method name="onReleaseVolume">
      <body>
        <![CDATA[
          this.trackingVolume = false;
          this.gPPS.volume = this.value;
          if (this.value != 0) {
            this.remote_lastVolume.intValue = this.value;
          }
        ]]>
      </body>
    </method>

    <method name="onRemoteVolumeChange">
      <body>
        <![CDATA[
          try {
            if (this.trackingVolume) // if volume is being actively changed, wait until release
              return; 
            this.value = this.remote_volume.intValue;
          } catch (err) {
            dump("playerControls.xml - onRemoteVolumeChange - " + err + "\n");
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- MUTE CONTROL -->




  <binding id="mute-button">
  
   <content>
     <xul:sb-clickhold-button class="sb-player-mute-button-muteoff sb-player-button" sbid="mute-off" oncommand="onMute();" tooltiptext="&tooltip.control.mute;"/>
     <xul:sb-clickhold-button class="sb-player-mute-button-muteon sb-player-button"  sbid="mute-on"  oncommand="onMute();" tooltiptext="&tooltip.control.mute;"/>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind the data remotes
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_lastVolume = SB_NewDataRemote( "faceplate.volume.last", null );
        this.remote_mute = SB_NewDataRemote( "faceplate.mute", null );
        this.bindmuteon = SBDataBindElementAttribute( "faceplate.mute", this.mute_on, "hidden", true, true );
        this.bindmuteoff = SBDataBindElementAttribute( "faceplate.mute", this.mute_off, "hidden", true );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "mute binding destructor");
        if (this.bindmuteon) {
          this.bindmuteon.unbind();
          this.bindmuteon = null;
        }
        if (this.bindmuteoff) {
          this.bindmuteoff.unbind();
          this.bindmuteoff = null;
        }
      ]]>
    </destructor>

    <field name="mute_on">document.getAnonymousElementByAttribute(this, 'sbid', 'mute-on');</field>
    <field name="mute_off">document.getAnonymousElementByAttribute(this, 'sbid', 'mute-off');</field>

    <method name="onMute">
      <body>
        <![CDATA[
          var newmute = !this.gPPS.mute; 
          this.gPPS.mute = newmute;
          if (!newmute) {
            // restore last volume when coming back from mute state
            this.gPPS.volume = this.remote_lastVolume.intValue;
          } 
          else {
            this.remote_lastVolume.intValue = this.remote_volume.intValue;
            this.gPPS.volume = 0;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  

  <!-- FORWARD BUTTON-->

  
  
  
  <binding id="forward-button" extends="chrome://global/content/bindings/button.xml#button">

   <handlers>
     <handler event="mousedown" button="0" action="this.onFwdMouseDown();"/>
     <handler event="mouseup" button="0" action="this.onFwdMouseUp();"/>
     <handler event="mouseout" action="this.onFwdMouseOut();"/>
     <handler event="mouseover" action="this.onFwdMouseOver();"/>
   </handlers>

  <implementation>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.fwd;")
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
    </destructor>
    
    <method name="onFwdMouseDown">
      <body>
        <![CDATA[
          this.seen_skip = false;
          if ( this.gPPS.playing )
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOut">
      <body>
        <![CDATA[
           if (this.skip_interval) {
             clearInterval( this.skip_interval );
             this.skip_interval = null;
           }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOver">
      <body>
        <![CDATA[
           if (this.skip && !this.skip_interval ) {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
           }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseUp">
      <body>
        <![CDATA[
          this.skip = false;
          this.onFwdCommand();
        ]]>
      </body>
    </method>

    <method name="onFwdCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.gPPS.next();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          if ( _this.skip )
          {
            _this.seen_skip = true;
            _this.gPPS.position = _this.gPPS.position + 15000;
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- BACK BUTTON-->

  
  
  
  <binding id="back-button" extends="chrome://global/content/bindings/button.xml#button">

   <handlers>
     <handler event="mousedown" button="0" action="this.onBackMouseDown();"/>
     <handler event="mouseup" button="0" action="this.onBackMouseUp();"/>
     <handler event="mouseout" action="this.onBackMouseOut();"/>
     <handler event="mouseover" action="this.onBackMouseOver();"/>
   </handlers>

  <implementation>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.back;")
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
    </destructor>
    
    <method name="onBackMouseDown">
      <body>
        <![CDATA[
          this.seen_skip = false;
          if ( this.gPPS.playing )
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onBackMouseUp">
      <body>
        <![CDATA[
          this.skip = false;
          this.onBackCommand();
        ]]>
      </body>
    </method>

    <method name="onBackMouseOut">
      <body>
        <![CDATA[
           if (this.skip_interval) {
             clearInterval( this.skip_interval );
             this.skip_interval = null;
           }
        ]]>
      </body>
    </method>

    <method name="onBackMouseOver">
      <body>
        <![CDATA[
           if (this.skip && !this.skip_interval ) {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
           }
        ]]>
      </body>
    </method>

    <method name="onBackCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.gPPS.previous();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          if ( _this.skip )
          {
            _this.seen_skip = true;
            _this.gPPS.position = _this.gPPS.position - 15000;
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- REPEAT CONTROL -->




  <binding id="repeat-button">
  
   <content>
     <xul:stack xbl:inherits="class=class" >
       <xul:sb-clickhold-button sbid="repeat_none" class="sb-player-repeat-button-repnone sb-player-button" oncommand="onRepeat(event.target);" tooltiptext="&menu.control.repx;">
         <xul:menuitem id="menu_repeat_none" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
         <xul:menuitem id="menu_repeat_1" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
         <xul:menuitem id="menu_repeat_all" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
       </xul:sb-clickhold-button>
       <xul:sb-clickhold-button sbid="repeat_1" class="sb-player-repeat-button-rep1 sb-player-button" oncommand="onRepeat(event.target);" tooltiptext="&menu.control.rep1;">
         <xul:menuitem id="menu_repeat_none" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
         <xul:menuitem id="menu_repeat_1" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
         <xul:menuitem id="menu_repeat_all" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
       </xul:sb-clickhold-button>
       <xul:sb-clickhold-button sbid="repeat_all" class="sb-player-repeat-button-repall sb-player-button" oncommand="onRepeat(event.target);" tooltiptext="&menu.control.repa;">
         <xul:menuitem id="menu_repeat_none" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
         <xul:menuitem id="menu_repeat_1" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
         <xul:menuitem id="menu_repeat_all" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
       </xul:sb-clickhold-button>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_repeat = SB_NewDataRemote( "playlist.repeat", null );
        this.repnonebinding = SBDataBindElementAttribute( "playlist.repeat", this.repeat_none, "hidden", true, false, "parseInt( value ) != 0" );
        this.rep1binding = SBDataBindElementAttribute( "playlist.repeat", this.repeat_1, "hidden", true, false, "parseInt( value ) != 1" );
        this.repallbinding = SBDataBindElementAttribute( "playlist.repeat", this.repeat_all, "hidden", true, false, "parseInt( value ) != 2" );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "repeat binding destructor");
        if (this.repnonebinding) {
          this.repnonebinding.unbind();
          this.repnonebinding = null;
        }
        if (this.rep1binding) {
          this.rep1binding.unbind();
          this.rep1binding = null;
        }
        if (this.repallbinding) {
          this.repallbinding.unbind();
          this.repallbinding = null;
        }
      ]]>
    </destructor>

    <field name="repeat_none">document.getAnonymousElementByAttribute(this, 'sbid', 'repeat_none');</field>
    <field name="repeat_1">document.getAnonymousElementByAttribute(this, 'sbid', 'repeat_1');</field>
    <field name="repeat_all">document.getAnonymousElementByAttribute(this, 'sbid', 'repeat_all');</field>

    <method name="onRepeat">
      <parameter name="target"/>
      <body>
        <![CDATA[
          var value = 0;
          switch(target.id) 
          {
            case "menu_repeat_none": 
              value = 0;
              break;
            case "menu_repeat_1": 
              value = 1;
              break;
            case "menu_repeat_all": 
              value = 2;
              break;
            default:
              switch ( this.remote_repeat.intValue )
              {
                case 0:
                  value = 2;
                  break;
                case 1:
                  value = 0;
                  break;
                case 2:
                  value = 1;
                  break;
              }
              break;
          }
          this.remote_repeat.intValue = value;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- SHUFFLE CONTROL -->




  <binding id="shuffle-button">
  
   <content>
     <xul:stack xbl:inherits="class=class" >
       <xul:sb-clickhold-button sbid="shuffle_off" class="sb-player-shuffle-button-shuffleoff sb-player-button" oncommand="onShuffle( );" tooltiptext="&tooltip.control.shuf_off;"/>
       <xul:sb-clickhold-button sbid="shuffle_on" class="sb-player-shuffle-button-shuffleon sb-player-button" oncommand="onShuffle( );" tooltiptext="&tooltip.control.shuffle;"/>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_shuffle = SB_NewDataRemote( "playlist.shuffle", null );
        this.bindshuffleoff = SBDataBindElementAttribute( "playlist.shuffle", this.shuffle_off, "hidden", true );
        this.bindshuffleon = SBDataBindElementAttribute( "playlist.shuffle", this.shuffle_on, "hidden", true, true );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "shuffle binding destructor");
        if (this.bindshuffleoff) {
          this.bindshuffleoff.unbind()
          this.bindshuffleoff = null;
        }
        if (this.bindshuffleon) {
          this.bindshuffleon.unbind()
          this.bindshuffleon = null;
        }
      ]]>
    </destructor>

    <field name="shuffle_off">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_off');</field>
    <field name="shuffle_on">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_on');</field>
    
    <method name="onShuffle">
      <body>
        <![CDATA[
          this.remote_shuffle.boolValue = !this.remote_shuffle.boolValue;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- SEEK CONTROL -->

  
  
  
  <binding id="seek-slider" extends="chrome://songbird/content/bindings/progressSlider.xml#progress-slider">

   <handlers>
     <handler event="progressSliderChange" action="this.onTrackSeekbar();"/>
     <handler event="progressSliderRelease" action="this.onReleaseSeekbar();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // observer for DataRemote 
        const on_remote_position_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onRemotePositionChange(); } 
        };
        on_remote_position_change._that = this;

        // Create and bind data remotes
        this.remote_position = SB_NewDataRemote( "metadata.position", null );
        this.remote_position.bindObserver(on_remote_position_change, true);
        this.remote_length = SBDataBindElementProperty( "metadata.length", this, "maxpos" );
       
        this.trackingPosition = 0;
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "seek-slider binding destructor");
        if (this.remote_position) {
          this.remote_position.unbind();
          this.remote_position = null;
        }
        if (this.remote_length) {
          this.remote_length.unbind();
          this.remote_length = null;
        }
      ]]>
    </destructor>

    <method name="onTrackSeekbar">
      <body>
        <![CDATA[
          this.trackingPosition = 1;
        ]]>
      </body>
    </method>

    <method name="onReleaseSeekbar">
      <body>
        this.gPPS.position = this.value;
        this.trackingPosition = 0;
      </body>
    </method>

    <method name="onRemotePositionChange">
      <body>
        <![CDATA[
          try {
            if (this.trackingPosition) return; // we are the control changing the position, ignore this callback
            this.value = this.gPPS.position;
          } catch (e) {
            alert("playerControls.xml - onRemotePositionChange - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- TOTALTIME CONTROL -->




  <binding id="totaltime-label">
  
   <content>
     <xul:label sbid="timelabel" xbl:inherits="class,align,crop,disabled,flex" onmousedown="onTotalDown();"/> 
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remote
        this.remote_showRemaining = SB_NewDataRemote( "faceplate.showremainingtime", null );
        this.bindtotaltime = SBDataBindElementAttribute( "metadata.length.str", this.label, "value" );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "totaltime binding destructor");
        if (this.bindtotaltime) {
          this.bindtotaltime.unbind();
          this.bindtotaltime = null;
        }
      ]]>
    </destructor>

    <field name="label">document.getAnonymousElementByAttribute(this, 'sbid', 'timelabel');</field>
    
    <method name="onTotalDown">
      <body>
        <![CDATA[
          var len = this.gPPS.length;
          if ( len > 0 )
            this.remote_showRemaining.boolValue = !this.remote_showRemaining.boolValue;
          // If you try to toggle it while it is zero, you lose the state.
          else
            this.remote_showRemaining.boolValue = false;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>




  <!-- PLAYPAUSE/PLAY/PAUSE/STOP CONTROLS -->


  <binding id="play-control-base">

    <implementation>

      <constructor>
        <![CDATA[
          this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                      .getService(Components.interfaces.sbIPlaylistPlayback);
        // Create and bind data remotes
        this.remote_seenPlaying = SB_NewDataRemote( "faceplate.seenplaying", null );
        this.remote_playingRef =  SB_NewDataRemote( "playing.ref", null ); 
        this.remote_playlistIndex =  SB_NewDataRemote( "playlist.index", null ); 
        ]]>
      </constructor>
      <destructor>
        this.gPPS = null;
        if (this.remote_seenPlaying) {
          this.remote_seenPlaying.unbind();
          this.remote_seenPlaying = null;
        }
        if (this.remote_playingRef) {
          this.remote_playingRef.unbind();
          this.remote_playingRef = null;
        }
        if (this.remote_playlistIndex) {
          this.remote_playlistIndex.unbind();
          this.remote_playlistIndex = null;
        }
      </destructor>
                     
      <method name="playbackPlay">
        <body>
          <![CDATA[
            var ref = "";
            if (this.gPPS.started ||
                (this.remote_playingRef.stringValue != "" &&
                  this.remote_playlistIndex.stringValue != "") ) {
              if (this.gPPS.paused) {
                this.gPPS.play();
              } else {
                // player is buffering (or stopped!), because the play button is visible (not started) yet 
                // pause is not set and the player is started.  start the playlist again at the current spot
                this.gPPS.playRef( this.remote_playingRef.stringValue, this.remote_playlistIndex.intValue );
              }
            } else {
              var ref = "";
              var playlist = this.getCurrentPlaylist();
              if (playlist) {
                ref = playlist.ref;
              } 
              if (ref == "") {
                this.loadLibrary();
                this.gPPS.play(); // let gpps handle default playback.
              } else {
                this.gPPS.playRef(ref, -1);
              }
            }
          ]]>
        </body>
      </method>

      <method name="loadLibrary">
        <body>
          <![CDATA[
            // optional connection
            if (gBrowser) gBrowser.loadURI("chrome://songbird/content/xul/playlist_test.xul?library" );
          ]]>
        </body>
      </method>

      <method name="getCurrentPlaylist">
        <body>
          <![CDATA[
            var pl = document.__CURRENTPLAYLIST__;
            if (!pl) pl = document.__CURRENTWEBPLAYLIST__;
            if (!pl) return null;
            if ( pl.wrappedJSObject )
              pl = pl.wrappedJSObject;
            return pl;
          ]]>
        </body>
      </method>

      <method name="playbackPause">
        <body>
          <![CDATA[
            if ( this.remote_seenPlaying.boolValue ) {
              this.gPPS.pause();
            }
          ]]>
        </body>
      </method>

      <method name="playbackStop">
        <body>
          <![CDATA[
            this.gPPS.stop();
          ]]>
        </body>
      </method>
      
    </implementation>

  </binding>


  <!-- a play button, always enabled because it is legitimate to restart playback in the middle of playback -->

  <binding id="play-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
   <content>
     <xul:sb-clickhold-button sbid="play" class="sb-player-play-button-play sb-player-button" oncommand="onPlay();" tooltiptext="&tooltip.control.play;"/>
   </content>

  <implementation>

    <method name="onPlay">
      <body>
        this.playbackPlay();
      </body>
    </method>

   </implementation>
 
  </binding>


  <!-- a pause/restore button -->

  <binding id="pause-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
   <content>
     <xul:stack xbl:inherits="class=class" >
       <xul:sb-clickhold-button sbid="pause" class="sb-player-pause-button-pause sb-player-button" oncommand="onPause();" label="&menu.control.pause.button;"/>
       <xul:sb-clickhold-button sbid="resume" class="sb-player-pause-button-resume sb-player-button" oncommand="onPause();" label="&menu.control.resume.button;"/>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        // Create and bind the data remotes
        this.remote_playing = SB_NewDataRemote( "faceplate.playing", null );
        this.remote_paused = SB_NewDataRemote( "faceplate.paused", null );

        this.on_state_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onStateChange(); } 
        };
        this.on_state_change._that = this;
        
        this.remote_playing.bindObserver(this.on_state_change, false);
        this.remote_paused.bindObserver(this.on_state_change, false);

      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.remote_playing) {
          this.remote_playing.unbind();
          this.remote_playing = null;
          this.on_state_change._that = null;
          this.on_state_change = null;
        }
        if (this.remote_paused) {
          this.remote_paused.unbind();
          this.remote_paused = null;
          this.on_state_change._that = null;
          this.on_state_change = null;
        }
      ]]>
    </destructor>

    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>
    <field name="resume">document.getAnonymousElementByAttribute(this, 'sbid', 'resume');</field>

    <method name="onStateChange">
      <body>
        <![CDATA[
          if (!this.remote_playing.boolValue) {
            // if we are not playing, disable both buttons, pause button will be made visible by default
            this.pause.setAttribute("disabled", "true");
            this.resume.setAttribute("disabled", "true");
          } else {
            // otherwise enable both buttons
            this.pause.removeAttribute("disabled");
            this.resume.removeAttribute("disabled");
          }
          if (this.remote_paused.boolValue) {
            // if we are paused (which implies that our buttons have been enabled), show only the resume button
            this.pause.removeAttribute("hidden");
            this.resume.setAttribute("hidden", "true");
          } else {
            // otherwise show the pause button. if the core is actually stopped, then the pause button will have been disabled
            this.pause.setAttribute("hidden", "true");
            this.resume.removeAttribute("hidden");
          }
        ]]>
      </body>
    </method>

    <method name="onPause">
      <body>
        this.playbackPause();
      </body>
    </method>

   </implementation>
 
  </binding>

  <!-- a stop button that enables itself when the core is playing, and disables itself when the core is stopped -->

  <binding id="stop-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
   <content>
     <xul:stack xbl:inherits="class=class" >
       <xul:sb-clickhold-button sbid="stop" class="sb-player-stop-button-stop sb-player-button" oncommand="onStop();" label="&menu.control.stop.button;"/>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        // Create and bind the data remotes
        this.bindstop = SBDataBindElementAttribute( "faceplate.playing", this.stop, "disabled", true, false);
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.bindstop) {
          this.bindstop.unbind();
          this.bindstop = null;
        }
      ]]>
    </destructor>

    <field name="stop">document.getAnonymousElementByAttribute(this, 'sbid', 'stop');</field>

    <method name="onStop">
      <body>
        this.playbackStop();
      </body>
    </method>

   </implementation>
 
  </binding>

  <binding id="playpause-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
   <content>
     <xul:sb-clickhold-button sbid="play" 
                         class="sb-player-play-button-play sb-player-button" 
                         oncommand="onPlayPause(event.target);" 
                         tooltiptext="&tooltip.control.play;" 
                         xbl:inherits="position,popupanchor,popupalign"
                         onmenushowing="syncMenus();">
       <xul:menuitem id="menu_play" class="menuitem-iconic" label="&menu.control.play.button;"/>
       <xul:menuitem id="menu_pause" class="menuitem-iconic" label="&menu.control.pause.button;"/>
       <xul:menuitem id="menu_stop" class="menuitem-iconic" label="&menu.control.stop.button;"/>
     </xul:sb-clickhold-button>
     <xul:sb-clickhold-button sbid="pause" 
                         class="sb-player-pause-button-pause sb-player-button" 
                         oncommand="onPlayPause(event.target);" 
                         tooltiptext="&tooltip.control.pause;" 
                         xbl:inherits="position,popupanchor,popupalign"
                         onmenushowing="syncMenus();">
       <xul:menuitem id="menu_play" class="menuitem-iconic" label="&menu.control.play.button;"/>
       <xul:menuitem id="menu_pause" class="menuitem-iconic" label="&menu.control.pause.button;"/>
       <xul:menuitem id="menu_stop" class="menuitem-iconic" label="&menu.control.stop.button;"/>
     </xul:sb-clickhold-button>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        // observer for DataRemote 
        this.on_state_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onStateChanged(); } 
        };
        this.on_state_change._that = this;
        this.remote_playing = SB_NewDataRemote("faceplate.playing", null);
        this.remote_paused = SB_NewDataRemote("faceplate.paused", null);
        this.remote_playing.bindObserver(this.on_state_change, false);
        this.remote_paused.bindObserver(this.on_state_change, false);
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
      ]]>
    </destructor>

    <field name="play">document.getAnonymousElementByAttribute(this, 'sbid', 'play');</field>
    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>

    <method name="onStateChanged">
      <body>
        <![CDATA[
          if (this.remote_playing.boolValue && !this.remote_paused.boolValue) { 
            this.play.hidden = true; 
            this.pause.hidden = false; 
          } else { 
            this.play.hidden = false; 
            this.pause.hidden = true; 
          }
        ]]>
      </body>
    </method>
    
    <method name="syncMenus">
      <body>
        this.syncMenu(this.play);
        this.syncMenu(this.pause);
      </body>
    </method>
    
    <method name="syncMenu">
      <parameter name="parent"/>
      <body>
        <![CDATA[
          for (var i=0;i<parent.childNodes.length;i++) {
            var node = parent.childNodes[i];
            switch (node.id) {
              case "menu_play":
                // play is disabled if we are already playing but we are not also paused (playing remains true while we are paused!)
                node.disabled = this.gPPS.playing && !this.gPPS.paused;
                break;
              case "menu_pause":
                // pause is disabled if we are already paused, or if we are stopped
                node.disabled = this.gPPS.paused || !this.gPPS.playing;
                break;
              case "menu_stop":
                // stop is disabled if we are already stopped (ie, the playbutton is visible, but we are not paused)
                node.disabled = !this.gPPS.playing;
                break;
            }
          }
        ]]>
      </body>
    </method>

    <method name="onPlay">
      <body>
        this.playbackPlay();
      </body>
    </method>
    
    <method name="onPause">
      <body>
        this.playbackPause();
      </body>
    </method>

    <method name="onStop">
      <body>
        this.playbackStop();
      </body>
    </method>
    
    <method name="onPlayPause">
      <parameter name="target"/>
      <body>
        <![CDATA[
          var sbid = target.getAttribute("sbid");
          if (sbid == "play") this.onPlay();
          else if (sbid == "pause") this.onPause();
          else {
            switch (target.id) {
              case "menu_play": this.onPlay(); break; 
              case "menu_pause": this.onPause(); break;
              case "menu_stop": this.onStop(); break;
            }
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>





  <!-- ARTIST DISPLAY -->




  <binding id="artist-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.artist";
    </constructor>

   </implementation>
 
  </binding>




  <!-- TITLE DISPLAY -->




  <binding id="title-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.data  = "metadata.title";
        this.autotip = this.getAttribute("autotip");
        if (this.autotip) {
          // observer for DataRemote 
          const on_remote_artist_album_change = { 
            _that: null, 
            observe: function( aSubject, aTopic, aData ) { this._that.rebuildTip(); } 
          };
          on_remote_artist_album_change._that = this;

          // Create and bind data remotes
          this.remote_artist = SB_NewDataRemote( "metadata.artist", null );
          this.remote_album = SB_NewDataRemote( "metadata.album", null );
          this.remote_artist.bindObserver(on_remote_artist_album_change, true);
          this.remote_album.bindObserver(on_remote_artist_album_change, true);

          this.rebuildTip();
      }
      ]]>
    </constructor>

    <destructor>
      <![CDATA[
        if (this.remote_album) {
          this.remote_album.unbind();
          this.remote_album = null;
        }
        if (this.remote_artist) {
          this.remote_artist.unbind();
          this.remote_artist = null
        }
      ]]>
    </destructor>

    <method name="rebuildTip">
      <body>
        <![CDATA[
          try {
            var tip = "";
            if ( this.remote_artist.stringValue &&
                 this.remote_artist.stringValue.length ) {
              tip = this.remote_artist.stringValue;
            }
            if ( this.remote_album.stringValue &&
                 this.remote_album.stringValue.length ) {
              if (tip.length > 0) tip += " / ";
              tip += this.remote_album.stringValue;
            }
            this.label.setAttribute("tooltiptext", tip);
          } catch (e) {
            alert("playerControls.xml - rebuildTip - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>




  <!-- ALBUM DISPLAY -->




  <binding id="album-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.album";
    </constructor>

   </implementation>
 
  </binding>




  <!-- TIME ELAPSED DISPLAY -->




  <binding id="timeelapsed-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.position.str";
    </constructor>

   </implementation>
 
  </binding>




  <!-- GENRE DISPLAY -->




  <binding id="genre-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.genre";
    </constructor>

   </implementation>
 
  </binding>




  <!-- CUSTOM DISPLAY -->



  <binding id="custom-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-compound-label">
  
  <implementation>

    <constructor>
      
      // this is a special version of a remote compound label, it takes its value from the preferences
      // and can be configured by the user from a preference pane
      
      this.setAttribute("value", SBDataGetStringValue("custom.display"));
    
    </constructor>

   </implementation>
 
  </binding>




  <!-- NUM PLAYLIST ITEMS DISPLAY -->




  <binding id="numplaylistitems-label" xextends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
    <content>
      <xul:label sbid="label" xbl:inherits="id,class,value,align,crop,disabled,flex"/> 
    </content>

    <implementation>
      <constructor>
        this._source = new sbIPlaylistsource();
        this.setInterval();
      </constructor>

      <destructor>
        clearInterval( this._interval );
      </destructor>

      <method name="setInterval">
        <body>
          <![CDATA[
            this._interval = setInterval( this.onInterval, 500, this );
          ]]>
        </body>
      </method>
 
      <method name="onInterval">
        <parameter name="that"/>
        <body>
          <![CDATA[
            // Look at what I do to have the correct 'this' pointer!  Woo!
            that.doInterval();
          ]]>
        </body>
      </method>
 
      <method name="doInterval">
        <body>
          <![CDATA[
          
          try
          {
            if (!gBrowser)
              return;
            
            // Display the number of items in the currently viewed playlist.
            var tree_ref = "";
            var display_string = "";
            // gBrowser.playlistTree is non-null when a playlist is showing.
            if (gBrowser.playlistTree)
            {
              tree_ref = gBrowser.playlistTree.getAttribute( "ref" );
            }
            else if (theWebPlaylistHasItems)
            {
              // If there is a web playlist query, then we can pop the webplaylist.
              var mediafound = SBString( "faceplate.mediafound", "Media Found" );
              var pct = parseInt( SBDataGetIntValue( "webplaylist.current" ) * 100 / SBDataGetIntValue( "webplaylist.total" ) );
              if ( pct < 100 )
              {
                display_string = mediafound + " " + pct + "%";
              }
              else
              {
                tree_ref = theWebPlaylist.ref;
              }
            }
            
            if ( tree_ref.length )
            {
              var rows = this._source.getRefRowCount( tree_ref );
              if ( rows > 0 )
              {
                var items = SBString( "faceplate.items", "items" );
                display_string = rows + " " + items;
              }
            }
            
            this.setAttribute( "value", display_string );
          }
          catch ( err )
          {
            alert( "PFU - " + err );
          }
          ]]>
        </body>
      </method>
    </implementation>
 
  </binding>




  <!-- PLAYER SCANNING DISPLAY -->




  <binding id="scanning-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.setAttribute( "hidden", "true" );
        this.data  = "backscan.status";

        // See if we want to pop our balloon tip.
        this.on_value_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onValue( aData ); } 
        };
        this.on_value_change._that = this;
        this.bindvalue = SB_NewDataRemote("backscan.concurrent", null);
        this.bindvalue.bindObserver( this.on_value_change, false );

//        this.setAttribute("onmousedown", "SBDataSetIntValue('backscan.paused', SBDataGetIntValue('backscan.paused') == 0 );");
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.bindvisible) {
          this.bindvisible.unbind();
          this.bindvisible = null;
        }
        if (this.bindvalue) {
          this.bindvalue.unbind();
          this.bindvalue = null;
        }
      ]]>
    </destructor>
    
    <method name="onValue">
      <parameter name="aData"/>
      <body>
        <![CDATA[
          if ( parseInt( aData ) > 0  )
          {
            this.setAttribute( "hidden", "false" );
            if ( ! SBDataGetBoolValue( "balloontip.backscan.shown" ) )
            {
              this.balloon = new BalloonTip();
              this.balloon.onCloseCallback = this.onBalloonClose;
              var title = SBString("balloontip.backscan.title", "Scanning For Metadata");
              var text = SBString("balloontip.backscan.text", "This indicates that Songbird is scanning the files in your Library to import their Metadata Tags.");
              this.balloon.showText(text, this, title, 'balloon-icon-songbird', null);
              this.balloon._that = this;
              SBDataSetBoolValue( "balloontip.backscan.shown", true )
            }
          }
          else
          {
            if ( ! this.balloon )
              this.setAttribute( "hidden", "true" );
          }
        ]]>
      </body>
    </method>
    
    <method name="onBalloonClose">
      <parameter name="aBalloonInstance"/>
      <parameter name="aCheckboxState"/>
      <body>
        <![CDATA[
          var that = aBalloonInstance._that;
          if ( SBDataGetIntValue("backscan.concurrent") < 1 )
            that.setAttribute( "hidden", "true" );
            
          that.balloon = null;
        ]]>
      </body>
    </method>
 

   </implementation>
 
  </binding>
  
  
  
  <!-- JUMP TO CURRENT TRACK BUTTON -->
  
  
  <binding id="curtrack-button">
    
    <content>
      <xul:sb-clickhold-button oncommand="onCurrentTrack( );" class="sb-player-curtrack-button sb-player-button" tooltiptext="&tooltip.control.curtrack;"/>
    </content>
    
    <implementation>
    
      <constructor>
        this.interval = null;
      </constructor>
      
      <destructor>
        if (this.interval) {
          clearInterval(this.interval);
          this.interval = null;
        }
      </destructor>
      
      <method name="onCurrentTrack">
        <body>
          <![CDATA[
            if (this.interval) {
              clearInterval(this.interval);
              this.interval = null;
            }
            var guid;
            var table;
            var ref = SBDataGetStringValue("playing.ref");
            if (ref != "") {
              source_ref = ref;
              var source = new sbIPlaylistsource();
              guid = source.getRefGUID( ref );
              table = source.getRefTable( ref );
            } else {
              source_ref = "NC:songbird_library";
              guid = "songbird";
              table = "library";
            }
            
            var curplaylist = document.__CURRENTPLAYLIST__;
            if (curplaylist && curplaylist.ref == source_ref) {
              curplaylist.syncPlaylistIndex(true);
              return;
            }
            
            this.loadView(guid, table);
            this.interval = setInterval(function(obj) { obj.onCurrentTrack(); }, 500, this); 
          ]]>
        </body>
      </method>
      
      <method name="loadView">
        <parameter name="guid"/>
        <parameter name="table"/>
        <body>
          <![CDATA[
            // optional connection
            if (gBrowser) {
              if (guid == "songbird" && table == "library")
                gBrowser.loadURI( "chrome://songbird/content/xul/playlist_test.xul?library");
              else 
                gBrowser.loadURI( "chrome://songbird/content/xul/playlist_test.xul?" + table+ "," + guid);
            }
          ]]>
        </body>
      </method>

    </implementation>
  </binding>
  
  
  
  
   
  <!-- TOGGLE JUMP TO WINDOW -->
  
  <binding id="jumpto-button" extends="chrome://global/content/bindings/button.xml#button">
    
    <handlers>
      <handler event="command" action="this.onCommand();"/>
    </handlers>
    
    <implementation>
    
      <constructor>
        this.setAttribute("tooltiptext", "&jumptofile.title;")
      </constructor>
      
      <method name="onCommand">
        <body>
          <![CDATA[
            // At this point there isn't much we can do other than hope that
            // jumptofile.js has been included in the window
            // TODO this will need to change once jumptofile has been refactored
            try {
              toggleJumpTo();
            } catch (e) {
              var msg = "sb-player-jumpto-button: unable to call toggleJumpTo.\n" +
                        "Please make sure this window includes jumptofile.js.\n";
              dump(msg);
              Components.utils.reportError(msg);
            }
          ]]>
        </body>
      </method>
      
    </implementation>
  </binding>


  <!-- ENTER FULLSCREEN MODE (WHEN PLAYING VIDEO) -->
  
  <binding id="fullscreen-button" extends="chrome://global/content/bindings/button.xml#button">
    
    <handlers>
      <handler event="command" action="this.onCommand();"/>
    </handlers>
    
    <implementation>
    
      <constructor>
        this.setAttribute("tooltiptext", "&tooltip.fullscreen;");
        
        // Mac fullscreen coming soon.
        var sysInfo = Components.classes["@mozilla.org/system-info;1"]
                                .getService(Components.interfaces.nsIPropertyBag2);
        if ( sysInfo.getProperty("name") == "Darwin" ) {
          this.setAttribute("hidden", "true");
        }
      </constructor>
      
      <method name="onCommand">
        <body>
          <![CDATA[
            var playlistPlayback = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                                             .getService(Components.interfaces.sbIPlaylistPlayback);
            playlistPlayback.goFullscreen();
          ]]>
        </body>
      </method>
      
    </implementation>
  </binding>
  

  
  
  <!-- EOF -->
</bindings>
