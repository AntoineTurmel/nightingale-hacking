<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE bindings SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">


  
  
  <!-- VOLUME CONTROL -->

  
  
  
  <binding id="volume-slider" extends="chrome://songbird/content/bindings/progressSlider.xml#progress-slider">

   <handlers>
     <handler event="progressSliderChange" action="this.onTrackVolume();"/>
     <handler event="progressSliderRelease" action="this.onReleaseVolume();"/>
   </handlers>

  <implementation>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.volume;")
      <![CDATA[
        Components.utils.import("resource://app/components/sbProperties.jsm");

        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        this.box.setAttribute("id", "sb-player-volume-slider" );
        
        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " sb-player-volume-slider");
      
        // Then do the rest of your crap
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);
 
        // observer for DataRemote 
        const on_remote_volume_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onRemoteVolumeChange(); } 
        };
        on_remote_volume_change._that = this;

        // Create and bind data remotes
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_lastVolume = SB_NewDataRemote("faceplate.volume.last", null );
        this.remote_volume.bindObserver(on_remote_volume_change, true);

        this.maxpos = 255;
        this.value = this.remote_volume.intValue;
        this.trackingVolume = false;
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.remote_volume) {
          this.remote_volume.unbind();
          this.remote_volume = null;
        }
        if (this.remote_lastVolume) {
          this.remote_lastVolume = null;
        }
      ]]>
    </destructor>
    
    <method name="onTrackVolume">
      <body>
        <![CDATA[
          // prevent this volume control from being updated while it is being
          //   moved (but other volume controls are updated with our motion)
          this.trackingVolume = true; 
          this.gPPS.volume = this.value;
          this.remote_volume.intValue = this.value;
          if (this.value == 0) {
            // set mute when we bring the volume to 0
            this.gPPS.mute = true;
          }
          else {
            // otherwise reset it, and record the last volume
            this.gPPS.mute = false;
          }
        ]]>
      </body>
    </method>

    <method name="onReleaseVolume">
      <body>
        <![CDATA[
          this.trackingVolume = false;
          this.gPPS.volume = this.value;
          if (this.value != 0) {
            this.remote_lastVolume.intValue = this.value;
          }
        ]]>
      </body>
    </method>

    <method name="onRemoteVolumeChange">
      <body>
        <![CDATA[
          try {
            if (this.trackingVolume) // if volume is being actively changed, wait until release
              return; 
            this.value = this.remote_volume.intValue;
          } catch (err) {
            dump("playerControls.xml - onRemoteVolumeChange - " + err + "\n");
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- MUTE CONTROL -->




  <binding id="mute-button">
  
    <content>
      <xul:hbox id="sb-player-mute-button" oncommand="onMute();" flex="1">
        <xul:sb-clickhold-button hidden="false" id="sb-player-mute-button-muteoff" class="sb-player-mute-button-muteoff sb-player-button" sbid="mute-off" tooltiptext="&tooltip.control.mute;" xbl:inherits="label,position,popupanchor,popupalign">
          <xul:observes type="dataremote"
                    key="faceplate.mute" 
                    attribute="hidden" 
                    boolean="true"
                    inverted="false" />  
          <xul:menuitem id="sb-player-mute-menu-muteoff" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&tooltip.control.mute;"/>
        </xul:sb-clickhold-button>
        <xul:sb-clickhold-button hidden="false" id="sb-player-mute-button-muteon" class="sb-player-mute-button-muteon sb-player-button" sbid="mute-on" tooltiptext="&tooltip.control.mute;" xbl:inherits="label,position,popupanchor,popupalign">
          <xul:observes type="dataremote"
                    key="faceplate.mute" 
                    attribute="hidden" 
                    boolean="true"
                    inverted="true" />  
          <xul:menuitem id="sb-player-mute-menu-muteon" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&tooltip.control.mute;"/>
        </xul:sb-clickhold-button>
      </xul:hbox>
    </content>

    <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind the data remotes
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_lastVolume = SB_NewDataRemote( "faceplate.volume.last", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "mute binding destructor");
        // Release the data remotes
        this.remote_volume = this.remote_lastVolume = null;
      ]]>
    </destructor>

    <field name="mute_on">document.getAnonymousElementByAttribute(this, 'sbid', 'mute-on');</field>
    <field name="mute_off">document.getAnonymousElementByAttribute(this, 'sbid', 'mute-off');</field>

    <method name="onMute">
      <body>
        <![CDATA[
          // Yikes.  If we hide the clickholdbutton because of the popupmenu,
          // the popupmenu gets broken.  Therefore, we wait until the next UI
          // frame to change the mute state.
          var that = this;
          setTimeout( function() { that.doMute() }, 0 );
        ]]>
      </body>
    </method>

    <method name="doMute">
      <body>
        <![CDATA[
          var newmute = !this.gPPS.mute; 
          this.gPPS.mute = newmute;
          if (!newmute) {
            // restore last volume when coming back from mute state
            this.gPPS.volume = this.remote_lastVolume.intValue;
          } 
          else {
            this.remote_lastVolume.intValue = this.remote_volume.intValue;
            this.gPPS.volume = 0;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  <!-- BASECLASS BINDINGS FOR SONGBIRD OVERLAY TRICKS
  
  These bindings will set some magic values inside of the objects we inherit from xpfe.
  
  It places the nodename as the id on the inner hbox for XBL Overlay and adds a class
  value that may be used in the CSS.
  
  -->
  <binding id="sb-button-base" extends="chrome://global/content/bindings/button.xml#button">
    <implementation>
      <constructor>
      <![CDATA[
        // ENFORCE CLICKABILITY!  (why do I have to do this?)
        this.setAttribute("mousethrough","never");
        
        // Get the nodename (without the namespace)
        var nameArray = this.nodeName.split(":");
        var nodeName = ( nameArray.length > 1 ) ? nameArray[ 1 ] : nameArray[ 0 ];
        
        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        var box = document.getAnonymousElementByAttribute(this, "class", "box-inherit button-box");
        box.setAttribute( 'id', nodeName );
        
        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " " + nodeName);
      ]]>
      </constructor>
    </implementation>
  </binding>

  <binding id="sb-checkbox-base" extends="chrome://global/content/bindings/checkbox.xml#checkbox-baseline">
    <implementation>
      <constructor>
      <![CDATA[
        // ENFORCE CLICKABILITY!  (why do I have to do this?)
        this.setAttribute("mousethrough","never");
        
        // Get the nodename (without the namespace)
        var nameArray = this.nodeName.split(":");
        var nodeName = ( nameArray.length > 1 ) ? nameArray[ 1 ] : nameArray[ 0 ];
        
        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        var box = document.getAnonymousElementByAttribute(this, "class", "checkbox-label-box");
        box.setAttribute( 'id', nodeName );
        
        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " " + nodeName);
      ]]>
      </constructor>
    </implementation>
  </binding>


  <!-- FORWARD BUTTON-->

  
  
  
  <binding id="forward-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">

  <handlers>
    <handler event="mousedown" button="0" action="this.onFwdMouseDown();"/>
    <handler event="mouseup" button="0" action="this.onFwdMouseUp();"/>
    <handler event="mouseout" action="this.onFwdMouseOut();"/>
    <handler event="mouseover" action="this.onFwdMouseOver();"/>
  </handlers>

  <implementation>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.fwd;")
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
    </destructor>
    
    <method name="onFwdMouseDown">
      <body>
        <![CDATA[
          this.seen_skip = false;
          if ( this.gPPS.playing )
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOut">
      <body>
        <![CDATA[
           if (this.skip_interval) {
             clearInterval( this.skip_interval );
             this.skip_interval = null;
           }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOver">
      <body>
        <![CDATA[
           if (this.skip && !this.skip_interval ) {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
           }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseUp">
      <body>
        <![CDATA[
          this.skip = false;
          this.onFwdCommand();
        ]]>
      </body>
    </method>

    <method name="onFwdCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.gPPS.next();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          if ( _this.skip )
          {
            _this.seen_skip = true;
            _this.gPPS.position = _this.gPPS.position + 15000;
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- BACK BUTTON-->

  
  
  
  <binding id="back-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">

   <handlers>
     <handler event="mousedown" button="0" action="this.onBackMouseDown();"/>
     <handler event="mouseup" button="0" action="this.onBackMouseUp();"/>
     <handler event="mouseout" action="this.onBackMouseOut();"/>
     <handler event="mouseover" action="this.onBackMouseOver();"/>
   </handlers>

  <implementation>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.back;")
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
    </destructor>
    
    <method name="onBackMouseDown">
      <body>
        <![CDATA[
          this.seen_skip = false;
          if ( this.gPPS.playing )
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onBackMouseUp">
      <body>
        <![CDATA[
          this.skip = false;
          this.onBackCommand();
        ]]>
      </body>
    </method>

    <method name="onBackMouseOut">
      <body>
        <![CDATA[
           if (this.skip_interval) {
             clearInterval( this.skip_interval );
             this.skip_interval = null;
           }
        ]]>
      </body>
    </method>

    <method name="onBackMouseOver">
      <body>
        <![CDATA[
           if (this.skip && !this.skip_interval ) {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
           }
        ]]>
      </body>
    </method>

    <method name="onBackCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.gPPS.previous();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          if ( _this.skip )
          {
            _this.seen_skip = true;
            _this.gPPS.position = _this.gPPS.position - 15000;
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- REPEAT CONTROL -->




  <binding id="repeat-button">
  
   <content>
     <xul:stack id="sb-player-repeat-button" xbl:inherits="class=class" >
       <xul:sb-clickhold-button id="repeat_none" class="sb-player-repeat-button-repnone sb-player-button" oncommand="onRepeat(event.target);" tooltiptext="&menu.control.repx;" xbl:inherits="label,position,popupanchor,popupalign">
         <xul:observes type="dataremote"
                   key="playlist.repeat" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 0" />  
         <xul:menuitem id="menu_repeat_none" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
         <xul:menuitem id="menu_repeat_all" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
         <xul:menuitem id="menu_repeat_1" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
       </xul:sb-clickhold-button>
       <xul:sb-clickhold-button id="repeat_1" class="sb-player-repeat-button-rep1 sb-player-button" oncommand="onRepeat(event.target);" tooltiptext="&menu.control.rep1;" xbl:inherits="label,position,popupanchor,popupalign">
         <xul:observes type="dataremote"
                   key="playlist.repeat" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 1" />  
         <xul:menuitem id="menu_repeat_none" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
         <xul:menuitem id="menu_repeat_all" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
         <xul:menuitem id="menu_repeat_1" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
       </xul:sb-clickhold-button>
       <xul:sb-clickhold-button id="repeat_all" class="sb-player-repeat-button-repall sb-player-button" oncommand="onRepeat(event.target);" tooltiptext="&menu.control.repa;" xbl:inherits="label,position,popupanchor,popupalign">
         <xul:observes type="dataremote"
                   key="playlist.repeat" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 2" />  
         <xul:menuitem id="menu_repeat_none" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
         <xul:menuitem id="menu_repeat_all" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
         <xul:menuitem id="menu_repeat_1" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
       </xul:sb-clickhold-button>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_repeat = SB_NewDataRemote( "playlist.repeat", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "repeat binding destructor");
        if (this.remote_repeat) {
          this.remote_repeat.unbind();
          this.remote_repeat = null;
        }
      ]]>
    </destructor>

    <field name="repeat_none">document.getAnonymousElementByAttribute(this, 'id', 'repeat_none');</field>
    <field name="repeat_1">document.getAnonymousElementByAttribute(this, 'id', 'repeat_1');</field>
    <field name="repeat_all">document.getAnonymousElementByAttribute(this, 'id', 'repeat_all');</field>

    <method name="onRepeat">
      <parameter name="target"/>
      <body>
        <![CDATA[
          var value = 0;
          switch( target.id )
          {
            case "menu_repeat_none": 
              value = 0;
              break;
            case "menu_repeat_1": 
              value = 1;
              break;
            case "menu_repeat_all":
              value = 2;
              break;
            default:
              switch ( this.remote_repeat.intValue )
              {
                case (0): // Apparently, "case 0:" != "case (0):" ?!?!?
                  value = 2;
                  break;
                case (1): // BUT, "case 1:" == "case (1):" ?!?!?
                  value = 0;
                  break;
                case (2):
                  value = 1;
                  break;
              }
              break;
          }
          this.remote_repeat.intValue = value;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- SHUFFLE CONTROL -->




  <binding id="shuffle-button">
  
   <content>
     <xul:stack id="sb-player-shuffle-button" xbl:inherits="class=class" oncommand="onShuffle( );">
       <xul:sb-clickhold-button id="sb-player-shuffle-button-off" sbid="shuffle_off" class="sb-player-shuffle-button-off sb-player-button" tooltiptext="&tooltip.control.shuf_off;" xbl:inherits="label,position,popupanchor,popupalign">
         <xul:observes type="dataremote"
                   key="playlist.shuffle" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 0" />  
         <xul:menuitem id="menu_shuffle_off" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&tooltip.control.shuffle;"/>
       </xul:sb-clickhold-button>
       <xul:sb-clickhold-button id="sb-player-shuffle-button-on" sbid="shuffle_on" class="sb-player-shuffle-button-on sb-player-button" tooltiptext="&tooltip.control.shuffle;" xbl:inherits="label,position,popupanchor,popupalign">
         <xul:observes type="dataremote"
                   key="playlist.shuffle" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 1" />  
         <xul:menuitem id="menu_shuffle_on" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&tooltip.control.shuffle;"/>
       </xul:sb-clickhold-button>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_shuffle = SB_NewDataRemote( "playlist.shuffle", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "shuffle binding destructor");
      ]]>
    </destructor>

    <field name="shuffle_off">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_off');</field>
    <field name="shuffle_on">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_on');</field>
    
    <method name="onShuffle">
      <body>
        <![CDATA[
          this.remote_shuffle.boolValue = !this.remote_shuffle.boolValue;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- SEEK CONTROL -->

  
  
  
  <binding id="seek-slider" extends="chrome://songbird/content/bindings/progressSlider.xml#progress-slider">

   <handlers>
     <handler event="progressSliderChange" action="this.onTrackSeekbar();"/>
     <handler event="progressSliderRelease" action="this.onReleaseSeekbar();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        this.box.setAttribute("id", "sb-player-seek-slider" );

        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " sb-player-seek-slider");

        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // observer for DataRemote 
        const on_remote_position_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onRemotePositionChange(); } 
        };
        on_remote_position_change._that = this;

        // Create and bind data remotes
        this.remote_position = SB_NewDataRemote( "metadata.position", null );
        this.remote_position.bindObserver(on_remote_position_change, true);
        this.remote_length = SBDataBindElementProperty( "metadata.length", this, "maxpos" );
       
        this.trackingPosition = 0;
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "seek-slider binding destructor");
        if (this.remote_position) {
          this.remote_position.unbind();
          this.remote_position = null;
        }
        if (this.remote_length) {
          this.remote_length.unbind();
          this.remote_length = null;
        }
      ]]>
    </destructor>

    <method name="onTrackSeekbar">
      <body>
        <![CDATA[
          this.trackingPosition = 1;
        ]]>
      </body>
    </method>

    <method name="onReleaseSeekbar">
      <body>
        this.gPPS.position = this.value;
        this.trackingPosition = 0;
      </body>
    </method>

    <method name="onRemotePositionChange">
      <body>
        <![CDATA[
          try {
            if (this.trackingPosition) return; // we are the control changing the position, ignore this callback
            this.value = this.gPPS.position;
          } catch (e) {
            alert("playerControls.xml - onRemotePositionChange - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
 
  <!-- PLAYPAUSE/PLAY/PAUSE/STOP CONTROLS -->


  <binding id="play-control-base">

    <implementation>

      <constructor>
        <![CDATA[
          this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                      .getService(Components.interfaces.sbIPlaylistPlayback);
        // Create and bind data remotes
        this.remote_seenPlaying = SB_NewDataRemote( "faceplate.seenplaying", null );
        ]]>
      </constructor>
      <destructor>
        this.gPPS = null;
        if (this.remote_seenPlaying) {
          this.remote_seenPlaying.unbind();
          this.remote_seenPlaying = null;
        }
      </destructor>
                     
      <method name="playbackPlay">
        <body>
          <![CDATA[
            if (this.gPPS.playing) {
              // if we're playing already then play / pause
              if (this.gPPS.paused) {
                this.gPPS.play();
              } else {
                this.gPPS.pause();
              }
            } else if (window.gBrowser && window.gBrowser.currentPlaylist) {
              // if there's a browser and a playlist active, tell the playlist
              // to play itself
              gBrowser.currentPlaylist.sendPlayEvent();
            } else {

              // otherwise go get the library and play it
              var libraryManager =
                Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                          .getService(Components.interfaces.sbILibraryManager);
              var view = libraryManager.mainLibrary.createView();

              // Filter the view as if it is being shown in the UI to determine
              // if this library actually has anything playable in it
              view.setFilters(SBProperties.createArray([
                [SBProperties.isList, "0"],
                [SBProperties.hidden, "0"]
              ]));
              if (view.length > 0) {
                this.gPPS.playView(view, 0);
              }
            }
          ]]>
        </body>
      </method>

      <method name="loadLibrary">
        <body>
          <![CDATA[
            // optional connection
            if (window.gBrowser) gBrowser.loadURI("chrome://songbird/content/xul/playlist_test2.xul?library" );
          ]]>
        </body>
      </method>

      <method name="playbackPause">
        <body>
          <![CDATA[
            if ( this.remote_seenPlaying.boolValue ) {
              this.gPPS.pause();
            }
          ]]>
        </body>
      </method>

      <method name="playbackStop">
        <body>
          <![CDATA[
            this.gPPS.stop();
          ]]>
        </body>
      </method>
      
    </implementation>

  </binding>


  <!-- a play button, always enabled because it is legitimate to restart playback in the middle of playback -->

  <binding id="play-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-play-button" flex="1" xbl:inherits="hidden,class">
      
        <xul:sb-clickhold-button id="sb-player-play-button-play" sbid="play" 
                  class="sb-player-play-button-play sb-player-button" 
                  oncommand="onPlay();" 
                  tooltiptext="&tooltip.control.play;" 
                  xbl:inherits="label,position,popupanchor,popupalign"/>
          
      </xul:hbox>
    </content>

  <implementation>

    <method name="onPlay">
      <body>
        this.playbackPlay();
      </body>
    </method>

   </implementation>
 
  </binding>


  <!-- a pause/restore button -->

  <binding id="pause-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-pause-button" flex="1" xbl:inherits="hidden,class">
        <xul:stack xbl:inherits="class=class" >
        
          <xul:sb-clickhold-button id="sb-player-pause-button-pause" sbid="pause" 
                    class="sb-player-pause-button-pause sb-player-button" 
                    onmousedown="onPause();" 
                    tooltiptext="&tooltip.control.pause;" 
                    xbl:inherits="label,position,popupanchor,popupalign">
            
            <xul:observes type="dataremote"
                      key="faceplate.playing" 
                      attribute="disabled" 
                      boolean="true"
                      inverted="true"/>  
            <xul:observes type="dataremote"
                      key="faceplate.paused" 
                      attribute="hidden" 
                      boolean="true"
                      inverted="false"/>  
          </xul:sb-clickhold-button>
          
          <xul:sb-clickhold-button id="sb-player-pause-button-resume" sbid="resume" 
                    class="sb-player-pause-button-resume sb-player-button" 
                    oncommand="onPlay();" 
                    tooltiptext="&tooltip.control.resume;" 
                    xbl:inherits="label,position,popupanchor,popupalign">
            
            <xul:observes type="dataremote"
                      key="faceplate.playing" 
                      attribute="disabled" 
                      boolean="true"
                      inverted="true"/>  
            <xul:observes type="dataremote"
                      key="faceplate.paused" 
                      attribute="hidden" 
                      boolean="true"
                      inverted="true"/>  
          </xul:sb-clickhold-button>
          
        </xul:stack>
      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
      ]]>
    </destructor>

    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>
    <field name="resume">document.getAnonymousElementByAttribute(this, 'sbid', 'resume');</field>

    <method name="onPause">
      <body>
        this.playbackPause();
      </body>
    </method>

    <method name="onPlay">
      <body>
        this.playbackPlay();
      </body>
    </method>

   </implementation>
 
  </binding>

  <!-- a stop button that enables itself when the core is playing, and disables itself when the core is stopped -->

  <binding id="stop-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-stop-button" flex="1" xbl:inherits="hidden,class">
      
        <xul:sb-clickhold-button id="sb-player-stop-button-stop" sbid="stop" 
                  class="sb-player-stop-button-stop sb-player-button" 
                  oncommand="onStop();" 
                  tooltiptext="&tooltip.control.stop;" 
                  xbl:inherits="label,position,popupanchor,popupalign">
          
          <xul:observes type="dataremote"
                    key="faceplate.playing" 
                    attribute="disabled" 
                    boolean="true"
                    inverted="true" />  
        </xul:sb-clickhold-button>
        
      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
      ]]>
    </destructor>

    <field name="stop">document.getAnonymousElementByAttribute(this, 'sbid', 'stop');</field>

    <method name="onStop">
      <body>
        this.playbackStop();
      </body>
    </method>

   </implementation>
 
  </binding>



  <binding id="playpause-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-playpause-button" flex="1" xbl:inherits="hidden,class">
      
        <xul:sb-clickhold-button id="sb-player-playpause-button-play" sbid="play" 
                            class="sb-player-playpause-button-play sb-player-button" 
                            oncommand="onPlayPause(event.target);" 
                            tooltiptext="&tooltip.control.play;" 
                            xbl:inherits="label,position,popupanchor,popupalign"
                            onmenushowing="syncMenus();">
          <xul:menuitem id="menu_play" class="menuitem-iconic" label="&menu.control.play.button;"/>
          <xul:menuitem id="menu_pause" class="menuitem-iconic" label="&menu.control.pause.button;"/>
          <xul:menuitem id="menu_stop" class="menuitem-iconic" label="&menu.control.stop.button;"/>
        </xul:sb-clickhold-button>
        
        <xul:sb-clickhold-button id="sb-player-playpause-button-pause" sbid="pause" 
                            class="sb-player-playpause-button-pause sb-player-button" 
                            oncommand="onPlayPause(event.target);" 
                            tooltiptext="&tooltip.control.pause;" 
                            xbl:inherits="label,position,popupanchor,popupalign"
                            onmenushowing="syncMenus();">
          <xul:menuitem id="menu_play" class="menuitem-iconic" label="&menu.control.play.button;"/>
          <xul:menuitem id="menu_pause" class="menuitem-iconic" label="&menu.control.pause.button;"/>
          <xul:menuitem id="menu_stop" class="menuitem-iconic" label="&menu.control.stop.button;"/>
        </xul:sb-clickhold-button>
        
      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
        // observer for DataRemote 
        this.on_state_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onStateChanged(); } 
        };
        this.on_state_change._that = this;
        this.remote_playing = SB_NewDataRemote("faceplate.playing", null);
        this.remote_paused = SB_NewDataRemote("faceplate.paused", null);
        this.remote_playing.bindObserver(this.on_state_change, false);
        this.remote_paused.bindObserver(this.on_state_change, false);
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
      ]]>
    </destructor>

    <field name="play">document.getAnonymousElementByAttribute(this, 'sbid', 'play');</field>
    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>

    <method name="onStateChanged">
      <body>
        <![CDATA[
          if (this.remote_playing.boolValue && !this.remote_paused.boolValue) { 
            this.play.hidden = true; 
            this.pause.hidden = false; 
          } else { 
            this.play.hidden = false; 
            this.pause.hidden = true; 
          }
        ]]>
      </body>
    </method>
    
    <method name="syncMenus">
      <body>
        this.syncMenu(this.play);
        this.syncMenu(this.pause);
      </body>
    </method>
    
    <method name="syncMenu">
      <parameter name="parent"/>
      <body>
        <![CDATA[
          for (var i=0;i<parent.childNodes.length;i++) {
            var node = parent.childNodes[i];
            switch (node.id) {
              case "menu_play":
                // play is disabled if we are already playing but we are not also paused (playing remains true while we are paused!)
                node.disabled = this.gPPS.playing && !this.gPPS.paused;
                break;
              case "menu_pause":
                // pause is disabled if we are already paused, or if we are stopped
                node.disabled = this.gPPS.paused || !this.gPPS.playing;
                break;
              case "menu_stop":
                // stop is disabled if we are already stopped (ie, the playbutton is visible, but we are not paused)
                node.disabled = !this.gPPS.playing;
                break;
            }
          }
        ]]>
      </body>
    </method>

    <method name="onPlay">
      <body>
        this.playbackPlay();
      </body>
    </method>
    
    <method name="onPause">
      <body>
        this.playbackPause();
      </body>
    </method>

    <method name="onStop">
      <body>
        this.playbackStop();
      </body>
    </method>
    
    <method name="onPlayPause">
      <parameter name="target"/>
      <body>
        <![CDATA[
          var sbid = target.getAttribute("sbid");
          if (sbid == "play") this.onPlay();
          else if (sbid == "pause") this.onPause();
          else {
            switch (target.id) {
              case "menu_play": this.onPlay(); break; 
              case "menu_pause": this.onPause(); break;
              case "menu_stop": this.onStop(); break;
            }
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>



  <!-- CONTROL PANE BUTTONS BLOCK -->

  <binding id="control-buttons">

    <content>
      <xul:hbox id="sb-player-control-buttons" flex="1" xbl:inherits="class,hidden">
        <xul:sb-player-back-button id="songbird_btn_back" class="sb-player-button" xbl:inherits="class"/>
        <!-- Bonus Buttons!
          <xul:sb-player-pause-button id="songbird_btn_pause" popupanchor="topleft" popupalign="bottomleft"/>
          <xul:sb-player-play-button id="songbird_btn_play" popupanchor="topleft" popupalign="bottomleft"/>
          <xul:sb-player-stop-button id="songbird_btn_stop" popupanchor="topleft" popupalign="bottomleft"/>
        -->
        <xul:sb-player-playpause-button id="songbird_btn_play_pause" class="sb-player-button" xbl:inherits="class" popupanchor="topleft" popupalign="bottomleft"/>
        <xul:sb-player-forward-button id="songbird_btn_fwd" class="sb-player-button" xbl:inherits="class"/> 
      </xul:hbox>
    </content>
  
    <implementation>
      <constructor>
      </constructor>
    </implementation>
 
  </binding>



  <!-- TOTALTIME DISPLAY -->

  <binding id="totaltime-label">
  
    <content>
      <xul:hbox id="sb-player-totaltime-label" flex="1" xbl:inherits="class,align,crop,disabled,flex">
        <xul:label sbid="timelabel" xbl:inherits="class,align,crop,disabled,flex" mousethrough="never">
          <xul:observes type="dataremote"
                    key="metadata.length.str" 
                    attribute="value"/>  
        </xul:label>
      </xul:hbox>
    </content>

    <handlers>
      <handler event="mousedown" action="this.onTotalDown();"/>
    </handlers>


  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remote
        this.remote_showRemaining = SB_NewDataRemote( "faceplate.showremainingtime", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "totaltime binding destructor");
        this.remote_showRemaining = null;
      ]]>
    </destructor>

    <method name="onTotalDown">
      <body>
        <![CDATA[
          var len = this.gPPS.length;
          if ( len > 0 )
            this.remote_showRemaining.boolValue = !this.remote_showRemaining.boolValue;
          // If you try to toggle it while it is zero, you lose the state.
          else
            this.remote_showRemaining.boolValue = false;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>



  <!-- ARTIST DISPLAY -->


  <binding id="artist-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
    <implementation>

      <constructor>
        this.data  = "metadata.artist";
      </constructor>

    </implementation>
 
  </binding>



  <!-- TITLE DISPLAY -->


  <binding id="title-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.data  = "metadata.title";
        this.autotip = this.getAttribute("autotip");
        if (this.autotip) {
          // observer for DataRemote 
          const on_remote_artist_album_change = { 
            _that: null, 
            observe: function( aSubject, aTopic, aData ) { this._that.rebuildTip(); } 
          };
          on_remote_artist_album_change._that = this;

          // Create and bind data remotes
          this.remote_artist = SB_NewDataRemote( "metadata.artist", null );
          this.remote_album = SB_NewDataRemote( "metadata.album", null );
          this.remote_artist.bindObserver(on_remote_artist_album_change, true);
          this.remote_album.bindObserver(on_remote_artist_album_change, true);

          this.rebuildTip();
      }
      ]]>
    </constructor>

    <destructor>
      <![CDATA[
        if (this.remote_album) {
          this.remote_album.unbind();
          this.remote_album = null;
        }
        if (this.remote_artist) {
          this.remote_artist.unbind();
          this.remote_artist = null
        }
      ]]>
    </destructor>

    <method name="rebuildTip">
      <body>
        <![CDATA[
          try {
            var tip = "";
            if ( this.remote_artist.stringValue &&
                 this.remote_artist.stringValue.length ) {
              tip = this.remote_artist.stringValue;
            }
            if ( this.remote_album.stringValue &&
                 this.remote_album.stringValue.length ) {
              if (tip.length > 0) tip += " / ";
              tip += this.remote_album.stringValue;
            }
            this.label.setAttribute("tooltiptext", tip);
          } catch (e) {
            alert("playerControls.xml - rebuildTip - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>



  <!-- ALBUM DISPLAY -->


  <binding id="album-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.album";
    </constructor>

   </implementation>
 
  </binding>




  <!-- TIME ELAPSED DISPLAY -->




  <binding id="timeelapsed-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.position.str";
    </constructor>

   </implementation>
 
  </binding>




  <!-- GENRE DISPLAY -->




  <binding id="genre-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.genre";
    </constructor>

   </implementation>
 
  </binding>




  <!-- CUSTOM DISPLAY -->



  <binding id="custom-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-compound-label">
  
  <implementation>

    <constructor>
      
      // this is a special version of a remote compound label, it takes its value from the preferences
      // and can be configured by the user from a preference pane
      
      this.setAttribute("value", SBDataGetStringValue("custom.display"));
    
    </constructor>

   </implementation>
 
  </binding>




  <!-- NUM PLAYLIST ITEMS DISPLAY -->




  <binding id="numplaylistitems-label" xextends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
    <content>
      <xul:hbox id="sb-player-numplaylistitems-label" flex="1" xbl:inherits="class">
        <xul:label id="sb-player-numplaylistitems-label-label" sbid="label" xbl:inherits="class,value,align,crop,disabled,flex"/> 
      </xul:hbox>
    </content>

    <implementation>
      <constructor>
        this.setInterval();
      </constructor>

      <destructor>
        clearInterval( this._interval );
      </destructor>

      <method name="setInterval">
        <body>
          <![CDATA[
            this._interval = setInterval( this.onInterval, 500, this );
          ]]>
        </body>
      </method>
 
      <method name="onInterval">
        <parameter name="that"/>
        <body>
          <![CDATA[
            // Look at what I do to have the correct 'this' pointer!  Woo!
            that.doInterval();
          ]]>
        </body>
      </method>
 
      <method name="doInterval">
        <body>
          <![CDATA[
          try
          {
            if (!gBrowser)
              return;
            
            var displayValue = ''
            if (gBrowser.mCurrentTab.scanProgress >= 0 &&
                gBrowser.mCurrentTab.scanProgress < 1) {
              // display page scan progress
              var mediafound = SBString("faceplate.mediafound", "Media Found");
              var percent = Math.round(gBrowser.mCurrentTab.scanProgress*100);
              displayValue = mediafound + ': ' + percent + '%';
            } else if (gBrowser.currentPlaylist != null &&
                       gBrowser.currentPlaylist.mediaListView != null &&
                       gBrowser.currentPlaylist.mediaListView.length > 0) {
              // display media list length
              displayValue = SBString("faceplate.items", "items") + ': ' +
                  gBrowser.currentPlaylist.mediaListView.length;
            }
            var label = document.getAnonymousElementByAttribute(this, "sbid", "label");
            label.setAttribute('value', displayValue);
          }
          catch ( err )
          {
            alert( "numplaylistitems-label\n\n" + err );
          }
          ]]>
        </body>
      </method>
    </implementation>
 
  </binding>




  <!-- PLAYER SCANNING DISPLAY -->




  <binding id="scanning-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.setAttribute( "hidden", "true" );
        this.data = "backscan.status";

        // See if we want to pop our balloon tip.
        this.on_value_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onValue( aData ); } 
        };
        this.on_value_change._that = this;
        this.bindvalue = SB_NewDataRemote("backscan.concurrent", null);
        this.bindvalue.bindObserver( this.on_value_change, false );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.bindvalue) {
          this.bindvalue.unbind();
          this.bindvalue = null;
        }
      ]]>
    </destructor>
    
    <method name="onValue">
      <parameter name="aData"/>
      <body>
        <![CDATA[
          if ( parseInt( aData ) > 0  )
          {
            this.setAttribute( "hidden", "false" );
            if ( ! SBDataGetBoolValue( "balloontip.backscan.shown" ) )
            {
              this.balloon = new BalloonTip();
              this.balloon.onCloseCallback = this.onBalloonClose;
              var title = SBString("balloontip.backscan.title", "Scanning For Metadata");
              var text = SBString("balloontip.backscan.text", "This indicates that Songbird is scanning the files in your Library to import their Metadata Tags.");
              this.balloon.showText(text, this, title, 'balloon-icon-songbird', null);
              this.balloon._that = this;
              SBDataSetBoolValue( "balloontip.backscan.shown", true )
            }
          }
          else
          {
            if ( ! this.balloon )
              this.setAttribute( "hidden", "true" );
          }
        ]]>
      </body>
    </method>
    
    <method name="onBalloonClose">
      <parameter name="aBalloonInstance"/>
      <parameter name="aCheckboxState"/>
      <body>
        <![CDATA[
          var that = aBalloonInstance._that;
          if ( SBDataGetIntValue("backscan.concurrent") < 1 )
            that.setAttribute( "hidden", "true" );
            
          that.balloon = null;
        ]]>
      </body>
    </method>
 

   </implementation>
 
  </binding>
  
  
  
  <!-- JUMP TO CURRENT TRACK BUTTON -->
  
  
  <binding id="curtrack-button">
    
    <content>
      <xul:hbox id="sb-player-curtrack-button" flex="1" xbl:inherits="hidden,class">
        <xul:sb-clickhold-button id="sb-player-curtrack-button-button" oncommand="onCurrentTrack( );" class="sb-player-curtrack-button sb-player-button" tooltiptext="&tooltip.control.curtrack;" xbl:inherits="label,position,popupanchor,popupalign"/>
      </xul:hbox>
    </content>
    
    <implementation>
    
      <constructor>
        this.interval = null;
      </constructor>
      
      <destructor>
        if (this.interval) {
          clearInterval(this.interval);
          this.interval = null;
        }
      </destructor>
      
      <method name="onCurrentTrack">
        <body>
          <![CDATA[
          if (!gPPS.playingView) {
            // nothing to see here, move along
            return;
          }
          
          if (!gBrowser) {
            // where do you expect me to show you this currently playing
            // track of yours?
            return;
          }
          
          // Create a self-calling function to try to set the selection over time.
          function selectCurrentIndex( iterationCount ) {
            // Tell the view to select the item?  
            // Steve says I need no context beyond what gPPS has.
            var currentIndex = gPPS.currentIndex;
            if ( currentIndex > -1 ) {
              try {
                gPPS.playingView.treeView.selection.clearSelection();
                gPPS.playingView.treeView.selection.select( currentIndex );
                gPPS.playingView.treeView.selection.tree.ensureRowIsVisible( currentIndex );
              } catch ( e ) { 
                dump("\n************\ncurtrack-button::onCurrentTrack\n" + 
                      "Steve says that this should work!\n\n" + e + 
                      "\n\n************\n");
                if ( iterationCount++ < 20 ) 
                  setTimeout( selectCurrentIndex, 250, iterationCount );
              }
            }
          }
          selectCurrentIndex( 0 );

          var tab = gBrowser.getTabForView(gPPS.playingView);          
          if (tab) {
            gBrowser.selectedTab = tab;
          } else {
            var mediaList = gPPS.playingView.mediaList;
            gBrowser.loadURI("chrome://songbird/content/xul/playlist_test2.xul?" +
                             'library,' + mediaList.library.guid, 
                             null, null, null, null,
                             gPPS.playingView);
          }
          ]]>
        </body>
      </method>
    </implementation>
  </binding>
  
  
  
  
   
  <!-- TOGGLE JUMP TO WINDOW -->
  
  <binding id="jumpto-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">
    
    <handlers>
      <handler event="command" action="this.onCommand();"/>
    </handlers>
    
    <implementation>
    
      <constructor>
        this.setAttribute("tooltiptext", "&jumptofile.title;")
      </constructor>
      
      <method name="onCommand">
        <body>
          <![CDATA[
            // At this point there isn't much we can do other than hope that
            // jumptofile.js has been included in the window
            // TODO this will need to change once jumptofile has been refactored
            try {
              toggleJumpTo();
            } catch (e) {
              var msg = "sb-player-jumpto-button: unable to call toggleJumpTo.\n" +
                        "Please make sure this window includes jumptofile.js.\n";
              dump(msg);
              Components.utils.reportError(msg);
            }
          ]]>
        </body>
      </method>
      
    </implementation>
  </binding>


  <!-- ENTER FULLSCREEN MODE (WHEN PLAYING VIDEO) -->
  
  <binding id="fullscreen-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">
    
    <handlers>
      <handler event="command" action="this.onCommand();"/>
    </handlers>
    
    <implementation>
    
      <constructor>
        this.setAttribute("tooltiptext", "&tooltip.fullscreen;");
        
        // Mac fullscreen coming soon.
        var sysInfo = Components.classes["@mozilla.org/system-info;1"]
                                .getService(Components.interfaces.nsIPropertyBag2);
        if ( sysInfo.getProperty("name") == "Darwin" ) {
          this.setAttribute("hidden", "true");
        }
      </constructor>
      
      <method name="onCommand">
        <body>
          <![CDATA[
            var playlistPlayback = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                                             .getService(Components.interfaces.sbIPlaylistPlayback);
            playlistPlayback.goFullscreen();
          ]]>
        </body>
      </method>
      
    </implementation>
  </binding>
  

  
  
  <!-- EOF -->
</bindings>
