<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2008 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE bindings SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">


  
  
  <!-- VOLUME CONTROL -->

  
  
  
  <binding id="volume-slider" extends="chrome://songbird/content/bindings/progressSlider.xml#progress-slider">

   <handlers>
     <handler event="progressSliderChange" action="this.onTrackVolume();"/>
     <handler event="progressSliderRelease" action="this.onReleaseVolume();"/>
   </handlers>

  <implementation>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.volume;")
      <![CDATA[
        if (typeof(SBProperties) == "undefined") {
          Components.utils.import("resource://app/jsmodules/sbProperties.jsm");
          if (!SBProperties)
            throw new Error("Import of sbProperties module failed");
        }

        if (typeof(LibraryUtils) == "undefined") {
          Components.utils.import("resource://app/jsmodules/sbLibraryUtils.jsm");
          if (!SBProperties)
            throw new Error("Import of LibraryUtils module failed");
        }

        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        this.box.setAttribute("id", "sb-player-volume-slider" );
        
        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " sb-player-volume-slider");
      
        // Then do the rest of your crap
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);
 
        // observer for DataRemote 
        const on_remote_volume_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onRemoteVolumeChange(); } 
        };
        on_remote_volume_change._that = this;

        // Create and bind data remotes
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_lastVolume = SB_NewDataRemote("faceplate.volume.last", null );
        this.remote_volume.bindObserver(on_remote_volume_change, true);

        this.maxpos = 255;
        this.value = this.remote_volume.intValue;
        this.trackingVolume = false;
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.remote_volume) {
          this.remote_volume.unbind();
          this.remote_volume = null;
        }
        if (this.remote_lastVolume) {
          this.remote_lastVolume = null;
        }
      ]]>
    </destructor>
    
    <method name="onTrackVolume">
      <body>
        <![CDATA[
          // prevent this volume control from being updated while it is being
          //   moved (but other volume controls are updated with our motion)
          this.trackingVolume = true; 
          this.gPPS.volume = this.value;
          this.remote_volume.intValue = this.value;
          if (this.value == 0) {
            // set mute when we bring the volume to 0
            this.gPPS.mute = true;
          }
          else {
            // otherwise reset it, and record the last volume
            this.gPPS.mute = false;
          }
        ]]>
      </body>
    </method>

    <method name="onReleaseVolume">
      <body>
        <![CDATA[
          this.trackingVolume = false;
          this.gPPS.volume = this.value;
          if (this.value != 0) {
            this.remote_lastVolume.intValue = this.value;
          }
        ]]>
      </body>
    </method>

    <method name="onRemoteVolumeChange">
      <body>
        <![CDATA[
          try {
            if (this.trackingVolume) // if volume is being actively changed, wait until release
              return; 
            this.value = this.remote_volume.intValue;
          } catch (err) {
            dump("playerControls.xml - onRemoteVolumeChange - " + err + "\n");
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>




  <!-- MUTE CONTROL -->



  <binding id="mute-button">
  
    <content>
      <xul:hbox id="sb-player-mute-button" oncommand="onMute();" flex="1">
        <xul:sb-clickhold-button
					          hidden="false" 
					          id="sb-player-mute-button-muteoff" 
					          class="sb-player-mute-button-muteoff sb-player-button" 
					          sbid="mute-off" 
					          tooltiptext="&tooltip.control.mute;" 
					          xbl:inherits="label,position">
          <xul:observes type="dataremote"
                    key="faceplate.mute" 
                    attribute="hidden" 
                    boolean="true"
                    inverted="false" />
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="sb-player-mute-menu-muteoff" 
                          autocheck="false" 
                          checked="false" 
                          class="menuitem-iconic" 
                          type="radio" 
                          label="&tooltip.control.mute;"/>
          </xul:menupopup>
        </xul:sb-clickhold-button>
        <xul:sb-clickhold-button
                    hidden="false" 
                    id="sb-player-mute-button-muteon" 
                    class="sb-player-mute-button-muteon sb-player-button" 
                    sbid="mute-on" tooltiptext="&tooltip.control.mute;" 
                    xbl:inherits="label,position">
          <xul:observes type="dataremote"
                    key="faceplate.mute" 
                    attribute="hidden" 
                    boolean="true"
                    inverted="true" />  
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="sb-player-mute-menu-muteon" 
                          autocheck="false" 
                          checked="true" 
                          class="menuitem-iconic" 
                          type="radio" 
                          label="&tooltip.control.mute;"/>
          </xul:menupopup>
        </xul:sb-clickhold-button>
      </xul:hbox>
    </content>

    <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind the data remotes
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_lastVolume = SB_NewDataRemote( "faceplate.volume.last", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "mute binding destructor");
        // Release the data remotes
        this.remote_volume = this.remote_lastVolume = null;
      ]]>
    </destructor>

    <field name="mute_on">document.getAnonymousElementByAttribute(this, 'sbid', 'mute-on');</field>
    <field name="mute_off">document.getAnonymousElementByAttribute(this, 'sbid', 'mute-off');</field>

    <method name="onMute">
      <body>
        <![CDATA[
          // Yikes.  If we hide the clickholdbutton because of the popupmenu,
          // the popupmenu gets broken.  Therefore, we wait until the next UI
          // frame to change the mute state.
          var that = this;
          setTimeout( function() { that.doMute() }, 0 );
        ]]>
      </body>
    </method>

    <method name="doMute">
      <body>
        <![CDATA[
          var newmute = !this.gPPS.mute; 
          this.gPPS.mute = newmute;
          if (!newmute) {
            // restore last volume when coming back from mute state
            this.gPPS.volume = this.remote_lastVolume.intValue;
          } 
          else {
            this.remote_lastVolume.intValue = this.remote_volume.intValue;
            this.gPPS.volume = 0;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  <!-- BASECLASS BINDINGS FOR SONGBIRD OVERLAY TRICKS
  
  These bindings will set some magic values inside of the objects we inherit from xpfe.
  
  It places the nodename as the id on the inner hbox for XBL Overlay and adds a class
  value that may be used in the CSS.
  
  -->
  <binding id="sb-button-base" extends="chrome://global/content/bindings/button.xml#button">
    <implementation>
      <constructor>
      <![CDATA[
        // ENFORCE CLICKABILITY!  (why do I have to do this?)
        this.setAttribute("mousethrough","never");
        
        // Get the nodename (without the namespace)
        var nameArray = this.nodeName.split(":");
        var nodeName = ( nameArray.length > 1 ) ? nameArray[ 1 ] : nameArray[ 0 ];
        
        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        var box = document.getAnonymousElementByAttribute(this, "class", "box-inherit button-box");
        box.setAttribute( 'id', nodeName );
        
        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " sb-player-button " + nodeName);
      ]]>
      </constructor>
    </implementation>
  </binding>

  <binding id="sb-checkbox-base" extends="chrome://global/content/bindings/checkbox.xml#checkbox-baseline">
    <implementation>
      <constructor>
      <![CDATA[
        // ENFORCE CLICKABILITY!  (why do I have to do this?)
        this.setAttribute("mousethrough","never");
        
        // Get the nodename (without the namespace)
        var nameArray = this.nodeName.split(":");
        var nodeName = ( nameArray.length > 1 ) ? nameArray[ 1 ] : nameArray[ 0 ];
        
        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        var box = document.getAnonymousElementByAttribute(this, "class", "checkbox-label-box");
        box.setAttribute( 'id', nodeName );
        
        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " " + nodeName);
      ]]>
      </constructor>
    </implementation>
  </binding>


  <!-- FORWARD BUTTON-->

  
  
  
  <binding id="forward-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">

  <handlers>
    <handler event="mousedown" button="0" action="this.onFwdMouseDown();"/>
    <handler event="mouseup" button="0" action="this.onFwdMouseUp();"/>
    <handler event="mouseout" action="this.onFwdMouseOut();"/>
    <handler event="mouseover" action="this.onFwdMouseOver();"/>
  </handlers>

  <implementation>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.fwd;")
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                      .getService(Components.interfaces.sbIPlaylistPlayback);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
    </destructor>
    
    <method name="onFwdMouseDown">
      <body>
        <![CDATA[
          this.seen_skip = false;
          if ( this.gPPS.playing )
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOut">
      <body>
        <![CDATA[
           if (this.skip_interval) {
             clearInterval( this.skip_interval );
             this.skip_interval = null;
           }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOver">
      <body>
        <![CDATA[
           if (this.skip && !this.skip_interval ) {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
           }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseUp">
      <body>
        <![CDATA[
          this.skip = false;
          this.onFwdCommand();
        ]]>
      </body>
    </method>

    <method name="onFwdCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.gPPS.next();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          if ( _this.skip )
          {
            // If we're allowed to skip
            if ( _this.gPPS.length > 0 )
            {
              _this.seen_skip = true;
              var target = _this.gPPS.position + 15000;
              var max = _this.gPPS.length - 1000;
              _this.gPPS.position = ( max < target ) ? max : target;
            }
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- BACK BUTTON-->

  
  
  
  <binding id="back-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">

   <handlers>
     <handler event="mousedown" button="0" action="this.onBackMouseDown();"/>
     <handler event="mouseup" button="0" action="this.onBackMouseUp();"/>
     <handler event="mouseout" action="this.onBackMouseOut();"/>
     <handler event="mouseover" action="this.onBackMouseOver();"/>
   </handlers>

  <implementation>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.back;")
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                      .getService(Components.interfaces.sbIPlaylistPlayback);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
    </destructor>
    
    <method name="onBackMouseDown">
      <body>
        <![CDATA[
          this.seen_skip = false;
          if ( this.gPPS.playing )
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onBackMouseUp">
      <body>
        <![CDATA[
          this.skip = false;
          this.onBackCommand();
        ]]>
      </body>
    </method>

    <method name="onBackMouseOut">
      <body>
        <![CDATA[
           if (this.skip_interval) {
             clearInterval( this.skip_interval );
             this.skip_interval = null;
           }
        ]]>
      </body>
    </method>

    <method name="onBackMouseOver">
      <body>
        <![CDATA[
           if (this.skip && !this.skip_interval ) {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
           }
        ]]>
      </body>
    </method>

    <method name="onBackCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.gPPS.previous();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          if ( _this.skip )
          {
            _this.seen_skip = true;
            var target = _this.gPPS.position - 15000;
            _this.gPPS.position = ( target > 1 ) ? target : 1;
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- REPEAT CONTROL -->




  <binding id="repeat-button">
  
   <content>
     <xul:stack id="sb-player-repeat-button" xbl:inherits="class=class" >
       <xul:sb-clickhold-button
                   id="repeat_none" 
                   class="sb-player-repeat-button-repnone sb-player-button" 
                   oncommand="onRepeat(event.target);" 
                   tooltiptext="&menu.control.repx;" 
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.repeat" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 0" />
         <xul:menupopup xbl:inherits="popupanchor,popupalign">  
          <xul:menuitem id="menu_repeat_none" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
          <xul:menuitem id="menu_repeat_all" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
          <xul:menuitem id="menu_repeat_1" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
         </xul:menupopup>
       </xul:sb-clickhold-button>
       <xul:sb-clickhold-button
                   id="repeat_1" 
                   class="sb-player-repeat-button-rep1 sb-player-button" 
                   oncommand="onRepeat(event.target);" 
                   tooltiptext="&menu.control.rep1;" 
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.repeat" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 1" />
          <xul:menupopup xbl:inherits="popupanchor,popupalign">  
            <xul:menuitem id="menu_repeat_none" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
            <xul:menuitem id="menu_repeat_all" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
            <xul:menuitem id="menu_repeat_1" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
          </xul:menupopup>
       </xul:sb-clickhold-button>
       <xul:sb-clickhold-button
                   id="repeat_all" 
                   class="sb-player-repeat-button-repall sb-player-button" 
                   oncommand="onRepeat(event.target);" 
                   tooltiptext="&menu.control.repa;" 
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.repeat" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 2" />
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="menu_repeat_none" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
            <xul:menuitem id="menu_repeat_all" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
            <xul:menuitem id="menu_repeat_1" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
          </xul:menupopup>
       </xul:sb-clickhold-button>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_repeat = SB_NewDataRemote( "playlist.repeat", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "repeat binding destructor");
        if (this.remote_repeat) {
          this.remote_repeat.unbind();
          this.remote_repeat = null;
        }
      ]]>
    </destructor>

    <field name="repeat_none">document.getAnonymousElementByAttribute(this, 'id', 'repeat_none');</field>
    <field name="repeat_1">document.getAnonymousElementByAttribute(this, 'id', 'repeat_1');</field>
    <field name="repeat_all">document.getAnonymousElementByAttribute(this, 'id', 'repeat_all');</field>

    <method name="onRepeat">
      <parameter name="target"/>
      <body>
        <![CDATA[
          var value = 0;
          switch( target.id )
          {
            case "menu_repeat_none": 
              value = 0;
              break;
            case "menu_repeat_1": 
              value = 1;
              break;
            case "menu_repeat_all":
              value = 2;
              break;
            default:
              switch ( this.remote_repeat.intValue )
              {
                case (0): // Apparently, "case 0:" != "case (0):" ?!?!?
                  value = 2;
                  break;
                case (1): // BUT, "case 1:" == "case (1):" ?!?!?
                  value = 0;
                  break;
                case (2):
                  value = 1;
                  break;
              }
              break;
          }
          this.remote_repeat.intValue = value;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- SHUFFLE CONTROL -->




  <binding id="shuffle-button">
  
   <content>
     <xul:stack id="sb-player-shuffle-button" xbl:inherits="class=class" oncommand="onShuffle( );">
       <xul:sb-clickhold-button
                   id="sb-player-shuffle-button-off" 
                   sbid="shuffle_off" 
                   class="sb-player-shuffle-button-off sb-player-button" 
                   tooltiptext="&tooltip.control.shuf_off;" 
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.shuffle" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 0" />  
         <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="menu_shuffle_off" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&tooltip.control.shuffle;"/>
         </xul:menupopup>
       </xul:sb-clickhold-button>
       <xul:sb-clickhold-button
                   id="sb-player-shuffle-button-on" 
                   sbid="shuffle_on" 
                   class="sb-player-shuffle-button-on sb-player-button" 
                   tooltiptext="&tooltip.control.shuffle;" 
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.shuffle" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 1" />
         <xul:menupopup xbl:inherits="popupanchor,popupalign">  
          <xul:menuitem id="menu_shuffle_on" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&tooltip.control.shuffle;"/>
         </xul:menupopup>
       </xul:sb-clickhold-button>
     </xul:stack>
   </content>

  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remotes
        this.remote_shuffle = SB_NewDataRemote( "playlist.shuffle", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "shuffle binding destructor");
      ]]>
    </destructor>

    <field name="shuffle_off">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_off');</field>
    <field name="shuffle_on">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_on');</field>
    
    <method name="onShuffle">
      <body>
        <![CDATA[
          this.remote_shuffle.boolValue = !this.remote_shuffle.boolValue;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- SEEK CONTROL -->

  
  
  
  <binding id="seek-slider" extends="chrome://songbird/content/bindings/progressSlider.xml#progress-slider">

   <handlers>
     <handler event="progressSliderChange" action="this.onTrackSeekbar();"/>
     <handler event="progressSliderRelease" action="this.onReleaseSeekbar();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        this.box.setAttribute("id", "sb-player-seek-slider" );

        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " sb-player-seek-slider");

        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // observer for DataRemote 
        const on_remote_position_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onRemotePositionChange(); } 
        };
        on_remote_position_change._that = this;

        // Create and bind data remotes
        this.remote_position = SB_NewDataRemote( "metadata.position", null );
        this.remote_position.bindObserver(on_remote_position_change, true);
        this.remote_length = SBDataBindElementAttribute( "metadata.length", this, "maxpos" );
       
        this.trackingPosition = 0;
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "seek-slider binding destructor");
        if (this.remote_position) {
          this.remote_position.unbind();
          this.remote_position = null;
        }
        if (this.remote_length) {
          this.remote_length.unbind();
          this.remote_length = null;
        }
      ]]>
    </destructor>

    <method name="onTrackSeekbar">
      <body>
        <![CDATA[
          this.trackingPosition = 1;
        ]]>
      </body>
    </method>

    <method name="onReleaseSeekbar">
      <body>
        this.gPPS.position = this.value;
        this.trackingPosition = 0;
      </body>
    </method>

    <method name="onRemotePositionChange">
      <body>
        <![CDATA[
          try {
            if (this.trackingPosition) return; // we are the control changing the position, ignore this callback
            this.value = this.gPPS.position;
          } catch (e) {
            alert("playerControls.xml - onRemotePositionChange - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
 
  <!-- PLAYPAUSE/PLAY/PAUSE/STOP CONTROLS -->


  <binding id="play-control-base">

    <implementation>

      <constructor>
        <![CDATA[
        if (typeof(SBProperties) == "undefined") {
          Components.utils.import("resource://app/jsmodules/sbProperties.jsm");
          if (!SBProperties)
            throw new Error("Import of sbProperties module failed");
        }
        if (typeof(ColumnSpecParser) == "undefined") {
          Components.utils.import("resource://app/jsmodules/sbColumnSpecParser.jsm");
          if (!ColumnSpecParser)
            throw new Error("Import of sbColumnSpecParser module failed");
        }
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                      .getService(Components.interfaces.sbIPlaylistPlayback);
        // Create and bind data remotes
        this.remote_seenPlaying = SB_NewDataRemote( "faceplate.seenplaying", null );
        ]]>
      </constructor>
      <destructor>
        this.gPPS = null;
        if (this.remote_seenPlaying) {
          this.remote_seenPlaying.unbind();
          this.remote_seenPlaying = null;
        }
      </destructor>
                     
      <method name="playbackPlay">
        <parameter name="nopause"/>
        <body>
          <![CDATA[
            // If we are already playing something just pause/unpause playback
            if (this.gPPS.playing) {
              // if we're playing already then play / pause
              if (this.gPPS.paused || nopause) {
                this.gPPS.play();
              } else {
                this.gPPS.pause();
              }
            // Otherwise dispatch a play event.  Someone should catch this
            // and intelligently initiate playback.  If not, just have
            // the playback service play the default.
            } else {
              var event = document.createEvent("Events");
              event.initEvent("Play", true, true);
              var notHandled = this.dispatchEvent(event);
              if (notHandled) {
                this.gPPS.play();
              }
            }
          ]]>
        </body>
      </method>

      <method name="playbackPause">
        <body>
          <![CDATA[
            if ( this.remote_seenPlaying.boolValue ) {
              this.gPPS.pause();
            }
          ]]>
        </body>
      </method>

      <method name="playbackStop">
        <body>
          <![CDATA[
            this.gPPS.stop();
          ]]>
        </body>
      </method>
      
    </implementation>
  </binding>


  <!-- a play button, always enabled because it is legitimate to restart playback in the middle of playback -->

  <binding id="play-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-play-button" flex="1" xbl:inherits="hidden,class">
      
        <xul:sb-clickhold-button
                    id="sb-player-play-button-play" 
                    sbid="play" 
	                  class="sb-player-play-button-play sb-player-button" 
	                  oncommand="onPlay();" 
	                  tooltiptext="&tooltip.control.play;" 
	                  xbl:inherits="label,position">
          <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
        </xul:sb-clickhold-button>
          
      </xul:hbox>
    </content>

  <implementation>

    <method name="onPlay">
      <body>
        this.playbackPlay(true);
      </body>
    </method>

   </implementation>
 
  </binding>


  <!-- a pause/restore button -->

  <binding id="pause-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-pause-button" flex="1" xbl:inherits="hidden,class">
        <xul:stack xbl:inherits="class=class" >
        
          <xul:sb-clickhold-button
                    id="sb-player-pause-button-pause" 
                    sbid="pause" 
                    class="sb-player-pause-button-pause sb-player-button" 
                    onmousedown="onPause();" 
                    tooltiptext="&tooltip.control.pause;" 
                    xbl:inherits="label,position">
            
            <xul:observes type="dataremote"
                      key="faceplate.playing" 
                      attribute="disabled" 
                      boolean="true"
                      inverted="true"/>  
            <xul:observes type="dataremote"
                      key="faceplate.paused" 
                      attribute="hidden" 
                      boolean="true"
                      inverted="false"/>
                      
            <xul:menupopup xbl:inherits="popupanchor,popupalign"/>  
          </xul:sb-clickhold-button>
          
          <xul:sb-clickhold-button
                    id="sb-player-pause-button-resume" 
                    sbid="resume" 
                    class="sb-player-pause-button-resume sb-player-button" 
                    oncommand="onPlay();" 
                    tooltiptext="&tooltip.control.resume;" 
                    xbl:inherits="label,position">
            
            <xul:observes type="dataremote"
                      key="faceplate.playing" 
                      attribute="disabled" 
                      boolean="true"
                      inverted="true"/>  
            <xul:observes type="dataremote"
                      key="faceplate.paused" 
                      attribute="hidden" 
                      boolean="true"
                      inverted="true"/>  
            <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
          </xul:sb-clickhold-button>
          
        </xul:stack>
      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
      ]]>
    </destructor>

    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>
    <field name="resume">document.getAnonymousElementByAttribute(this, 'sbid', 'resume');</field>

    <method name="onPause">
      <body>
        this.playbackPause();
      </body>
    </method>

    <method name="onPlay">
      <body>
        this.playbackPlay();
      </body>
    </method>

   </implementation>
 
  </binding>

  <!-- a stop button that enables itself when the core is playing, and disables itself when the core is stopped -->

  <binding id="stop-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-stop-button" flex="1" xbl:inherits="hidden,class">
      
        <xul:sb-clickhold-button
	                  id="sb-player-stop-button-stop" 
	                  sbid="stop" 
	                  class="sb-player-stop-button-stop sb-player-button" 
	                  oncommand="onStop();" 
	                  tooltiptext="&tooltip.control.stop;" 
	                  xbl:inherits="label,position">
          
          <xul:observes type="dataremote"
		                    key="faceplate.playing" 
		                    attribute="disabled" 
		                    boolean="true"
		                    inverted="true" />
         <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
        </xul:sb-clickhold-button>
        
      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
      ]]>
    </destructor>

    <field name="stop">document.getAnonymousElementByAttribute(this, 'sbid', 'stop');</field>

    <method name="onStop">
      <body>
        this.playbackStop();
      </body>
    </method>

   </implementation>
 
  </binding>



  <binding id="playpause-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-playpause-button" flex="1" xbl:inherits="hidden,class">
      
        <xul:sb-clickhold-button
                    id="sb-player-playpause-button-play" 
                    sbid="play" 
                    class="sb-player-playpause-button-play sb-player-button" 
                    oncommand="onPlayPause(event.target);" 
                    tooltiptext="&tooltip.control.play;" 
                    xbl:inherits="label,position"
                    onmenushowing="syncMenus();">
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="menu_play" class="menuitem-iconic" label="&menu.control.play.button;"/>
            <xul:menuitem id="menu_pause" class="menuitem-iconic" label="&menu.control.pause.button;"/>
            <xul:menuitem id="menu_stop" class="menuitem-iconic" label="&menu.control.stop.button;"/>
          </xul:menupopup>
        </xul:sb-clickhold-button>
        
        <xul:sb-clickhold-button
						        id="sb-player-playpause-button-pause" 
						        sbid="pause" 
                    class="sb-player-playpause-button-pause sb-player-button" 
                    oncommand="onPlayPause(event.target);" 
                    tooltiptext="&tooltip.control.pause;" 
                    xbl:inherits="label,position"
                    onmenushowing="syncMenus();">
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
	          <xul:menuitem id="menu_play" class="menuitem-iconic" label="&menu.control.play.button;"/>
	          <xul:menuitem id="menu_pause" class="menuitem-iconic" label="&menu.control.pause.button;"/>
	          <xul:menuitem id="menu_stop" class="menuitem-iconic" label="&menu.control.stop.button;"/>
	        </xul:menupopup>
        </xul:sb-clickhold-button>
        
      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
        // observer for DataRemote 
        this.on_state_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onStateChanged(); } 
        };
        this.on_state_change._that = this;
        this.remote_playing = SB_NewDataRemote("faceplate.playing", null);
        this.remote_paused = SB_NewDataRemote("faceplate.paused", null);
        this.remote_playing.bindObserver(this.on_state_change, false);
        this.remote_paused.bindObserver(this.on_state_change, false);
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        this.remote_playing.unbind();
        this.remote_paused.unbind();
      ]]>
    </destructor>

    <field name="play">document.getAnonymousElementByAttribute(this, 'sbid', 'play');</field>
    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>

    <method name="onStateChanged">
      <body>
        <![CDATA[
          if (this.remote_playing.boolValue && !this.remote_paused.boolValue) { 
            this.play.hidden = true; 
            this.pause.hidden = false; 
          } else { 
            this.play.hidden = false; 
            this.pause.hidden = true; 
          }
        ]]>
      </body>
    </method>
    
    <method name="syncMenus">
      <body>
        this.syncMenu(this.play);
        this.syncMenu(this.pause);
      </body>
    </method>
    
    <method name="syncMenu">
      <parameter name="parent"/>
      <body>
        <![CDATA[
          for (var i=0;i<parent.childNodes.length;i++) {
            var node = parent.childNodes[i];
            switch (node.id) {
              case "menu_play":
                // play is disabled if we are already playing but we are not also paused (playing remains true while we are paused!)
                node.disabled = this.gPPS.playing && !this.gPPS.paused;
                break;
              case "menu_pause":
                // pause is disabled if we are already paused, or if we are stopped
                node.disabled = this.gPPS.paused || !this.gPPS.playing;
                break;
              case "menu_stop":
                // stop is disabled if we are already stopped (ie, the playbutton is visible, but we are not paused)
                node.disabled = !this.gPPS.playing;
                break;
            }
          }
        ]]>
      </body>
    </method>

    <method name="onPlay">
      <body>
        this.playbackPlay();
      </body>
    </method>
    
    <method name="onPause">
      <body>
        this.playbackPause();
      </body>
    </method>

    <method name="onStop">
      <body>
        this.playbackStop();
      </body>
    </method>
    
    <method name="onPlayPause">
      <parameter name="target"/>
      <body>
        <![CDATA[
          var sbid = target.getAttribute("sbid");
          if (sbid == "play") this.onPlay();
          else if (sbid == "pause") this.onPause();
          else {
            switch (target.id) {
              case "menu_play": this.onPlay(); break; 
              case "menu_pause": this.onPause(); break;
              case "menu_stop": this.onStop(); break;
            }
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>



  <!-- CONTROL PANE BUTTONS BLOCK -->

  <binding id="control-buttons">

    <content>
      <xul:hbox id="sb-player-control-buttons" flex="1" xbl:inherits="class,hidden">
        <xul:sb-player-back-button id="sb-player-control-buttons-back" class="sb-player-button" xbl:inherits="class"/>
        <!-- Bonus Buttons!
          <xul:sb-player-pause-button id="sb-player-control-buttons-pause" popupanchor="topleft" popupalign="bottomleft"/>
          <xul:sb-player-play-button id="sb-player-control-buttons-play" popupanchor="topleft" popupalign="bottomleft"/>
          <xul:sb-player-stop-button id="sb-player-control-buttons-stop" popupanchor="topleft" popupalign="bottomleft"/>
        -->
        <xul:sb-player-playpause-button id="sb-player-control-buttons-playpause" class="sb-player-button" xbl:inherits="class" popupanchor="topleft" popupalign="bottomleft"/>
        <xul:sb-player-forward-button id="sb-player-control-buttons-forward" class="sb-player-button" xbl:inherits="class"/> 
      </xul:hbox>
    </content>
  
    <implementation>
      <constructor>
      </constructor>
    </implementation>
 
  </binding>



  <!-- TOTALTIME DISPLAY -->

  <binding id="totaltime-label">
  
    <content>
      <xul:hbox id="sb-player-totaltime-label" flex="1" xbl:inherits="class,align,crop,disabled,flex">
        <xul:label sbid="timelabel" xbl:inherits="class,align,crop,disabled,flex" mousethrough="never">
          <xul:observes type="dataremote"
                    key="metadata.length.str" 
                    attribute="value"/>  
        </xul:label>
      </xul:hbox>
    </content>

    <handlers>
      <handler event="mousedown" action="this.onTotalDown();"/>
    </handlers>


  <implementation>

    <constructor>
      <![CDATA[
        this.gPPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                    .getService(Components.interfaces.sbIPlaylistPlayback);

        // Create and bind data remote
        this.remote_showRemaining = SB_NewDataRemote( "faceplate.showremainingtime", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "totaltime binding destructor");
        this.remote_showRemaining = null;
      ]]>
    </destructor>

    <method name="onTotalDown">
      <body>
        <![CDATA[
          var len = this.gPPS.length;
          if ( len > 0 )
            this.remote_showRemaining.boolValue = !this.remote_showRemaining.boolValue;
          // If you try to toggle it while it is zero, you lose the state.
          else
            this.remote_showRemaining.boolValue = false;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>



  <!-- ARTIST DISPLAY -->


  <binding id="artist-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
    <implementation>

      <constructor>
        this.data  = "metadata.artist";
      </constructor>

    </implementation>
 
  </binding>



  <!-- TITLE DISPLAY -->


  <binding id="title-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.data  = "metadata.title";
        this.autotip = this.getAttribute("autotip");
        if (this.autotip) {
          // observer for DataRemote 
          this.on_remote_artist_album_change = { 
            _that: null, 
            observe: function( aSubject, aTopic, aData ) { this._that.rebuildTip(); } 
          };
          this.on_remote_artist_album_change._that = this;

          // Create and bind data remotes
          this.remote_artist = SB_NewDataRemote( "metadata.artist", null );
          this.remote_album = SB_NewDataRemote( "metadata.album", null );
          this.remote_artist.bindObserver(this.on_remote_artist_album_change, true);
          this.remote_album.bindObserver(this.on_remote_artist_album_change, true);

          this.rebuildTip();
      }
      ]]>
    </constructor>

    <destructor>
      <![CDATA[
        this.on_remote_artist_album_change = null;
        if (this.remote_album) {
          this.remote_album.unbind();
          this.remote_album = null;
        }
        if (this.remote_artist) {
          this.remote_artist.unbind();
          this.remote_artist = null
        }
      ]]>
    </destructor>

    <method name="rebuildTip">
      <body>
        <![CDATA[
          try {
            var tip = "";
            if ( this.remote_artist.stringValue &&
                 this.remote_artist.stringValue.length ) {
              tip = this.remote_artist.stringValue;
            }
            if ( this.remote_album.stringValue &&
                 this.remote_album.stringValue.length ) {
              if (tip.length > 0) tip += " / ";
              tip += this.remote_album.stringValue;
            }
            this.label.setAttribute("tooltiptext", tip);
          } catch (e) {
            alert("playerControls.xml - rebuildTip - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>



  <!-- ALBUM DISPLAY -->


  <binding id="album-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.album";
    </constructor>

   </implementation>
 
  </binding>




  <!-- TIME ELAPSED DISPLAY -->




  <binding id="timeelapsed-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.position.str";
    </constructor>

   </implementation>
 
  </binding>




  <!-- GENRE DISPLAY -->




  <binding id="genre-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.genre";
    </constructor>

   </implementation>
 
  </binding>




  <!-- CUSTOM DISPLAY -->



  <binding id="custom-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-compound-label">
  
  <implementation>

    <constructor>
      
      // this is a special version of a remote compound label, it takes its value from the preferences
      // and can be configured by the user from a preference pane
      
      this.setAttribute("value", SBDataGetStringValue("custom.display"));
    
    </constructor>

   </implementation>
 
  </binding>




  <!-- NUM PLAYLIST ITEMS DISPLAY -->




  <binding id="numplaylistitems-label" xextends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
    <content>
      <xul:hbox id="sb-player-numplaylistitems-label" flex="1" xbl:inherits="class">
        <xul:label id="sb-player-numplaylistitems-label-label" sbid="label" xbl:inherits="class,value,align,crop,disabled,flex"/> 
      </xul:hbox>
    </content>

    <implementation>
      <constructor>
        this.setInterval();
      </constructor>

      <destructor>
        clearInterval( this._interval );
      </destructor>

      <method name="setInterval">
        <body>
          <![CDATA[
            this._interval = setInterval( this.onInterval, 1000, this );
          ]]>
        </body>
      </method>

      <method name="onInterval">
        <parameter name="that"/>
        <body>
          <![CDATA[
            // Look at what I do to have the correct 'this' pointer!  Woo!
            that.doInterval();
          ]]>
        </body>
      </method>

      <method name="doInterval">
        <body>
          <![CDATA[
            var label = document.getAnonymousElementByAttribute(this, "sbid", "label");
            var displayValue = this.getAttribute('default');

            var browser = window.gBrowser;
            if (!browser) {
              label.setAttribute('value', displayValue);
              return;
            }

            if (browser.mCurrentTab.scanProgress >= 0 &&
                browser.mCurrentTab.scanProgress < 1) {
              // display page scan progress
              var mediafound = SBString("faceplate.mediafound", "Media Found");
              var percent = Math.round(browser.mCurrentTab.scanProgress*100);
              displayValue = mediafound + ': ' + percent + '%';
            } else if (browser.currentMediaListView != null) {
              var mediaListView = browser.currentMediaListView; 
              // HOORAY!!  It's okay for mediaListView.length to throw!
              var length = 0;
              try {
                length = mediaListView.length;
              } catch(e) {
                Components.utils.reportError(e);
                length = 0;
              }
              if ( length > 0 ) {
                // display media list length
                var displayFormat = SBString("faceplate.itemsformat." + length,
                        SBString("faceplate.itemsformat", "%s items"));

                displayValue = displayFormat.replace('%s', length);
              }
            }
            label.setAttribute('value', displayValue);
          ]]>
        </body>
      </method>
    </implementation>
 
  </binding>




  <!-- PLAYER SCANNING DISPLAY -->




  <binding id="scanning-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.setAttribute( "hidden", "true" );
        this.data = "backscan.status";

        // See if we want to pop our balloon tip.
        this.on_value_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onValue( aData ); } 
        };
        this.on_value_change._that = this;
        this.bindvalue = SB_NewDataRemote("backscan.concurrent", null);
        this.bindvalue.bindObserver( this.on_value_change, false );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.bindvalue) {
          this.bindvalue.unbind();
          this.bindvalue = null;
        }
      ]]>
    </destructor>
    
    <method name="onValue">
      <parameter name="aData"/>
      <body>
        <![CDATA[
          if ( parseInt( aData ) > 0  )
          {
            this.setAttribute( "hidden", "false" );
            if ( ! SBDataGetBoolValue( "balloontip.backscan.shown" ) )
            {
              this.balloon = new BalloonTip();
              this.balloon.onCloseCallback = this.onBalloonClose;
              var title = SBString("balloontip.backscan.title", "Scanning For Metadata");
              var text = SBString("balloontip.backscan.text", "This indicates that Songbird is scanning the files in your Library to import their Metadata Tags.");
              this.balloon.showText(text, this, title, 'balloon-icon-songbird', null);
              this.balloon._that = this;
              SBDataSetBoolValue( "balloontip.backscan.shown", true )
            }
          }
          else
          {
            if ( ! this.balloon )
              this.setAttribute( "hidden", "true" );
          }
        ]]>
      </body>
    </method>
    
    <method name="onBalloonClose">
      <parameter name="aBalloonInstance"/>
      <parameter name="aCheckboxState"/>
      <body>
        <![CDATA[
          var that = aBalloonInstance._that;
          if ( SBDataGetIntValue("backscan.concurrent") < 1 )
            that.setAttribute( "hidden", "true" );
            
          that.balloon = null;
        ]]>
      </body>
    </method>
 

   </implementation>
 
  </binding>
  
  
  
  <!-- JUMP TO CURRENT TRACK BUTTON -->
  
  <binding id="curtrack-base">
    
    <implementation>
      
      <method name="getBrowser">
        <body>
          <![CDATA[
            var retval = null;
            try {
              // Dig through the parent chain to find a happy gBrowser.
              for ( var win = window; 
                    win != null && win != win.parent && 
                    typeof win.gBrowser == 'undefined'; 
                    win = win.parent ) ; // Yes, it is there on purpose.
              if ( win ) {
                retval = win.gBrowser;
              }
            } catch(e) {}
            return retval;
          ]]>
        </body>
      </method>
          
      <method name="onCurrentTrack">
        <body>
          <![CDATA[

          if (!gPPS.playingView) {
            // nothing to see here, move along
            return;
          }

          // Before showing the current track we trigger
          // a custom event, so that if this object is used wihout
          // a gBrowser object, the current window may still perform
          // its own custom action.
          
          var e = document.createEvent("Events");
          e.initEvent("ShowCurrentTrack", false, true);
          var handled = !this.dispatchEvent(e);
          if (handled) { 
            return;
          }
          
          
          // Find a gBrowser in the window hierarchy chain (for display panels, etc)
          var browser = this.getBrowser();
          if (typeof browser == 'undefined') {
            // where do you expect me to show you this currently playing
            // track of yours?
            return;
          }
          
          if (gPPS.currentIndex >= 0) {
            browser.showIndexInView(gPPS.playingView, gPPS.currentIndex);
          }
          ]]>
        </body>
      </method>
    </implementation>
  </binding>

  <binding id="curtrack-button" extends="chrome://songbird/content/bindings/playerControls.xml#curtrack-base">
    
    <content>
      <xul:hbox id="sb-player-curtrack-button" flex="1" xbl:inherits="hidden,class">
        <xul:sb-clickhold-button
                    id="sb-player-curtrack-button-button" 
                    oncommand="onCurrentTrack( );" 
                    class="sb-player-curtrack-button sb-player-button" 
                    tooltiptext="&tooltip.control.curtrack;" 
                    xbl:inherits="label,position">
          <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
        </xul:sb-clickhold-button>
      </xul:hbox>
    </content>

  </binding>
  
  <binding id="curtrack-box" extends="chrome://songbird/content/bindings/playerControls.xml#curtrack-base">
    
    <content>
      <xul:box id="sb-player-curtrack-box" 
                orient="horizontal" 
                mousethrough="never" 
                onmousedown="onCurrentTrack();" 
                xbl:inherits="hidden,class,flex,pack,orient">
        <children/>
      </xul:box>
    </content>

  </binding>
  
  
  
   
  <!-- TOGGLE JUMP TO WINDOW -->
  
  <binding id="jumpto-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">
    
    <handlers>
      <handler event="command" action="this.onCommand();"/>
    </handlers>
    
    <implementation>
    
      <constructor>
        this.setAttribute("tooltiptext", "&jumptofile.title;")
      </constructor>
      
      <method name="onCommand">
        <body>
          <![CDATA[
            // At this point there isn't much we can do other than hope that
            // jumpToFile.js has been included in the window
            // TODO this will need to change once jumptofile has been refactored
            try {
              toggleJumpTo();
            } catch (e) {
              var msg = "sb-player-jumpto-button: unable to call toggleJumpTo.\n" +
                        "Please make sure this window includes jumpToFile.js.\n";
              dump(msg);
              Components.utils.reportError(msg);
            }
          ]]>
        </body>
      </method>
      
    </implementation>
  </binding>


  <!-- ENTER FULLSCREEN MODE (WHEN PLAYING VIDEO) -->
  
  <binding id="fullscreen-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">
    
    <handlers>
      <handler event="command" action="this.onCommand();"/>
    </handlers>
    
    <implementation>
    
      <constructor>
        this.setAttribute("tooltiptext", "&tooltip.fullscreen;");
        
        // Mac fullscreen coming soon.
        var sysInfo = Components.classes["@mozilla.org/system-info;1"]
                                .getService(Components.interfaces.nsIPropertyBag2);
        if ( sysInfo.getProperty("name") == "Darwin" ) {
          this.setAttribute("hidden", "true");
        }
      </constructor>
      
      <method name="onCommand">
        <body>
          <![CDATA[
            var playlistPlayback = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                                             .getService(Components.interfaces.sbIPlaylistPlayback);
            playlistPlayback.goFullscreen();
          ]]>
        </body>
      </method>
      
    </implementation>
  </binding>
  

  
  
  <!-- EOF -->
</bindings>
