<?xml version="1.0"?>
<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl"
[
<!ENTITY % songbirdDTD SYSTEM "chrome://songbird/locale/songbird.dtd">
%songbirdDTD;
]
>
<!--
//
// BEGIN SONGBIRD GPL
//
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2008 POTI, Inc.
// http://songbirdnest.com
//
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
//
// Software distributed under the License is distributed
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either
// express or implied. See the GPL for the specific language
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
//
// END SONGBIRD GPL
//
-->

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="sb-tabbrowser" extends="chrome://songbird/content/bindings/tabBrowser.xml#tabbrowser">
    <implementation implements="nsIWebProgressListener,sbITabBrowser,sbIServicePaneListener">
      <constructor><![CDATA[
        window.gBrowser = this;

        if (!window.SBProperties)
          Components.utils.import("resource://app/jsmodules/sbProperties.jsm");
        if (!window.kPlaylistCommands) 
          Components.utils.import("resource://app/jsmodules/kPlaylistCommands.jsm");
        if (!window.LibraryUtils) 
          Components.utils.import("resource://app/jsmodules/LibraryUtils.jsm");
        if (!window.ArrayConverter) 
          Components.utils.import("resource://app/jsmodules/ArrayConverter.jsm");

        this.addProgressListener(this,
            Components.interfaces.nsIWebProgress.NOTIFY_LOCATION |
            Components.interfaces.nsIWebProgress.NOTIFY_STATE_ALL);

        this.loading = false;
        this.tabStateRestored = false;

        /* we need to track when tabs change */
        this.tabChangeEventListener = {
          tabbrowser: this,
          timer_period: 200, // fire after 1/5th of a second
          timer: null,
          handleEvent: function(event) {
            if (event.attrName == 'selectedIndex' &&
                event.prevValue != event.newValue &&
                !this.timer) {
              this.timer = Components.classes['@mozilla.org/timer;1']
                  .createInstance(Components.interfaces.nsITimer);
              this.timer.initWithCallback(this, this.timer_period,
                  Components.interfaces.nsITimer.TYPE_ONE_SHOT);

            }
          },
          notify: function(timer) {
            //this.tabbrowser._loaded();
            this.timer = null;
          }
        };
        this.mTabBox.addEventListener("DOMAttrModified",
            this.tabChangeEventListener, false);

        /* we want to know when the window has finished opening so we can
          restore tabs and other fun stuff
        */
        this.windowLoadEventListener = {
          tabbrowser: this,
          document: document,
          handleEvent: function(event) {
            if (event.target != this.document) {
              return;
            }
            this.tabbrowser.restoreTabState();
          }
        }
        window.addEventListener('load', this.windowLoadEventListener, true);

        window.addEventListener("remoteapi", this.onRemoteAPI, true);

        // tell appshell how to open new tabs (sb bug 3757)
        var self = this;
        window.QueryInterface(Components.interfaces.nsIDOMChromeWindow)
              .browserDOMWindow = {
          openURI: function browserDOMWindow_openURI(aURI, aOpener, aWhere, aContext) {
            // XXX Mook: for now, just always open in new tab (ignore aWhere)
            if (aURI instanceof Components.interfaces.nsIURI)
              aURI = aURI.spec;
            // XXX Mook: if the tab isn't loaded in the background,
            // onLocationChange freaks out; so we focus it later if needed
            var newTab = self.loadOneTab("about:blank", null, null, null, true, false);
            var newWindow = self.getBrowserForTab(newTab).docShell
                                .QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                                .getInterface(Components.interfaces.nsIDOMWindow);
            try {
              var loadflags = (aContext == Components.interfaces.nsIBrowserDOMWindow.OPEN_EXTERNAL) ?
                         Components.interfaces.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL :
                         Components.interfaces.nsIWebNavigation.LOAD_FLAGS_NONE;
              if (aOpener) {
                var referrer =
                        Components.classes["@mozilla.org/network/io-service;1"]
                                  .getService(Components.interfaces.nsIIOService)
                                  .newURI(aOpener.location, null, null);
              }
              if (!aURI)
                aURI = "about:blank";
              newWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                       .getInterface(Components.interfaces.nsIWebNavigation)
                       .loadURI(aURI, loadflags, referrer, null, null);
            } catch(e) {
            }
            var loadInBackground = self._prefsService
                                       .getBoolPref("browser.tabs.loadDivertedInBackground");
            if (!loadInBackground) {
              self.selectedTab = newTab;
            }
            return newWindow;
          },
          isTabContentWindow: function browserDOMWindow_isTabContentWindow(aWindow) {
            for (var ctr = 0; ctr < self.browsers.length; ctr++)
              if (self.browsers.item(ctr).contentWindow == aWindow)
                return true;
            return false;
          }
        };

        this.setAttribute("onnewtab", "onNewTab()");

        this.webNavigation.sessionHistory =
            Components.classes["@mozilla.org/browser/shistory;1"]
            .createInstance(Components.interfaces.nsISHistory);
        this.browsers[0].removeAttribute("disablehistory");

        // force tabbed mode
        this.enterTabbedMode();
        
        // display pane
        XML.prettyPrinting = false;
        var xml =  <sb-smart-splitter collapse="after" orient="vertical" resizeafter="closest"
                                      id="displaypane_contentpane_bottom_splitter"
                                      xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
                     <grippy/>
                   </sb-smart-splitter>;
        var doc = (new DOMParser()).parseFromString(xml.toXMLString(), "application/xml");
        var splitter = document.importNode(doc.documentElement, true);
        this.parentNode.appendChild(splitter);

        /*var splitter = document.createElement("sb-smart-splitter");
        splitter.setAttribute("collapse", "after");
        splitter.setAttribute("orient", "vertical");
        splitter.setAttribute("resizeafter", "closest");
        splitter.setAttribute("id", "displaypane_contentpane_bottom_splitter");
        var grippy = document.createElement("grippy");
        grippy.setAttribute("flex", "1");
        splitter.appendChild(grippy);
        this.parentNode.appendChild(splitter);*/

        xml = <sb-displaypane id="displaypane_contentpane_bottom" contentgroup="contentpane"
                              splitter="displaypane_contentpane_bottom_splitter"
                              xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"/>;
        doc = (new DOMParser()).parseFromString(xml.toXMLString(), "application/xml");
        var pane = document.importNode(doc.documentElement, true);
        
        // evil hack to get the localizable name from the dtd
        pane.setAttribute("label", ]]>"&displaypane.name.browser;"<![CDATA[);
        this.parentNode.appendChild(pane);

        /*var pane = document.createElement("sb-displaypane");
        pane.setAttribute("id", "displaypane_contentpane_bottom");
        pane.setAttribute("contentgroup", "contentpane");
        pane.setAttribute("splitter", "displaypane_contentpane_bottom_splitter");
        this.parentNode.appendChild(pane);*/
        
        // manually restore the height if set (because the two elements are inserted dynamically
        // and thus when the restore was attempted the pane didn't exist yet)
        if (!pane.collapsed) {
          splitter.restoreLastState(true);
        }

        // add a service pane listener
        this._servicePaneService = 
            Components.classes['@songbirdnest.com/servicepane/service;1']
            .getService(Components.interfaces.sbIServicePaneService);
        this._servicePaneService.init();
        this._servicePaneService.addListener(this);
      ]]></constructor>
      <destructor><![CDATA[

        // remove service pane listener        
        this._servicePaneService.removeListener(this);
        this._servicePaneService = null;

        this.removeProgressListener(this);
        if (this.tabChangeEventListener) {
          if (this.tabChangeEventListener.timer) {
            this.tabChangeEventListener.timer.cancel();
          }
          this.mTabBox.removeEventListener("DOMAttrModified",
              this.tabChangeEventListener, false);
        }

        window.removeEventListener('load', this.windowLoadEventListener, true);

        window.removeEventListener("remoteapi", this.onRemoteAPI, true);
        window.QueryInterface(Components.interfaces.nsIDOMChromeWindow)
              .browserDOMWindow = null;
      ]]></destructor>

      <field name="_tabStatePref">'songbird.browser.tab_state'</field>
      <property name="_tabState">
        <getter><![CDATA[
          if (this._prefsService.prefHasUserValue(this._tabStatePref)) {
            return eval(this._prefsService.getCharPref(this._tabStatePref));
          }
          return null;
        ]]></getter>
        <setter><![CDATA[
          this._prefsService.setCharPref(this._tabStatePref, val.toSource());
        ]]></setter>
      </property>
      <method name="onNewTab">
        <body><![CDATA[
          this.loadURI(this.homePage, null, null, null, '_blank');
        ]]></body>
      </method>
      <method name="saveTabState">
        <body><![CDATA[

          var tab = this.mTabContainer.firstChild;
          var urls = [];
          while (tab) {
            try {
              // For media pages, store the list GUIDs
              // so that the page can be restored correctly
              if (tab.mediaPage) {
                if (tab.mediaPage.mediaListView) {
                  var mediaList = tab.mediaPage.mediaListView.mediaList;
                  urls.push({
                      listGUID: mediaList.guid,
                      libraryGUID: mediaList.library.guid,
                      pageURL: tab.linkedBrowser.currentURI.spec
                    });
                }
              // For all other pages, just keep the URI
              } else {
                urls.push(tab.linkedBrowser.currentURI.spec);
              }
            } catch (e) { 
              Components.utils.reportError(e);
            }
            tab = tab.nextSibling;
          }
          
          this._tabState = urls;
        ]]></body>
      </method>
      <method name="restoreTabState">
        <body><![CDATA[
          if ( !SBDataGetBoolValue( "firstrun.tabs.restore" ) ) {
            // If we have never run the app before, load this keen stuff!@
            var homePageURL = this.homePage;
            var firstrunURL = SBDataGetStringValue( "url.firstrun" );
            this.loadURI(homePageURL, null, null, null, '_top');
            this.loadURI(firstrunURL, null, null, null, '_blank');
            SBDataSetBoolValue( "firstrun.tabs.restore", true );
          } else {

            // Otherwise, just restore whatever was there, previously.
            var tabs = this._tabState;
            if (tabs) {
              var location = "_top";
              var tab;
              for (var i=0; i<tabs.length; i++) {  
                tab = tabs[i];             
                // If the tab had a media page, restore it by reloading
                // the media list
                if (tab.listGUID) {
                  this.loadMediaListGUID(tab.libraryGUID, tab.listGUID, null,
                                         location, tab.pageURL);
                // Otherwise just reload the URL
                } else {
                  this.loadURI(tab, null, null, null, location);
                }
                
                // Load the first url into the current tab and subsequent 
                // urls into new tabs 
                location = "_blank";
              }
            }
          }
          this.tabStateRestored = true;
        ]]></body>
      </method>
      
      
      <!-- Override tabBrowser.setTabTitle in order to support
           service pane icons and titles for chrome URLs -->
      <method name="setTabTitle">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            var browser = this.getBrowserForTab(aTab);
            var crop = "end";
            var title = browser.contentTitle;

            if (!title) {
              if (browser.currentURI.spec) {
              
                //XXXAus: Looks like we have a chrome URL. Let's try and see if it has 
                //a pretty name registered with the service pane so that we can match what
                //the location bar will have (ie, Library, not chrome://songbird[...]).
                if (browser.currentURI.scheme == "chrome") {
                  // If we have a servicepane node, use it for the title
                  var servicePaneNode = aTab.servicePaneNode
                  if (servicePaneNode && servicePaneNode.name) {
                    title = servicePaneNode.name;
                  }
                }
              
                //XXXAus: Looks like the service pane didn't have a pretty name for 
                //this chrome URI. Let's fallback to using the URI itself. This also
                //works for all other types of schemes (http, ftp, etc).
                if (!title) {
                  try {
                    title = this.mURIFixup.createExposableURI(browser.currentURI).spec;
                  } catch(ex) {
                    title = browser.currentURI.spec;
                  }
                }
              }

              if (title && title != "about:blank") {
                // At this point, we now have a URI.
                // Let's try to unescape it using a character set
                // in case the URI is not ASCII.
                try {
                  var characterSet = browser.contentDocument.characterSet;
                  const textToSubURI = Components.classes["@mozilla.org/intl/texttosuburi;1"]
                                                 .getService(Components.interfaces.nsITextToSubURI);
                  title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);
                } catch(ex) { /* Do nothing. */ }

                crop = "center";

              } else // Still no title?  Fall back to our untitled string.
                title = this.mStringBundle.getString("tabs.untitled");
            }

            aTab.label = title;
            aTab.setAttribute("crop", crop);
          ]]>
        </body>
      </method>

      <method name="_checkTarget">
        <parameter name="aTarget"/>
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
            var returnValue = aTarget;
            
            if (aEvent) {
              // if an event as supplied infer where we want to load this URI
              //
              var isMac = window.navigator.platform.match(/^Mac/) == 'Mac';
              var middleButton = aEvent?(aEvent.button == 1):false;
              var modifierKey = aEvent?(isMac?aEvent.metaKey:aEvent.ctrlKey):false;

              if (middleButton || modifierKey) {
                returnValue = "_blank";
              }
            }

            // check to see if tabs are allowed
            if (returnValue == '_blank' &&
                !this._prefsService.getBoolPref('browser.tabs.enabled')) {
              returnValue = '_top';
            }

            return returnValue;
          ]]>
        </body>
      </method>
      
      <!-- the public interface for loading URLs.
           this overrides the implementation in tabBrowser.xml#tabbrowser
           it takes the existing aURI, aReferrerURI and aCharset arguments
           and optionally an aEvent and aMediaListView.

           aMediaListView will be provided to the tab and used if a
           media page is loaded.
           -->
      <method name="loadURI">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aEvent"/>
        <parameter name="aDefaultLocation"/>
        <parameter name="aMediaListView"/>
        <body>
          <![CDATA[
          
            // If this is a request for the old sbLibaryPage
            // redirect it to the new page showing the main library 
            // TODO delete this post 0.5
            if (aURI && aURI.indexOf &&
                aURI.indexOf("chrome://songbird/content/xul/sbLibraryPage.xul") == 0)
            {
              Components.utils.reportError("TabBrowser.loadURI was called for" +
                    " sbLibraryPage.xul! Use gBrowser.loadMediaList instead.");
                    
              this.loadMediaList(LibraryUtils.mainLibrary, aEvent, 
                    aDefaultLocation);
              return;
            }

          
            var retval = null;
            var where = this._checkTarget(aDefaultLocation, aEvent);
            if (where == null || where == undefined) {
              where= '_top';
            }

            // make sure the referrer is an nsIURI
            if (aReferrerURI == '') {
              aReferrerURI = null;
            } else {
              if (typeof(aReferrerURI) == 'string') {
                aReferrerURI = (Components
                    .classes["@mozilla.org/network/io-service;1"]
                    .getService(Components.interfaces.nsIIOService)
                    .newURI(aReferrerURI, aCharset, null));
              }
            }

            // Now, actually open the URI
            if (where == "_blank") {
              var tab = this.loadOneTab(aURI, aReferrerURI, aCharset, null, null, null);
              tab._viewForPage = aMediaListView;
              tab._isNewViewForPage = true;
              retval = tab;
            } else if (where == "_top") {
              this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
              this.mCurrentTab._viewForPage = aMediaListView;
              this.mCurrentTab._isNewViewForPage = true;
              retval = this.mCurrentTab;
            
            // If aDefaultLocation is a tab, load there
            } else if (where && where.linkedBrowser) {
              var tab = where;
              tab.linkedBrowser.loadURI(aURI, aReferrerURI, aCharset);
              tab._viewForPage = aMediaListView;
              tab._isNewViewForPage = true;
              retval = tab;
            } else {
              // eek! unknown target
            }
            return retval;
          ]]>
        </body>
      </method>

      <!-- Use a Media Page to display the given list and
           (optional) view. 
        -->
      <method name="loadMediaList">
        <parameter name="aMediaList"/>
        <parameter name="aEvent"/>
        <parameter name="aDefaultLocation"/>
        <parameter name="aMediaListView"/>
        <parameter name="aPageURL"/>
        <body>
          <![CDATA[
            // If we weren't passed a view, create one
            if (aMediaListView == null) {
              aMediaListView = LibraryUtils.createStandardMediaListView(aMediaList);
            }

            var mgr = Components.classes["@songbirdnest.com/Songbird/MediaPageManager;1"]
                                .getService(Components.interfaces.sbIMediaPageManager);

            // If a page URL was provided, confirm that it is allowed for this medialist
            if (aPageURL) {
              var found = false;
              for each (var page in ArrayConverter.JSArray(mgr.getAvailablePages(aMediaList))) {
                if (aPageURL.indexOf(page.QueryInterface(Components.interfaces.sbIMediaPageInfo)
                        .contentUrl) == 0) {
                  found = true;
                  break;
                }
              }
              if (!found){
                aPageURL = null;
              }            
            }
            
            // If no URL, get the default from the page manager
            if (!aPageURL) {
              var page = mgr.getPage(aMediaList);
              aPageURL = page.contentUrl;
            }
            
            // If not already present, attach the guids to the querystring 
            // so that the page gets a unique browser history entry.  
            // I would have preferred to use a # instead of a querystring, 
            // but anchors are ignored in loadURI.
            if (aPageURL.indexOf("libraryGUID=") == -1) {
              if (aPageURL.indexOf("?") != -1) {
                aPageURL += "&";
              } else {
                aPageURL += "?";
              }
              aPageURL += "libraryGUID=" + escape(aMediaList.library.guid) +
                          "&listGUID=" + escape(aMediaList.guid);
            }
            
            return this.loadURI(aPageURL, null, null, aEvent, 
                                   aDefaultLocation, aMediaListView);
          ]]>
        </body>
      </method>
      
      
      <!-- Use a Media Page to display the list with 
           the given library/list GUIDs 
        -->
      <method name="loadMediaListGUID">
        <parameter name="aLibraryGUID"/>
        <parameter name="aListGUID"/>
        <parameter name="aEvent"/>
        <parameter name="aDefaultLocation"/>
        <parameter name="aPageURL"/>
        <body>
          <![CDATA[
            var libraryManager = 
              Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                        .getService(Components.interfaces.sbILibraryManager);
                        
            var mediaList = libraryManager.getLibrary( aLibraryGUID );
            
            // Are we loading the root library or a media list within
            // the library
            if (aListGUID && aLibraryGUID != aListGUID) {
              mediaList = mediaList.getMediaItem( aListGUID );            
            }
            
            return this.loadMediaList(mediaList, aEvent, aDefaultLocation, 
                               null, aPageURL);
          ]]>
        </body>
      </method>
      
      

      <!-- Reveal the given index in the given sbIMediaListView  -->
      <method name="showIndexInView">
        <parameter name="aMediaListView"/>
        <parameter name="aHighlightIndex"/>
        <body>
          <![CDATA[
            if (!(aMediaListView instanceof Ci.sbIMediaListView) ||
                !(aHighlightIndex >= 0)) {
              throw new Error("showIndexInView requires a media list view and index");
            }
              
            // If we already have a tab for this view, show it there
            var tab = this.getTabForView(aMediaListView);          
            if (tab) {
              this.selectedTab = tab;
              if (tab.mediaPage) {
                tab.mediaPage.highlightItem(aHighlightIndex);
              } else if (tab.outerPlaylist) {
                var tree = tab.outerPlaylist.tree;
                tree.treeBoxObject.ensureRowIsVisible(aHighlightIndex);
                tree.view.selection.select(aHighlightIndex);
              }
            
            // Not already visible.  Load and highlight.
            } else {
              var tab = this.loadMediaList(aMediaListView.mediaList, null, 
                                           null, aMediaListView);
              tab._highlightViewIndexOnLoad = aHighlightIndex;
            }
          ]]>
        </body>
      </method>
      

      <field name="_prefsService">
        Components.classes["@mozilla.org/preferences-service;1"].
                getService(Components.interfaces.nsIPrefBranch);
      </field>
      

      <!-- Get the web playlist for the current tab -->
      <property name="currentOuterPlaylist" readonly="true"
                onget="return this.mCurrentTab.outerPlaylist" />

      <!-- control the visibility of the web playlist on the current tab -->
      <property name="currentOuterPlaylistShowing"
                onget="return this.mCurrentTab.outerPlaylistShowing"
                onset="this.mCurrentTab.outerPlaylistShowing = val" />

      <!-- Get the sbIMediaPage for the current tab -->
      <property name="currentMediaPage" readonly="true"
                onget="return this.mCurrentTab.mediaPage" />

      <!-- Get the sbIMediaListView for the current tab.
           May come from the web playlist or media page. -->
      <property name="currentMediaListView" readonly="true"
                onget="return this.mCurrentTab.mediaListView" />




      <field name="_loading">SB_NewDataRemote("faceplate.loading", null)</field>
      <property name="loading"
                onget="return this._loading.boolValue"
                onset="this._loading.boolValue = val;" />

      <property name="showWebPlaylist">
        <getter><![CDATA[
          // the value is taken from the current tab
          return this.currentOuterPlaylistShowing;
        ]]></getter>
        <setter><![CDATA[
          // boolify the value that is passed in

          var value = (val)?true:false;
          this.currentOuterPlaylistShowing = value;
        ]]></setter>
      </property>

      <method name="getTabForView">
        <parameter name="aView" />
        <body><![CDATA[        
          // Search open tabs for an sbIMediaListView that is showing the given view
          var tabs = this.mTabContainer.childNodes;
          var tab;
          for (var i = 0; i < tabs.length; i++) {
            tab = tabs[i];
            if (tab.mediaListView && tab.mediaListView == aView) {
              return tab;
            }
          }
          return null;
        ]]></body>
      </method>

      <!-- implementation of nsIWebProgressListener -->
      <method name="onLocationChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aLocation" />
        <body><![CDATA[
          try {
            // for some reason we need to do this dance to get scrollbars to
            // show up
            var nsIScrollable = Components.interfaces.nsIScrollable;
            var scrollable = this.webNavigation.QueryInterface(nsIScrollable);
            scrollable.setDefaultScrollbarPreferences(nsIScrollable.ScrollOrientation_Y,
                                                      nsIScrollable.Scrollbar_Auto);
            scrollable.setDefaultScrollbarPreferences(nsIScrollable.ScrollOrientation_X,
                                                      nsIScrollable.Scrollbar_Auto);

            if (this.webNavigation.sessionHistory) {
              SBDataSetBoolValue('browser.cangoback', this.webNavigation.canGoBack);
              SBDataSetBoolValue('browser.cangofwd', this.webNavigation.canGoForward);
            }

            // Nothing in the status text
            SBDataSetStringValue( "faceplate.status.text", "");

            if (!aLocation) {
              aLocation = "about:blank";
            }

            // set the context-menu based on the chromeyness of the location
            if (aLocation.scheme == 'chrome') {

              //XXXAus: Disable bookmarking for chrome URI's to prevent
              //stale bookmarks. See bug #4009.
              SBDataSetBoolValue('browser.canbookmark', false);

              this.mCurrentBrowser.contextMenu = null;

            } else {

              //XXXAus: Enable bookmarking for all other URI schemes.
              //See bug #4009.
              SBDataSetBoolValue('browser.canbookmark', true);

              this.mCurrentBrowser.contextMenu = this.getAttribute('contentcontextmenu');

            }

            SBDataSetBoolValue('browser.cansubscription',
                               this.mCurrentTab.outerPlaylistShowing);

            // Let listeners know that the tab location has changed
            this.notifyTabContentChange();
          }
          catch ( err )
          {
            alert( "sb-tabbrowser::onLocationChange\n\n" + err );
          }
        ]]></body>
      </method>

      <method name="onProgressChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aCurSelfProgress" />
        <parameter name="aMaxSelfProgress" />
        <parameter name="aCurTotalProgress" />
        <parameter name="aMaxTotalProgress" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>

      <method name="onSecurityChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>

      <method name="onStateChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aStatus" />
        <body><![CDATA[
          const nsIWebProgressListener =
            Components.interfaces.nsIWebProgressListener;
            
          // if this state change isn't on the top-level window, ignore it
          if (aWebProgress.DOMWindow != aWebProgress.DOMWindow.parent ||
              !(aState & Components.interfaces.nsIWebProgressListener.STATE_IS_WINDOW)) {
            return;
          }

          if (aState & nsIWebProgressListener.STATE_START) {
            // Start the spinner if necessary
            this.loading = true;
          }
          else if (aState & nsIWebProgressListener.STATE_STOP) {
            // Stop the spinner if necessary
            this.loading = false;

            // Let listeners know that the tab has finished loading
            // but only if aStatus == 0, an nsresult representing whether the request 
            // finished or was cancelled...
            if (aStatus == 0) {
              this.notifyTabContentChange();
            }

            // Save the tab state after every page load, just in case we crash
            if (this.tabStateRestored) {
              this.saveTabState();
            }
          }
        ]]></body>
      </method>

      <method name="onStatusChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aMessage" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>


      <!-- Sends a "TabContentChange" event from the current tab. 
           Called when the user switches tabs, and before and after
           a new page is loaded in the current tab.
           
           Use this event if you want to track what the user is
           viewing in the tab browser.
           
           This event is needed because:
             * nsIWebProgressListener does not provide access to 
               the changing tab
             * "load" is dispatched only for tab favicons
             * "TabSelect" is dispatched only on tab change, not on 
                new content
       -->
      <method name="notifyTabContentChange">
        <body>
        <![CDATA[
          var event = document.createEvent("Events");
          event.initEvent("TabContentChange", true, false);
          this.dispatchEvent(event);
        ]]></body>
      </method>
      
      
      
      <!-- a bunch of methods from browser_xbl_temp.js / songbird_hack.js.
           I'm not convinced they belong here, but till we refactor a couple
           more things there's nowhere better for them to go. -->
           
      <!-- Handles playing the given URL by adding it to the web
           library, and if possible playing it from the current 
           web playlist.
        -->
      <method name="_playExternalUrl">
        <parameter name="aURL" />
        <parameter name="aTryWeb" />
        <body>
            <![CDATA[

          // figure out if the url is in the webplaylist
          var currentPlaylist = this.currentOuterPlaylist;
          
          if (aTryWeb && currentPlaylist)
          {
            var currentView = currentPlaylist.getListView();
            
            // Try to see if we've already found and scanned this url
            var listener = {
              foundItem: null,
              onEnumerationBegin: function onEnumerationBegin() {
                if (this.foundItem) {
                  return Components.interfaces.sbIMediaListEnumerationListener.CANCEL;
                }
                else {
                  return Components.interfaces.sbIMediaListEnumerationListener.CONTINUE;
                }
              },
              onEnumeratedItem: function onEnumeratedItem(list, item) {
                this.foundItem = item;
                return Components.interfaces.sbIMediaListEnumerationListener.CANCEL;
              },
              onEnumerationEnd: function onEnumerationEnd() {
              }
            };

            var currentMediaList = currentView.mediaList;
            
            currentMediaList.enumerateItemsByProperty(SBProperties.originURL, aURL, listener );
            currentMediaList.enumerateItemsByProperty(SBProperties.contentURL, aURL, listener );

            if (listener.foundItem) {
              gPPS.playView(currentView, 
                            currentView.getIndexForItem(listener.foundItem));
              return;
            }
          } 
          
          // otherwise, play the url as external (added to the db, 
          // plays the library from that point on)
          // if the url is already in the lib, it is not added twice
          var item = SBImportURLIntoWebLibrary(aURL);
          
          var view = LibraryUtils.createStandardMediaListView(LibraryUtils.webLibrary);

          // Get the sort for this list by parsing the list's column spec.  Then hit
          // the property manager to see if there is a special sort profile for this
          // ID
          var parser = new ColumnSpecParser(LibraryUtils.webLibrary, null);
          if (parser.sortID) {
            var pm =
              Components.classes["@songbirdnest.com/Songbird/Properties/PropertyManager;1"]
                        .getService(Components.interfaces.sbIPropertyManager);
            var sort = pm.getPropertySort(parser.sortID, parser.sortIsAscending);
            view.setSort(sort);
          }

          var index = view.getIndexForItem(item);
          
          // If we have a browser, try to show the view
          if (window.gBrowser) {
            gBrowser.showIndexInView(view, index);
          }
          
          // Play the item
          gPPS.playView(view, index);
          
        ]]></body>
      </method>


      <!-- Called when the user clicks on a media URL in a web page.
           Handles playing from the web playlist, opening as a playlist, etc. 
        -->
      <method name="_handleMediaURL">
        <parameter name="aURL" />
        <parameter name="aShouldBeginPlayback" />
        <parameter name="forcePlaylist" />
        <parameter name="target" />
        <parameter name="referrer" />
        <body><![CDATA[
          var retval = false;
          try
          {
            var ioService =
              Components.classes["@mozilla.org/network/io-service;1"]
                        .getService(Components.interfaces.nsIIOService);
            var uri;
            try {
              uri = ioService.newURI(aURL, null, null);
            }
            catch(e) {
            }

            // Stick playlists in the service pane (for now).
            if ( uri && (forcePlaylist || gPPS.isPlaylistURL( uri.spec )) )
            {
              var library = null;
              var scheme = uri.scheme;

              if ( scheme != "file" &&
                   scheme != "resource" &&
                   scheme != "chrome" &&
                   scheme != "jar" ) {
                library = LibraryUtils.webLibrary;
              }
              else {
                library = Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                          .getService(Components.interfaces.sbILibraryManager).mainLibrary;
              }

              // Check to see if this playlist already exists
              var propertyArray =
                Components.classes["@songbirdnest.com/Songbird/Properties/MutablePropertyArray;1"]
                          .createInstance(Components.interfaces.sbIMutablePropertyArray);
              propertyArray.appendProperty(SBProperties.isList, "1");
              propertyArray.appendProperty(SBProperties.originURL, uri.spec);

              var getFirstListener = {
                item: null,
                onEnumerationBegin: function() {
                },
                onEnumeratedItem: function(list, item) {
                  this.item = item;
                  return Components.interfaces.sbIMediaListEnumerationListener.CANCEL;
                },
                onEnumerationEnd: function() {
                }
              };

              library.enumerateItemsByProperties(propertyArray,
                                                 getFirstListener );

              // If we found a matching list, clear it, otherwise create it
              var mediaList;
              if (getFirstListener.item) {
                mediaList = getFirstListener.item;
                mediaList.clear();
              }
              else {
                if ( scheme == "http" ){
                  mediaList = this.mCurrentTab.outerPlaylist.mediaList;
                  if (mediaList) {
                    mediaList.clear();
                    this.showWebPlaylist = true;
                    var locationBar = document.getElementById("location_bar");
                    locationBar.uri = aURL;
                  }
                }
                
                if (!mediaList) {
                  mediaList = library.createMediaList("simple");
                  mediaList.name = gPPS.convertURLToDisplayName(aURL);
                  mediaList.setProperty("http://songbirdnest.com/data/1.0#originURL", uri.spec);
                }
              }

              var playlistReaderManager =
                Components.classes["@songbirdnest.com/Songbird/PlaylistReaderManager;1"]
                          .getService(Components.interfaces.sbIPlaylistReaderManager);
              var playlistReaderListener =
                Components.classes["@songbirdnest.com/Songbird/PlaylistReaderListener;1"]
                          .createInstance(Components.interfaces.sbIPlaylistReaderListener);

              // Create this closure here to prevent this object from getting garbage
              // collected too soon.  The playlist reader uses the nsIWebBrowserPersist
              // component that does _not_ addref this listener :(
              var playlist_observer = {
                observe: function ( aSubject, aTopic, aData ) {
                  if (aTopic.indexOf("error") != -1) {
                    // if we get an error parsing a page we thought was a 
                    // playlist then we were probably wrong. let's just load
                    // it in the browser
                    gBrowser.loadURI(aURL, referrer, null, null, target);
                  }
                  else {
                    var array =
                      Components.classes["@mozilla.org/array;1"]
                                .createInstance(Components.interfaces.nsIMutableArray);
                    for (var i = 0; i < mediaList.length; i++) {
                      array.appendElement(mediaList.getItemByIndex(i), false);
                    }

                    // Send the items in the new media list to the metadata scanner
                    var metadataJobManager =
                      Components.classes["@songbirdnest.com/Songbird/MetadataJobManager;1"]
                                .getService(Components.interfaces.sbIMetadataJobManager);
                    var metadataJob = metadataJobManager.newJob(array, 5);

                    // Start playback
                    var view = mediaList.createView();
                    gPPS.playView(view, 0);
                  }
                }
              };

              playlistReaderListener.playWhenLoaded = aShouldBeginPlayback;
              playlistReaderListener.observer = playlist_observer;
              playlistReaderListener.mediaMimetypesOnly = true;
              playlistReaderManager.originalURI = uri;
              playlistReaderManager.loadPlaylist(uri, mediaList, null, false, playlistReaderListener);
              retval = true;
            }
            // Everything else gets played directly.
            else if ( gPPS.isMediaURL( aURL ) )
            {
              this._playExternalUrl(aURL, true);
              retval = true;
            }
          }
          catch ( err )
          {
            alert("sb-tabbrowser::_handleMediaURL(" + aURL + "); " + err );
          }
          return retval;
        ]]></body>
      </method>



      <method name="onRemoteAPI">
        <parameter name="event" />
        <body>
              <![CDATA[
          // todo:
          //       hook up an action to do when the user clicks through, probably launch prepanel

          try {
            var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"]
                     .getService(Components.interfaces.nsIStringBundleService);
            var songbirdStrings = sbs.createBundle(
                               "chrome://songbird/locale/songbird.properties");
            var brandingStrings = sbs.createBundle(
                                  "chrome://branding/locale/brand.properties");
          } catch (e) { return; }

          var notificationName = "remoteapi-called";
          var message = "Web Page has accessed Songbird Directly";
          var editOptionsLabel = "Edit Options...";
          var editOptionsAccessKey = "O";
          var allowAlwaysLabel = "Always Allow Site"
          var iconURL = "";
          var appName = "Songbird";
          
          try {
            message = songbirdStrings
                        .GetStringFromName("rapi.access.message." + event.categoryID);
            editOptionsLabel = songbirdStrings
                                .GetStringFromName("rapi.access.button.label.options");
            editOptionsAccessKey = songbirdStrings
                                     .GetStringFromName("rapi.access.button.accessKey.options");
            allowAlwaysLabel = songbirdStrings
                                 .GetStringFromName("rapi.access.button.label.allow.always");
            iconURL = brandingStrings
                        .GetStringFromName("rapi.access.iconURL");
                        
            appName = brandingStrings
                        .GetStringFromName("brandShortName");
          } catch (e) { }

          message = message.replace(/\%S/, appName);

          var closure = event;
          
          var allowAlwaysCallback = function(aHat, aButtonInfo) {
            var nsIPermissionManager = Components.interfaces.nsIPermissionManager;
            var permManager = Components.classes["@mozilla.org/permissionmanager;1"]
                                .getService(nsIPermissionManager);
            permManager.add(closure.siteScope, "rapi." + closure.categoryID, nsIPermissionManager.ALLOW_ACTION);
            
            var allowEvt = Components.classes["@songbirdnest.com/remoteapi/security-event;1"]
                             .createInstance(Components.interfaces.sbIMutableRemoteSecurityEvent);

            allowEvt.initSecurityEvent( document,
                                        closure.siteScope,
                                        closure.category,
                                        closure.categoryID,
                                        true);

            aHat.closeEvent = allowEvt;

            // add metrics reporting here
          }

          var editOptionsCallback = function(aHat, aButtonInfo) {
            var editEvt = Components.classes["@songbirdnest.com/remoteapi/security-event;1"]
                        .createInstance(Components.interfaces.sbIMutableRemoteSecurityEvent);

            // this causes an access denied event to be sent to the page
            editEvt.initSecurityEvent( document,
                                       closure.siteScope,
                                       closure.category,
                                       closure.categoryID,
                                       false);

            aHat.closeEvent = editEvt;

            var prefWindow = SBOpenPreferences("paneRemoteAPI");
            if (prefWindow.gRemoteAPIPane) {
              /* if the window is already open ask it to configure the 
                 whitelist */
              prefWindow.gRemoteAPIPane.configureWhitelist(closure.categoryID,
                  closure.siteScope.spec);
            } else {
              /* if it's not yet open, ask it to open the whitelist when 
                 it's ready */
              prefWindow.pleaseConfigureWhitelist = 
                  [closure.categoryID, closure.siteScope.spec];
            }
            

            // add metrics reporting here
          }

          var buttons = [
                         {
                           label: editOptionsLabel,
                           accessKey: editOptionsAccessKey,
                           popup: null,
                           callback: editOptionsCallback
                         },
                         {
                           label: allowAlwaysLabel,
                           accessKey: null,
                           popup: null,
                           callback: allowAlwaysCallback
                         }
                         ];

          var browser = event.currentTarget
                             .gBrowser.getBrowserForDocument(event.target);
          var notificationBox = browser.parentNode;
          const priority = notificationBox.PRIORITY_WARNING_MEDIUM;
          var notification = event.currentTarget
                                  .gBrowser
                                  .showNotification(browser, notificationName, 
                                                    message, iconURL, priority,
                                                    buttons);
          
          var defaultEvt = Components.classes["@songbirdnest.com/remoteapi/security-event;1"]
                             .createInstance(Components.interfaces.sbIMutableRemoteSecurityEvent);

          defaultEvt.initSecurityEvent( document,
                                        closure.siteScope,
                                        closure.category,
                                        closure.categoryID,
                                        false);

          notification.closeEvent = defaultEvt;
        ]]></body>
      </method>
      
      <!--
        Show a notification message.  If the given notification already exists
        (but not necessarily shown), show it with an updated message.  Note that
        only the message (and not the icon, priority, or buttons) get updated.
        -->
      <method name="showNotification">
        <parameter name="aBrowser"/>
        <parameter name="aNotificationName"/>
        <parameter name="aMessage"/>
        <parameter name="aIconURL"/>
        <parameter name="aPriority"/>
        <parameter name="aButtons"/>
        <body><![CDATA[
          var browser = aBrowser;
          if (aBrowser instanceof Document) {
            // given a document; find the containing <browser> instead
            browser = this.getBrowserForDocument(aBrowser);
          } else if (aBrowser instanceof Components.interfaces.nsIDocShell) {
            // given a random docshell, try to find a <browser> that holds
            // an ancestor
            for (var i = 0; i < this.browsers.length; ++i) {
              // walk up the docshell tree to see if the <browser> we have is a parent
              var targetDocShell = aBrowser.QueryInterface(Components.interfaces.nsIDocShellTreeItem);
              browser = this.getBrowserAtIndex(i);
              while (targetDocShell && browser.docShell != targetDocShell) {
                targetDocShell = targetDocShell.parent;
              }
              if (browser.docShell == targetDocShell)
                break;
              browser = null;
            }
          }
          if (!browser) {
            throw Components.interfaces.NS_ERROR_INVALID_ARG;
          }
          
          var notificationBox = this.getNotificationBox(browser);
          var notification = notificationBox
                                   .getNotificationWithValue(aNotificationName);
          if (!notification) {
            // if there isn't a notification object, make one and append it
            notification = notificationBox.appendNotification(aMessage,
                                                              aNotificationName,
                                                              aIconURL,
                                                              aPriority,
                                                              aButtons);
          } else {
            // if there is a notification object set it's text.
            // this has the side effect of showing it if it was dismissed
            notification.message = aMessage;
          }
          return notification;
        ]]></body>
      </method>

      <!-- sbITabBrowser -->
      <method name="getTabForDocument">
        <parameter name="aDocument" />
        <body><![CDATA[
          var numTabs = this.mTabContainer.childNodes.length;
          for ( var index = 0; index < numTabs; index++ ) {
            if ( this.mTabContainer
                     .childNodes[index]
                     .linkedBrowser
                     .contentDocument == aDocument ) {
              return this.mTabContainer.childNodes[index];
            }
          }
          return null;
        ]]></body>
      </method>

      
      
      <!-- context menu handler -->
      <field name="_urlForHTMLContextMenu">null</field>
      <method name="onHTMLContextMenu">
        <parameter name="target" />
        <body><![CDATA[
          if ( this._urlForHTMLContextMenu ) {
            var v = target.getAttribute( "id" );
            switch ( v ) {
              case "html.context.open":
                // can be track or playlist
                // try dealing with media, might just be web content.
                if ( !this._handleMediaURL(this._urlForHTMLContextMenu, true, false, null, this.currentURI.spec) )
                {
                  this.loadURI(this._urlForHTMLContextMenu, this.currentURI.spec, null);
                }
              break;
              case "html.context.opentab":
                // can be track or playlist
                // try dealing with media, might just be web content.
                if ( !this._handleMediaURL(this._urlForHTMLContextMenu, true, false, '_blank', this.currentURI.spec) )
                {
                  this.loadOneTab(this._urlForHTMLContextMenu, this.currentURI, null, null, null, null);
                }
                break;
              case "html.context.openexternal":
                  var externalLoader = (Components
                           .classes["@mozilla.org/uriloader/external-protocol-service;1"]
                          .getService(Components.interfaces.nsIExternalProtocolService));
                  var nsURI = (Components
                          .classes["@mozilla.org/network/io-service;1"]
                          .getService(Components.interfaces.nsIIOService)
                          .newURI(this._urlForHTMLContextMenu, null, null));
                  externalLoader.loadURI(nsURI, null);
              break;
              case "html.context.play":
                // can be track or playlist
                this._handleMediaURL(this._urlForHTMLContextMenu, true, false);
              break;
              case "html.context.download":
                // figure out the media item for the url
                var currentPlaylist = this.currentOuterPlaylist;
                if (currentPlaylist)
                {
                  var currentView = currentPlaylist.getListView();
                  // Try to see if we've already found and scanned this url
                  var listener = {
                    item: null,
                    onEnumerationBegin: function onEnumerationBegin() {
                      if (this.item) {
                        return Components.interfaces.sbIMediaListEnumerationListener.CANCEL;
                      }
                      else {
                        return Components.interfaces.sbIMediaListEnumerationListener.CONTINUE;
                      }
                    },
                    onEnumeratedItem: function onEnumeratedItem(list, item) {
                      this.item = item;
                      return Components.interfaces.sbIMediaListEnumerationListener.CANCEL;
                    },
                    onEnumerationEnd: function onEnumerationEnd() {
                    }
                  };

                  var currentMediaList = currentView.mediaList;
                  
                  currentMediaList.enumerateItemsByProperty(SBProperties.originURL, this._urlForHTMLContextMenu, listener );
                  if (!listener.item)
                    currentMediaList.enumerateItemsByProperty(SBProperties.contentURL, this._urlForHTMLContextMenu, listener );

                  if (listener.item) {
                    var ddh =
                      Components.classes["@songbirdnest.com/Songbird/DownloadDeviceHelper;1"]
                                .getService(Components.interfaces.sbIDownloadDeviceHelper);
                    ddh.downloadItem(listener.item);
                  }
                }
              break;
              case "html.context.playlist":
                // Add playlists to the service pane (force it as a playlist)
                this._handleMediaURL(this._urlForHTMLContextMenu, false, true);
              break;
              case "html.context.copytoclipboard":
                var clipboard = Components.classes["@mozilla.org/widget/clipboardhelper;1"].getService(Components.interfaces.nsIClipboardHelper);
                clipboard.copyString(this._urlForHTMLContextMenu);
              break;
            }
            this._urlForHTMLContextMenu = null; // clear it because now we're done.
          }
        ]]></body>
      </method>

      <field name="_popupShowing">false</field>
      <method name="onContextPopupShowing">
        <parameter name="popup" />
        <parameter name="event" />
        <body><![CDATA[
          this._popupShowing = false;

          var XLINK_NS = 'http://www.w3.org/1999/xlink';

          this._urlForHTMLContextMenu = '';

          // are we on a link?
          var onLink = false;
          var elem = document.popupNode; // the node that triggered the popup
          // walk up the DOM looking for a link of some sort
          while (elem) {
            if(elem.nodeType == Node.ELEMENT_NODE) {
              if (elem instanceof HTMLAnchorElement && elem.href ||
                  elem instanceof HTMLAreaElement ||
                  elem instanceof HTMLLinkElement ||
                  elem.getAttribute(XLINK_NS, 'type') == 'simple') {
                onLink = true;
                break;
              }
            }
            elem = elem.parentNode;
          }
          if (elem && onLink) {
            // looks like we've got something
            if (elem.href) {
              // it's some kind of HTML link
              this._urlForHTMLContextMenu = elem.href;
            } else if (elem.hasAttributeNS(XLINK_NS, 'href')) {
              // it's an XLink link
              var xlink_href = elem.getAttributeNS(XLINK_NS, 'href');
              if (!xlink_href || !xlink_href.match(/\S/)) {
                // no link - fail
                onLink = false;
              }
              // use the IO service to make the URL absolute
              var ioService = Components.classes["@mozilla.org/network/io-service;1"]
                .getService(Components.interfaces.nsIIOService);
              var baseURI  = ioService.newURI(elem.baseURI, null, null);
              onLink = true;
              this._urlForHTMLContextMenu = ioService.newURI(baseURI.resolve(xlink_href), null, null).spec;
            } else {
              // we shouldn't get here, but if we do that thing we thought was a link isn't
              onLink = false;
            }

          }

          if (this._urlForHTMLContextMenu) {
            // Disable "Add" if the url isn't media or is already there.
            document.getElementById("html.context.download").setAttribute("disabled",
              SBUrlExistsInDatabase(this._urlForHTMLContextMenu) ||
              !gPPS.isMediaURL(this._urlForHTMLContextMenu));
            // allow the popup to be shown
            this._popupShowing = true;

          }

          return this._popupShowing; // should show
        ]]></body>
      </method>

      <method name="onContextPopupHiding">
        <parameter name="popup"/>
        <body><![CDATA[
          this._popupShowing = false;
        ]]></body>
      </method>


      <!-- Override tabBrowser.xul homepage.  Uses mozilla.org by default -->
      <property name="homePage">
        <getter><![CDATA[
          return Application.prefs.get("browser.startup.homepage").value;
        ]]></getter>
        <setter><![CDATA[
          Application.prefs.setValue("browser.startup.homepage", val);
        ]]></setter>
      </property>
      <method name="goHome">
        <body><![CDATA[
          this.loadURI(this.homePage, null, null);
        ]]></body>
      </method>

      <!-- implement sbIServicePaneListener -->
      <method name="nodePropertyChanged">
        <parameter name="aNodeId" />
        <parameter name="aPropertyName" />
        <body><![CDATA[
          var SP_NS = 'http://songbirdnest.com/rdf/servicepane#';
          var NC_NS = 'http://home.netscape.com/NC-rdf#';
          if (aPropertyName != SP_NS+'Properties' &&
              aPropertyName != NC_NS+'Name' &&
              aPropertyName != SP_NS+'Image') {
            // we only care about Properties and Image changing
            return;
          }

          // go through the tabs
          var tab = this.tabContainer.firstChild;
          while(tab) {
            // looking for one associated with the node that changed
            if (tab.servicePaneNode && 
                tab.servicePaneNode.id == aNodeId) {
              // and apply its properties
              tab.applyPropertiesFromServicePaneNode();
            }
            tab = tab.nextSibling;
          }
          ]]></body>
      </method>

    </implementation>

    <handlers>
      <handler event="click" phase="capturing" ><![CDATA[
        // inspired by contentAreaClick in ffox browser.js
        if (!event.isTrusted || event.getPreventDefault()) {
          return true;
        }

        if (this._popupShowing || event.button == 2) {
          // if we're showing a popup or about to show one, let's do nothing
          return true;
        }

        var target = event.target;
        var linkNode = null;

        if (target instanceof HTMLAnchorElement ||
            target instanceof HTMLAreaElement ||
            target instanceof HTMLLinkElement) {
          if (target.hasAttribute("href")) {
            linkNode = target;
          }

          // backwards compat - use the outermost link node
          var parent = target.parentNode;
          while (parent) {
            if (parent instanceof HTMLAnchorElement ||
                parent instanceof HTMLAreaElement ||
                parent instanceof HTMLLinkElement) {
                if (parent.hasAttribute("href")) {
                  linkNode = parent;
                }
            }
            parent = parent.parentNode;
          }
        } else {
          linkNode = event.originalTarget;
          while (linkNode && !(linkNode instanceof HTMLAnchorElement)) {
            linkNode = linkNode.parentNode;
          }
          // <a> cannot be nested.  So if we find an anchor without an
          // href, there is no useful <a> around the target
          if (linkNode && !linkNode.hasAttribute("href")) {
            linkNode = null;
          }
        }

        var wrapper = null;
        var href = null;
        var target = null;
        if (linkNode) {
          href = linkNode.href;
          if (linkNode.hasAttribute('target')) {
            target = linkNode.getAttribute('target');
          }
        } else {
          // Try simple XLink
          var realHref, baseURI;
          linkNode = target;
          while (linkNode) {
            if (linkNode.nodeType == Node.ELEMENT_NODE) {
              wrapper = linkNode;

              realHref = wrapper.getAttributeNS("http://www.w3.org/1999/xlink", "href");
              if (realHref) {
                href = realHref;
                baseURI = wrapper.baseURI
              }
            }
            linkNode = linkNode.parentNode;
          }
          if (href) {
            var ioService = Components.classes["@mozilla.org/network/io-service;1"]
                .getService(Components.interfaces.nsIIOService);
            var base = ioService.newURI(baseURI, null, null);
            href = ioService.newURI(base.resolve(href), null, null).spec;
          }
        }

        if (href) {
          // get the document that this event originated in
          var doc = event.target.ownerDocument;

          var secMan = Components.classes["@mozilla.org/scriptsecuritymanager;1"]
              .getService(Components.interfaces.nsIScriptSecurityManager);
          secMan.checkLoadURIStrWithPrincipal(doc.nodePrincipal, href,
              Components.interfaces.nsIScriptSecurityManager.STANDARD);

          // get the referrer if we can
          var referrer = doc ? doc.documentURIObject : null;
          
          // we need to handle playlists and media items specially
          if ( gPPS.isPlaylistURL(href) ||
               gPPS.isMediaURL(href) ) {
            this._handleMediaURL(href, false, false, target, referrer);
            event.stopPropagation();
            event.preventDefault();
          } else {
            var where = this._checkTarget(target, event);
            if (where &&
                this.loadURI(href, referrer, null, event, target)) {
              event.stopPropagation();
              event.preventDefault();
            }
          }

        }
        return true;
      ]]></handler>
    </handlers>
  </binding>






  <!-- these are from globalBindings.xml -->
  <binding id="tabbrowser-tab" extends="chrome://songbird/content/bindings/tabBrowser.xml#tabbrowser-tab">
    <content closetabtext="&tabs.closeTab;" mousethrough="never">
      <xul:hbox class="tab-image-left" xbl:inherits="selected"/>
      <xul:hbox flex="1" class="tab-image-middle" align="center" xbl:inherits="selected">
        <xul:stack class="tab-icon">
          <xul:image xbl:inherits="validate,src=image" class="tab-icon-image"/>
          <xul:image class="tab-extra-status"/>
        </xul:stack>
        <xul:label flex="1" xbl:inherits="value=label,crop,accesskey" crop="right" class="tab-text"/>
      </xul:hbox>
      <xul:toolbarbutton anonid="close-button" class="tab-close-button" tabindex="-1"/>
      <xul:hbox class="tab-image-right" xbl:inherits="selected"/>
    </content>
    <implementation implements="nsIWebProgressListener,sbITabBrowserTab">
      <constructor><![CDATA[
        // right after all the constructors run...
        var self = this;
        window.setTimeout(function () { self.createOuterPlaylist(); }, 0);
        this._hrefLoop = null;

        this._progressFilter =
          Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
                    .createInstance(Components.interfaces.nsIWebProgress);
        this._metrics =
          Components.classes["@songbirdnest.com/Songbird/Metrics;1"]
                    .createInstance(Components.interfaces.sbIMetrics);
        
        // Watch for page unloading so that we can store
        // the MediaListView state in the history
        this._onBrowserUnloadListener = function(e) {
          if (e.target.wrappedJSObject && 
            e.target.wrappedJSObject == self.linkedBrowser.contentDocument) 
          {
            self.onBrowserUnload(e);
          }
        }
        window.addEventListener("unload", 
              this._onBrowserUnloadListener, true);
        
        // Watch the inner medialist in case the tab needs to be closed                         
        this._mediaListRemovalMonitor = new LibraryUtils.RemovalMonitor(this);
        
      ]]></constructor>
     <destructor><![CDATA[
        this.closeBalloonTip();
        
        // Remove the browser DOM loaded event listener.
        this.linkedBrowser.removeEventListener("DOMContentLoaded",
                                               this.browserDOMLoadedEventListener,
                                               true);

        // Clear the progress filter.
        this._progressFilter.removeProgressListener(this);
        this.linkedBrowser.removeProgressListener(this._progressFilter);
        
        window.removeEventListener("unload", 
              this._onBrowserUnloadListener, true);
        
        if (this._mediaListRemovalMonitor) {
          this._mediaListRemovalMonitor.setMediaList(null);
          this._mediaListRemovalMonitor = null;
        }
     ]]></destructor>

      <field name="_progressFilter">null</field>
      
      <!-- LibraryUtils.RemovalMonitor -->
      <field name="_mediaListRemovalMonitor">null</field>

      <field name="_metrics">null</field>

      <method name="createOuterPlaylist">
        <body><![CDATA[
          /* from mainplayer.xul:
            <sb-smart-splitter id="playlist-web-splitter" hidden="true" state="open" resizebefore="closest" resizeafter="closest" target="after" collapse="after">
              <grippy/>
            </sb-smart-splitter>


            <vbox id="playlist_web_vbox" height="200" hidden="true" minheight="0" _resize_height="200">
              <sb-playlist
                id="playlist_web"
                height="105"
                flex="1"
                hidden="true"
                enableColumnDrag="true"
                persist="columnSpec"
                editable="true"
                minheight="0"
                columnSpec="http://songbirdnest.com/data/1.0#ordinal 20 a " +
                           "http://songbirdnest.com/data/1.0#trackName 395 " +
                           "http://songbirdnest.com/data/1.0#duration 50 " +
                           "http://songbirdnest.com/data/1.0#artistName 222 " +
                           "http://songbirdnest.com/data/1.0#albumName 222 " +
                           "http://songbirdnest.com/data/1.0#genre 70");
                _resize_height="105"
              />
            </vbox>
          */

          // get the notification box around the browser
          var nbox = this.linkedBrowser.parentNode;


          // make the splitter
          this._splitter = document.createElement('sb-smart-splitter');
          this._splitter.setAttribute('class', 'playlist-web-splitter');
          this._splitter.setAttribute('stateid', 'playlist_web_splitter');
          this._splitter.setAttribute('hidden', 'true');
          this._splitter.setAttribute('state', 'open');
          this._splitter.setAttribute('resizebefore', 'closest');
          this._splitter.setAttribute('resizeafter', 'closest');
          this._splitter.setAttribute('target', 'after');
          this._splitter.setAttribute('collapse', 'after');
          this._splitter.appendChild(document.createElement('grippy'));


          // SCARY HACK!  See Bug 3504.
          //
          // For whatever reason, hiding and then showing an
          // element in this context causes it to reappear
          // above its previous sibling.
          //
          // The Dom stays the same, but visually the
          // element moves.
          //
          // Fortunately adding a hidden box prevents this
          // behaviour.
          //
          // Awesome.

          var hack = document.createElement('vbox');
          hack.setAttribute('hidden', 'true');
          nbox.appendChild(hack);

          nbox.appendChild(this._splitter);

          hack = document.createElement('vbox');
          hack.setAttribute('hidden', 'true');
          nbox.appendChild(hack);

          // make the playlist
          this._playlist = document.createElement('sb-playlist');
          this._playlist.setAttribute('class', 'playlist_web');
          this._playlist.setAttribute('height', '200');
          this._playlist.setAttribute('hidden', 'true');
          this._playlist.setAttribute('enableColumnDrag', 'true');
          this._playlist.setAttribute('editable', 'true');
          this._playlist.setAttribute('minheight', '0');
          this._playlist.setAttribute('hidefilters', 'true');
          this._playlist.setAttribute('columnSpec',
              SBProperties.ordinal + ' 28 a ' +
              SBProperties.trackName + ' 300 ' +
              SBProperties.duration + ' 38 ' +
              SBProperties.artistName + ' 169 ' +
              SBProperties.albumName + ' 159 ' +
              SBProperties.downloadButton + ' 83');
          this._playlist.setAttribute('useColumnSpecPreference', 
                                      'songbird.webplaylist.columnspec');

          // Start the first scan as soon as the browser DOM has loaded
          this.browserDOMLoadedEventListener = {
            tabbrowser: this,
            handleEvent: function(event) {
              this.tabbrowser.setUpMediaPage();
              this.tabbrowser.scanWebPage();
            }
          }
          this.linkedBrowser.addEventListener("DOMContentLoaded",
                                              this.browserDOMLoadedEventListener,
                                              true);

          // wire up the browser progress filter
          this._progressFilter.addProgressListener(this, /* ignored */ null);
          this.linkedBrowser.addProgressListener(this._progressFilter,
            Components.interfaces.nsIWebProgress.NOTIFY_ALL);

          nbox.appendChild(this._playlist);

          this.outerPlaylistShowing = false;
        ]]></body>
      </method>

      <!-- sbITabBrowserTab -->
      <property name="outerPlaylist" readonly="true">
        <getter><![CDATA[
          return this._playlist;
        ]]></getter>
      </property>
      
      <!-- sbITabBrowserTab 
           TODO: Redundant, but needed for the remote API.  
           Remote API can't get the outerplaylist attribute
           for some stupid XPConnect reason.  Ask redfive.
        -->
      <method name="getPlaylist">
        <body><![CDATA[
          return this._playlist;
        ]]></body>
      </method>

      <!-- sbITabBrowserTab -->
      <method name="hideOuterPlaylist">
        <body><![CDATA[
          this.outerPlaylistShowing = false;
        ]]></body>
      </method>

      <!-- sbITabBrowserTab -->
      <method name="showOuterPlaylist">
        <body><![CDATA[
          this.outerPlaylistShowing = true;
        ]]></body>
      </method>

      <property name="outerPlaylistShowing">
        <getter><![CDATA[
          if (!this._playlist) return false;
          return (!this._playlist.hasAttribute("hidden") ||
                  this._playlist.getAttribute("hidden") == 'false');
        ]]></getter>
        <setter><![CDATA[
          if (!this._playlist) return;
          dump('\n\n\nsetting outerWebPlaylistShowing to: '+val+'\n\n\n\n');
          this._playlist.setAttribute("hidden", !val);
          this._splitter.setAttribute("hidden", !val);

          if (!val) {
            // if the balloontip for the webplaylist is shown, close it
            this.closeBalloonTip();
          } else {
            // open the balloontip if needed
            this.openBalloonTip();
          }

          if (this == this.parentNode.selectedItem) {
            // if in the foreground then we should set the state of the
            // subscribe button based on the visibility of the playlist
            SBDataSetBoolValue('browser.cansubscription', val);
          }
        ]]></setter>
      </property>

      <!-- sbITabBrowserTab -->
      <property name="mediaPage" readonly="true">
        <getter><![CDATA[

          if (!this.linkedBrowser.currentURI) {
            // guard against null currentURI that can be caused by about:blank
            return null;
          }

          if (!this.linkedBrowser.currentURI.schemeIs('chrome')) {
            // only chrome urls can supply a media page (for now)
            return null;
          }

          // Get the document from the current browser tab
          var pageWindow = this.linkedBrowser.contentWindow;
          if (pageWindow == null) {
            return null;
          } 
          else {
            pageWindow = pageWindow.wrappedJSObject;          
          }
          if (!("mediaPage" in pageWindow)) {
            return null;
          } 
          
          return pageWindow.mediaPage;
        ]]></getter>
      </property>

      <!-- sbITabBrowserTab -->
      <property name="mediaListView" readonly="true">
        <getter><![CDATA[
          if (this.mediaPage && this.mediaPage.mediaListView) {
            return this.mediaPage.mediaListView;
          } 
          if (this._viewForPage) {
            return this._viewForPage;
          } 
          if (this.outerPlaylist && this.outerPlaylist.mediaListView) {
            return this.outerPlaylist.mediaListView;
          } 
          return null;
        ]]></getter>
      </property>

      <!-- sbITabBrowserTab -->
      <field name="_shouldScan">true</field>

      <!-- sbITabBrowserTab -->
      <method name="enableScan">
        <body><![CDATA[
          this._shouldScan = true;
        ]]></body>
      </method>

      <!-- sbITabBrowserTab -->
      <method name="disableScan">
        <body><![CDATA[
          this._shouldScan = false;
        ]]></body>
      </method>

      <field name="scanProgress">-1</field>

      <!-- sbITabBrowserTab -->
      <method name="clearOuterPlaylist">
        <body><![CDATA[
          // hide the outer playlist
          CancelAsyncWebDocument(this._hrefLoop);
          this._hrefLoop = null;
          this.outerPlaylistShowing = false;
          this.scanProgress = -1;
        ]]></body>
      </method>
      
      <!-- The service pane node corresponding to this tab, 
           if one exists. -->
      <method name="_findServicePaneNode">
        <body><![CDATA[

          // Since this is a chrome URL the service pane
          // may have extra information about the location
          var servicePane = Components.classes['@songbirdnest.com/servicepane/service;1']
                                      .getService(Components.interfaces.sbIServicePaneService);
          servicePane.init();
          var servicePaneNode = servicePane.getNodeForURL(this.linkedBrowser.currentURI.spec); 

          // If we couldnt find a node for the URL, try
          // looking it up by media list
          if (!servicePaneNode && this.mediaListView) {
            var mediaList = this.mediaListView.mediaList;
            var libraryServicePane = 
              Components.classes['@songbirdnest.com/servicepane/library;1']
              .getService(Components.interfaces.sbILibraryServicePaneService);
            servicePaneNode = libraryServicePane.getNodeForLibraryResource(mediaList);
          }

          return servicePaneNode;
        ]]></body>
      </method>

      <method name="applyPropertiesFromServicePaneNode">
        <body><![CDATA[
            // Extra tags to be applied to the tab.
            // Used for CSS styling.
            var properties = "";

            var servicePaneNode = this.servicePaneNode;
            
            // The look of the tab may be controlled by
            // the service pane info
            if (servicePaneNode) {
              if (servicePaneNode.image) {
                gBrowser.setIcon(this, servicePaneNode.image);
              } 
              if (servicePaneNode.properties) {
                properties = servicePaneNode.properties;
              }
              if (servicePaneNode.name) {
                this.label = servicePaneNode.name;
              }
            }

            // Reflect the service pane properties for this URL (if any) onto the 
            // tab so that it can by styled with CSS.
            this.setAttribute("properties", properties);

            if (this.selected) {
              var event = document.createEvent('Events');
              event.initEvent('TabPropertyChange', true, false);
              this.dispatchEvent(event);
            }

          ]]></body>
      </method>

      <method name="scanWebPage">
        <body><![CDATA[
          if (!SBDataGetBoolValue('webplaylist.enabled')) {
            return;
          }

          // check to see if scanning has been disabled
          if (!this._shouldScan)
            return;

          // Only scrape http(s) and file pages
          var scheme = this.linkedBrowser.currentURI.scheme;
          if (scheme != 'http' && scheme != 'https' && scheme != 'file') {
            this.outerPlaylistShowing = false;
            return;
          }

          // Now all I have to do is find something resembling a usefully unique key.
          var browser = this.linkedBrowser;
          var history = browser.webNavigation.sessionHistory;
          var entry = history.getEntryAtIndex( history.index, false );

          // See if we're supposed to be restoring a view or making a new one
          var viewMap =
            Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
                      .getService(Components.interfaces.sbIMediaListViewMap);
          var view = viewMap.getView(browser, entry);


          if (!view) {
            var mediaList =
              this._getWebMediaListForURL(this.linkedBrowser.currentURI.spec,
                                          this.linkedBrowser.contentTitle);
            view = mediaList.createView();
          }

          // Otherwise, don't show the web playlist until we see some tracks.
          this.outerPlaylistShowing = false;

          // Bind the Web Playlist UI element to the subscribed playlist
          //SBWebPlaylistCommands.m_Playlist = this.outerPlaylist;

          var mgr =
            Components.classes["@songbirdnest.com/Songbird/PlaylistCommandsManager;1"]
                      .createInstance(Components.interfaces.sbIPlaylistCommandsManager);
          var cmds = mgr.request(kPlaylistCommands.MEDIAITEM_WEBPLAYLIST);

          this.outerPlaylist.outerWindow = window;
          this.outerPlaylist.bind(view, cmds,
                                  SBDataGetIntValue("browser.playlist.height"),
                                  SBDataGetBoolValue("browser.playlist.collapsed"));

          // If something has already been scanned into the view, show it.
          if (view.length)
              this.outerPlaylistShowing = true;

          // scrape the document.
          var context = {
            tab: this,
            pt: 0,
            get progressTotal() {
              return this.pt;
            },
            set progressTotal(p) {
              this.pt = p;
              this.setProgress();
            },
            pc: 0,
            get progressCurrent() {
              return this.pc;
            },
            set progressCurrent(p) {
              this.pc = p;
              this.setProgress();
            },
            setProgress: function setProgress() {
              this.tab.scanProgress = (1.0*this.pc)/this.pt;
            },
            sp: false,
            get showPlaylist() {
              return this.sp;
            },
            set showPlaylist(s) {
              this.tab.outerPlaylistShowing = s;
              this.sp = s;
            }
          };
          this.scanProgress = 0;
          this._hrefLoop = AsyncWebDocument(this.linkedBrowser.contentDocument,
                                            view, this._hrefLoop, context,
                                            this.linkedBrowser.contentTitle);
        ]]></body>
      </method>

      <!-- Holds an sbIMediaListView that is to be handed to the
           window if it turns out to be a Media Page.  
           Set when loadURI is passed a view, and cleared when
           loading a non media page. -->
      <field name="_viewForPage">null</field>
      
      <!-- Indicates that _viewForPage has been newly set
           by browser.loadURI, and is to be loaded for the 
           first time in setUpMediaPage.  Used to determine
           when _viewForPage should be cleared. -->
      <field name="_isNewViewForPage">false</field>
      
      <!-- A media list view index that the mediapage should 
           highlight on load.   
           Set by gBrowser.showIndexInView and consumed
           by tab.setUpMediaPage. -->
      <field name="_highlightViewIndexOnLoad">null</field>
      

      <method name="setUpMediaPage">
        <body><![CDATA[
        if (!this.mediaPage) {
          
          // The loaded page is not a MediaPage, so we can't
          // do anything with the view we were given.  
          // Throw it away.
          this._viewForPage = null;
          this._isNewViewForPage = false;
          this._highlightViewIndexOnLoad = null;
          return;
        }
        
        try {          
          
          var page = this.mediaPage;
          var view;
          
          // If nothing in the history, were we explicitly passed a view?
          if (this._viewForPage) {
            view = this._viewForPage;  
            
            // We've consumed the view, so it is no longer a new load
            this._isNewViewForPage = false;            
          }
          
          if (view) {
            page.mediaListView = view;

            // Monitor the media list that the page is displaying.
            // If it dies, we need to close the tab.
            this._mediaListRemovalMonitor.setMediaList(view.mediaList);
          
          } else {
          
            // We did not get a view.  This may be an error, or may be 
            // because the medialist has been removed.
            Components.utils.reportError("sbTabBrowser.setUpMediaPage did not find a view!");
            this.backWithDefault();           
          }
        }
        catch (e) {
          Components.utils.reportError(e);
        }
        ]]></body>
      </method>
      

      <!-- Called if the medialist in the browser
           is removed from the system -->
      <method name="onMediaListRemoved">
        <body><![CDATA[
          this._viewForPage = null;
          this.backWithDefault();
        ]]></body>
      </method>

      <method name="_getWebMediaListForURL">
        <parameter name="aURL"/>
        <parameter name="aTitle"/>
        <body><![CDATA[
          var listener = {
            foundList: null,
            onEnumerationBegin: function onEnumerationBegin(list) {
            },
            onEnumeratedItem: function onEnumeratedItem(list, item) {
              if (!(item instanceof Components.interfaces.sbIMediaList)) {
                throw new Error("Given an item, not a list!");
              }
              this.foundList = item;
              return Components.interfaces.sbIMediaListEnumerationListener.CANCEL;
            },
            onEnumerationEnd: function onEnumerationEnd(list) {
            }
          };

          var propArray =
            Components.classes["@songbirdnest.com/Songbird/Properties/MutablePropertyArray;1"]
                      .createInstance(Components.interfaces.sbIMutablePropertyArray);
          propArray.appendProperty(SBProperties.originPage, aURL);
          propArray.appendProperty(SBProperties.isList, "1");

          var webLibrary = LibraryUtils.webLibrary;
          webLibrary.enumerateItemsByProperties(propArray, listener );

          if (listener.foundList) {
            return listener.foundList;
          }

          var propArray = [
              [SBProperties.originPage, aURL],
              [SBProperties.originPageTitle, aTitle]
            ];

          // Make a new list and set the originPage property.
          var newList = webLibrary.createMediaList("simple", SBProperties.createArray(propArray));

          // XXXben Do this for now because the new AddToPlaylist code sweeps
          //        all non-hidden media lists from *all* libraries.
          newList.setProperty(SBProperties.hidden, "1");

          return newList;
        ]]></body>
      </method>

      <!-- Used to save the URL that is loading so that we can properly match
           the web progress messages -->
      <field name="_loadingURL">""</field>

      <!-- nsIWebProgressListener implementation -->
      <method name="onLocationChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aLocation" />
        <body><![CDATA[
          // if this location change isn't on the top-level window, ignore it
          if (aWebProgress.DOMWindow != aWebProgress.DOMWindow.parent) {
            return;
          }

          // clear the search engines that have been discovered
          this.linkedBrowser.engines = null;

          var location = aLocation ? aLocation.spec : "";

          // Remove live HTML tooltips
          if (document.tooltipNode) {
            // Optimise for the common case
            if (aWebProgress.DOMWindow == content) {
              // TODO: Songbird does not have an aHTMLTooltip! 
              // This needs to be copied from browser.xul!
              //document.getElementById("aHTMLTooltip").hidePopup();
              document.tooltipNode = null;
            }
            else {
              for (var tooltipWindow =
                      document.tooltipNode.ownerDocument.defaultView;
                    tooltipWindow != tooltipWindow.parent;
                    tooltipWindow = tooltipWindow.parent) {
                if (tooltipWindow == aWebProgress.DOMWindow) {
                  // TODO: Songbird does not have an aHTMLTooltip! 
                  // This needs to be copied from browser.xul!
                  //document.getElementById("aHTMLTooltip").hidePopup();
                  document.tooltipNode = null;
                  break;
                }
              }
            }
          }

          // Remove the notification only if the URL has actually changed
          
          // This code here does not compare uris exactly when determining
          // whether or not the message should be hidden since the message
          // may be prematurely hidden when an install is invoked by a click
          // on a link that looks like this:
          //
          // <a href="#" onclick="return install();">Install Foo</a>
          //
          // - which fires a onLocationChange message to uri + '#'...
          var selectedBrowser = getBrowser().selectedBrowser;
          if (selectedBrowser.lastURI) {
            var oldSpec = selectedBrowser.lastURI.spec;
            var oldIndexOfHash = oldSpec.indexOf("#");
            if (oldIndexOfHash != -1)
              oldSpec = oldSpec.substr(0, oldIndexOfHash);
            var newSpec = location;
            var newIndexOfHash = newSpec.indexOf("#");
            if (newIndexOfHash != -1)
              newSpec = newSpec.substr(0, newSpec.indexOf("#"));
            if (newSpec != oldSpec) {
              // Remove all the notifications, except for those which want to
              // persist across the first location change.
              var nBox = gBrowser.getNotificationBox(selectedBrowser);
              for (var n = nBox.allNotifications.length - 1; n >= 0; n--) {
                var notify = nBox.allNotifications[n];
                if (notify.ignoreFirstLocationChange)
                  notify.ignoreFirstLocationChange = false;
                else if (!notify.ignoreLocationChangeTimeout ||
                  (Date.now() / 1000) > notify.ignoreLocationChangeTimeout)
                  nBox.removeNotification(notify);
              }
            }
          }
          selectedBrowser.lastURI = aLocation;

          // Stop monitoring the current media list, since it no longer matters
          this._mediaListRemovalMonitor.setMediaList(null);

          // set the loadingURI so we know in onStateChange when to  cause a
          // scan of the web page to populate the web playlist. Do it
          // here and not in onStateChange because the STATE_START message has
          // the wrong document URI when using the back button (and probably
          // when going from site to site).

          this._loadingURL = aLocation.spec;
          this.clearOuterPlaylist();
          this._shouldScan = true;
          
          
          if (!this._isNewViewForPage) {

            // Look for an existing view for this page using the browser history
            var viewMap =
              Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
                        .getService(Components.interfaces.sbIMediaListViewMap);

            var browser = this.linkedBrowser;
            var history = browser.webNavigation.sessionHistory;
            var entry = history.getEntryAtIndex( history.index, false );
            
            this._viewForPage = viewMap.getView( browser, entry );
          }

          this.servicePaneNode = this._findServicePaneNode();

          this.applyPropertiesFromServicePaneNode();
          
        ]]></body>
      </method>

      <method name="onProgressChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aCurSelfProgress" />
        <parameter name="aMaxSelfProgress" />
        <parameter name="aCurTotalProgress" />
        <parameter name="aMaxTotalProgress" />
        <body><![CDATA[ ]]></body>
      </method>

      <method name="onSecurityChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <body><![CDATA[ ]]></body>
      </method>

      <method name="onStateChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aStatus" />
        <body><![CDATA[
          // if this state change isn't on the top-level window, ignore it
          if (aWebProgress.DOMWindow != aWebProgress.DOMWindow.parent ||
              !(aState & Components.interfaces.nsIWebProgressListener.STATE_IS_WINDOW)) {
            return;
          }

          const nsIWebProgressListener =
            Components.interfaces.nsIWebProgressListener;
          if (aState & nsIWebProgressListener.STATE_STOP) {
            if (!(this.linkedBrowser.contentDocument &&
                  this.linkedBrowser.contentDocument.documentURI == this._loadingURL)) {
              return;
            }
            this._loadingURL = "";

            if (this.mediaPage) {

              // If we have to highlight something, now is
              // probably a good time
              if (this._highlightViewIndexOnLoad !== null && 
                  this.mediaPage.mediaListView) 
              {
                var index = this._highlightViewIndexOnLoad;
                var page = this.mediaPage;
                this._highlightViewIndexOnLoad = null;
                
                // XXX Whhhhhy do I have to use a timeout? 
                // The playlist sets the selection correctly, but then 
                // immediately clears it.
                setTimeout(function() { page.highlightItem(index); }, 500);
              }

            } else {
              this._metrics.metricsInc("app.browser", "pageViews", "");
              this.scanWebPage();
            }
          }
        ]]></body>
      </method>

      <method name="onStatusChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aMessage" />
        <body><![CDATA[ ]]></body>
      </method>

      <!-- Called when the page in the linked browser is unloaded -->
      <method name="onBrowserUnload">
        <parameter name="evt"/>
        <body>
        <![CDATA[
           
          // For now only save view history for chrome media pages
          if (!this.linkedBrowser.currentURI.schemeIs("chrome") ||
              !this.mediaPage) {
            return;
          }

          var browser = this.linkedBrowser;
          var history = browser.webNavigation.sessionHistory;
          var entry = history.getEntryAtIndex( history.index, false );

          // TODO why dont we care about saving view history for web pages?
          var viewMap =
            Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
                      .getService(Components.interfaces.sbIMediaListViewMap);
          viewMap.setView(browser, entry, this.mediaPage.mediaListView);
        ]]>
        </body>
      </method>

      <method name="openBalloonTip">
        <body><![CDATA[
          if (!SBDataGetBoolValue("balloontip.firstwebplaylist.shown")) {
            this.balloontip = new BalloonTip;
            var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"].getService(Components.interfaces.nsIStringBundleService);
            var songbirdStrings = sbs.createBundle("chrome://songbird/locale/songbird.properties");
            var title = "Found media."
            var text = "Songbird has found the following playable tracks."
            try {
              title = songbirdStrings.GetStringFromName("balloontip.firstwebplaylist.title");
              text = songbirdStrings.GetStringFromName("balloontip.firstwebplaylist.text");
            } catch (e) { }
            this.balloontip.showText(text, this._playlist, title, 'balloon-icon-songbird', null, -1);
            SBDataSetBoolValue("balloontip.firstwebplaylist.shown", true);
          }
        ]]></body>
      </method>

      <method name="closeBalloonTip">
        <body><![CDATA[
          if (this.balloontip) {
            this.balloontip.closeTip();
            this.balloontip = null;
          }
        ]]></body>
      </method>

      <!-- tab dnd helpers -->
      <method name="canDrop">
        <parameter name="event"></parameter>
        <parameter name="session"></parameter>
        <body><![CDATA[
          var canDrop = false;
          var mediaPage = this.mediaPage;
          if (mediaPage) {
            canDrop = mediaPage.canDrop(event, session);
          }
          return canDrop;
        ]]></body>
      </method>
      <field name="_dragTimeout">350</field>
      <field name="_dragTimer">null</field>

      <method name="backWithDefault">
        <body>
          <![CDATA[
            var browser = this.linkedBrowser;
            var history = browser.webNavigation.sessionHistory;

            // Try going back in the history
            if (this.linkedBrowser.canGoBack) {
              this.linkedBrowser.goBack();
              return;
            }

            // Going back failed.  Just go to the library.
            gBrowser.loadMediaList(LibraryUtils.mainLibrary, null, this);
          ]]>
        </body>
      </method>

    </implementation>

    <handlers>
      <handler event="TabClose"><![CDATA[
        // Stop async scanner and hide outerplaylist
        this.clearOuterPlaylist();

        // When we drop the tab, release all of the associated views stored in the map.
        Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
                  .getService(Components.interfaces.sbIMediaListViewMap)
                  .releaseViews(event.target.linkedBrowser);

        if (this._playlist) {
          this._playlist.destroy();
          this._playlist.parentNode.removeChild(this._playlist);
          this._playlist = null;
        }
        if (this._splitter) {
          this._splitter.destroy();
          this._splitter.parentNode.removeChild(this._splitter);
          this._splitter = null;
        }

        this._metrics = null;
        
        if (this._mediaListRemovalMonitor) {
          this._mediaListRemovalMonitor.setMediaList(null);
          this._mediaListRemovalMonitor = null;
        }
        
        this._viewForPage = null;

        // save the tab state soon
        setTimeout("window.gBrowser.saveTabState();", 100);
      ]]></handler>

      <handler event="dragenter"><![CDATA[
        var dragService = Components.classes["@mozilla.org/widget/dragservice;1"]
           .getService(Components.interfaces.nsIDragService);
        var session = dragService.getCurrentSession();

        session.canDrop = this.canDrop(event, session);

        if (session.canDrop && !this._dragTimer && this._dragTimeout) {
          (function(tab) {
            tab._dragTimer = setTimeout(function() {
              tab._dragTimer = null;

              // set up an interval callback to check if the drag has completed
              // and restore the original tab when it's done
              if (!gBrowser._springLoadedTab) {
                gBrowser._springLoadedTab = {
                  tab: gBrowser.mTabContainer.selectedItem,
                  interval: setInterval(function() {
                    if (!dragService.getCurrentSession()) {
                      // the drag is over, clear the timer, clear the state
                      // restore the tab
                      gBrowser.mTabContainer.selectedItem =
                          gBrowser._springLoadedTab.tab;
                      clearInterval(gBrowser._springLoadedTab.interval);
                      gBrowser._springLoadedTab = null;
                    }
                  }, 500)
                }
              }

              gBrowser.mTabContainer.selectedItem = tab;
            }, tab._dragTimeout);
          })(this);
        }

      ]]></handler>
      <handler event="dragleave"><![CDATA[
        if (this._dragTimer) {
          clearTimeout(this._dragTimer);
          this._dragTimer = null;
        }
      ]]></handler>
      <handler event="dragdrop"><![CDATA[
        var dragService = Components.classes["@mozilla.org/widget/dragservice;1"]
           .getService(Components.interfaces.nsIDragService);
        var session = dragService.getCurrentSession();

        if (this.canDrop(event, session)) {
          var mediaPage = this.mediaPage;
          if (mediaPage) {
            mediaPage.onDrop(event, session);
          }
        }
      ]]></handler>
    </handlers>
  </binding>

   <binding id="tabbrowser-tabs"
            extends="chrome://songbird/content/bindings/tabBrowser.xml#tabbrowser-tabs">
    <content>
      <xul:stack flex="1" class="tabs-stack">
        <xul:vbox>
          <xul:spacer flex="1"/>
          <xul:hbox class="tabs-bottom" align="center"/>
        </xul:vbox>
        <xul:vbox>
          <xul:hbox>
            <xul:stack>
              <xul:spacer class="tabs-left"/>
            </xul:stack>
            <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1" style="min-width: 1px;" class="tabbrowser-arrowscrollbox">
              <children/>
            </xul:arrowscrollbox>
            <xul:stack align="center" pack="end" hidden="true">
              <!-- XXXMook the all-tabs button is hidden for now because it's
                   totally broken - see songbird bug 4066 -->
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035
              -->
              <xul:hbox style="position: relative;">
                <xul:hbox flex="1" class="tabs-alltabs-box"
                          anonid="alltabs-box"/>
              </xul:hbox>
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035
              -->
              <xul:hbox style="position: relative;">
                <xul:hbox flex="1" class="tabs-alltabs-box-animate"
                          anonid="alltabs-box-animate"/>
              </xul:hbox>
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035
              -->
              <xul:hbox style="position: relative;">
                <xul:toolbarbutton class="tabs-alltabs-button"
                                   type="menu"
                                   anonid="alltabs-button"
                                   tooltipstring="&tabs.listAllTabs;">
                  <xul:menupopup class="tabs-alltabs-popup"
                                 anonid="alltabs-popup" position="after_end"/>
                </xul:toolbarbutton>
              </xul:hbox>
            </xul:stack>
            <xul:hbox class="tabs-closebutton-box" align="center" pack="end" anonid="tabstrip-closebutton">
              <xul:toolbarbutton class="close-button tabs-closebutton"/>
            </xul:hbox>
          </xul:hbox>
          <xul:spacer class="tabs-bottom-spacer"/>
        </xul:vbox>
      </xul:stack>
    </content>
  </binding>

</bindings>
