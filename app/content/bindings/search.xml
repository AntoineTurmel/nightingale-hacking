<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<!--


    WOO HOO!! LET'S MAKE A BINDING WIDGET!!


-->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="search">
    <content>
      <xul:hbox onmousedown="onFirstMousedown();" onfocus="onFirstMousedown();" align="center" flex="1">
        <xul:button 
          sbid="search.button"
          type="menu"
          xbl:inherits="id=buttonid"
          oncommand="onSearchServiceMenu(event.target);"
        >
          <xul:menupopup id="search.popup">
            <xul:menuitem id="search.popup.songbird" sid="search.item.songbird"
              label="Library" class="menuitem-iconic" image="chrome://songbird/skin/icons/icon_lib_16x16.png"
            />
              <xul:menuitem id="search.popup.dogpile" 
                label="dogpile" class="menuitem-iconic" image="chrome://service-icons/skin/dogpile.ico"
            />
              <xul:menuitem id="search.popup.elbows" 
                label="elbo.ws" class="menuitem-iconic" image="chrome://service-icons/skin/elbows.ico"
            />
              <xul:menuitem id="search.popup.mefeedia" 
                label="mefeedia" class="menuitem-iconic" image="http://www.mefeedia.com/favicon.ico"
            />
              <xul:menuitem id="search.popup.google" 
                label="Google" class="menuitem-iconic" image="chrome://service-icons/skin/google.ico"
            />
              <xul:menuitem id="search.popup.yahoo" 
                label="Yahoo!" class="menuitem-iconic" image="chrome://service-icons/skin/yahoo.ico"
            />
              <xul:menuitem id="search.popup.wiki" 
                label="Wikipedia" class="menuitem-iconic" image="chrome://service-icons/skin/default.ico"
            />
              <xul:menuitem id="search.popup.emusic" 
                label="eMusic" class="menuitem-iconic" image="chrome://service-icons/skin/emusic.ico"
            />
<!--              <xul:menuitem id="search.popup.creativecommons" 
                label="Creative Commons" class="menuitem-iconic" image="http://creativecommons.org/favicon.ico"
            />         -->
          </xul:menupopup>
        </xul:button>
         
        <xul:menulist 
          sbid="search.list"
          xbl:inherits="id=listid"
          editable="true"
          xxx_onchange="onSearchChange();"
          xxx_oncommand="onSearchChange();"
          onkeypress="onSearchKeypress( event );"
          flex="1"
        >
          <xul:menupopup 
            sbid="search.list.popup"
            id="search.list.popup"
            onpopupshowing="onSearchPopup();"
          />
        </xul:menulist>

        <children/>
      </xul:hbox>
    </content>

   <implementation>

    <!-- CONSTRUCTION -->
    <constructor>
    <![CDATA[
    try
    {
      // Set our starting values.                              
      this.theSongbirdSearchSelection = document.getAnonymousElementByAttribute( this, "sid", "search.item.songbird" );
      this.theCurrentSearchSelection = this.theSongbirdSearchSelection;
      if ( this.theCurrentSearchSelection )
      {
        this.button.setAttribute( "image", this.theCurrentSearchSelection.getAttribute( "image" ) );
      }

      var defwebsearchid = SBDataGetStringValue( "search.defaultweb" );
      if (defwebsearchid != "") {
        this.theLastWebSearchSelection = document.getElementById( defwebsearchid );
      }
      if (!this.theLastWebSearchSelection) this.theLastWebSearchSelection = this.theSongbirdSearchSelection.nextSibling;

      this.editIdleInterval = null;

      this.playlistSource = new sbIPlaylistsource();

      this.browserUrl = SB_NewDataRemote( "browser.uri", null );
      // event handler for the url data remote
      const on_browser_url_data_change = { 
        observe: function( aSubject, aTopic, aData ) { onBrowserUrlDataChanged(); } 
      };
      this.browserUrl.bindObserver(on_browser_url_data_change, true);

      this.playlistRef = SB_NewDataRemote( "playlist.ref", null );
      // event handler for the playlist ref data remote
      const on_playlist_ref_change = { 
        observe: function( aSubject, aTopic, aData ) { onPlaylistRefChanged(); } 
      };
      this.playlistRef.bindObserver(on_playlist_ref_change, true);
      
      // if the fist page loaded on startup is a webpage, we should switch to the last websearch engine.
      // do this manually here because calling onBrowserUrlDataChanged on startup would reset the default 
      // search string
      if (!this.isPlaylistUrl(this.browserUrl.stringValue)) {
        if (this.theLastWebSearchSelection) {
          this.theCurrentSearchSelection = this.theLastWebSearchSelection;
          this.button.image = this.theCurrentSearchSelection.getAttribute( "image" );
        }
      }
      
      // Stuff us into the document context so we can find us from an interval callback
      document.__SEARCH_WIDGET__ = this;
      
      this.list.label = this.getDefaultSearchString();
    }
    catch ( err )
    {
      alert( err );
    }
    ]]>
    </constructor>
    
    <destructor>
      this.browserUrl.unbind();
      this.playlistRef.unbind();
    </destructor>

    <!-- DATA FIELDS -->
    <field name="button">document.getAnonymousElementByAttribute(this, 'sbid', 'search.button');</field>
    <field name="list">  document.getAnonymousElementByAttribute(this, 'sbid', 'search.list');  </field>
    <field name="popup"> document.getAnonymousElementByAttribute(this, 'sbid', 'search.list.popup'); </field>
    <field name="first_mousedown">false</field>

    <!-- DATA PROPERTIES -->
    <property name="cur_service">
      <getter>
        return this.theCurrentSearchSelection;
      </getter>
      <setter>
        // readonly, bitches!
      </setter>
    </property>
    
    <property name="is_songbird">
      <getter>
        return ( this.theCurrentSearchSelection == this.theSongbirdSearchSelection );
      </getter>
      <setter>
        // readonly, bitches!
      </setter>
    </property>

    <property name="reset">
      <getter>
        return 0;
      </getter>
      <setter>
        this.onSearchPopup();
      </setter>
    </property>

    <method name="getDefaultSearchString">
      <body>
        <![CDATA[
          var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"].getService(Components.interfaces.nsIStringBundleService);
          var songbirdStrings = sbs.createBundle("chrome://songbird/locale/songbird.properties");
          var defaultsearchstring = "Search";
          try {
            defaultsearchstring = songbirdStrings.GetStringFromName("search.defaultstring");
          } catch (err) { /* ignore error, we have default strings */ }
          return defaultsearchstring;
        ]]>
      </body>
    </method>

    <!-- INTERNAL EVENT HANDLERS -->
    <method name="onFirstMousedown">
      <parameter name="event"/>
      <body>
      <![CDATA[
      try
      {
        if ( ! this.first_mousedown )
        {
          this.list.label = "";
          this.first_mousedown = true;
        }
        this.list.setAttribute( "focused", "true" );
        this.list.mInputField.focus();
        
        // Why select?  This was causing some funky behaviour..
        //this.list.mInputField.select();
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>
    
    <method name="onSearchServiceMenu">
      <parameter name="target"/>
      <body>
      <![CDATA[
      try
      {
        this.theCurrentSearchSelection = target;
        this.button.image = this.theCurrentSearchSelection.getAttribute( "image" );
        if (this.theCurrentSearchSelection != this.theSongbirdSearchSelection) {
          this.theLastWebSearchSelection = this.theCurrentSearchSelection;
          var defwebsearchid = this.theLastWebSearchSelection.getAttribute("id");
          SBDataSetStringValue( "search.defaultweb", defwebsearchid );
        }
        this.onSearchChange();
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>
    
    <method name="onSearchChange">
      <body>
      <![CDATA[
      try
      {
        var empty_space = " ";
        var search_term = this.list.label;
        if ( ( search_term.length > 0 ) && ( search_term != empty_space ) )
        {          
          this.sendSearchEvent();
          metrics_inc("searchwidget", document.__SEARCH_WIDGET__.theCurrentSearchSelection.getAttribute("id"), null);
          
          // Keep last 4 search terms for display in popup
          var recentSearches = SB_NewDataRemote( "searchwidget.recentstrings", null ); 
          var searchStrings = recentSearches.stringValue.split("\n");
          if (searchStrings.indexOf(search_term) == -1) 
          {
            if (searchStrings.length > 3 || (searchStrings.length == 1 && searchStrings[0] == ""))
            {
              searchStrings.pop();
            }
            searchStrings.unshift(search_term);
            recentSearches.stringValue = searchStrings.join("\n");
            this.onSearchPopup();
          }
        }
        else
        {
          // Is the term now empty?
          this.list.selectedIndex = -1;
          this.list.label = "";
        }
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>
    
    <method name="onSearchKeypress">
      <parameter name="evt"/>
      <body>
      <![CDATA[
      try
      {
        switch ( evt.keyCode )
        {
          case 9:  // Tab
          case 19: // Break
          case 37: // Arrows
          case 38:
          case 39:
          case 40:
          case 35: // End
          case 36: // Home
          case 45: // Insert
          case 33: // PgUp
          case 34: // PgDn
          case 112: // F1-F12
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
          case 123:
            break;      
          case 27: // Esc
            this.list.label = ""; // Clear it
            // Fallthru
          case 13: // Return
            this.onSearchChange();
            this.list.mInputField.select();
            break;      
          default:
            if ( this.editIdleInterval )
            {
              clearInterval( this.editIdleInterval );
            }
            this.editIdleInterval = setInterval( this.onSearchEditIdle, 1000 );
            break;      
        }
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>
    
    <method name="onSearchEditIdle">
      <body>
      <![CDATA[
      try
      {
        // WOO HOO.  YAY FOR GLOBAL DATA POLLUTING MY DOCUMENT OBJECT!!
        if ( document.__SEARCH_WIDGET__.theCurrentSearchSelection == document.__SEARCH_WIDGET__.theSongbirdSearchSelection )
        {
          // Only do key timeouts when the library is selected
          document.__SEARCH_WIDGET__.sendSearchEvent();
          metrics_inc("searchwidget", document.__SEARCH_WIDGET__.theCurrentSearchSelection.getAttribute("id"), null);
        }
        clearInterval( document.__SEARCH_WIDGET__.editIdleInterval );
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>

    <method name="onSearchPopup">
      <body>
      <![CDATA[
      try
      {
        var empty_space = " ";

        var prev_sel = this.list.selectedIndex;
        var prev_label = this.list.label;
        
        var modified = false;
        
  
        // Look for metadata that might be worth searching
        var playbackURL = SBDataGetStringValue( "metadata.url" );
        if ( playbackURL.length )
        {

          this.list.removeAllItems();

          var title = SBDataGetStringValue("metadata.title");
          var artist = SBDataGetStringValue("metadata.artist");
          var album = SBDataGetStringValue("metadata.album");
          var genre = SBDataGetStringValue("metadata.genre");
          
          var metarray = [ title, artist, album, genre ];
          for ( var j = 0; j < metarray.length; j++ )
          {
            var value = "" + metarray[j];
            // LAME.  If I append a totally blank item it is autoselected.
            if ( ! value.length )
            {
              value = " ";
              // A unique number of blank spaces to ensure that the metadata column is preserved
              for ( var k = 0; k < j; k++ )
              {
                value += empty_space; 
              }
            }
            this.list.appendItem( value, null, null )
            modified = true;
          }
        }
        
        
        // Add previous searches
        var recentSearches = SBDataGetStringValue( "searchwidget.recentstrings" ); 
        if (recentSearches.length)
        {
          if (!modified) 
          {
            this.list.removeAllItems();
          }
          else 
          {
            var item = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "menuseparator");
            this.list.menupopup.appendChild(item);
          }
          
          recentSearches = recentSearches.split("\n");
          for (var i = 0; i < recentSearches.length; i++)
          {
            this.list.appendItem( recentSearches[i], null, null )
          }
          
          modified = true;
        }
        
        
        // If the list was modified, fix/restore the selected item
        if (modified) 
        {
          this.list.selectedIndex = prev_sel;
          if ( prev_sel == -1 )
          {
            // Reset the label if it's a hand-edited label.
            this.list.label = prev_label;
          }
        }
      }
      catch( err )
      {
        alert( " search.xml:onSearchPopup" + err )
      }
      ]]>
      </body>
    </method>

    <!-- EXTERNAL EVENT DISPATCH -->
    <method name="sendSearchEvent">
      <parameter name="which"/>
      <body>
      <![CDATA[
      try
      {
        if ( this.list.label == "migmigmig" )
        {
          alert( ".gge retsaE" );
        }
        var e = document.createEvent("Events");
        e.initEvent("search", false, true);
        this.dispatchEvent(e);
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>

    <method name="onBrowserUrlDataChanged">
      <body>
        <![CDATA[
          if (this.theCurrentSearchSelection != this.theSongbirdSearchSelection) {
            this.theLastWebSearchString = this.list.label;
          }
          setTimeout(function(obj) { obj.loadSearchStringForCurrentUrl(); }, 100, this); 
        ]]>
      </body>
    </method>

    <method name="loadSearchStringForCurrentUrl">
      <body>
        <![CDATA[
          if (this.isPlaylistUrl(this.browserUrl.stringValue)) {
            this.theCurrentSearchSelection = this.theSongbirdSearchSelection;
            this.button.image = this.theCurrentSearchSelection.getAttribute( "image" );
            this.loadPlaylistSearchString(this.playlistRef.stringValue);
          } else {
            if (this.theLastWebSearchSelection) {
              this.theCurrentSearchSelection = this.theLastWebSearchSelection;
              this.button.image = this.theCurrentSearchSelection.getAttribute( "image" );
              if (this.theLastWebSearchString)
                this.list.label = this.theLastWebSearchString;
              else {
                this.list.label = this.getDefaultSearchString();
                this.first_mousedown = false;                
              }
            }
          }
        ]]>
      </body>
    </method>

    <method name="onPlaylistRefChanged">
      <body>
        <![CDATA[
          if (this.isPlaylistUrl(this.browserUrl.stringValue)) {
            this.loadPlaylistSearchString(this.playlistRef.stringValue);
          }
        ]]>
      </body>
    </method>

    <method name="loadPlaylistSearchString">
      <parameter name="ref"/>
      <body>
        <![CDATA[
          try {
            var searchstring = this.playlistSource.getSearchString(ref);
            if (!searchstring || searchstring == "") {
              searchstring = this.getDefaultSearchString();
              this.first_mousedown = false;
            } else {
              this.first_mousedown = true;
            }
            this.list.label = searchstring;
          } catch (e) {
            /* playlistsource ref doesnt exist yet ? reset search text */
            this.list.label = "";
          }
        ]]>
      </body>
    </method>

    <method name="isPlaylistUrl">
      <parameter name="url"/>
      <body>
        <![CDATA[
          var qmark = url.indexOf("?")
          if (qmark > -1) url = url.substr(0, qmark);
          url = url.toLowerCase();
          return (url.substr(0, 9) == "chrome://" &&
              url.substr(url.length-17) == "playlist_test.xul");
          //return (url.toLowerCase() == "chrome://songbird/content/xul/playlist_test.xul");
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>
  
  
  
  
  <!-- Web and Library Search Widget.  
  
       Extends the Firefox searchbar widget to intercept Songbird library searches
       and add "search as you type" functionality.
       
       See dependencies/vendor/mozilla/browser/components/search/content/search.xml
       
       TODO:
         - Metrics
         - Context based suggestions
    -->
  <binding id="sb-searchbar"
           extends="chrome://browser/content/search/search.xml#searchbar">
    <implementation>

      <!-- Temporary legacy fields to keep onSearchTerm and onSBMainwinSearchEvent happy -->
      <!-- TODO: Remove  -->
      <field name="cur_service">"search.popup.songbird"</field>
      <property name="is_songbird">
        <getter>
          return this.songbirdSearchSelected;
        </getter>
      </property>
      <property name="list">
        <getter>
          return { label: this.value };
        </getter>
      </property>    
    
    
      <!-- True if queries from the current search engine 
           should be handled by Songbird -->
      <property name="songbirdSearchSelected">
        <getter><![CDATA[  
          return this.currentEngine.alias == "Songbird:Library";
        ]]></getter>
      </property>  


      <!-- When true, causes searches to be sent automatically after
           a short delay -->
      <property name="searchOnEditIdle">
        <getter><![CDATA[  
          return this.songbirdSearchSelected;
        ]]></getter>
      </property>  
      
                
      <!-- Override the method responsible for executing searches
           so that we can splice in library support -->      
      <method name="doSearch">
        <parameter name="aData"/>
        <parameter name="aWhere"/>
        <body><![CDATA[
          // If the current search should be handled by songbird,
          // then dispatch it via an event
          if (this.songbirdSearchSelected) 
          {
            this._doLibrarySearch(aData);
          }
          // Otherwiser hand it off the standard FF way.
          else
          {
            // null parameter below specifies HTML response for search
            var submission = this.currentEngine.getSubmission(aData, null);
            openUILinkIn(submission.uri.spec, aWhere, null, submission.postData);
          }          
        ]]></body>
      </method>    
          
      <!-- Dispatch the given query string to the Songbird library/playlist -->
      <method name="_doLibrarySearch">
        <parameter name="aQuery"/>
        <body><![CDATA[              
          // Add your eggs here...
          if ( aQuery == "migmigmig" )  { alert( ".gge retsaE" ); } 
          else if ( aQuery == "mattmattmatt" )  { alert( "Eggstereast." ); } 
                    
          var e = document.createEvent("Events");
          e.initEvent("search", false, true);
          this.dispatchEvent(e);
        ]]></body>
      </method>      
      
      <!-- Called when a Songbird search is selected, and a short delay has passed since
           the last keystroke.  Provides "search as you type" functionality. -->
      <method name="_onSearchEditIdle">
        <body>
        <![CDATA[
          if (this.searchOnEditIdle)
          {
            this._doLibrarySearch(this.value);

            // TODO: do something with metrics
            //metrics_inc("searchwidget", document.__SEARCH_WIDGET__.theCurrentSearchSelection.getAttribute("id"), null);
          }
        ]]>
        </body>
      </method>      
    </implementation>
    
    <handlers>
    
      <!-- Starts the idle search timer after keypress when 
           this.searchOnEditIdle is true
        -->
      <handler event="keypress"><![CDATA[

        if (!this.searchOnEditIdle) {
          return;
        }
          
        switch ( event.keyCode )
        {
          case 9:  // Tab
          case 19: // Break
          case 37: // Arrows
          case 38:
          case 39:
          case 40:
          case 35: // End
          case 36: // Home
          case 45: // Insert
          case 33: // PgUp
          case 34: // PgDn
          case 112:// F1-F12
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
          case 123:
          case 27: // Esc
          case 13: // Return
            break;      
          default:
            if ( this._editIdleInterval )
            {
              clearInterval( this._editIdleInterval );
            }
            this._editIdleInterval = setInterval( 
              function(o) { 
                clearInterval( o._editIdleInterval );
                o._onSearchEditIdle(); 
              }, 1000, this);
            break;      
        }
      ]]></handler>    
    </handlers>
  </binding>  
  
  

</bindings>
