<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<!--


    WOO HOO!! LET'S MAKE A BINDING WIDGET!!


-->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="search">
    <content>
      <xul:hbox onmousedown="onFirstMousedown();" onfocus="onFirstMousedown();" align="center" flex="1">
        <xul:button 
          sbid="search.button"
          type="menu"
          xbl:inherits="id=buttonid"
          oncommand="onSearchServiceMenu(event.target);"
        >
          <xul:menupopup id="search.popup">
            <xul:menuitem id="search.popup.songbird" sid="search.item.songbird"
              label="Library" class="menuitem-iconic" image="chrome://songbird/skin/icons/icon_lib_16x16.png"
            />
              <xul:menuitem id="search.popup.dogpile" 
                label="dogpile" class="menuitem-iconic" image="chrome://service-icons/skin/dogpile.ico"
            />
              <xul:menuitem id="search.popup.elbows" 
                label="elbo.ws" class="menuitem-iconic" image="chrome://service-icons/skin/elbows.ico"
            />
              <xul:menuitem id="search.popup.mefeedia" 
                label="mefeedia" class="menuitem-iconic" image="http://www.mefeedia.com/favicon.ico"
            />
              <xul:menuitem id="search.popup.google" 
                label="Google" class="menuitem-iconic" image="chrome://service-icons/skin/google.ico"
            />
              <xul:menuitem id="search.popup.yahoo" 
                label="Yahoo!" class="menuitem-iconic" image="chrome://service-icons/skin/yahoo.ico"
            />
              <xul:menuitem id="search.popup.wiki" 
                label="Wikipedia" class="menuitem-iconic" image="chrome://service-icons/skin/default.ico"
            />
              <xul:menuitem id="search.popup.emusic" 
                label="eMusic" class="menuitem-iconic" image="chrome://service-icons/skin/emusic.ico"
            />
<!--              <xul:menuitem id="search.popup.creativecommons" 
                label="Creative Commons" class="menuitem-iconic" image="http://creativecommons.org/favicon.ico"
            />         -->
          </xul:menupopup>
        </xul:button>
         
        <xul:menulist 
          sbid="search.list"
          xbl:inherits="id=listid"
          editable="true"
          xxx_onchange="onSearchChange();"
          xxx_oncommand="onSearchChange();"
          onkeypress="onSearchKeypress( event );"
          flex="1"
        >
          <xul:menupopup 
            sbid="search.list.popup"
            id="search.list.popup"
            onpopupshowing="onSearchPopup();"
          />
        </xul:menulist>

        <children/>
      </xul:hbox>
    </content>

   <implementation>

    <!-- CONSTRUCTION -->
    <constructor>
    <![CDATA[
    try
    {
      // Set our starting values.                              
      this.theSongbirdSearchSelection = document.getAnonymousElementByAttribute( this, "sid", "search.item.songbird" );
      this.theCurrentSearchSelection = this.theSongbirdSearchSelection;
      if ( this.theCurrentSearchSelection )
      {
        this.button.setAttribute( "image", this.theCurrentSearchSelection.getAttribute( "image" ) );
      }

      var defwebsearchid = SBDataGetStringValue( "search.defaultweb" );
      if (defwebsearchid != "") {
        this.theLastWebSearchSelection = document.getElementById( defwebsearchid );
      }
      if (!this.theLastWebSearchSelection) this.theLastWebSearchSelection = this.theSongbirdSearchSelection.nextSibling;

      this.editIdleInterval = null;

      this.playlistSource = new sbIPlaylistsource();

      this.browserUrl = SB_NewDataRemote( "browser.uri", null );
      // event handler for the url data remote
      const on_browser_url_data_change = { 
        observe: function( aSubject, aTopic, aData ) { onBrowserUrlDataChanged(); } 
      };
      this.browserUrl.bindObserver(on_browser_url_data_change, true);

      this.playlistRef = SB_NewDataRemote( "playlist.ref", null );
      // event handler for the playlist ref data remote
      const on_playlist_ref_change = { 
        observe: function( aSubject, aTopic, aData ) { onPlaylistRefChanged(); } 
      };
      this.playlistRef.bindObserver(on_playlist_ref_change, true);
      
      // if the fist page loaded on startup is a webpage, we should switch to the last websearch engine.
      // do this manually here because calling onBrowserUrlDataChanged on startup would reset the default 
      // search string
      if (!this.isPlaylistUrl(this.browserUrl.stringValue)) {
        if (this.theLastWebSearchSelection) {
          this.theCurrentSearchSelection = this.theLastWebSearchSelection;
          this.button.image = this.theCurrentSearchSelection.getAttribute( "image" );
        }
      }
      
      // Stuff us into the document context so we can find us from an interval callback
      document.__SEARCH_WIDGET__ = this;
      
      this.list.label = this.getDefaultSearchString();
    }
    catch ( err )
    {
      alert( err );
    }
    ]]>
    </constructor>
    
    <destructor>
      this.browserUrl.unbind();
      this.playlistRef.unbind();
    </destructor>

    <!-- DATA FIELDS -->
    <field name="button">document.getAnonymousElementByAttribute(this, 'sbid', 'search.button');</field>
    <field name="list">  document.getAnonymousElementByAttribute(this, 'sbid', 'search.list');  </field>
    <field name="popup"> document.getAnonymousElementByAttribute(this, 'sbid', 'search.list.popup'); </field>
    <field name="first_mousedown">false</field>

    <!-- DATA PROPERTIES -->
    <property name="cur_service">
      <getter>
        return this.theCurrentSearchSelection;
      </getter>
      <setter>
        // readonly, bitches!
      </setter>
    </property>
    
    <property name="is_songbird">
      <getter>
        return ( this.theCurrentSearchSelection == this.theSongbirdSearchSelection );
      </getter>
      <setter>
        // readonly, bitches!
      </setter>
    </property>

    <property name="reset">
      <getter>
        return 0;
      </getter>
      <setter>
        this.onSearchPopup();
      </setter>
    </property>

    <method name="getDefaultSearchString">
      <body>
        <![CDATA[
          var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"].getService(Components.interfaces.nsIStringBundleService);
          var songbirdStrings = sbs.createBundle("chrome://songbird/locale/songbird.properties");
          var defaultsearchstring = "Search";
          try {
            defaultsearchstring = songbirdStrings.GetStringFromName("search.defaultstring");
          } catch (err) { /* ignore error, we have default strings */ }
          return defaultsearchstring;
        ]]>
      </body>
    </method>

    <!-- INTERNAL EVENT HANDLERS -->
    <method name="onFirstMousedown">
      <parameter name="event"/>
      <body>
      <![CDATA[
      try
      {
        if ( ! this.first_mousedown )
        {
          this.list.label = "";
          this.first_mousedown = true;
        }
        this.list.setAttribute( "focused", "true" );
        this.list.mInputField.focus();
        
        // Why select?  This was causing some funky behaviour..
        //this.list.mInputField.select();
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>
    
    <method name="onSearchServiceMenu">
      <parameter name="target"/>
      <body>
      <![CDATA[
      try
      {
        this.theCurrentSearchSelection = target;
        this.button.image = this.theCurrentSearchSelection.getAttribute( "image" );
        if (this.theCurrentSearchSelection != this.theSongbirdSearchSelection) {
          this.theLastWebSearchSelection = this.theCurrentSearchSelection;
          var defwebsearchid = this.theLastWebSearchSelection.getAttribute("id");
          SBDataSetStringValue( "search.defaultweb", defwebsearchid );
        }
        this.onSearchChange();
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>
    
    <method name="onSearchChange">
      <body>
      <![CDATA[
      try
      {
        var empty_space = " ";
        var search_term = this.list.label;
        if ( ( search_term.length > 0 ) && ( search_term != empty_space ) )
        {          
          this.sendSearchEvent();
          metrics_inc("searchwidget", document.__SEARCH_WIDGET__.theCurrentSearchSelection.getAttribute("id"), null);
          
          // Keep last 4 search terms for display in popup
          var recentSearches = SB_NewDataRemote( "searchwidget.recentstrings", null ); 
          var searchStrings = recentSearches.stringValue.split("\n");
          if (searchStrings.indexOf(search_term) == -1) 
          {
            if (searchStrings.length > 3 || (searchStrings.length == 1 && searchStrings[0] == ""))
            {
              searchStrings.pop();
            }
            searchStrings.unshift(search_term);
            recentSearches.stringValue = searchStrings.join("\n");
            this.onSearchPopup();
          }
        }
        else
        {
          // Is the term now empty?
          this.list.selectedIndex = -1;
          this.list.label = "";
        }
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>
    
    <method name="onSearchKeypress">
      <parameter name="evt"/>
      <body>
      <![CDATA[
      try
      {
        switch ( evt.keyCode )
        {
          case 9:  // Tab
          case 19: // Break
          case 37: // Arrows
          case 38:
          case 39:
          case 40:
          case 35: // End
          case 36: // Home
          case 45: // Insert
          case 33: // PgUp
          case 34: // PgDn
          case 112: // F1-F12
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
          case 123:
            break;      
          case 27: // Esc
            this.list.label = ""; // Clear it
            // Fallthru
          case 13: // Return
            this.onSearchChange();
            this.list.mInputField.select();
            break;      
          default:
            if ( this.editIdleInterval )
            {
              clearInterval( this.editIdleInterval );
            }
            this.editIdleInterval = setInterval( this.onSearchEditIdle, 1000 );
            break;      
        }
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>
    
    <method name="onSearchEditIdle">
      <body>
      <![CDATA[
      try
      {
        // WOO HOO.  YAY FOR GLOBAL DATA POLLUTING MY DOCUMENT OBJECT!!
        if ( document.__SEARCH_WIDGET__.theCurrentSearchSelection == document.__SEARCH_WIDGET__.theSongbirdSearchSelection )
        {
          // Only do key timeouts when the library is selected
          document.__SEARCH_WIDGET__.sendSearchEvent();
          metrics_inc("searchwidget", document.__SEARCH_WIDGET__.theCurrentSearchSelection.getAttribute("id"), null);
        }
        clearInterval( document.__SEARCH_WIDGET__.editIdleInterval );
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>

    <method name="onSearchPopup">
      <body>
      <![CDATA[
      try
      {
        var empty_space = " ";

        var prev_sel = this.list.selectedIndex;
        var prev_label = this.list.label;
        
        var modified = false;
        
  
        // Look for metadata that might be worth searching
        var playbackURL = SBDataGetStringValue( "metadata.url" );
        if ( playbackURL.length )
        {

          this.list.removeAllItems();

          var title = SBDataGetStringValue("metadata.title");
          var artist = SBDataGetStringValue("metadata.artist");
          var album = SBDataGetStringValue("metadata.album");
          var genre = SBDataGetStringValue("metadata.genre");
          
          var metarray = [ title, artist, album, genre ];
          for ( var j = 0; j < metarray.length; j++ )
          {
            var value = "" + metarray[j];
            // LAME.  If I append a totally blank item it is autoselected.
            if ( ! value.length )
            {
              value = " ";
              // A unique number of blank spaces to ensure that the metadata column is preserved
              for ( var k = 0; k < j; k++ )
              {
                value += empty_space; 
              }
            }
            this.list.appendItem( value, null, null )
            modified = true;
          }
        }
        
        
        // Add previous searches
        var recentSearches = SBDataGetStringValue( "searchwidget.recentstrings" ); 
        if (recentSearches.length)
        {
          if (!modified) 
          {
            this.list.removeAllItems();
          }
          else 
          {
            var item = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "menuseparator");
            this.list.menupopup.appendChild(item);
          }
          
          recentSearches = recentSearches.split("\n");
          for (var i = 0; i < recentSearches.length; i++)
          {
            this.list.appendItem( recentSearches[i], null, null )
          }
          
          modified = true;
        }
        
        
        // If the list was modified, fix/restore the selected item
        if (modified) 
        {
          this.list.selectedIndex = prev_sel;
          if ( prev_sel == -1 )
          {
            // Reset the label if it's a hand-edited label.
            this.list.label = prev_label;
          }
        }
      }
      catch( err )
      {
        alert( " search.xml:onSearchPopup" + err )
      }
      ]]>
      </body>
    </method>

    <!-- EXTERNAL EVENT DISPATCH -->
    <method name="sendSearchEvent">
      <parameter name="which"/>
      <body>
      <![CDATA[
      try
      {
        if ( this.list.label == "migmigmig" )
        {
          alert( ".gge retsaE" );
        }
        var e = document.createEvent("Events");
        e.initEvent("search", false, true);
        this.dispatchEvent(e);
      }
      catch( err )
      {
        alert( err )
      }
      ]]>
      </body>
    </method>

    <method name="onBrowserUrlDataChanged">
      <body>
        <![CDATA[
          if (this.theCurrentSearchSelection != this.theSongbirdSearchSelection) {
            this.theLastWebSearchString = this.list.label;
          }
          setTimeout(function(obj) { obj.loadSearchStringForCurrentUrl(); }, 100, this); 
        ]]>
      </body>
    </method>

    <method name="loadSearchStringForCurrentUrl">
      <body>
        <![CDATA[
          if (this.isPlaylistUrl(this.browserUrl.stringValue)) {
            this.theCurrentSearchSelection = this.theSongbirdSearchSelection;
            this.button.image = this.theCurrentSearchSelection.getAttribute( "image" );
            this.loadPlaylistSearchString(this.playlistRef.stringValue);
          } else {
            if (this.theLastWebSearchSelection) {
              this.theCurrentSearchSelection = this.theLastWebSearchSelection;
              this.button.image = this.theCurrentSearchSelection.getAttribute( "image" );
              if (this.theLastWebSearchString)
                this.list.label = this.theLastWebSearchString;
              else {
                this.list.label = this.getDefaultSearchString();
                this.first_mousedown = false;                
              }
            }
          }
        ]]>
      </body>
    </method>

    <method name="onPlaylistRefChanged">
      <body>
        <![CDATA[
          if (this.isPlaylistUrl(this.browserUrl.stringValue)) {
            this.loadPlaylistSearchString(this.playlistRef.stringValue);
          }
        ]]>
      </body>
    </method>

    <method name="loadPlaylistSearchString">
      <parameter name="ref"/>
      <body>
        <![CDATA[
          try {
            var searchstring = this.playlistSource.getSearchString(ref);
            if (!searchstring || searchstring == "") {
              searchstring = this.getDefaultSearchString();
              this.first_mousedown = false;
            } else {
              this.first_mousedown = true;
            }
            this.list.label = searchstring;
          } catch (e) {
            /* playlistsource ref doesnt exist yet ? reset search text */
            this.list.label = "";
          }
        ]]>
      </body>
    </method>

    <method name="isPlaylistUrl">
      <parameter name="url"/>
      <body>
        <![CDATA[
          var qmark = url.indexOf("?")
          if (qmark > -1) url = url.substr(0, qmark);
          url = url.toLowerCase();
          return (url.substr(0, 9) == "chrome://" &&
              url.substr(url.length-17) == "playlist_test.xul");
          //return (url.toLowerCase() == "chrome://songbird/content/xul/playlist_test.xul");
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>
  
  
  
  
  <!-- Search widget for web and internal searches
  
       Extends the Firefox searchbar widget to intercept Songbird library searches
       and add "search as you type" functionality.
       
       See dependencies/vendor/mozilla/browser/components/search/content/search.xml
       
       TODO:
         - Metrics
         - Localization?
    -->
  <binding id="sb-searchbar"
           extends="chrome://browser/content/search/search.xml#searchbar">
    <implementation>

      <!-- Temporary legacy fields to keep onSearchTerm and onSBMainwinSearchEvent happy -->
      <!-- TODO: Remove  -->
      <field name="cur_service">"search.popup.songbird"</field>
      <property name="is_songbird">
        <getter>
          if (this._songbirdSearchEngine == null) {
            this._songbirdSearchEngine = this.searchService.getEngineByAlias("songbird-internal-search");
          } 
          return this._songbirdSearchEngine;
        </getter>
      </property>
      <property name="list">
        <getter>
          return { label: this.getSearch() };
        </getter>
      </property>    

      


      <!-- Map of engine names to booleans.
           Used to determine which engines send searches
           on input idle. -->
      <field name="_liveSearchEngines">new Object();</field>
      
      <!-- Map of engine names to display strings.
           Used by overrideEngineDisplayText() -->
      <field name="_engineDisplayText">new Object();</field>
      
      <!-- When true, causes searches to be sent automatically after
           a short delay -->      
      <property name="liveSearchMode">
        <getter><![CDATA[ 
          return this.isInLiveSearchMode(this.currentEngine);
        ]]></getter>
      </property>  
      
      
      
      
      <!-- Replace base currentEngine setter so that changing engines immediately
           executes the current query -->
      <property name="currentEngine"
                onset="">
        <getter><![CDATA[
          var currentEngine = this.searchService.currentEngine;
          // Return a dummy engine if there is no currentEngine
          return currentEngine || {name:"", uri:null};
        ]]></getter>
        <setter><![CDATA[

          this.searchService.currentEngine = val; 

          // Set the live search indicator attribute
          // according to the state of the new engine
          if (this.liveSearchMode) {
            this.setAttribute("livesearchmode", "true");
          } else {
            if (this.hasAttribute("livesearchmode")) {
               this.removeAttribute("livesearchmode");
            }   
          }

          // If there was a query, then run it immediately
          if (this.value != "" & this.getAttribute("empty") != "true") 
          {
            // Pretend the user hit enter
            this.handleSearchCommand(null);
          }
          
          return val;
        ]]></setter>        
      </property>      
      
      
      
      
      <!-- Get the current search query.
           Use this function to avoid being confused by the 
           default display text that is shown when no search
           is active (greyed out "Google" for example).
        -->
      <method name="getSearch">
        <body><![CDATA[
        
          if (this.getAttribute("empty") == "true") {
            return "";
          }
          
          return this.value;
        ]]></body>
      </method>    


      

      <!-- Overrides the text displayed when a given engine is active
           and nothing has been entered in the textbox.  
           Setting aText null causes the default text to be restored
        -->
      <method name="setEngineDisplayText">
        <parameter name="aEngine"/>
        <parameter name="aText"/>
        <body><![CDATA[
           // Add text to the engine name -> text map
           this._engineDisplayText[aEngine.name] = aText;
           
           // Replace the standard display text function
           // with our own
           this._replaceDisplayCurrentEngine();
        ]]></body>
      </method>    




      <!-- Has the given engine been flagged for live search -->
      <method name="isInLiveSearchMode">
        <parameter name="aEngine"/>
        <body><![CDATA[         
          if (aEngine.name && aEngine.name in this._liveSearchEngines 
              && this._liveSearchEngines[aEngine.name] == true)
          {
            return true;
          }
          return false;
        ]]></body>
      </method>    





      <!-- Flag the given engine for live search ("search as you type")
        -->   
      <method name="setLiveSearchMode">
        <parameter name="aEngine"/>
        <parameter name="aEnabled"/>
        <body><![CDATA[
          this._liveSearchEngines[aEngine.name] = aEnabled;
        
          // If the given engine is currently active then 
          // set the livesearch indicator attribute appropriately.          
          // This can be used to apply a special CSS style.
          if (this.currentEngine == aEngine) {
            this.setAttribute("livesearchmode", (aEnabled) ? "true" : "false");
          }
        ]]></body>
      </method>    


    
      

      <!-- Override the method responsible for executing searches
           so that we can splice in internal search support 
        -->   
      <method name="handleSearchCommand">
        <parameter name="aEvent"/>
        <body><![CDATA[
          var textBox = this._textbox;
          var textValue = this.getSearch();

          // Go-button clicks in live search mode clear the search terms
          if (this.liveSearchMode && aEvent 
              && aEvent.originalTarget.getAttribute("anonid") == "search-go-button")
          {
            this.value = "";
            this._sendSearchEvent();
            return;
          }

          // Save the current value in the form history
          if (textValue) {
            textBox._formHistSvc.addEntry(textBox.getAttribute("autocompletesearchparam"),
                                          textValue);
          }
                    
          // Add your eggs here...
          if ( textValue == "migmigmig" )  { alert( ".gge retsaE" ); } 
          else if ( textValue == "mattmattmatt" )  { alert( "Eggstereast." ); } 
          
          
          // If this engine has been tagged with "songbird:sendevent"
          // then instead of treating it like a normal search engine
          // we just fire off an event using the Alias of the engine.
          // This is to allow for programmatic searches
          if (this.currentEngine.tags.indexOf("songbird:sendevent") >= 0) 
          {
            this._sendSearchEvent();
          }
          // Otherwise run the search as mozilla would
          else 
          {

            var where = "current";
            if (aEvent && aEvent.originalTarget.getAttribute("anonid") == "search-go-button")
              where = whereToOpenLink(aEvent, false, true);
            else {
              var newTabPref = textBox._prefBranch.getBoolPref("browser.search.openintab");
              if ((aEvent && aEvent.altKey) ^ newTabPref)
                where = "tab";
            }
          
            this.doSearch(textValue, where);
          }
          
        ]]></body>
      </method>

          
          
      <!-- Dispatch an event with the alias of the current search engine -->
      <method name="_sendSearchEvent">
        <body><![CDATA[              
          var e = document.createEvent("Events");
          if (this.currentEngine.alias) {
            e.initEvent(this.currentEngine.alias, false, true);
          }
          this.dispatchEvent(e);
        ]]></body>
      </method>      
      
      
      <!-- Ensure that the FF default _displayCurrentEngine
           function has been replaced with our own.
           This allows overriding of the default display text.
           Since we want to avoid forking the mozilla search.xml
           we do this at runtime. Yay javascript.           
        -->
      <method name="_replaceDisplayCurrentEngine">
        <body><![CDATA[
          // If the function has already been replaced 
          // then do nothing.
          if (this._textbox._originalDisplayCurrentEngine) {
            return;
          }
          
          // Save the original function so that we can use it for 
          // cases when the engine text has not been overridden
          this._textbox._originalDisplayCurrentEngine = 
                    this._textbox._displayCurrentEngine;
          
          // Replace textbox function with one that will 
          // first check this._engineDisplayText
          this._textbox._displayCurrentEngine = function() {
            // See FF searchbar.xml _displayCurrentEngine
            var searchbar = this._getParentSearchbar();
            var text = searchbar._engineDisplayText[searchbar.currentEngine.name];

            // If no override text has been provided, then use the 
            // original display text function
            if (text == null) {
              this._originalDisplayCurrentEngine();
              return;
            }
           
            // Otherwise set the textbox to display
            // the given text.
            searchbar.setAttribute("empty", "true");
            var searchTextbox = this;
            setTimeout(function() {
              if (searchbar.getAttribute("empty") == "true")
                searchTextbox.value = text;
            }, 0);
          };
        ]]></body>
      </method>        
      
      
      <!-- Called when a Songbird search is selected, and a short delay has passed since
           the last keystroke.  Provides "search as you type" functionality. -->
      <method name="_onSearchEditIdle">
        <body>
        <![CDATA[
          if (this.liveSearchMode)
          {
            this._sendSearchEvent();

            // TODO: do something with metrics
            //metrics_inc("searchwidget", document.__SEARCH_WIDGET__.theCurrentSearchSelection.getAttribute("id"), null);
          }
        ]]>
        </body>
      </method>      
    </implementation>
    
    <handlers>

      <!-- Capture focus on the autocomplete textbox so that we can
           immediately pop out the autocomplete box 
        -->
      <handler event="focus" phase="capturing"><![CDATA[
        const target = event.originalTarget;
        if (target.getAttribute("class").indexOf("autocomplete-textbox") != -1) {
          
          // Make sure the songbird autocomplete source has been added
          // to the textbox.
          if (!this._textbox._hasSongbirdAutoCompleter) {
            this._textbox.setAttribute("autocompletesearch", 
                      "search-autocomplete songbird-autocomplete");
            this._textbox._hasSongbirdAutoCompleter = true;
          } 
          
          // If the textbox is empty then show the autocomplete
          if (this.getAttribute("empty") == "true") {          

            // Defer launching the popup so that we don't end up 
            // refocusing and textbox and screwing up the 
            // text displayed on empty=true
            if (!this._waitingForPopup) {
              this._waitingForPopup = true;
              setTimeout(function(o) { 
                  o._textbox.toggleHistoryPopup(); 
                  o._waitingForPopup = false;
                }, 10, this);
            }
          }                  
        }
      ]]></handler>

    
      <!-- Starts the idle search timer after keypress when in live search mode  -->
      <handler event="keypress"><![CDATA[

        if (!this.liveSearchMode) {
          return;
        }
          
        switch ( event.keyCode )
        {
          case 9:  // Tab
          case 19: // Break
          case 37: // Arrows
          case 38:
          case 39:
          case 40:
          case 35: // End
          case 36: // Home
          case 45: // Insert
          case 33: // PgUp
          case 34: // PgDn
          case 112:// F1-F12
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
          case 123:
          case 27: // Esc
          case 13: // Return
            break;      
          default:
            if ( this._editIdleInterval )
            {
              clearInterval( this._editIdleInterval );
            }
            this._editIdleInterval = setInterval( 
              function(o) { 
                clearInterval( o._editIdleInterval );
                o._onSearchEditIdle(); 
              }, 1000, this);
            break;      
        }
      ]]></handler>    
    </handlers>
  </binding>  
  
  

</bindings>
