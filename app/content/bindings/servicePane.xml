<?xml version="1.0" encoding="UTF-8"?>
<!--
/*
 *=BEGIN SONGBIRD GPL
 *
 * This file is part of the Songbird web player.
 *
 * Copyright(c) 2005-2010 POTI, Inc.
 * http://www.songbirdnest.com
 *
 * This file may be licensed under the terms of of the
 * GNU General Public License Version 2 (the ``GPL'').
 *
 * Software distributed under the License is distributed
 * on an ``AS IS'' basis, WITHOUT WARRANTY OF ANY KIND, either
 * express or implied. See the GPL for the specific language
 * governing rights and limitations.
 *
 * You should have received a copy of the GPL along with this
 * program. If not, go to http://www.gnu.org/licenses/gpl.html
 * or write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 *=END SONGBIRD GPL
 */
-->

<!--
  -TODO:
  - Bug 18545
  -  1. Create 3 bindings (done)
  -   i.   Service Pane (done)
  -   ii.  Service Pane Group (done)
  -   iii. Service Pane Node (done)
  -  2. Migrate functionality of old service pane to new service pane
  -  3. Context menus for nodes.
  -  4. Edit names for nodes.
  -  5. Ability to highlight nodes.
  - Bug 18548
  -  1. Toggle node visibility when clicking on toggle image in header of group.
  - Bug 18551
  -  1. Make sure we can change the badge on nodes easily.
  - Bug 18552
  -  1. Make sure we can change the image on nodes easily.
  -->

<!DOCTYPE window SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:xbl="http://www.mozilla.org/xbl">

  <!--
    - \brief ServicePaneNodeBadge is a single badge attached to a
    - ServicePaneNode.  It contains a text label, image, and an associated
    - action.  If the image is null, then the text label will be used.
    - When the badge is clicked, the action will be taken if one is defined.
    -->
  <binding id="servicepane-node-badge">
    <content mousethrough="never">
      <xul:hbox class="servicepane-node-badge">
        <xul:label sbid="servicepane-node-badge-label"
                   class="servicepane-node-badge-label"/>
        <xul:image sbid="servicepane-node-badge-image"
                   class="servicepane-node-badge-image"
                   hidden="true"/>
      </xul:hbox>
    </content>

    <implementation>
      <constructor>
      <![CDATA[
          if (this.hasAttribute("badgeImage")) {
            this.badgeImage = this.getAttribute("badgeImage");
          }
          if (this.hasAttribute("badgeLabel")) {
            this.badgeLabel = this.getAttribute("badgeLabel");
          }

          // Don't overwrite badgeAction property if it was set already
          if (!("badgeAction" in this)) {
            this.badgeAction = null;
          }
      ]]>
      </constructor>

      <!--
        - \brief Gets an element in this binding that has the sbid matching the
        -   anonID parameter.
        - \param anonID Anonymous id of the element requested (matches sbid)
        - \return element if found, or null if not
        -->
      <method name="_getElement">
        <parameter name="anonID"/>
        <body><![CDATA[
          return document.getAnonymousElementByAttribute(this,
                                                         "sbid",
                                                         anonID);
        ]]></body>
      </method>

      <!--
        - \brief Updates the badge depending on the values of the elements. If
        - the image has no src then we show the label and hide the image, if the
        - image has a src then we hide the label and show the image.
        -->
      <method name="_update">
        <body><![CDATA[
          let imageNode = this._getElement("servicepane-node-badge-image");
          let textNode = this._getElement("servicepane-node-badge-label");
          if (this.hasAttribute("badgeImage")) {
            imageNode.removeAttribute("hidden");
            textNode.setAttribute("hidden", true);
          }
          else {
            imageNode.setAttribute("hidden", true);
            textNode.removeAttribute("hidden");
          }
        ]]></body>
      </method>

      <!--
        - \brief property for the image of this badge.
        -->
      <property name="badgeImage">
        <getter><![CDATA[
          let imageNode = this._getElement("servicepane-node-badge-image");
          return this.getAttribute("badgeImage");
        ]]></getter>
        <setter><![CDATA[
          let imageNode = this._getElement("servicepane-node-badge-image");
          let textNode = this._getElement("servicepane-node-badge-label");
          this.setAttribute("badgeImage", val);
          imageNode.style.listStyleImage = "url('" + val + "')";
          this._update();
          return val;
        ]]></setter>
      </property>

      <!--
        - \brief property for the text of this badge
        -->
      <property name="badgeLabel">
        <getter><![CDATA[
          let textNode = this._getElement("servicepane-node-badge-label");
          return imageNode.value;
        ]]></getter>
        <setter><![CDATA[
          let textNode = this._getElement("servicepane-node-badge-label");
          this.removeAttribute("badgeImage");
          textNode.value = val;
          this._update();
          return val;
        ]]></setter>
      </property>

    </implementation>

    <handlers>
      <handler event="click">
      <![CDATA[
        if (event.button == 0) {
          if (this.badgeAction) {
            try {
              this.badgeAction();
            } catch (e) {
              dump("Badge action exception: " + e + "\n");
            }
            event.stopPropagation();
            event.preventDefault();
          }
        }
      ]]>
      </handler>
    </handlers>


  </binding>

   <!--
    - \brief ServicePaneNode is a single entry attached to a ServicePaneGroup.
    - it contains an icon, label and an arbitrary # of ServicePaneNodeBadges.
    - When the user clicks the node the url attached to this node will launch
    - in the browser if any.  If the node is already selected and the user
    - clicks it, the node should be renamed.
    -->
  <binding id="servicepane-node">
    <content mousethrough="never">
      <xul:vbox class="servicepane-node" flex="1">

        <xul:hbox class="servicepane-node-info" mousethrough="always">
          <xul:image class="servicepane-node-container-arrow"
                     flex="0"
                     mousethrough="never"
                     onclick="toggleContainer(event)" />
          <xul:image class="servicepane-node-image"
                     xbl:inherits="src=image" flex="0" />
          <xul:stack sbid="servcepane-node-stack" flex="1">
            <xul:hbox flex="1">
              <xul:label class="servicepane-node-label"
                         crop="end"
                         flex="1"
                         mousethrough="never"
                         xbl:inherits="value=label"/>
              <xul:spacer flex="1" />
              <xul:hbox class="servicepane-node-badges"
                        sbid="servicepane-node-badges" flex="1" />
            </xul:hbox>

            <!-- that onblur event is a little confusing.  the event bubbles up
                 so that it fires for both the HTML input element & the XUL
                 element.  we check the original target to make sure it's the
                 right element (e.g. where textboxBlur() is defined -->
            <xul:textbox class="servicepane-node-textbox"
                         sbid="servicepane-node-textbox"
                         xbl:inherits="value=label"
                         flex="1"
                         onkeypress="textboxKeypress(event)"
                         onblur="if (event.originalTarget != this) textboxBlur(event)"
                         hidden="true" />
          </xul:stack>
        </xul:hbox>

        <xul:vbox sbid="servicepane-node-children"
                  class="servicepane-node-children"
                  mousethrough="never"
                  xbl:inherits="hidden=closed">
          <children />
        </xul:vbox>

      </xul:vbox>
    </content>

    <implementation>
      <constructor>
        <![CDATA[
          // TODO: Check for a better way to load. (stevo)
          // This is here because we can not call nodeData until the binding has
          // been applied.
          Components.utils.import("resource://app/jsmodules/DropHelper.jsm");
          Components.utils.import("resource://app/jsmodules/URLUtils.jsm");

          // If this element has a node id then load up the data from the node
          // we are always expected to be in the service pane under a group at
          // this point so we call up the DOM of nodes.
          try {
            if (this.hasAttribute("nodeid")) {
              var nodeID = this.getAttribute("nodeid");
              if (this.parentNode)
                this.nodeData = this.parentNode.getNode(nodeID);
            } else {
              // If we have no node data, then hide by default.
              this.setAttribute("hidden", true);
            }

            this._textbox = this._getElement("servicepane-node-textbox");
            this._textbox.realParent = this;
            this.mService =
              Components.classes['@songbirdnest.com/servicepane/service;1']
              .getService(Components.interfaces.sbIServicePaneService);
            this.mDragService = 
              Components.classes['@mozilla.org/widget/dragservice;1']
              .getService(Components.interfaces.nsIDragService);

            // Determine how much to indent this node
            let spacer = this._getElement("servicepane-node-spacer");
            let indent = -1;
            let parent = this.nodeData.parentNode;
            while (parent) {
              indent++;
              parent = parent.parentNode;
            }
            this.setAttribute("indent", indent);
          } catch (e) {
            dump("Exception: " + e + "\n");
          }
        ]]>
      </constructor>

      <!--
        - \brief Hold the actual node data for this node so we can reference it
        -   whenever we need
        -->
      <field name="_nodeData">null</field>

      <!--
        - \brief The node ID
        -->
      <field name="nodeId">this._nodeData.id</field>

      <!--
        - \brief Get the servicepane element itself
        -->
      <property name="_servicePane">
        <getter><![CDATA[
          let parent = this.parentNode;
          while (parent && parent.tagName != "sb-servicepane")
            parent = parent.parentNode;
          return parent;
        ]]></getter>
      </property>

      <!--
        - \brief Gets an element in this binding that has the sbid matching the
        -   anonID parameter.
        - \param anonID Anonymous id of the element requested (matches sbid)
        - \return element if found, or null if not
        -->
      <method name="_getElement">
        <parameter name="anonID"/>
        <body><![CDATA[
          return document.getAnonymousElementByAttribute(this,
                                                         "sbid",
                                                         anonID);
        ]]></body>
      </method>

      <!--
        - \brief sbIServicePaneNode data associated with this node
        -->
      <property name="nodeData">
        <getter><![CDATA[
          return this._nodeData;
        ]]></getter>
        <setter><![CDATA[
          // val should be a sbIServicePaneNode object
          this._nodeData = val;
          if (this._nodeData) {
            // Set up the elements
            this.setAttribute("image", this._nodeData.image);
            this.setAttribute("label", this._nodeData.displayName);
            if (!this._nodeData.isOpen)
              this.setAttribute("closed", "true");

            // Hide the node if it should be hidden
            if (this._nodeData.hidden) {
              this.setAttribute("hidden", true);
            } else if (this.hasAttribute("hidden")) {
              this.removeAttribute("hidden");
            }

            this.className = this._nodeData.className;

            // If the node has children mark it as a container
            if (this._nodeData.firstChild)
              this.className += " container";

            // If it's ejectable let's add the right badge
            if (this._nodeData.getAttribute("ejectable") == "true") {
              if (!this._ejectBadge) {
                let self = this;
                this._ejectBadge = this.appendBadge(null,
                              "chrome://songbird/skin/service-pane/eject.png",
                              function() {
                                self._nodeData.dispatchEvent("eject");
                              });
              }
            } else if (this._ejectBadge) {
              this._ejectBadge.parentNode.removeChild(this._ejectBadge);
            }
          }
          else {
            this.removeAttribute("image");
            this.removeAttribute("label");
            this.setAttribute("hidden", "true");
            this.removeAttribute("closed");
            this.className = "";
            if (this._ejectBadge) {
              this._ejectBadge.parentNode.removeChild(this._ejectBadge);
            }
          }
          return this._nodeData;
        ]]></setter>
      </property>

      <!--
        - \brief Get the parent service pane group element
        -->
      <property name="_servicePaneGroup">
        <getter>
        <![CDATA[
          let parent = this.parentNode;
          while (parent && parent.tagName != "sb-servicepane-group")
            parent = parent.parentNode;
          return parent;
        ]]>
        </getter>
      </property>

      <!-- 
         - \brief The browser we are linked to if any.
        -->
      <field name="_browser">null</field>
      <property name="browser">
        <getter><![CDATA[
          if (!this._browser) {
            this._browser = document.getElementById(this.getAttribute('browser'));
          }
          return this._browser;
        ]]></getter>
      </property>

      <!--
        - \brief If this is a container, toggle the open/closed state.
        -->
      <method name="toggleContainer">
        <parameter name="event"/>
        <body><![CDATA[
          // First see if we've actually got children, if not - then bail
          if (!this.firstChild)
            return;

          this.nodeData.isOpen = !this.nodeData.isOpen;
          event.stopPropagation();
          event.preventDefault();
        ]]></body>
      </method>

      <!--
        - \brief Load the URL associated with this node in the browser if
        - available.
        -->
      <method name="loadNodeURL">
        <parameter name="event"/>
        <parameter name="arguments"/>
        <body><![CDATA[
          if (!this.browser)
            return; // Nothing to do if we don't have a browser.

          // Style the node as active (which means first removing any
          // styles from any currently active node
          this._servicePane.makeNodeActive(this.nodeData);

          // If this node has a URL, just load it in the browser
          if (this._nodeData.url) {
            var target = null;
            if (LibraryUtils.isMediaTabURL(this._nodeData.url, this.browser)) {
              target = "_media";
              this.browser.selectedTab = this.browser.mediaTab;
            } else if (event.button == 1) {
              // Middle click.
              target = "_blank";
            }
            var url = this._nodeData.url;
            if (arguments)
              url = URLUtils.addQuery(url, arguments);
            this.browser.loadURI(url, null, null, event, target);

          // If no URL, apply special handling
          } else {
            // If there is a media list for this node, hand it off to the
            // browser to display somehow.
            // I'm told that this hack is fine, as it will one day be replaced
            // with the playlist commands system.
            var libraryServicePane =
              Components.classes['@songbirdnest.com/servicepane/library;1']
              .getService(Components.interfaces.sbILibraryServicePaneService);
            var mediaList = libraryServicePane.getLibraryResourceForNode(this._nodeData);
            if (mediaList) {
              const NS_SP = "http://songbirdnest.com/rdf/servicepane#";
              var view = LibraryUtils.createStandardMediaListView(mediaList);
              if (this._nodeData.hasAttributeNS(NS_SP,
                                                "mediaListViewConstraints")) {
                // set up the constraints
                var builder = Components.classes["@songbirdnest.com/Songbird/Library/ConstraintBuilder;1"]
                                        .createInstance(Components.interfaces.sbILibraryConstraintBuilder);
                try {
                  builder.parseFromString(
                    this._nodeData.getAttributeNS(NS_SP,
                                                  "mediaListViewConstraints"));
                  view.filterConstraint = builder.get();
                } catch (e) {
                  // boo, the constraints are bad, use standard instead
                  view.filterConstraint = LibraryUtils.standardFilterConstraint;
                }
              }
              var tab = this.browser.loadMediaList(mediaList,
                                                   event,
                                                   "_media",
                                                   view);
              this.browser.selectedTab = tab;

              // Record list type metrics for some reason.
              // See http://bugzilla.songbirdnest.com/show_bug.cgi?id=4021
              // changed to loadNode from click as there are ways other than clicking
              // to get here.
              try {
                var listType = mediaList.getProperty(SBProperties.customType);
                var libType = mediaList.library.getProperty(SBProperties.customType);
                metrics_inc("app.servicepane.loadnode.medialist", libType + "." + listType, null);
              } catch(e) { Components.utils.reportError(e); }

            } else {
              // we have no handler for this service pane node load
              // dispatch an event people can listen for and don't report
              let event = document.createEvent("XULCommandEvent");
              event.QueryInterface(Components.interfaces.nsIDOMXULCommandEvent);
              event.initCommandEvent("servicepane-loadnode",
                                     event.bubble,
                                     false,
                                     event.view,
                                     event.detail,
                                     event.ctrlKey,
                                     event.altKey,
                                     event.shiftKey,
                                     event.metaKey,
                                     event);
              this.dispatchEvent(event);

              var SP_NS = "http://songbirdnest.com/rdf/servicepane#";
              var eventType = this._nodeData.getAttributeNS(SP_NS, "eventType");
              if (eventType) {
                let event = document.createEvent("UIEvent");
                event.initUIEvent(eventType, true, true, window, 0);
                window.dispatchEvent(event);
              }
            }
          }
        ]]></body>
      </method>

      <!--
        - \brief Creates a badge element.
        - \param badgeLabel - Value to set the badge to (can be null)
        - \param badgeImage - Image to set the badge to (can be null)
        - \return newly created badge element
        -->
      <method name="_createBadge">
        <parameter name="badgeLabel"/>
        <parameter name="badgeImage"/>
        <body><![CDATA[
          var XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          var newBadge = document.createElementNS(XULNS,
                                                  "sb-servicepane-node-badge");
          if (badgeLabel)
            newBadge.setAttribute("badgeLabel", badgeLabel);
          if (badgeImage)
            newBadge.setAttribute("badgeImage", badgeImage);
          return newBadge;
        ]]></body>
      </method>

      <!--
        - \brief Appends a badge element to the node.
        - \param badgeLabel - Value to set the badge to (can be null)
        - \param badgeImage - Image to set the badge to (can be null)
        - \return newly appended badge element.
        -->
      <method name="appendBadge">
        <parameter name="badgeLabel"/>
        <parameter name="badgeImage"/>
        <parameter name="badgeAction"/>
        <body><![CDATA[
          var newBadge = this._createBadge(badgeLabel, badgeImage);
          var badgeContainer = this._getElement("servicepane-node-badges");
          badgeContainer.appendChild(newBadge);
          if (badgeAction) {
            newBadge.setAttribute("mousethrough", "never");
            newBadge.badgeAction = badgeAction;
          }
          return newBadge;
        ]]></body>
      </method>

      <!--
        - \brief Removes a badge element.
        - \param index - Index of the badge to remove.
        - \return copy of removed badge.
        -->
      <method name="removeBadge">
        <parameter name="index"/>
        <body><![CDATA[
          var oldChild = null;
          var badgeContainer = this._getElement("servicepane-node-badges");
          if (badgeContainer.childNodes.length > index) {
            oldChild = badgeContainer.removeChild(badgeContainer.childNodes[index]);
          }
          return oldChild;
        ]]></body>
      </method>

      <!--
        - \brief Inserts a badge element before an existing one.
        - \param badgeLabel - Value to set the badge to (can be null)
        - \param badgeImage - Image to set the badge to (can be null)
        - \param beforeIndex - Index of badge to insert a new badge before.
        - \return newly appended badge element.
        -->
      <method name="insertBadgeBefore">
        <parameter name="badgeLabel"/>
        <parameter name="badgeImage"/>
        <parameter name="beforeIndex"/>
        <body><![CDATA[
          var badgeContainer = this._getElement("servicepane-node-badges");
          if (beforeIndex > 0 &&
              beforeIndex < badgeContainer.childNodes.length) {
            var newBadge = this._createBadge(badgeLabel, badgeImage);
            badgeContainer.insertBefore(newBadge,
                                        badgeContainer.childNodes[beforeIndex]);
          }
          return newBadge;
        ]]></body>
      </method>
      
      <method name="setAsDropTarget">
        <parameter name="isdroptarget"/>
        <body><![CDATA[
          var nodeToUpdate;
          // If we're a library node, and our parent node is a device node,
          // then apply the styles to the device node
          if (this.nodeData.className &&
              this.nodeData.className.match(/\blibrary\b/) &&
              this.nodeData.parentNode.className &&
              this.nodeData.parentNode.className.match(/\bdevice\b/))
          {
            // We're a device library
            nodeToUpdate = this.nodeData.parentNode;
          } else {
            nodeToUpdate = this.nodeData;
          }
          
          var domNode = this._servicePane.getDOMNode(nodeToUpdate.id);

          if (isdroptarget) {
            if (domNode.className.search(/\bdroptarget\b/) == -1) {
              domNode.className += " droptarget";
            }
          } else {
            domNode.className =
                        domNode.className.replace(/\bdroptarget\b/g,'');
          }
        ]]></body>
      </method>

      <method name="textboxBlur">
        <parameter name="event"/>
        <body><![CDATA[
          if (this._textbox.getAttribute("hidden"))
            return;
          this._textbox.setAttribute("hidden", true);
          this._servicePane.mService.onRename(this.nodeData,
                                              this._textbox.value);
          this.setAttribute("label", this.nodeData.name);
          event.stopPropagation();
          event.preventDefault();
        ]]></body>
      </method>

      <method name="textboxKeypress">
        <parameter name="event"/>
        <body><![CDATA[
          switch (event.keyCode) {
            case 27: // escape
              // reset changes & exit editing mode
              this._textbox.value = this.getAttribute("label");
              this._textbox.setAttribute("hidden", true);
              this._servicePane.mService.onRename(this.nodeData, null);
              this._servicePane._editingNode = null;

              // ensure the service pane has focus
              this._servicePane.focus();

              break;
            case 13: // enter
              // save changes & exit editing mode
              this._textbox.setAttribute("hidden", true);
              this._servicePane.mService.onRename(this.nodeData,
                                                  this._textbox.value);
              this.setAttribute("label", this.nodeData.name);
              this._servicePane._editingNode = null;
              this.loadNodeURL(event);
              
              // ensure the service pane has focus
              this._servicePane.focus();
              
              break;
          }
        ]]></body>
      </method>

      <!-- drag-and-drop helpers -->
      <method name="_onDragGesture">
        <parameter name="event"/>
        <body>
          <![CDATA[
          var transferable = {};
          if (this.mService.onDragGesture(this.nodeData, transferable)) {
            transferable = transferable.value;
            var transArray = Components.classes["@mozilla.org/supports-array;1"]
                                       .createInstance(Components.interfaces.nsISupportsArray);
            transArray.AppendElement(transferable);
            
            var region = null;
            // let's build the drag region
            try {
              region = Components.classes["@mozilla.org/gfx/region;1"]
                        .createInstance(Components.interfaces.nsIScriptableRegion);
              region.init();

              var bo = this.boxObject;

              region.unionRect(bo.x, bo.y, bo.width, bo.height);

            } catch(ex) {
              dump("Error while building drag region: " + ex + "\n");
              region = null;
            }
            
            var group = this._servicePaneGroup;
            group._dndReordering = true; 
            var dragAction = this.mDragService.DRAGDROP_ACTION_COPY +
                             this.mDragService.DRAGDROP_ACTION_MOVE;
            this.mDragService.invokeDragSessionWithImage(this, 
                                                         transArray,
                                                         region, dragAction,
                                                         null, 0, 0,
                                                         event);
            
            group._dndReordering = false; 
            event.preventDefault();
          }
        ]]>
        </body>
      </method>

      <!-- begin nsDragAndDropObserver -->
      <method name="getSupportedFlavours">
        <body>
        <![CDATA[
          var flavourSet;
          flavourSet = new FlavourSet();
          InternalDropHandler.addFlavours(flavourSet);
          ExternalDropHandler.addFlavours(flavourSet);
          return flavourSet;
        ]]>
        </body>
      </method>

      <method name="_getDropOrientations">
        <parameter name="event"/>
        <body>
          <![CDATA[
          var orientations = [0];
          var tophalf = false;
          if (this._servicePaneGroup._dndReordering) {
          var y = event.screenY - this.boxObject.screenY;
          var third = this.boxObject.height/3;
          if (y < this.boxObject.height/2)
              tophalf = true;
            if (y < third) 
              orientations = [-1, 0, 1]; // before, inside, after
            else if (y > third*2) 
              orientations = [1, 0, -1]; // after, inside, before
            else
              orientations = [0, (tophalf ? -1 : 1), (tophalf ? 1 : -1)]; // inside, closest, farthest
          }
          return orientations;
          ]]>
        </body>
      </method>
      <method name="canDrop">
        <parameter name="event"/>
        <parameter name="session"/>
        <body>
          <![CDATA[
          var orientations = this._getDropOrientations(event);
          var can = false;
          for (var i in orientations) {
            can = this.mService.canDrop(this.nodeData,
                                        this.mDragService.getCurrentSession(),
                                        orientations[i], 
                                        window);
            if (can) {
              this.mDropOrientation = orientations[i];
              break;
            }
          }
          if (!can) {
            this.mDropOrientation = 0;
          } else {
            this._setDropOrientationClass();
          }
          return can;
        ]]></body>
      </method>

      <method name="_removeDropOrientationClass">
        <body>
          <![CDATA[
          this.className = this.className.replace(/\b(dndAcceptIn|dndAcceptBefore|dndAcceptAfter)\b/g, '');
          ]]>
        </body>
      </method>
      
      <method name="_setDropOrientationClass">
        <body>
          <![CDATA[
          var className = this.className;
          className = className.replace(/\b(dndAcceptIn|dndAcceptBefore|dndAcceptAfter)\b/g, '');
          if (this._servicePaneGroup._dndReordering) {
            switch (this.mDropOrientation) {
              case 0:
                className += " dndAcceptIn";
                break;
              case -1:
                className += " dndAcceptBefore";
                break;
              case 1:
                className += " dndAcceptAfter";
                break;
            }
          }
          if (this.className != className)
            this.className = className;
          ]]>
        </body>
      </method>


      <method name="onDragOver">
        <parameter name="event"/>
        <parameter name="flavour"/>
        <parameter name="session"/>
        <body>
        <![CDATA[
          if (session.sourceNode != event.target) {
            if (this._servicePaneGroup._dndReordering) {
              // do nothing
            } else {
              if (this.canDrop(event, session))
                this.setAsDropTarget(true);
            }
          } 
        ]]>
        </body>
      </method>

      <method name="onDragExit">
        <parameter name="event"/>
        <parameter name="session"/>
        <body>
        <![CDATA[
          this.setAsDropTarget(false);
          this._removeDropOrientationClass();
        ]]></body>
      </method>

      <method name="onDrop">
        <parameter name="event"/>
        <parameter name="session"/>
        <body>
          <![CDATA[
          this.mService.onDrop(this.nodeData,
                               this.mDragService.getCurrentSession(),
                               this.mDropOrientation,
                               window);
          this.setAsDropTarget(false);
        ]]></body>
      </method>

      <method name="getNode">
        <parameter name="nodeID"/>
        <body><![CDATA[
          return this.parentNode.getNode(nodeID);
        ]]></body>
      </method>
 
    </implementation>

    <handlers>
      <handler event="click">
      <![CDATA[
        if (event.button == 0) {
          this._servicePane._leaveKeyboardFocus();
          // if we're the active node, & the user clicked on the label
          // then rename
          if (this._servicePane.getActiveNode() == this.nodeData &&
              this.nodeData.editable &&
              event.originalTarget.tagName == "xul:label")
            this._servicePane.startEditingNode(this.nodeData);
          // otherwise load 
          else
            this.loadNodeURL(event);

          event.stopPropagation();
          event.preventDefault();
        }
      ]]>
      </handler>

      <handler event="contextmenu">
      <![CDATA[
        this._servicePane._leaveKeyboardFocus();
        this._servicePane.openContextMenu(event, this.nodeId);
      ]]>
      </handler>

      <!-- drag and drop handling -->
      <handler event="draggesture"><![CDATA[
        // don't allow drag gestures with the popup menu open.
        if (this.mPopup && 
            this.mPopup.state != "closed") {
          return;
        }
        this._onDragGesture(event);
      ]]></handler>

      <handler event="dragover"><![CDATA[
        nsDragAndDrop.dragOver(event, this);
        this._servicePane.needScroll(event);
        event.stopPropagation();
      ]]></handler>

      <handler event="dragdrop">
        nsDragAndDrop.drop(event, this);
        event.stopPropagation();
      </handler>

      <handler event="dragexit">
        nsDragAndDrop.dragExit(event, this);
        event.stopPropagation();
      </handler>

    </handlers>

  </binding>

  <binding id="servicepane-group">
    <content mousethrough="never" persist="collapsedChildren">
      <xul:vbox id="group" class="servicepane-group" >
        <xul:hbox id="hbox-header" class="servicepane-group-header">
          <xul:hbox class="servicepane-group-header-wrapper"
                    flex="1"
                    onclick="toggleVisibility(event)">
                    <!-- Reverted back to previous behaviour per
                         bug 21108
                    onmouseover="checkCollapsible(event)"
                    onmouseout="uncheckCollapsible(event)">
                    -->
            <xul:description class="servicepane-group-label"
                       xbl:inherits="xbl:text=label"/>
            <xul:spacer flex="1" />
          </xul:hbox>
          <xul:image sbid="servicepane-group-header-image"
                     onclick="newPlaylist(event)" />
        </xul:hbox>
        <xul:vbox class="servicepane-group-overflow-container">
          <xul:vbox class="servicepane-group-nodes"
                    sbid="groupNodes" flex="1">
            <children /> <!-- servicepane-nodes -->
          </xul:vbox>
        </xul:vbox>
      </xul:vbox>
    </content>

    <implementation>
      <constructor><![CDATA[
        Components.utils.import("resource://app/jsmodules/LocalStore.jsm", this);

        this._groupNodes = this._getElement("groupNodes");

        var self = this;
        this.nodeData = this.getNode(this.id);

        // Determine whether we're starting up collapsed or visible
        this._visible = true;

        let collapsed = this.LocalStore.getPersistedAttribute(
                                    document.location.href,
                                    this.id,
                                    "collapsedChildren");
        if (collapsed) {
          self.nodeData.isOpen = (collapsed == "false");
        }
        
        // The group header image
        this.image = null;
        // Special handling for the SB:Playlists group
        if (this.id == "SB:Playlists") {
          this.image = this._getElement("servicepane-group-header-image");
          this.image.className = "sb-servicepane-new-playlist";
        }

        this.servicePane = this.parentNode;

        this._isMac = (getPlatformString() == "Darwin");
        this.keyListener = function(e) {
          if (!self.image)
            return;

          // Don't switch the modes if the currently focused element is
          // a text field.  We need to catch the document's active element,
          // as well as look for the case of the browser's active element
          // (i.e. if the user is editing a track name in sb-playlist
          const XULNS =
                "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          const HTMLNS = "http://www.w3.org/1999/xhtml";
          let element = document.activeElement;
          if (element.namespaceURI == XULNS && element.localName == "browser")
            element = document.activeElement.docShell.document.activeElement;
          
          if (element.namespaceURI == HTMLNS && element.localName == "input")
            return;

          if ((self._isMac && e.altKey) || (!self._isMac && e.shiftKey)) {
            self.image.setAttribute("altKey", "true");
          } else {
            self.image.removeAttribute("altKey");
          }
        }

        window.addEventListener("keydown", this.keyListener, false);
        window.addEventListener("keyup", this.keyListener, false);
      ]]></constructor>

      <destructor><![CDATA[
        window.removeEventListener("keydown", this.keyListener, false);
        window.removeEventListener("keyup", this.keyListener, false);
      ]]></destructor>

      <field name="_dndReordering">false</field>
      <field name="_autoCloseOnLeaveKeyboardFocus">false</field>

      <method name="newPlaylist">
        <parameter name="e" />
        <body><![CDATA[
          if (e.button != 0)
            return;

          this.image.removeAttribute("altKey");
          if ((this._isMac && e.altKey) || (!this._isMac && e.shiftKey)) {
            SBNewSmartPlaylist();
          } else {
            var enumerator;
            if (gBrowser &&
                gBrowser.selectedTab &&
                gBrowser.selectedTab.mediaListView)
            {
              enumerator = gBrowser.selectedTab
                .mediaListView
                .selection
                .selectedMediaItems;
            }

            SBNewPlaylist(enumerator, false);
          }
        ]]></body>
      </method>

      <property name="actuallyVisible">
        <getter><![CDATA[
          return (!this._groupNodes.style.marginTop ||
                  this._groupNodes.style.marginTop == "0px");
        ]]></getter>
      </property>

      <property name="visible">
        <getter><![CDATA[
          return this._visible;
        ]]></getter>
        <setter><![CDATA[
          if (this._visible == val)
            return;
          this._visible = val;
          if (this._visible) {
            this.animateTo(this._groupNodes, 0, 0, this._height, 5, true);
          } else {
            this._height = this._groupNodes.boxObject.height;
            this.animateTo(this._groupNodes, this._height, this._height, 0, 5, false);
          }
        ]]></setter>
      </property>
      
      <method name="animateTo">
        <parameter name="element" />
        <parameter name="orig" />
        <parameter name="from" />
        <parameter name="to" />
        <parameter name="interval" />
        <parameter name="dir" />
        <body><![CDATA[
          var self = this;
          try {
            if (dir) {
              if (from < to) {
                let diff = to - from;
                interval = diff/2;
                let newdim = from + interval;
                if (newdim >= to || interval < 5)
                  newdim = to;

                let marginTop = to - newdim; 
                element.style.marginTop = "-" + marginTop + "px";
                setTimeout(function() {
                    self.animateTo(element, orig, newdim, to, interval, dir);
                    }, 40);
              } else {
                element.style.marginTop = "-" + orig + "px";
                self.setAttribute("collapsedChildren", "false");

                var evt = document.createEvent("UIEvents");
                evt.initEvent("expand-servicepane-group", true, true);
                self.dispatchEvent(evt);
              }
            } else {
              if (from > to) {
                let diff = from - to;
                interval = diff/2;
                let newdim = from - interval;
                if (newdim <= to || interval < 3)
                  newdim = to;

                let marginTop = orig - newdim;
                element.style.marginTop = "-" + marginTop + "px";
                setTimeout(function() {
                    self.animateTo(element, orig, newdim, to, interval, dir);
                    }, 40);
              } else {
                element.style.marginTop = "-" + orig + "px";
                self.setAttribute("collapsedChildren", "true");

                var evt = document.createEvent("UIEvents");
                evt.initEvent("collapse-servicepane-group", true, true);
                self.dispatchEvent(evt);
              }
            }
          } catch (e) {
            dump("Exception: " + e + "\n\n\n");
          }
        ]]></body>
      </method>

      <method name="_getElement">
        <parameter name="anonID"/>
        <body><![CDATA[
          return document.getAnonymousElementByAttribute(this,
                                                         "sbid",
                                                         anonID);
        ]]></body>
      </method>

      <method name="getNode">
        <parameter name="nodeID"/>
        <body><![CDATA[
          return this.parentNode.getNode(nodeID);
        ]]></body>
      </method>

      <method name="getRelationshipToActiveNode">
        <body><![CDATA[
          let activeNode = this.servicePane.getActiveNode();
          let activeDomNode = this.servicePane.getDOMNode(activeNode.id);
          let relationship = this.compareDocumentPosition(activeDomNode);
          return relationship;
        ]]></body>
      </method>

      <method name="toggleVisibility">
        <parameter name="event" />
        <body><![CDATA[
          /* Commented out per bug 21108
          // Don't allow collapsing of the group if our currently active node
          // is in it
          let relationship = this.getRelationshipToActiveNode();
          if (relationship & this.DOCUMENT_POSITION_CONTAINED_BY)
            return;
            */

          this.visible = !this.visible;
        ]]></body>
      </method>

      <method name="checkCollapsible">
        <parameter name="event" />
        <body><![CDATA[
          // Don't visually indicate collapsible if we contain the active node
          let relationship = this.getRelationshipToActiveNode();
          if (relationship & this.DOCUMENT_POSITION_CONTAINED_BY)
            return;

          this.className += " collapsible";
        ]]></body>
      </method>

      <method name="uncheckCollapsible">
        <parameter name="event" />
        <body><![CDATA[
          this.className = this.className.replace(/\bcollapsible\b/g, '');
        ]]></body>
      </method>

    </implementation>

    <handlers>
      <handler event="dragover"><![CDATA[
        // If there is an existing expanded group that isn't us, then
        // collapse it
        if (this.servicePane._collapsedGroup &&
            this.servicePane._collapsedGroup != this)
        {
          this.servicePane._collapsedGroup._collapseOnDragExit = null;
          this.servicePane._collapsedGroup.visible = false;
          this.servicePane._collapsedGroup = null;
        }

        // If we have an existing timer running for a group that isn't us,
        // clear it
        if (this.servicePane._timer &&
            this.servicePane._timerGroup &&
            this.servicePane._timerGroup != this)
        {
          this.servicePane.log("Existing timer found, clearing");
          clearTimeout(this.servicePane._timer);
          this.servicePane._timer = null;
        }

        if (!this.visible && !this._expandTimerRunning) {
          this.servicePane.log("Collapsed group found: " + this.id +
                               ", setting expand timer for 1s");
          var self = this;
          // Flag a timer as running
          this._expandTimerRunning = true;
          this.servicePane._timerGroup = this;
          this.servicePane._timer = setTimeout(function() {
              // Make the group visible
              self.servicePane.log("Expanding group: " + self.id);
              self.visible = true;
              self._collapseOnDragExit = true;
              self.servicePane._collapsedGroup = self;
              self._expandTimerRunning = null;
              self.servicePane._timerGroup = null;
              self.servicePane._timer = null;
            }, 750);
          event.stopPropagation();
        }
      ]]></handler>

      <handler event="dragexit"><![CDATA[
        if (!event.relatedTarget)
          return;
        let relation = this.compareDocumentPosition(event.relatedTarget);
        if (this._expandTimerRunning &&
            !((relation & this.DOCUMENT_POSITION_CONTAINS) ||
              (relation & this.DOCUMENT_POSITION_CONTAINED_BY)))
        {
          // We've exited the group, so cancel any existing timer
          this.servicePane.log("Exited group: " + this.id + ", clearing timer");
          clearTimeout(this.servicePane._timer);
          this._expandTimerRunning = null;
          this.servicePane.timer = null;
          this.servicePane._timerGroup = null;
        }

        /* Auto-collapse if we auto-expanded */
        if (this._collapseOnDragExit &&
            !((relation & this.DOCUMENT_POSITION_CONTAINS) ||
              (relation & this.DOCUMENT_POSITION_CONTAINED_BY)))
        {
          this.visible = false;
          this._collapseOnDragExit = null;
          this.servicePane._collapsedGroup = null;
        }
      ]]></handler>
    </handlers>
  </binding>

  <binding id="servicepane">
    <content mousethrough="never" wheelvolume="false">
      <xul:vbox id="sb_servicepane" class="servicepane-outer-box" flex="1">
        <xul:scrollbox id="sb_servicepane_box"
                  orient="vertical"
                  sbid="innerbox"
                  class="servicepane-inner-box"
                  flex="1">
          <children /> <!-- servicepane-group elements -->
        </xul:scrollbox>
        <xul:sb-displaypane-splitter
                collapse="after"
                orient="vertical"
                resizeafter="closest"
                id="displaypane_servicepane_bottom_splitter"
                menuid="displaypane_servicepane_bottom_menu" />
        <xul:sb-displaypane id="displaypane_servicepane_bottom"
                            label="&displaypane.name.servicepane;"
                            splitter="displaypane_servicepane_bottom_splitter"
                            contentgroup="servicepane"/>
      </xul:vbox>
      <!-- menupopup needs to be outside the vbox otherwise it
           gets height adjusted to 0 when the splitter is
           adjusted -->
      <xul:menupopup id="displaypane_servicepane_bottom_menu"
                     class="menulist-menupopup">
        <xul:sb-displaypane-content-menuitems
                     paneid="displaypane_servicepane_bottom" />
      </xul:menupopup>

      <!-- context menu popup -->
      <xul:popupset>
        <xul:popup sbid="popup"
                   onpopupshown="onPopupShown(event);"
                   onpopuphidden="onPopupHidden(event);" />
      </xul:popupset>
    </content>

    <implementation>
      <constructor>
      <![CDATA[
        window.gServicePane = this;

        Components.utils.import("resource://app/jsmodules/DOMUtils.jsm", this);

        // Setup logging
        Components.utils.import("resource://app/jsmodules/DebugUtils.jsm");
        this.log = DebugUtils.generateLogFunction("ServicePane", 4);
        this.noisyLog = DebugUtils.generateLogFunction("ServicePane", 5);

        this.mService =
          Components.classes['@songbirdnest.com/servicepane/service;1']
          .getService(Components.interfaces.sbIServicePaneService);

        this.loadServicePane();

        // save the popup node
        this.mPopup = document.getAnonymousElementByAttribute(this,
                                                              'sbid',
                                                              'popup');
        this.mInnerBox = document.getAnonymousElementByAttribute(this,
                                                                 'sbid',
                                                                 'innerbox');
        /* Add a listener to the root node so we know to update when the
           hierarchy of nodes changes */
        this._mutationListener.element = this;
        this.mService.root.addMutationListener(this._mutationListener);

        /* Add a listener to the tabbrowser so we highlight the proper
           nodes on location changes */
        if (this.browser) {
          let sp = this;
          this._onBrowserTabChangeListener = function(e) {
            sp.onBrowserTabChange(e);
          }
          this.browser.addEventListener("TabContentChange",
                                        this._onBrowserTabChangeListener,
                                        false);
        }
      ]]>
      </constructor>

      <destructor>
      <![CDATA[
        if (this.browser) {
          this.browser.removeEventListener("TabContentChange",
                                           this._onBrowserTabChangeListener,
                                           false);
        }
        this.mService.root.removeMutationListener(this._mutationListener);
      ]]>
      </destructor>

      <!-- sbIServicePaneMutationListener & sbIServicePaneListener -->
      <field name="_mutationListener">
      <![CDATA[
        ({
          element: null,
          // Old interface, deprecated
          hiddenAttributeChanged: function(node, oldVal, newVal) {
          },

          // Old interface, deprecated
          isOpenAttributeChanged: function(node, oldVal, newVal) {
          },

          attrModified: function(node, attrName, namespace, oldVal, newVal) {
            if (oldVal == newVal)
              return;

            // attempt to find the DOM node in the SP, bail otherwise
            let domNode = this.element.getDOMNode(node.id);
            if (!domNode)
              return;

            switch (attrName) {
              case "hidden":
                if (newVal == "false") {
                  domNode.removeAttribute("hidden");
                } else if (newVal == "true") {
                  domNode.setAttribute("hidden", true);
                }
                break;

              case "name":
                domNode.setAttribute("label", newVal);
                break;

              case "image":
                domNode.setAttribute("image", newVal);
                break;

              case "class":
                domNode.className = newVal;
                if (node.firstChild)
                  domNode.className += " container";
                break;

              case "isOpen":
                // group's open states are a little different
                if (domNode.tagName == "sb-servicepane-group") {
                  if (newVal == "true")
                    domNode.visible = true;
                  else
                    domNode.visible = false;
                  return;
                }

                // update the "closed" attribute
                if (newVal == "true") {
                  domNode.removeAttribute("closed");
                } else {
                  // could be null or false
                  domNode.setAttribute("closed", "true");
                }
                break;

              default:
                /* Can be useful, but noisy */
                this.element.noisyLog("Unhandled node attribute change: " +
                                 attrName + " from '" + oldVal + "' => '" +
                                 newVal + "'");
                break;
            }
          },

          nodeInserted: function(node, parent, insertBefore) {
            if (!parent || parent == this.element.mService.root) {
              // It's a new top level servicepane-group
              let newGroup = this.element.createGroup(node);
              this.element.log("New top level group: " + node.id);

              // Need to find the right place in the DOM hierarchy to put it
              const SP = "http://songbirdnest.com/rdf/servicepane#";
              let child = this.element.firstChild;
              let weight = parseInt(node.getAttributeNS(SP, "Weight"));
              while (child != null) {
                if (child.nodeType == child.TEXT_NODE) {
                  child = child.nextSibling;
                  continue;
                }
                let otherNode = this.element.getNode(child.id);
                let otherWeight = parseInt(
                                       otherNode.getAttributeNS(SP, "Weight"));
                this.element.log("Comparing " + node.id + " (weight: " +
                                 weight + ") to " + child.id +
                                 " (weight: " + otherWeight + ")");
                if (weight < otherWeight) {
                  this.element.log("Inserting " + node.id + " (weight: " +
                                   weight + ") before " + child.id +
                                   " (weight: " + otherWeight + ")");
                  this.element.insertBefore(newGroup, child);

                  // hacky workaround for bug 21128, comment #2
                  let hackNode = document.createTextNode("");
                  this.element.insertBefore(hackNode, child);

                  return;
                }
                child = child.nextSibling;
              }
              this.element.log("Appending " + node.id);
              this.element.appendChild(newGroup);
              
              // hacky workaround for bug 21128, comment #2
              let hackNode = document.createTextNode("");
              this.element.appendChild(hackNode);
            } else {
              // It's a regular node
              this.element.log("New node: " + node.id);
              /* find the node representing the parent */
              let parentNode = this.element.getDOMNode(parent.id);
              if (!parentNode) {
                this.element.log("\tNo parent node found, skipping..");
                return;
              }
              this.element.log("Parent node is: " +
                               parentNode.getAttribute("nodeid"));
              let newnode = this.element.createNode(node, parentNode, insertBefore);

              // Update parent node - if it wasn't a container before it is one now
              if (parentNode != this.element)
                this.element.DOMUtils.setClass(parentNode, "container");
            }

            // The new node may already have children associated with it, so
            // let's go look for those & add them to the hierarchy
            let childNode = node.firstChild;
            while (childNode) {
              this.element.log("\tChild node found: " + childNode.id);
              this.nodeInserted(childNode, node);
              childNode = childNode.nextSibling;
            }
          },

          nodeRemoved: function(node, parent) {
            this.element.log("\tAttempting to remove node : " + node.id +
                             " from " + parent.id);

            try {
              // find the DOM node representing this servicepane node
              let domNode = this.element.getDOMNode(node.id);

              // was this node active?
              let active = null;
              if (domNode)
                active = domNode.className.match(/\bactive\b/);
              else
                this.element.log("\tUnable to find a DOM node for " + node.id);

              // was this node the focus for keyboard operations ?
              if (this.element._keyboardFocusNode == node) {
                this.element._keyboardFocusNode = null;
              }

              // remove the actual node
              if (domNode && domNode.parentNode) {
                this.element.log("\tDOM nodes map to removing " + domNode.id +
                                 " from " + domNode.parentNode.id);
                domNode.parentNode.removeChild(domNode);
              }
            } catch (e) {
              dump("Exception: " + e + "\n");
            }
            // XXXtodo
            // if the node was active, then the browser will have gone back
            // in history and loaded the previously loaded page.  check the
            // servicepane to see if we have a node that matches the page,
            // and if so - visually highlight/select it
          }
        })
      ]]>
      </field>

      <!-- The ID of the active node, or null if none -->
      <field name="_activeNodeID">null</field>

      <!-- The ID of the highlighted node, or null if none -->
      <field name="_highlightedNodeID">null</field>

      <!-- The node we're currently editing -->
      <field name="_editingNode">null</field>

      <!-- The node with the current keyboard focus -->
      <field name="_keyboardFocusNode">null</field>

      <!--
        TODO: Change the use of these functions so we can remove the
        mTreePane dependency (not to be confused with the T-PAIN dependency).
        mTreePane is used for the following:
        isMediaTabURL(url) - SBSessionStore.js#298
        loadNode(node, null) - mainPlayerWindow.js#445, deviceSupport.js#477
      -->
      <field name="mTreePane">null</field>

      <!-- Splitter between the service pane and the content on the main view
           in the Purple Rain/Gonzo feathers. -->
      <field name="mSplitter">
        document.getElementById('servicepane_splitter');
      </field>

      <!--
        - \brief Create a group that may hold nodes
        -->
      <method name="createGroup">
        <parameter name="nodeData"/>
        <body><![CDATA[
          var XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          var newGroup = document.createElementNS(XULNS, "sb-servicepane-group");
          newGroup.setAttribute("label", nodeData.displayName);
          newGroup.setAttribute("nodeid", nodeData.id);
          newGroup.setAttribute("id", nodeData.id);
          if (!nodeData.isOpen) {
            newGroup.setAttribute("closed", true);
          }
          if (nodeData.hidden) {
            newGroup.setAttribute("hidden", true);
          }
          return newGroup;
        ]]></body>
      </method>

      <!--
        - \brief Create a node that belongs to another node or group
        -->
      <method name="createNode">
        <parameter name="nodeData"/>
        <parameter name="parentNode"/>
        <parameter name="aInsertBefore"/>
        <body>
            <![CDATA[
          var XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          var newNode = document.createElementNS(XULNS,"sb-servicepane-node");
          newNode.setAttribute("nodeid", nodeData.id);
          if (this.hasAttribute("browser")) {
            newNode.setAttribute("browser", this.getAttribute("browser"));
          }

          // If the servicepane-group holding this node is collapsed, then
          // add a load listener to make sure we adjust the margins for the
          // group once we're added
          newNode.addEventListener("load", function(e) {
              newNode.removeEventListener("load", arguments.callee, false);
              
              // find the parent servicepane-group
              let parentGroup = newNode._servicePaneGroup;

              // no need to do anything if it's already visible
              if (parentGroup.visible)
                return;

              // adjust the margin to include our newly added group
              let height = parentGroup._groupNodes.boxObject.height;
              parentGroup._groupNodes.style.marginTop = "-" + height + "px";
            }, false);
           
          if (parentNode) {
            var nodeBefore = aInsertBefore ? this.getDOMNode(aInsertBefore.id) : null;
            parentNode.insertBefore(newNode, nodeBefore);
          }

          return newNode;
        ]]></body>
      </method>

      <!--
        - \brief Inital load of the service pane, this will create the groups
        - and fill them with nodes as defined.
        -->
      <method name="loadServicePane">
        <body><![CDATA[
          if (!this.mService) {
            this.mService =
              Components.classes['@songbirdnest.com/servicepane/service;1']
              .getService(Components.interfaces.sbIServicePaneService);
            this.mService.init();
          }

          var XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";

          /* These should already be in sorted order */
          this.log("********** SERVICEPANE ROOT **********");
          var groupEntry = this.mService.root.firstChild;
          while (groupEntry) {
            this.log("|- " + groupEntry.id);
            // Create the group and set the state
            var newgroup = this.createGroup(groupEntry);

            // Helper function to add nodes (called recursively)
            function addNode(nodeEntry, parent)
            {
              this.log("\t|- " + nodeEntry.id);
              let newnode = this.createNode(nodeEntry, parent);
              for (let child = nodeEntry.firstChild; child; child = child.nextSibling)
                addNode.call(this, child, newnode);
            }

            // Create the nodes in this group
            for (let child = groupEntry.firstChild; child; child = child.nextSibling)
              addNode.call(this, child, newgroup);

            this.appendChild(newgroup);
            
            // hacky workaround for bug 21128, comment #2
            let hackNode = document.createTextNode("");
            this.appendChild(hackNode);

            groupEntry = groupEntry.nextSibling;
          }
        ]]></body>
      </method>

      <!--
        - \brief Get the node from an id.
        - \param nodeID is the id of the node.
        - \return the sbIServicePaneNode from the id.
        -->
      <method name="getNode">
        <parameter name="nodeID"/>
        <body><![CDATA[
          return this.mService.getNode(nodeID);
        ]]></body>
      </method>

      <method name="getDOMNode">
        <parameter name="nodeID"/>
        <body><![CDATA[
          let spNode = this.getElementsByAttribute("nodeid", nodeID)[0];
          return spNode;
        ]]></body>
      </method>

      <!--
        - \brief Get the active node if any.
        - \return sbIServicePaneNode of the active node, or null if none
        -->
      <method name="getActiveNode">
        <body><![CDATA[
          if (this._activeNodeID) {
            return this.mService.getNode(this._activeNodeID);
          }
          else {
            return null;
          }
        ]]></body>
      </method>

      <method name="getHighlightedNode">
        <body><![CDATA[
          if (this._highlightedNodeID) {
            return this.mService.getNode(this._highlightedNodeID);
          }
          else {
            return null;
          }
        ]]></body>
      </method>

      <method name="getKeyboardFocusNode">
        <parameter name="nodefault"/>
        <body><![CDATA[
          if (this._keyboardFocusNode)
            return this._keyboardFocusNode;
          if (!nodefault)
            return this.getActiveNode();
          return null;
        ]]></body>
      </method>

      <!-- to trigger selection highlighting -->
      <method name="_makeSelectedNodeActive">
        <body>
          <![CDATA[
          try {
            // Is there a servicepane node for the current tab?
            let node = this._browser.selectedTab.servicePaneNode;

            // if we didn't find a node, try looking it up by URL
            if (!node) {
              let uri = this._browser.selectedTab.linkedBrowser.currentURI;
              if (uri)
                node = this.mService.getNodeForURL(uri.spec);
            }

            // if we still didn't find a node, try looking it up by medialist
            if (!node && this._browser.selectedTab.mediaListView) {
              let librarySPS = Cc['@songbirdnest.com/servicepane/library;1']
                                 .getService(Ci.sbILibraryServicePaneService);
              node = librarySPS.getNodeFromMediaListView(
                                 this._browser.selectedTab.mediaListView);
            }

            // Do not switch active node if it's hidden
            if (node && !node.hidden) {
              this.makeNodeActive(node);
            }
          } catch (e) {
            Components.utils.reportError(e);
          }
        ]]>
        </body>
      </method>

      <!--
        - \brief Deselect any currently selected node(s) and select the
        - passed in node
        -->
      <method name="makeNodeActive">
        <parameter name="newNode"/>
        <body><![CDATA[
          if (!newNode)
            return;

          // Remove the 'active' CSS class from the currently active node
          let activeNode = this.getActiveNode();

          if (activeNode == newNode)
            return;

          if (this._editingNode) {
            // don't save any changes
            this._editingNode._textbox.setAttribute("hidden", true);
            this._editingNode._textbox.value =
                 this._editingNode.getAttribute("label");
            this.mService.onRename(this._editingNode.nodeData, null);
            this._editingNode = null;
          }

          if (activeNode) {
            activeNode.className =
                      activeNode.className.replace(/\bactive\b/g, '');
          }

          // Add the 'active' class to the new node
          newNode.className += " active";
          this._activeNodeID = newNode.id;

          // Auto expand the parent group of this node
          let parentNode = newNode.parentNode;
          while (parentNode && (parentNode.parentNode != this.mService.root))
            parentNode = parentNode.parentNode;
          if (parentNode) {
            let parentDomNode = this.getDOMNode(parentNode.id);
            parentDomNode.visible = true;
          }

          return newNode;
        ]]></body>
      </method>

      <!--
        - \brief Dehighlight any currently highlighted node(s) and
        - highlight the passed in node
        -->
      <method name="makeNodeHighlighted">
        <parameter name="newNode"/>
        <body><![CDATA[
          // Remove the 'highlight' CSS from the currently highlighted node
          let highlightedNode = this.getHighlightedNode();

          if (highlightedNode == newNode)
            return;

          if (highlightedNode) {
            let domNode = this.getDOMNode(highlightedNode.id);
            domNode.className = domNode.className.replace(/\bhighlighted\b/g,'');
          }

          // Add the 'highlighted' class to the new node
          newNode.className += " highlighted";
          this._highlightedNodeID = newNode.nodeData.id;
          return newNode;
        ]]></body>
      </method>
      
      <!--
        - \brief Highlight a node as being active
        -->
      <method name="highlightNode">
        <parameter name="aNode"/>
        <body><![CDATA[
          this.makeNodeActive(aNode);
        ]]></body>
      </method>

      <!--
        - \brief Start editing a nodes name, this may not be enabled if the
        -        node is read only.
        - \return true if editing started, false if not able to edit.
        -->
      <method name="startEditingNode">
        <parameter name="aNode"/>
        <body><![CDATA[
          if (!aNode || !aNode.editable)
            return false;

          try {
            // are we editing any other nodes currently?
            if (this._editingNode) {
              // don't save any changes
              this._editingNode._textbox.setAttribute("hidden", true);
              this._editingNode._textbox.value =
                   this._editingNode.getAttribute("label");
              this.mService.onRename(this._editingNode.nodeData, null);
              this._editingNode = null;
            }

            // notify servicepane service that we're about to rename the node
            this.mService.onBeforeRename(aNode);

            // get the DOM node for the node we're about to edit
            this._editingNode = this.getDOMNode(aNode.id);

            // ensure this node is visible.  we do this by having the scrollbox
            // scroll to make the element visible.  but if the group is
            // collapsed, this won't work, so we need to do it once the
            // group is visible, and no sooner
            let scrollbox =
                this.mInnerBox.boxObject.QueryInterface(Ci.nsIScrollBoxObject);
            let groupNode = aNode.parentNode;
            while (groupNode.parentNode != this.mService.root)
              groupNode = groupNode.parentNode;
            let groupDomNode = this.getDOMNode(groupNode.id);
            // if the group is already open, then just make sure our editing
            // node is visible
            if (groupDomNode.actuallyVisible)
              scrollbox.ensureElementIsVisible(this._editingNode);
            else {
              let editingNode = this._editingNode;
              groupDomNode.addEventListener("expand-servicepane-group",
                function(e) {
                  // remove listener
                  groupDomNode.removeEventListener("expand-servicepane-group",
                                                   arguments.callee,
                                                   false);
                  scrollbox.ensureElementIsVisible(editingNode);
                }, false);
            }

            // start editing this node
            this._editingNode._textbox.removeAttribute("hidden");
            this._editingNode._textbox.value =
                 this._editingNode.getAttribute("label");
            this._editingNode._textbox.select();
            return true;
          } catch (e) {
            dump("Exception: " + e + "\n");
            this._editingNode = null;
            return false;
          }
        ]]></body>
      </method>

      <!--
        - \brief Get the name of a node that has a particular URL.
        - \param aURL URL to search for in the nodes.
        - \return name of the node, or aURL if no node found.
        -->
      <method name="getURLName">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.name : aURL;
        ]]></body>
      </method>

      <!--
        - \brief Get the image of a node that has a particular URL.
        - \param aURL URL to search for in the nodes.
        - \return image of the node, or null if no node found.
        -->
      <method name="getURLImage">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.image : null;
        ]]></body>
      </method>

      <!--
        - \brief Get the properties of a node that has a particular URL.
        - \param aURL URL to search for in the nodes.
        - \return properties of the node, or "" if no node found.
        -->
      <method name="getURLProperties">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.properties : "";
        ]]></body>
      </method>

      <!-- Called when the content of the current browser tab is changed.
           This occurs when the user swiches tabs, or loads an new page 
           in the existing tab.  Note that on page load this method is called
           both at load start and at load complete. -->
      <method name="onBrowserTabChange">
        <body><![CDATA[
          this._makeSelectedNodeActive();
        ]]></body>
      </method>

      <!-- Popup menu methods -->
      <method name="onPopupShown">
        <parameter name="event" />
        <body>
          <![CDATA[
          let visibleChildren = false;
          for (var i=0;i<this.mPopup.childNodes.length;i++) {
            let thisChild = this.mPopup.childNodes[i];
            if (thisChild.hidden)
              continue;
            visibleChildren = true;
            break;
          }
          if (!visibleChildren)
            this.mPopup.hidePopup();
          ]]>
        </body>
      </method>

      <method name="onPopupHidden">
        <parameter name="event" />
        <body>
          <![CDATA[
          //this.mPopup.hidePopup();
          // Remove the 'highlight' CSS from the currently highlighted node
          let highlightedNode = this.getHighlightedNode();
          if (highlightedNode) {
            let domNode = this.getDOMNode(highlightedNode.id);
            domNode.className = domNode.className.replace(/\bhighlighted\b/g,'');
          }

          this._highlightedNodeID = null;
          ]]>
        </body>
      </method>

      <method name="openContextMenu">
        <parameter name="event" />
        <parameter name="nodeId" />
        <body>
          <![CDATA[
          // clear the popup menu
          while (this.mPopup.lastChild) {
            DOMUtils.destroyNode(this.mPopup.lastChild);
            this.mPopup.removeChild(this.mPopup.lastChild);
          }
          
          // if we got passed a DOM node, then fill the context menu with
          // the context menu options defined by the service handling the
          // node.  otherwise, fill the popup with the contents of the
          // "new stuff" menu
          var x, y;
          if (nodeId) {
            let node = this.getNode(nodeId);
            let domNode = this.getDOMNode(nodeId);
            this.makeNodeHighlighted(domNode);
            this.mService.fillContextMenu(node, this.mPopup, window);
            x = (event ? (event.screenX + 5) : domNode.boxObject.screenX);
            y = (event ? (event.screenY + 5) : (domNode.boxObject.screenY + 
                                                domNode.boxObject.height));
          } else {
            this.mService.fillNewItemMenu(null, this.mPopup, window);
            x = (event ? (event.screenX + 5) : this.boxObject.screenX + 5);
            y = (event ? (event.screenY + 5) : this.boxObject.screenY + 5);
          }

          // show the popup menu
          document.popupNode = null;
          this.mPopup.showPopup(document.documentElement, x, y,
                                'context', null, null, null);

          // XXXstevel: should we select/highlight the node?
          if (event) {
            event.stopPropagation();
            event.preventDefault();
          }
          ]]>
        </body>
      </method>

      <!--
        - \brief State of the service pane, open or closed.
        -->
      <property name="open">
        <getter>
        <![CDATA[
          var elId = this.mSplitter.getAttribute("collapseelement");
          return !document.getElementById(elId).collapsed;
        ]]>
        </getter>
        <setter>
        <![CDATA[
          var elId = this.mSplitter.getAttribute("collapseelement");
          var el = document.getElementById(elId);
          el.collapsed = !val;

          SBDataSetBoolValue('splitter.servicepane_splitter.collapsed',
                             el.collapsed);
          // If we are opening the service pane, make sure we highlight the
          // appropriate node.
          if(val) {
            // Is there a servicepane node for the current tab?
            //var node = this.mTreePane.browser.selectedTab.servicePaneNode;
            //if (node) {
            //  this.mTreePane.highlightNode(node);
            //}
          }
          ]]>
        </setter>
      </property>

      <field name="_browser">null</field>
      <property name="browser">
        <getter><![CDATA[
          if (!this._browser) {
            this._browser = document.getElementById(this.getAttribute('browser'));
          }
          return this._browser;
        ]]></getter>
      </property>
      
      <method name="needScroll">
        <parameter name="event" />
        <body><![CDATA[
          let scrollbox =
              this.mInnerBox.boxObject.QueryInterface(Ci.nsIScrollBoxObject);
          
          // If we're near the bottom or top of the servicepane, then scroll as
          // needed
          if (event.screenY <= this.boxObject.screenY + 20)
          {
            scrollbox.scrollBy(0, -10);
          } else if (event.screenY >=
                    (this.boxObject.screenY+this.mInnerBox.boxObject.height-20))
          {
            scrollbox.scrollBy(0, 10);
          }
          event.stopPropagation();
        ]]></body>
      </method>

      <method name="ensureNodeIsVisible">
        <parameter name="node" />
        <body><![CDATA[
          let scrollbox =
              this.mInnerBox.boxObject.QueryInterface(Ci.nsIScrollBoxObject);
          scrollbox.ensureElementIsVisible(this.getDOMNode(node.id));
        ]]></body>
      </method>
      
      <method name="_leaveKeyboardFocus">
        <body><![CDATA[ 
          if (this._keyboardFocusNode) {
            var node = this._keyboardFocusNode;
            var domnode = this.getDOMNode(node.id);
            if (domnode) {
              var group = domnode._servicePaneGroup;
              if (group && 
                  group._autoCloseOnLeaveKeyboardFocus) {
                // if this group was open by navigating to it with the kbd,
                // make it so leaving it with the keyboard won't close it
                // anymore now that we've loaded the url
                group._autoCloseOnLeaveKeyboardFocus = false;
              }
            }
            this.setKeyboardFocusNode(null);
          }
        ]]></body>
      </method>

      <method name="setKeyboardFocusNode">
        <parameter name="node"/>
        <body>
        <![CDATA[
          if (this._keyboardFocusNode) {
            var domnode = this.getDOMNode(this._keyboardFocusNode.id);
            domnode.className = 
              domnode.className.replace(/\bkeyboardfocus\b/g,'');
            this._keyboardFocusNode = null;
          }
          if (node) {
            var domnode = this.getDOMNode(node.id);
            if (domnode.className.search(/\bkeyboardfocus\b/) == -1) {
              domnode.className += " keyboardfocus";
            }
            this._keyboardFocusNode = node;
            this.ensureNodeIsVisible(node);
          }
        ]]>
        </body>
      </method>
      
      <method name="_expandKeyboardFocusNode">
        <body><![CDATA[ 
          var node = this.getKeyboardFocusNode();
          if (node && !node.isOpen) {
            var domnode = this.getDOMNode(node.id);
            if (domnode) 
              domnode.toggleContainer();
          }
        ]]></body>
      </method>
      <method name="_collapseKeyboardFocusNode">
        <body><![CDATA[ 
          var node = this.getKeyboardFocusNode();
          if (node && node.isOpen) {
            var domnode = this.getDOMNode(node.id);
            if (domnode) 
              domnode.toggleContainer();
          }
        ]]></body>
      </method>
      <method name="_editKeyboardFocusNode">
        <body><![CDATA[ 
          var node = this.getKeyboardFocusNode();
          if (node && node.editable)
            this.startEditingNode(node);
        ]]></body>
      </method>
      <method name="_openKeyboardFocusNode">
        <parameter name="event"/>
        <body><![CDATA[ 
          var node = this.getKeyboardFocusNode();
          if (node) {
            var domnode = this.getDOMNode(node.id);
            if (domnode) {
              this._leaveKeyboardFocus();
              domnode.loadNodeURL(event)
            }
          }
        ]]></body>
      </method>
      <method name="_contextMenuKeyboardFocusNode">
        <parameter name="event"/>
        <body><![CDATA[ 
          var node = this.getKeyboardFocusNode();
          if (node) {
            this.openContextMenu(null, node.id);
          }
        ]]></body>
      </method>
      <method name="_keyboardFocusUp">
        <body><![CDATA[ 
          var node = this._getKeyboardFocusSibling(-1);
          if (node) {
            if (node == -1) {
              setTimeout(function(o) { o._keyboardFocusUp(); }, 0, this);
              return;
            }
            this.setKeyboardFocusNode(node);
          }
        ]]></body>
      </method>
      <method name="_keyboardFocusDown">
        <body><![CDATA[ 
          var node = this._getKeyboardFocusSibling(1);
          if (node) {
            if (node == -1) {
              setTimeout(function(o) { o._keyboardFocusDown(); }, 0, this);
              return;
            }
            this.setKeyboardFocusNode(node);
          }
        ]]></body>
      </method>

      <method name="_getKeyboardFocusSibling">
        <parameter name="direction"/>
        <body><![CDATA[ 
          var oldgroup = null;
          var pos = -1;
          var kfnode = this.getKeyboardFocusNode();
          if (kfnode) {
            var kfdomnode = this.getDOMNode(kfnode.id);
            oldgroup = kfdomnode._servicePaneGroup;
            var XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
            var domnodes = this.getElementsByTagNameNS(XULNS,"sb-servicepane-node");
            for (var i in domnodes) {
              if (domnodes[i] == kfdomnode) {
                pos = parseInt(i);
                break;
              }
            }
          }
          while (1) {
            pos += direction;
            if (pos < 0 || pos >= domnodes.length)
              break;
            var domnode = domnodes[pos];
            // discard non-element domnodes
            if (domnode.nodeType != Node.ELEMENT_NODE)
              continue;
            var node = this.getNode(domnode.getAttribute("nodeid"));
            if (node) {
              // discard hidden nodes
              if (node.hidden)
                continue;
              var group = domnode._servicePaneGroup;
              if (group) {
                // if the parent group is collapsed, open it and delay selection
                // of the sibling.
                if (!group.visible) {
                  group.visible = true;
                  group._autoCloseOnLeaveKeyboardFocus = true;
                  return -1;
                }
              }
              // discard nodes in collapsed containers
              if (domnode.boxObject.height == 0)
                continue;
            }
            if (oldgroup &&
                group != oldgroup) {
              if (oldgroup._autoCloseOnLeaveKeyboardFocus &&
                  oldgroup.visible)
                oldgroup.visible = false;
            }
            return node;
          }
        ]]></body>
      </method>
      
      <method name="activateAndLoadNode">
        <parameter name="node"/>
        <parameter name="event"/>
        <parameter name="arguments"/>
        <body>
        <![CDATA[
          if (!node)
            return;
          var domnode = this.getDOMNode(node.id);
          if (domnode)
            domnode.loadNodeURL(event, arguments);
        ]]></body>
      </method>

    </implementation>
    
    <handlers>
      <handler event="dragover"><![CDATA[
        this.needScroll(event);
      ]]></handler>

      <handler event="dragdrop"><![CDATA[
        event.stopPropagation();
      ]]></handler>

      <handler event="dragexit"><![CDATA[
        // If we've exited the servicepane, then relatedTarget is null so
        // clear any timers we've got running
        if (this._timer && !event.relatedTarget) {
          this.log("Exited servicepane, canceling auto-expand timer");
          clearTimeout(this._timer);
          this._timer = null;
          if (this._timerGroup) {
            this._timerGroup._expandTimerRunning = null;
            this._timerGroup = null;
          }
        }

        if (this._collapsedGroup && !event.relatedTarget) {
          this._collapsedGroup._collapseOnDragExit = null;
          this._collapsedGroup.visible = false;
          this._collapsedGroup = null;
        }
      ]]></handler>
      
      <handler event="keydown"><![CDATA[
        if (this._editingNode) 
          return;
        const ke = Components.interfaces.nsIDOMKeyEvent;
        switch (event.keyCode) {
          case ke.DOM_VK_RIGHT:
            this._expandKeyboardFocusNode();
            break;
          case ke.DOM_VK_LEFT:
            this._collapseKeyboardFocusNode();
            break;
          case ke.DOM_VK_UP:
            this._keyboardFocusUp();
            break;
          case ke.DOM_VK_DOWN:
            this._keyboardFocusDown();
            break;
          case ke.DOM_VK_RETURN:
            this._openKeyboardFocusNode(event);
            break;
          case ke.DOM_VK_F2:
            this._editKeyboardFocusNode();
            break;
          case ke.DOM_VK_ESCAPE:
            this._leaveKeyboardFocus();
            break;
          case ke.DOM_VK_CONTEXT_MENU:
            this._contextMenuKeyboardFocusNode();
            break;
          // node deletion is handled by the command handler
          default:
            return;
        }
        event.stopPropagation();
        event.preventDefault();
      ]]></handler>
    </handlers>

  </binding>

</bindings>
