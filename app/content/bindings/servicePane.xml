<?xml version="1.0"?>
<!--
/*
 *=BEGIN SONGBIRD GPL
 *
 * This file is part of the Songbird web player.
 *
 * Copyright(c) 2005-2010 POTI, Inc.
 * http://www.songbirdnest.com
 *
 * This file may be licensed under the terms of of the
 * GNU General Public License Version 2 (the ``GPL'').
 *
 * Software distributed under the License is distributed
 * on an ``AS IS'' basis, WITHOUT WARRANTY OF ANY KIND, either
 * express or implied. See the GPL for the specific language
 * governing rights and limitations.
 *
 * You should have received a copy of the GPL along with this
 * program. If not, go to http://www.gnu.org/licenses/gpl.html
 * or write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 *=END SONGBIRD GPL
 */
-->

<!DOCTYPE window SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="servicepane">
    <content>
      <xul:vbox id="sb_servicepane" class="servicepane-outer-box" flex="1">
        <xul:vbox id="sb_servicepane_box" class="servicepane-inner-box" flex="1">
          <xul:vbox id="sb_servicepane_treepane"
                style="-moz-binding:url(#treepane)" flex="1"
                anonid="treepane"
                mousethrough="never"
                xbl:inherits="browser"/>
          <children/>
        </xul:vbox>
        <xul:sb-displaypane-splitter
                collapse="after"
                orient="vertical"
                resizeafter="closest"
                id="displaypane_servicepane_bottom_splitter"
                menuid="displaypane_servicepane_bottom_menu" />
        <xul:sb-displaypane id="displaypane_servicepane_bottom"
                            label="&displaypane.name.servicepane;"
                            splitter="displaypane_servicepane_bottom_splitter"
                            contentgroup="servicepane"/>
      </xul:vbox>
      <!-- menupopup needs to be outside the vbox otherwise it
           gets height adjusted to 0 when the splitter is 
           adjusted -->
      <xul:menupopup id="displaypane_servicepane_bottom_menu"
                     class="menulist-menupopup">
        <xul:sb-displaypane-content-menuitems
                     paneid="displaypane_servicepane_bottom" />
      </xul:menupopup>
    </content>
    <implementation>
      <constructor>
          <![CDATA[
        Components.utils.import("resource://app/jsmodules/DOMUtils.jsm");
        Components.utils.import("resource://app/jsmodules/URLUtils.jsm");

        window.gServicePane = this;
      ]]></constructor>

      <method name="getSelectedNode">
        <body><![CDATA[return this.mTreePane.getSelectedNode();]]></body>
      </method>

      <method name="startEditingNode">
        <parameter name="aNode"/>
        <body><![CDATA[return this.mTreePane.startEditingNode(aNode);]]></body>
      </method>

      <method name="getURLName">
        <parameter name="aURL"/>
        <body><![CDATA[return this.mTreePane.getURLName(aURL);]]></body>
      </method>

      <method name="getURLImage">
        <parameter name="aURL"/>
        <body><![CDATA[return this.mTreePane.getURLImage(aURL);]]></body>
      </method>

      <method name="getURLProperties">
        <parameter name="aURL"/>
        <body><![CDATA[return this.mTreePane.getURLProperties(aURL);]]></body>
      </method>
      
      <property name="open">
        <getter>
        <![CDATA[
          var elId = this.mSplitter.getAttribute("collapseelement");
          return !document.getElementById(elId).collapsed;
        ]]>
        </getter>
        <setter>
        <![CDATA[
          var elId = this.mSplitter.getAttribute("collapseelement");
          var el = document.getElementById(elId);
          el.collapsed = !val;

          SBDataSetBoolValue('splitter.servicepane_splitter.collapsed',
                             el.collapsed);
          // If we are opening the service pane, make sure we highlight the
          // appropriate node.
          if(val) {
            // Is there a servicepane node for the current tab?
            var node = this.mTreePane.browser.selectedTab.servicePaneNode;
            if (node) {
              this.mTreePane.highlightNode(node);
            }
          }
          ]]>
        </setter>
      </property>

      <field name="mTreePane">
        document.getAnonymousElementByAttribute(this, 'anonid', 'treepane');
      </field>
      <field name="mToolbar">
        document.getAnonymousElementByAttribute(this, 'anonid', 'toolbar');
      </field>
      <field name="mSplitter">
        document.getElementById('servicepane_splitter');
      </field>
    </implementation>
   </binding>



  <binding id="treepane">
    <content>
      <xul:tree class="servicepane-tree" anonid="tree" flex="1"
            hidecolumnpicker="true" seltype="single"
            mousethrough="never"
            >
        <!-- hide the column header - is there a better way? -->
        <xul:treecols style="height:0px">
          <xul:treecol primary="true" flex="1"
                 hideheader="true"
                 />
        </xul:treecols>
        <xul:treechildren flex="1"
          ondragdrop="/*hide from default handler*/ event.stopPropagation();"/>
      </xul:tree>
      <xul:popupset>
        <xul:popup anonid="popup"  onpopupshown="onPopupShown(event);" />
      </xul:popupset>
    </content>
    <implementation implements="nsITreeView">
      <constructor><![CDATA[
        // get the tree node
        this.mTree = document.getAnonymousElementByAttribute(this, 'anonid', 'tree');
        // get the popup node
        this.mPopup = document.getAnonymousElementByAttribute(this, 'anonid', 'popup');
        // clear out the old datasources from the tree

        this.mService =
          Components.classes['@songbirdnest.com/servicepane/service;1']
          .getService(Components.interfaces.sbIServicePaneService);

        // If we have a browser, set up listeners to monitor the location
        if (this.browser) {
          let sp = this;

          this._onBrowserTabChangeListener = function(e) {
            sp.onBrowserTabChange(e);
          }
          this.browser.addEventListener("TabContentChange", 
                                    this._onBrowserTabChangeListener, false);
        }

        // Register ourselves as tree view
        this.mTree.view = this;

        // Register mutation listener to update tree when necessary
        this._mutationListener.element = this;
        this.mService.root.addMutationListener(this._mutationListener);
      ]]></constructor>
      <destructor><![CDATA[
        this.mService.onSelectionChanged(null, this.mTree, window);

        // Remove the browser event listener
        if (this.browser) {
          this.browser.removeEventListener("TabContentChange",
            this._onBrowserTabChangeListener, false);
        }

        // Remove mutation listener
        this.mService.root.removeMutationListener(this._mutationListener);
      ]]></destructor>

      <field name="_mutationListener"><![CDATA[
        ({
          element: null,

          hiddenAttributeChanged: function(node, oldVal, newVal) {
            // Default value is "false" - convert any value that isn't "true"
            // to false.
            let oldHidden = (oldVal == "true");
            let newHidden = (newVal == "true");
            if (oldHidden == newHidden)
              return;

            if (newHidden) {
              let row = this.element.getRowForNode(node);
              if (row >= 0)
                this.element._removeChildren(node, row, true);
            }
            else {
              for (let parent = node.parentNode; parent; parent = parent.parentNode)
                if (parent.hidden)
                  return;

              // Find which row to insert this node into (start at the parent
              // and walk down the tree until we find our node). Note that the
              // parent node could be the tree root (getRowForNode returns -1).
              let row = this.element.getRowForNode(node.parentNode) + 1;
              let element = this.element;
              let found = false;
              function findNode(parent) {
                for (let child = parent.firstChild;
                     !found && child;
                     child = child.nextSibling) {
                  if (child == node)
                    found = true;
                  else {
                    if (child.hidden)
                      continue;

                    // The condition below should always be true, check just
                    // in case
                    if (row < element._rows.length && element._rows[row] == child)
                      row++;
                    if (child.isOpen)
                      findNode(child);
                  }
                }
              }
              findNode(node.parentNode);

              this.element._insertChildren(node, row, true);
            }
          },

          isOpenAttributeChanged: function(node, oldVal, newVal) {
            // Default value is "true" - convert any value that isn't "false"
            // to true.
            let oldOpen = (oldVal != "false");
            let newOpen = (newVal != "false");
            if (oldOpen == newOpen || node.hidden)
              return;

            let row = this.element.getRowForNode(node);
            if (row < 0)
              return;

            if (newOpen)
              this.element._insertChildren(node, row, false);
            else
              this.element._removeChildren(node, row, false);
          },

          attrModified: function(node, attrName, namespace, oldVal, newVal) {
            if (attrName == "hidden" && namespace == null) {
              this.hiddenAttributeChanged(node, oldVal, newVal);
            }
            else if (attrName == "isOpen" && namespace == null) {
              this.isOpenAttributeChanged(node, oldVal, newVal);
            }
            else if (!node.hidden) {
              let row = this.element.getRowForNode(node);
              if (row >= 0)
                this.element._treeBoxObject.invalidateRow(row);
            }
          },

          nodeInserted: function(node, parent) {
            if (!node.hidden)
              this.hiddenAttributeChanged(node, "true", "false");
          },

          nodeRemoved: function(node, parent) {
            if (!node.hidden)
              this.hiddenAttributeChanged(node, "false", "true");
          }
        })
      ]]></field>

      <field name="_dragService"><![CDATA[
        Components.classes['@mozilla.org/widget/dragservice;1']
            .getService(Components.interfaces.nsIDragService);
      ]]></field>

      <method name="getURLName">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.name : aURL;
        ]]></body>
      </method>

      <method name="getURLImage">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.image : null;
        ]]></body>
      </method>

      <method name="getURLProperties">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.className : "";
        ]]></body>
      </method>

      <method name="getSelectedNode">
        <body><![CDATA[
          return this.getNodeForRow(this.selection.currentIndex);
        ]]></body>
      </method>

      <!-- Attempt to trigger in-cell editing on the cell
           corresponding to the given sbIServicePaneNode
        -->
      <method name="startEditingNode">
        <parameter name="aNode"/>
        <body><![CDATA[
          aNode.parentNode.isOpen = true;
          // TODO: do we need to scroll to the row?

          // Ensure the node is highlighted and start editing it
          var index = this.getRowForNode(aNode);
          if (index >= 0 && aNode.editable) {
            // Highlight node
            this.highlightNode(aNode);

            // Notify service pane service that the node is about to be renamed
            this.mService.onBeforeRename(aNode);

            // Start editing
            var startedEditing = this.mTree.startEditing(index,
                                                         this.mTree.columns[0]);

            // If editing did not start, notify the service pane service that
            // the rename was canceled by passing null for the new name
            if (!startedEditing)
              this.mService.onRename(aNode, null);

            return startedEditing;
          }
          return false;
        ]]></body>
      </method>

      <method name="getNodeForRow">
        <parameter name="row" />
        <body><![CDATA[
          if (row < 0 || row >= this._rows.length)
            return null;

          return this._rows[row];
        ]]></body>
      </method>

      <method name="getRowForNode">
        <parameter name="node" />
        <body><![CDATA[
          // Cannot use Array.indexOf() here, it won't recognize different
          // wrappers of the same JS object as equal (like === operator)
          for (let i = 0; i < this._rows.length; i++)
            if (this._rows[i] == node)
              return i;

          return -1;
        ]]></body>
      </method>

      <field name="_browser">null</field>
      <property name="browser">
        <getter><![CDATA[
          if (!this._browser) {
            this._browser = document.getElementById(this.getAttribute('browser'));
          }
          return this._browser;
        ]]></getter>
      </property>

      <!-- Highlight/select the row corresponding to the given service node.
           Pass null to clear the selection -->
      <method name="highlightNode">
        <parameter name="aNode" />
        <body><![CDATA[
          // we only want to allow highlighting if we aren't currently editing.
          if (this.mTree.hasAttribute("editing")) {
            return;
          }

          if (aNode) {
            var row = this.getRowForNode(aNode);
            if (row >= 0) {
              this.selection.select(row);
            } else {
              this.selection.clearSelection();
            }
          } else {
            this.selection.clearSelection();
          }
        ]]></body>
      </method>


      
      <!-- Called when the content of the current browser tab is changed.
           This occurs when the user swiches tabs, or loads an new page 
           in the existing tab.  Note that on page load this method is called
           both at load start and at load complete. -->
      <method name="onBrowserTabChange">
        <body><![CDATA[
          this._highlightSelectedNode();
        ]]></body>
      </method>

      <method name="onPopupShown">
        <parameter name="event" />
        <body>
          <![CDATA[
          var gotstuff = false;
          for (var i=0;i<this.mPopup.childNodes.length;i++) {
            var e = this.mPopup.childNodes[i];
            if (e.hidden) continue;
            gotstuff = true;
          }
          if (!gotstuff)
            this.mPopup.hidePopup();
          ]]>
        </body>
      </method>
      <method name="selectAndLoadNode">
        <parameter name="node"/>
        <parameter name="event"/>
        <parameter name="arguments"/>
        <body><![CDATA[
          this.highlightNode(node);  // also unhighlights other nodes
          this.loadNode(node, event, arguments);
        ]]></body>
      </method>
      <method name="loadSelectedNode">
        <parameter name="event"/>
        <parameter name="arguments"/>
        <body><![CDATA[
          var node = this.getNodeForRow(this.selection.currentIndex);
          if (node) {
            this.loadNode(node, event, arguments);
          }
        ]]></body>
      </method>
      <method name="isLoadableNode">
        <parameter name="node"/>
        <body><![CDATA[
          if (node.url)
            return true;
          var libraryServicePane = 
            Components.classes['@songbirdnest.com/servicepane/library;1']
            .getService(Components.interfaces.sbILibraryServicePaneService);
          var mediaList = libraryServicePane.getLibraryResourceForNode(node);
          if (mediaList)
            return true;
          var SP_NS = "http://songbirdnest.com/rdf/servicepane#";
          var eventType = node.getAttributeNS(SP_NS, "eventType");
          if (eventType)
            return true;
          return false;
        ]]></body>
      </method>
      <method name="loadNode">
        <parameter name="node"/>
        <parameter name="event"/>
        <parameter name="arguments"/>
        <body><![CDATA[
          // If this node has a URL, just load it in the browser
          if (node.url) {
            var target = null;
            if (LibraryUtils.isMediaTabURL(node.url, this.browser)) {
              target = "_media";
              this.browser.selectedTab = this.browser.mediaTab;
            } else if (event.button == 1) {
              // Middle click.
              target = "_blank";
            }

            var url = node.url;
            if (arguments)
              url = URLUtils.addQuery(url, arguments);
            this.browser.loadURI(url, null, null, event, target);
          // If no URL, apply special handling
          } else {
            // If there is a media list for this node, hand it off to the 
            // browser to display somehow.
            // I'm told that this hack is fine, as it will one day be replaced
            // with the playlist commands system.
            var libraryServicePane = 
              Components.classes['@songbirdnest.com/servicepane/library;1']
              .getService(Components.interfaces.sbILibraryServicePaneService);
            var mediaList = libraryServicePane.getLibraryResourceForNode(node);
            if (mediaList) {
              const NS_SP = "http://songbirdnest.com/rdf/servicepane#";
              var view = LibraryUtils.createStandardMediaListView(mediaList);
              if (node.hasAttributeNS(NS_SP, "mediaListViewConstraints")) {
                // set up the constraints
                var builder = Cc["@songbirdnest.com/Songbird/Library/ConstraintBuilder;1"]
                                .createInstance(Ci.sbILibraryConstraintBuilder);
                try {
                  builder.parseFromString(node.getAttributeNS(NS_SP,
                                                              "mediaListViewConstraints"));
                  view.filterConstraint = builder.get();
                } catch (e) {
                  // boo, the constraints are bad, use standard instead
                  view.filterConstraint = LibraryUtils.standardFilterConstraint;
                }
              }
              var tab = this.browser.loadMediaList(mediaList,
                                                   event,
                                                   "_media",
                                                   view);
              this.browser.selectedTab = tab;

              // Record list type metrics for some reason.
              // See http://bugzilla.songbirdnest.com/show_bug.cgi?id=4021
              // changed to loadNode from click as there are ways other than clicking
              // to get here.
              try {
                var listType = mediaList.getProperty(SBProperties.customType);
                var libType = mediaList.library.getProperty(SBProperties.customType);
                metrics_inc("app.servicepane.loadnode.medialist", libType + "." + listType, null);
              } catch(e) { Components.utils.reportError(e); }

            } else {
              // we have no handler for this service pane node load
              // dispatch an event people can listen for and don't report
              let event = document.createEvent("XULCommandEvent");
              event.QueryInterface(Components.interfaces.nsIDOMXULCommandEvent);
              event.initCommandEvent("servicepane-loadnode",
                                     event.bubble,
                                     false,
                                     event.view,
                                     event.detail,
                                     event.ctrlKey,
                                     event.altKey,
                                     event.shiftKey,
                                     event.metaKey,
                                     event);
              this.dispatchEvent(event);
              
              var SP_NS = "http://songbirdnest.com/rdf/servicepane#";
              var eventType = node.getAttributeNS(SP_NS, "eventType");
              if (eventType) {
                let event = document.createEvent("UIEvent");
                event.initUIEvent(eventType, true, true, window, 0);
                window.dispatchEvent(event);
              }
            }
          }
        ]]></body>
      </method>
      <!-- context menu helper -->
      <method name="_onContextMenu">
        <parameter name="event" />
        <body><![CDATA[
          // work out what tree node was clicked on
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX, event.clientY,
                             row, col, obj);

          // clear the popup menu
          while (this.mPopup.lastChild) {
            DOMUtils.destroyNode(this.mPopup.lastChild);
            this.mPopup.removeChild(this.mPopup.lastChild);
          }

          var node = this.getNodeForRow(row.value);
          if (node) {
            // ask the service to fill in the popup for this node
            this.mService.fillContextMenu(node, this.mPopup, window);
          } else {
            // hmm, fill the popup with the contents of the "new stuff" menu
            this.mService.fillNewItemMenu(null, this.mPopup, window);
          }

          // show the popup menu
          document.popupNode = null;
          this.mPopup.showPopup(document.documentElement,
                      event.screenX+5, event.screenY,
                      'context', null, null, null);

          // ensure the node is highlighted last to prevent select from being
          // fired before pop up is shown.
          if (node) {
            this.highlightNode(node);
          }

          event.stopPropagation();
          event.preventDefault();
        ]]></body>
      </method>
      <!-- enter/return keypress helper -->
      <method name="_onEnterKeypress">
        <parameter name="event"/>
        <body><![CDATA[
          if (this.mTree.hasAttribute("editing")) {
            var row = this.mTree._editingRow;
            var node = this.getNodeForRow(row);
            
            this.mTree.stopEditing(true);
   
            // Reselect and load the node since we'll lose
            // the selection when the tree rebuilds.
            this.selectAndLoadNode(node, event);
            this.mTree.focus();
            
            event.preventDefault();
            event.stopPropagation();
            return;
          }

          this.loadSelectedNode(event);
          event.preventDefault();
          event.stopPropagation();
        ]]></body>
      </method>
      <!-- drag-and-drop helpers -->
      <method name="_onDragGesture">
        <parameter name="event"/>
        <parameter name="node"/>
        <body>
          <![CDATA[
          var transferable = {};
          if (node && this.mService.onDragGesture(node, transferable)) {
            transferable = transferable.value;
            var transArray = Components.classes["@mozilla.org/supports-array;1"]
                                       .createInstance(Components.interfaces.nsISupportsArray);
            transArray.AppendElement(transferable);
            
            // Oh Lordy lordy, I'm so glad I could just steal this from 
            // nsDragAndDrop.js instead of having to write it myself.
            var region = null;
            if (event.originalTarget.localName == "treechildren") {
              // let's build the drag region
              var tree = event.originalTarget.parentNode;
              try {
                region = Cc["@mozilla.org/gfx/region;1"]
                          .createInstance(Ci.nsIScriptableRegion);
                region.init();
  
                var obo = tree.treeBoxObject;
                var bo = obo.treeBody.boxObject;
                var sel= obo.view.selection;
  
                region.unionRect(bo.x, (obo.rowHeight * sel.currentIndex + bo.y),
                                 bo.width, obo.rowHeight);
  
                //and finally, clip the result to be sure we don't spill over...
                region.intersectRect(bo.x, bo.y, bo.width, bo.height);
  
              } catch(ex) {
                dump("Error while building selection region: " + ex + "\n");
                region = null;
              }
            }
            
            var dragAction = this._dragService.DRAGDROP_ACTION_COPY +
                             this._dragService.DRAGDROP_ACTION_MOVE;
            this._dragService.invokeDragSessionWithImage(event.target, transArray,
                region, dragAction,
                null, 0, 0,
                event);
            
            event.preventDefault();
          }
        ]]>
        </body>
      </method>

      <!-- to trigger selection highlighting -->
      <method name="_highlightSelectedNode">
        <body>
          <![CDATA[
          try {
            // Is there a servicepane node for the current tab?
            var node = this._browser.selectedTab.servicePaneNode;
          
            if (node) {
              this.highlightNode(node);
            }
          } catch (e) {
            Components.utils.reportError(e); 
          }
        ]]>
        </body>
      </method>

      <!-- nsITreeView -->
      <field name="_treeBoxObject">null</field>
      <field name="_rows">null</field>

      <method name="_addChildRows">
        <parameter name="array"/>
        <parameter name="parent"/>
        <body><![CDATA[
          for (let child = parent.firstChild; child; child = child.nextSibling) {
            if (child.hidden)
              continue;

            array.push(child);
            if (child.isOpen)
              this._addChildRows(array, child);
          }
        ]]></body>
      </method>

      <method name="_removeChildren">
        <parameter name="parent"/>
        <parameter name="row"/>
        <parameter name="removeParent"/>
        <body><![CDATA[
          let startIndex = (removeParent ? row : row + 1);
          let endIndex = row + 1;

          function isChild(node) {
            while (node) {
              if (node == parent)
                return true;

              node = node.parentNode;
            }
            return false;
          }

          while (endIndex < this._rows.length && isChild(this._rows[endIndex]))
            endIndex++;

          let count = endIndex - startIndex;
          this._rows.splice(startIndex, count);
          this._treeBoxObject.rowCountChanged(startIndex, -count);

          if (!removeParent)
            this._treeBoxObject.invalidateRow(row);
        ]]></body>
      </method>

      <method name="_insertChildren">
        <parameter name="parent"/>
        <parameter name="row"/>
        <parameter name="insertParent"/>
        <body><![CDATA[
          let startIndex = (insertParent ? row : row + 1);
          let children = [];
          if (insertParent)
            children.push(parent);
          this._addChildRows(children, parent);

          this._rows.splice.apply(this._rows, [startIndex, 0].concat(children));
          this._treeBoxObject.rowCountChanged(startIndex, children.length);

          if (insertParent) {
            // Update parent row just in case it became a container now
            this._treeBoxObject.invalidateRow(this.getRowForNode(parent.parentNode));
          }
          else {
            this._treeBoxObject.invalidateRow(row);
          }
        ]]></body>
      </method>

      <field name="_atomService">
        Components.classes["@mozilla.org/atom-service;1"]
                  .getService(Components.interfaces.nsIAtomService);
      </field>
      <field name="_atoms">({__proto__: null})</field>
      <method name="_getAtom">
        <parameter name="atom"/>
        <body><![CDATA[
          if (!(atom in this._atoms))
            this._atoms[atom] = this._atomService.getAtom(atom);

          return this._atoms[atom];
        ]]></body>
      </method>

      <field name="selection">null</field>
      <property name="rowCount" onget="return this._rows.length;"/>

      <method name="setTree">
        <parameter name="treeBoxObject"/>
        <body><![CDATA[
          this._treeBoxObject = treeBoxObject;
          this._rows = [];
          this._addChildRows(this._rows, this.mService.root);
          this._highlightSelectedNode();
        ]]></body>
      </method>

      <method name="getRowProperties">
        <parameter name="row"/>
        <parameter name="array"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          if (!node || !node.className)
            return;

          for each (let property in node.className.split(/\s+/)) {
            array.AppendElement(this._getAtom(property));
          }
        ]]></body>
      </method>
      <method name="getCellProperties">
        <parameter name="row"/>
        <parameter name="col"/>
        <parameter name="array"/>
        <body><![CDATA[
          this.getRowProperties(row, array);
        ]]></body>
      </method>

      <method name="isContainer">
        <parameter name="row"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          let child = (node ? node.firstChild : null);
          while (child && child.hidden)
            child = child.nextSibling;
          return !!child;
        ]]></body>
      </method>

      <method name="isContainerOpen">
        <parameter name="row"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          return node && node.isOpen;
        ]]></body>
      </method>

      <method name="canDrop">
        <parameter name="row"/>
        <parameter name="orientation"/>
        <parameter name="dataTransfer"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          return node && this.mService.canDrop(node,
                                        this._dragService.getCurrentSession(),
                                        orientation, window);
        ]]></body>
      </method>

      <method name="drop">
        <parameter name="row"/>
        <parameter name="orientation"/>
        <parameter name="dataTransfer"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          if (node) {
            this.mService.onDrop(node,
                                 this._dragService.getCurrentSession(),
                                 orientation, window);
          }
        ]]></body>
      </method>

      <method name="getParentIndex">
        <parameter name="row"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          return (node ? this.getRowForNode(node.parentNode) : -1);
        ]]></body>
      </method>

      <method name="hasNextSibling">
        <parameter name="row"/>
        <parameter name="afterRow"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          let sibling = (node ? node.nextSibling : null);
          while (sibling && sibling.hidden)
            sibling = sibling.nextSibling;
          return !!sibling;
        ]]></body>
      </method>

      <method name="getLevel">
        <parameter name="row"/>
        <body><![CDATA[
          // The result should always be non-negative because we will get at
          // least two iterations of the loop. We will only return -2 for an
          // invalid row number (node is null) and -1 if node is tree root
          // (this should never happen).
          let node = this.getNodeForRow(row);
          let level = -2;
          while (node) {
            node = node.parentNode;
            level++;
          }
          return level;
        ]]></body>
      </method>

      <method name="getImageSrc">
        <parameter name="row"/>
        <parameter name="col"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          return (node ? node.image : null);
        ]]></body>
      </method>

      <method name="getCellText">
        <parameter name="row"/>
        <parameter name="col"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          return (node ? node.displayName : null);
        ]]></body>
      </method>

      <method name="toggleOpenState">
        <parameter name="row"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          if (!node || !node.firstChild)
            return;

          node.isOpen = !node.isOpen;
        ]]></body>
      </method>

      <method name="selectionChanged">
        <body><![CDATA[
          let node = this.getNodeForRow(this.selection.currentIndex);
  
          // ask the service to notify the modules about selection changes
          this.mService.onSelectionChanged(node, this.mTree, window);
        ]]></body>
      </method>

      <method name="isEditable">
        <parameter name="row"/>
        <parameter name="col"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          return node && node.editable;
        ]]></body>
      </method>

      <method name="setCellText">
        <parameter name="row"/>
        <parameter name="col"/>
        <parameter name="value"/>
        <body><![CDATA[
          let node = this.getNodeForRow(row);
          if (node)
            this.mService.onRename(node, value);
        ]]></body>
      </method>

      <method name="getColumnProperties"><body/></method>
      <method name="isContainerEmpty"><body>return false;</body></method>
      <method name="isSeparator"><body>return false;</body></method>
      <method name="isSorted"><body>return false;</body></method>
      <method name="getProgressMode"><body>
        return Components.interfaces.nsITreeView.PROGRESS_NONE;</body></method>
      <method name="cycleHeader"><body/></method>
      <method name="cycleCell"><body/></method>
      <method name="isSelectable"><body>return true;</body></method>
      <method name="setCellValue"><body/></method>
      <method name="performAction"><body/></method>
      <method name="performActionOnRow"><body/></method>
      <method name="performActionOnCell"><body/></method>
    </implementation>
    <handlers>
      <handler event="contextmenu"><![CDATA[
        if (this.mTree.hasAttribute("editing")) {
          this.mTree.stopEditing(true);
        }

        this._onContextMenu(event);
      ]]></handler>
      <handler event="keypress" keycode="VK_ENTER" phase="capturing"><![CDATA[
        this._onEnterKeypress(event);
      ]]> </handler>
      <handler event="keypress" keycode="VK_RETURN" phase="capturing"><![CDATA[
        this._onEnterKeypress(event);
      ]]></handler>
      <handler event="mousedown" clickcount="1" button="0" phase="capturing"><![CDATA[
        // If the user is clicking on a non-loadable node in the servicepane
        // then suppress the event, otherwise let it pass through
        if (event.originalTarget.localName == "treechildren") {
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX,
                                             event.clientY,
                                             row,
                                             col,
                                             obj);
          
          if ((obj.value != 'twisty') && (row.value >= 0)) {
            var node = this.getNodeForRow(row.value);
            if (!node || !this.isLoadableNode(node)) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      ]]></handler>
      <handler event="click" clickcount="1" button="0" phase="capturing"><![CDATA[
        if (event.originalTarget.localName == "treechildren") {
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX,
                                             event.clientY,
                                             row,
                                             col,
                                             obj);

          if ((obj.value != 'twisty') && (row.value >= 0)) {
            var node = this.getNodeForRow(row.value);
            if (node) {
              if (this.isLoadableNode(node)) {
                this.selectAndLoadNode(node, event);
              }
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }        
      ]]></handler>
      <handler event="click" clickcount="1" button="1" phase="capturing"><![CDATA[
        if (event.originalTarget.localName == "treechildren") {
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX,
                                             event.clientY,
                                             row,
                                             col,
                                             obj);

          if ((obj.value != 'twisty') && (row.value >= 0)) {
            var node = this.getNodeForRow(row.value);
            if (node) {
              this.selectAndLoadNode(node, event);
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }        
      ]]></handler>
      <handler event="mousedown" clickcount="1" button="2" phase="capturing"><![CDATA[
        // we have to suppress this event to avoid unwanted 'select' events
        // being fired from the base binding.
        event.preventDefault();
        event.stopPropagation();
      ]]></handler>
      <handler event="click" clickcount="1" button="2"><![CDATA[
        if (this.mTree.hasAttribute("editing")) {
          this.mTree.stopEditing(true);
        }

        this._onContextMenu(event);
      ]]></handler>
      <handler event="click" clickcount="2" button="0"><![CDATA[
        if (event.originalTarget.localName == "treechildren") {
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX,
                                             event.clientY,
                                             row,
                                             col,
                                             obj);

          // ensure the node that was clicked is selected and loaded and is the
          // one to be edited
          if ((obj.value != 'twisty') && (row.value >= 0)) {
            var node = this.getNodeForRow(row.value);
            if (node) {
              if (this.isLoadableNode(node)) {
                // Since we'll be manually selecting in this case
                // we have to suppress the 'select' event.
                this.selection.selectEventsSuppressed = true;
                this.selectAndLoadNode(node, event);
                this.selection.selectEventsSuppressed = false;
              } else if (this.isContainer(row.value)) {
                node.isOpen = !node.isOpen;
              }

              if (node.editable)
                this.startEditingNode(node);

              event.preventDefault();
            }
          }
        }
      ]]></handler>

      <!-- drag and drop handling -->
      <handler event="draggesture"><![CDATA[
        // don't allow drag gestures with the popup menu open.
        if(this.mPopup.state != "closed") {
          return;
        }
        var row = { }
        var col = { }
        var child = { }
        this.mTree.treeBoxObject.getCellAt(event.pageX, event.pageY, row, col, child);
        if (col.value == null) {
          // not a valid column; e.g., the scrollbar
          return;
        }
        var node = this.getNodeForRow(row.value);
        
        this._onDragGesture(event, node);
      ]]></handler>
    </handlers>
  </binding>


  <binding id="toolbar">
    <content>
      <!-- Service Pane Button Bar, Buttons for adding a new service or playlist-->
      <!-- For now just hijacking the file menu implementation.. -->
      <!-- TODO: over state, up arrow, remove periods from all IDs -->
      <xul:hbox id="servicepane_toolbar_box" class="servicepane-toolbar-box">
        <xul:button class="servicepane-toolbar-newitem-button"
                    tooltiptext="&tooltip.servicepane.newnode;"
                    anonid="clickhold" flex="1" type="sb-clickhold">
          <xul:menupopup anonid="popup" popupanchor="topleft" popupalign="bottomleft"/>
        </xul:button>
      </xul:hbox>
    </content>
    <implementation>
      <constructor><![CDATA[
        var service = Components.classes['@songbirdnest.com/servicepane/service;1']
          .getService(Components.interfaces.sbIServicePaneService);
        this._service = service;
        
        this._dragService = Cc['@mozilla.org/widget/dragservice;1']
                            .getService(Ci.nsIDragService);
        
        
        this._clickHold = document.getAnonymousElementByAttribute(this, 'anonid', 'clickhold');
        this._popup     = document.getAnonymousElementByAttribute(this, 'anonid', 'popup');
        
        service.fillNewItemMenu(null, this._popup, window);
        
        // Make the button look like the first item in the list.
        var item = this._popup.firstChild;
        if (!item) {
          /* bad news */
          return;
        }
        
        this._clickHold.setAttribute('label', item.getAttribute('label'));
        // FIXME: this is needed for styling but sucks
        this._clickHold.setAttribute('id', item.getAttribute('id'));

      ]]></constructor>
      <field name="_clickHold">null</field>
    </implementation>
    <handlers>
      <handler event="command"><![CDATA[
        /**
         * NOTE: _DO NOT_ copy this code.  If you find that this is useful
         * elsewhere, _move_ this to some place generic and can be reused.
         */

        if (event.originalTarget.parentNode == this._popup) {
          // the event was heading for a menu item
          return;
        }
        // this wasn't heading to any of our children - let's find the best fit
        // defined as the first menu item with all of the specified modifiers
        // pressed with the greatest number of modifiers given
        var modifiers = {"": true};
        if (event.altKey)
          modifiers["alt"] = true;
        if (event.shiftKey)
          modifiers["shift"] = true;
        if (event.ctrlKey)
          modifiers["ctrl"] = true;
        if (event.metaKey)
          modifiers["meta"] = true;

        var kKeyCodeToName = {};
        kKeyCodeToName[KeyEvent.DOM_VK_CONTROL] = "ctrl";
        kKeyCodeToName[KeyEvent.DOM_VK_ALT] = "alt";
        kKeyCodeToName[KeyEvent.DOM_VK_SHIFT] = "shift";
        kKeyCodeToName[KeyEvent.DOM_VK_META] = "meta";

        var accelKey = Application.prefs.getValue("ui.key.accelKey", -1);
        if (kKeyCodeToName[accelKey] in modifiers) {
          modifiers["accel"] = true;
        }
        var accessKey = Application.prefs.getValue("ui.key.chromeAccess", -1);
        if (accessKey == -1) {
          accessKey = Application.prefs.getValue("ui.key.generalAccessKey", -1);
        }
        if (accessKey in kKeyCodeToName &&
            kKeyCodeToName[accessKey] in modifiers)
        {
          modifiers["access"] = true;
        }
        
        // modifiers is now a set of modifiers that have been pressed.
        // now keep an array of matched popups; the index is the number of matching
        // modifier keys, and the value is the first menupopup to match
        var matches = [];
        
        for (var popup = this._popup.firstChild; popup; popup = popup.nextSibling) {
          var matchCount = 0;
          for each (var modifier in popup.getAttribute("modifiers").split(/\s+/)) {
            if (!(modifier in modifiers)) {
              // this modifier is not pressed
              matchCount = Number.NEGATIVE_INFINITY;
              break;
            } else if ("" != modifier) {
              ++matchCount;
            }
          }
          if (matchCount >= 0 && !(matchCount in matches)) {
            matches[matchCount] = popup;
          }
        }
        
        var selectedPopup = matches[matches.length - 1];
        if (selectedPopup) {
          var newEvent = document.createEvent("XULCommandEvent");
          newEvent.initCommandEvent(event.type, event.bubbles, event.cancelable,
                                    event.view, event.detail, event.ctrlKey,
                                    event.altKey, event.shiftKey, event.metaKey,
                                    (event.sourceEvent || event));
          return selectedPopup.dispatchEvent(newEvent);
        }
      ]]></handler>
      <handler event="dragenter"><![CDATA[
        var session = this._dragService.getCurrentSession();
        
        var supported = DNDUtils.isSupported(session,
          ["application/x-sb-transfer-media-list",
           "application/x-sb-transfer-media-items"]);
        if (supported) {
          var element = this._clickHold;
          this._dragService.canDrop = true;
          element.setAttribute("dropon", "true");

          // we handle the drop, do not let the default dnd handler get the event
          event.stopPropagation();
        }
      ]]></handler>
      <handler event="dragexit"><![CDATA[
        var element = this._clickHold;
        element.removeAttribute("dropon");

        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
      <handler event="dragdrop"><![CDATA[
  try {
    var element = event.target;
    
    var session = this._dragService.getCurrentSession();
    
    // Note that this is called by our tree observer
    var dnd = Cc["@songbirdnest.com/Songbird/DndSourceTracker;1"]
                .getService(Ci.sbIDndSourceTracker);
  
    // handle mediaitem drops
    var data = DNDUtils.getTransferDataForFlavour("application/x-sb-transfer-media-list",
                                              session);
    if (data) {
      var context = dnd.getSourceSupports(data)
                       .QueryInterface(Ci.sbIMediaListTransferContext);
      
      var mediaList = SBNewPlaylist();
      mediaList.addAll(context.list);

      event.stopPropagation();
      return;
    }
  
    data = DNDUtils.getTransferDataForFlavour("application/x-sb-transfer-media-items",
                                              session);
    if (data) {
      var context = dnd.getSourceSupports(data)
                       .QueryInterface(Ci.sbIMediaItemsTransferContext);

      var mediaList = SBNewPlaylist();
      mediaList.addSome(context.items);

      event.stopPropagation();
      return;
    }

    // handle external drops
    var dropHandlerListener = {
      onDropComplete: function(aTargetList,
                               aImportedInLibrary,
                               aDuplicates,
                               aInsertedInMediaList,
                               aOtherDropsHandled) { 
        // show the standard report on the status bar
        return true;
      },
      onFirstMediaItem: function(aTargetList, aFirstMediaItem) {}
    };

    var mediaList = SBNewPlaylist();
    var position = 0;
    ExternalDropHandler.dropOnList(window, 
                                   session, 
                                   mediaList, 
                                   position, 
                                   dropHandlerListener);
    
    event.stopPropagation();
  } catch(e) { Components.utils.reportError(e); }
      ]]></handler>
    </handlers>
  </binding>

</bindings>
