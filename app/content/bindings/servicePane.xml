<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
//
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2008 POTI, Inc.
// http://songbirdnest.com
//
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
//
// Software distributed under the License is distributed
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either
// express or implied. See the GPL for the specific language
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
//
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE window SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="servicepane">
    <content>
      <xul:vbox id="sb_servicepane" class="servicepane-outer-box" flex="1">
        <xul:vbox id="sb_servicepane_box" class="servicepane-inner-box" flex="1">
          <xul:vbox id="sb_servicepane_treepane"
                style="-moz-binding:url(#treepane)" flex="1"
                anonid="treepane"
                mousethrough="never"
                xbl:inherits="browser"/>
          <children/>
        </xul:vbox>
        <xul:sb-smart-splitter collapse="after" orient="vertical" resizeafter="closest"
                               id="displaypane_servicepane_bottom_splitter">
          <xul:grippy/>
        </xul:sb-smart-splitter>
        <xul:sb-displaypane id="displaypane_servicepane_bottom"
                            label="&displaypane.name.servicepane;"
                            splitter="displaypane_servicepane_bottom_splitter"
                            contentgroup="servicepane"/>
      </xul:vbox>
    </content>
    <implementation>
      <constructor>
          <![CDATA[
        Components.utils.import("resource://app/jsmodules/DOMUtils.jsm");

        window.gServicePane = this;
      ]]></constructor>

      <method name="getSelectedNode">
        <body><![CDATA[return this.mTreePane.getSelectedNode();]]></body>
      </method>

      <method name="startEditingNode">
        <parameter name="aNode"/>
        <body><![CDATA[return this.mTreePane.startEditingNode(aNode);]]></body>
      </method>

      <method name="getURLName">
        <parameter name="aURL"/>
        <body><![CDATA[return this.mTreePane.getURLName(aURL);]]></body>
      </method>

      <method name="getURLImage">
        <parameter name="aURL"/>
        <body><![CDATA[return this.mTreePane.getURLImage(aURL);]]></body>
      </method>

      <method name="getURLProperties">
        <parameter name="aURL"/>
        <body><![CDATA[return this.mTreePane.getURLProperties(aURL);]]></body>
      </method>
      
      <method name="initSpringLoadPanel">
        <parameter name="aPanel"/>
        <body><![CDATA[
          setTimeout(function(){
            var tree = document.getAnonymousElementByAttribute(
                         aPanel.firstChild,
                         "anonid", "proxytree");
            if (tree.view)
              tree.view.selection.clearSelection();
  
            while (tree.database.GetDataSources().hasMoreElements()) {
              tree.database.RemoveDataSource(
                  tree.database.GetDataSources().getNext());
            }
    
            var service = Components.classes['@songbirdnest.com/servicepane/service;1']
                                    .getService(Components.interfaces.sbIServicePaneService);
            // add the datasource from the service
            tree.database.AddDataSource(service.dataSource);
            tree.ref = service.root.id;
    
            // and force a rebuild
            tree.builder.rebuild();
          }, 0);
        ]]></body>
      </method>
      
      <method name="onProxyClick">
        <!-- the spring-loaded copy of the tree was clicked on -->
        <parameter name="event"/>
        <body><![CDATA[
          var proxyTree = event.target;
          while (proxyTree && !(proxyTree instanceof Components.interfaces.nsIDOMXULTreeElement))
            proxyTree = proxyTree.parentNode;
          var row = {}, col = {}, obj = {};
          // need to manually find the node, because the real tree may have
          // collapsed rows
          proxyTree.boxObject.getCellAt(event.clientX, event.clientY, row, col, obj);
          if ((obj.value == 'twisty') || (row.value < 0)) {
            return;
          }
          var elem = proxyTree.view.getItemAtIndex(row.value);
          var nodeid = elem.getAttribute("nodeid");
          if (nodeid) {
            var node = this.mTreePane.mService.getNode(nodeid);
            this.mTreePane.loadNode(node, event);
          }
          var panel = document.getElementById("service_pane_spring_load_panel");
          panel.hidePopup();
        ]]></body>
      </method>
      
      <property name="open">
        <getter>
          if (this.mSplitter) {
            return this.mSplitter.getAttribute("state") == "open";
          } else {
            return this.boxObject.width > 0;
          }
        </getter>
        <setter>
          if (this.mSplitter) {
            this.mSplitter.setAttribute("state", val ? "open" : "collapsed");
          } else {
            this.collapsed = val;
          }
        </setter>
      </property>

      <field name="doneInit">false</field>
      
      <field name="mTreePane">
        document.getAnonymousElementByAttribute(this, 'anonid', 'treepane');
      </field>
      <field name="mToolbar">
        document.getAnonymousElementByAttribute(this, 'anonid', 'toolbar');
      </field>
      <field name="mSplitter">
        document.getElementById('servicepane_splitter');
      </field>
    </implementation>
   </binding>



  <binding id="treepane">
    <content>
      <xul:tree class="servicepane-tree" anonid="tree" flex="1"
            datasources="rdf:null" ref="SB:Root"
            hidecolumnpicker="true" seltype="single"
            mousethrough="never"
            >
        <!-- hide the column header - is there a better way? -->
        <xul:treecols style="height:0px">
          <xul:treecol primary="true" flex="1"
                 hideheader="true"
                 />
        </xul:treecols>
        <xul:template>
          <xul:rule>
            <xul:conditions>
              <xul:content uri="?start" />
              <xul:member container="?start" child="?node" />
              <xul:triple subject="?node"
                    predicate="http://home.netscape.com/NC-rdf#Name"
                    object="?name" />
              <xul:triple subject="?node"
                    predicate="http://songbirdnest.com/rdf/servicepane#Hidden"
                    object="false" />
            </xul:conditions>
            <xul:bindings>
              <xul:binding subject="?node"
                     predicate="http://home.netscape.com/NC-rdf#Icon"
                     object="?icon" />
              <xul:binding subject="?node"
                     predicate="http://songbirdnest.com/rdf/servicepane#Open"
                     object="?open" />
              <xul:binding subject="?node"
                     predicate="http://songbirdnest.com/rdf/servicepane#Properties"
                     object="?properties" />
            </xul:bindings>
            <xul:action>
              <xul:treechildren flex="1" properties="dropOn">
                <xul:treeitem open="?open" uri="?node" nodeid="?node">
                  <xul:treerow>
                    <xul:treecell label="?name" src="?icon" properties="?properties"/>
                  </xul:treerow>
                </xul:treeitem>
              </xul:treechildren>
            </xul:action>
          </xul:rule>
        </xul:template>
      </xul:tree>
      <xul:popupset>
        <xul:popup anonid="popup"  onpopupshown="onPopupShown(event);" />
      </xul:popupset>
    </content>
    <implementation>
      <constructor>
            <![CDATA[
        // get the tree node
        this.mTree = document.getAnonymousElementByAttribute(this, 'anonid', 'tree');
        // get the popup node
        this.mPopup = document.getAnonymousElementByAttribute(this, 'anonid', 'popup');
        // clear out the old datasources from the tree

        this.mService =
          Components.classes['@songbirdnest.com/servicepane/service;1']
          .getService(Components.interfaces.sbIServicePaneService);
        this.mService.init();

        while (this.mTree.database.GetDataSources().hasMoreElements()) {
          this.mTree.database.RemoveDataSource(
              this.mTree.database.GetDataSources().getNext());
        }

        // add the datasource from the service
        this.mTree.database.AddDataSource(this.mService.dataSource);
        this.mTree.ref = this.mService.root.id;

        // and force a rebuild
        this.mTree.builder.rebuild();

        var sp = this;
        // this is evil. really. i feel guilty.
        // let's replace the tree's stopEditing function with our own
        // that actually saves off the data
        this.mTree._stopEditing = this.mTree.stopEditing;
        this.mTree.stopEditing = function evilStopEditing(accept) {
          /* debugging output - really useful for debugging:
          dump('accept: '+accept+'\n');
          dump('this._editingColumn: '+this._editingColumn+'\n');
          dump('this._editingRow: '+this._editingRow+'\n');
          dump('this.inputField.value: '+this.inputField.value+'\n');
          dump('this.inputField.hidden: '+this.inputField.hidden+'\n');
          dump('this.hasAttribute("editing"): '+this.hasAttribute("editing")+'\n');
          */

          if (!this._editingColumn)
            return;

          var node = null;
          var newName = null;

          if (accept && this._editingRow != -1 &&
              this._editingColumn && !this.inputField.hidden &&
              this.hasAttribute('editing')) {
            node = sp.getNodeForRow(this._editingRow);
            newName = this.inputField.value;
          }

          // Always set accept to false, since we leave it
          // up to the service pane service to determine
          // what changes
          this._stopEditing(false);

          // Give the new name to the service pane.
          if (node) {
            sp.mService.onRename(node.id, newName);
          }

          // Now try to highlight the current node as per onBrowserTabChange
          try {
            var url = sp._browser.currentURI.spec;

            // Is there a servicepane node for the current tab?
            var node = sp._browser.selectedTab.servicePaneNode;

            if (node) {
              sp.highlightNode(node);
            }
          } catch (e) {
            Components.utils.reportError(e);
          }
        }

        // If we have a browser, set up listeners to monitor the location
        if (sp.browser) {
          this._onBrowserTabChangeListener = function(e) {
            sp.onBrowserTabChange(e);
          }
          function windowOnLoad() {
            sp.browser.addEventListener("TabContentChange", 
                  sp._onBrowserTabChangeListener, false);

            gServicePane.doneInit = true;
            window.removeEventListener('load', windowOnLoad, false);
          }
          window.addEventListener('load', windowOnLoad, false);
        }

        // xbl slight of hand
        this.mTree._changeOpenState = this.mTree.changeOpenState;
        this.mTree.changeOpenState = function (row, openState) {
          this._changeOpenState(row, openState);
          sp.getNodeForRow(row).isOpen = sp.mTree.view.isContainerOpen(row);
        }

        // Namespace for BookmarksServicePaneService attributes.
        this.BSP = 'http://songbirdnest.com/rdf/bookmarks#';

      ]]></constructor>
      <destructor><![CDATA[
        this.mService.onSelectionChanged(null, this.mTree, window);

        // Remove the browser event listener
        if (this.browser) {
          this.browser.removeEventListener("TabContentChange",
            this._onBrowserTabChangeListener, false);
        }

        this.mTree.stopEditing = this.mTree._stopEditing;
        this.mTree._stopEditing = null;

        this.mTree.changeOpenState = this.mTree._changeOpenState;
        this.mTree._changeOpenState = null;

        this.mTree.database.RemoveDataSource(this.mService.dataSource);
      ]]></destructor>

      <field name="_dragService"><![CDATA[
        Components.classes['@mozilla.org/widget/dragservice;1']
            .getService(Components.interfaces.nsIDragService);
      ]]></field>

      <method name="getURLName">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.name : aURL;
        ]]></body>
      </method>

      <method name="getURLImage">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.image : null;
        ]]></body>
      </method>

      <method name="getURLProperties">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.properties : "";
        ]]></body>
      </method>

      <method name="getSelectedNode">
        <body><![CDATA[
          return this.getNodeForRow(this.mTree.currentIndex);
        ]]></body>
      </method>

      <!-- Attempt to trigger in-cell editing on the cell
           corresponding to the given sbIServicePaneNode
        -->
      <method name="startEditingNode">
        <parameter name="aNode"/>
        <body><![CDATA[
          aNode.parentNode.isOpen = true;
          // TODO: do we need to scroll to the row?

          var index = this.getRowForNode(aNode);
          if (index >= 0 && aNode.editable) {
            this.mTree.startEditing(index, this.mTree.columns[0]);
            return true;
          }
          return false;
        ]]></body>
      </method>

      <method name="getNodeForRow">
        <parameter name="row" />
        <body><![CDATA[
          if (row < 0) {
            return null;
          }

          // If this is a dont-build-content tree, use this:
          //var id = this.mTree.builderView.getResourceAtIndex(row).Value;

          var element = this.mTree.contentView.getItemAtIndex(row);
          if (element && element.hasAttribute('nodeid')) {
            return this.mService.getNode(element.getAttribute('nodeid'));
          } else {
            return null;
          }
        ]]></body>
      </method>

      <method name="getRowForNode">
        <parameter name="node" />
        <body><![CDATA[
          if (!node) {
            return -1;
          }

          // If this is a dont-build-content tree, use this:
          //return this.mTree.builderView.getIndexOfResource(node.resource);

          var element = document.getAnonymousElementByAttribute(this, 'nodeid', node.id);
          return this.mTree.view.getIndexOfItem(element);
        ]]></body>
      </method>

      <!-- the element we're currently dragging over -->
      <field name="_dragOverElement">null</field>

      <field name="_browser">null</field>
      <property name="browser">
        <getter><![CDATA[
          if (!this._browser) {
            this._browser = document.getElementById(this.getAttribute('browser'));
          }
          return this._browser;
        ]]></getter>
      </property>

      <!-- Highlight/select the row corresponding to the given service node.
           Pass null to clear the selection -->
      <method name="highlightNode">
        <parameter name="aNode" />
        <body><![CDATA[
          // we only want to allow highlighting if we aren't currently editing
          if (this.mTree.hasAttribute("editing")) {
            return;
          }

          if (aNode) {
            var row = this.getRowForNode(aNode);
            if (row >= 0) {
              this.mTree.view.selection.select(row);
            } else {
              this.mTree.view.selection.clearSelection();
            }
          } else {
            this.mTree.view.selection.clearSelection();
          }
        ]]></body>
      </method>


      
      <!-- Called when the content of the current browser tab is changed.
           This occurs when the user swiches tabs, or loads an new page 
           in the existing tab.  Note that on page load this method is called
           both at load start and at load complete. -->
      <method name="onBrowserTabChange">
        <body><![CDATA[
          try {
            // Is there a servicepane node for the current tab?
            var node = this._browser.selectedTab.servicePaneNode;
          
            if (node) {
              this.highlightNode(node);
            }
          } catch (e) {
            Components.utils.reportError(e); 
          }
        ]]></body>
      </method>
      
      
      
      <!-- somewhat inspired by nsTreeBodyFrame::ComputeDropPosition -->
      <method name="computeEventPosition">
        <parameter name="event" />
        <parameter name="aTree"/>
        <parameter name="aNode"/>
        <body><![CDATA[
        // deal with optional arguments
        var tree = aTree || this.mTree;

        // what cell are we over?
        var row = { }, col = { }, child = { };
        tree.treeBoxObject.getCellAt(event.pageX, event.pageY, row, col, child);

        // what node is that?
        var node = aNode || this.getNodeForRow(row.value);

        // where is that cell?
        var x = { }, y = { }, width = { }, height = { };
        tree.treeBoxObject.getCoordsForCellItem(row.value, col.value,
                                                'cell', x, y, width, height);

        // what element is that?
        var element = tree.contentView.getItemAtIndex(row.value);

        // where in the cell are we?
        var position = (event.pageY - y.value -
                        tree.treeBoxObject.treeBody.boxObject.y);
        position = position / height.value;

        // so lets work out the orientation. the rules the real tree drag and
        // drop uses is:
        //   isContainer:
        //     <0.25: before
        //     >0.75: after
        //     else: on
        //   else:
        //     <0.5: before
        //     >0.5: after
        var orientation;
        if (node.isContainer) {
          if (position <= 0.25) {
            orientation = -1;
          } else if (position >= 0.75) {
            orientation = 1;
          } else {
            orientation = 0;
          }
        } else {
          if (position <= 0.5) {
            orientation = -1;
          } else {
            orientation = 1;
          }
        }

        return { row: row.value,
                 node: node,
                 orientation: orientation,
                 element: element };
        ]]></body>
      </method>
      <method name="onPopupShown">
        <parameter name="event" />
        <body>
          <![CDATA[
          var gotstuff = false;
          for (var i=0;i<this.mPopup.childNodes.length;i++) {
            var e = this.mPopup.childNodes[i];
            if (e.hidden) continue;
            gotstuff = true;
          }
          if (!gotstuff)
            this.mPopup.hidePopup();
          ]]>
        </body>
      </method>
      <method name="loadSelectedNode">
        <parameter name="event"/>
        <body><![CDATA[
          var node = this.getNodeForRow(this.mTree.currentIndex);
          this.highlightNode(node);  // also unhighlights other nodes
          
          if (node) {
            this.loadNode(node, event);
          }
        ]]></body>
      </method>
      <method name="loadNode">
        <parameter name="node"/>
        <parameter name="event"/>
        <body><![CDATA[
          // If this node has a URL, just load it in the browser
          if (node.url) {
            var target = null;
            if (this.isMediaTabURL(node.url)) {
              target = "_media";
            }
            this.browser.loadURI(node.url, null, null, event, target);
            
            if( node.getAttributeNS(this.BSP, "Imported") == 'true' ) {

              //This enables us to know if we're packaging bookmarks
              //that people like or hate while not tracking any bookmarks they create.
              //See http://bugzilla.songbirdnest.com/show_bug.cgi?id=4021

              try {
                metrics_inc("app.servicepane.bookmarks.click", node.url, null);
              } catch(e) { Components.utils.reportError(e); }
            }
            
          // If no URL, apply special handling
          } else {
          
            // If there is a media list for this node, hand it off to the 
            // browser to display somehow.
            // I'm told that this hack is fine, as it will one day be replaced
            // with the playlist commands system.
            var libraryServicePane = 
              Components.classes['@songbirdnest.com/servicepane/library;1']
              .getService(Components.interfaces.sbILibraryServicePaneService);
            var mediaList = libraryServicePane.getLibraryResourceForNode(node);
            if (mediaList) {
              var tab = this.browser.loadMediaList(mediaList, event, "_media");
              this.browser.selectedTab = tab;

              // Record list type metrics for some reason.
              // See http://bugzilla.songbirdnest.com/show_bug.cgi?id=4021
              try {
                var listType = mediaList.getProperty(SBProperties.customType);
                var libType = mediaList.library.getProperty(SBProperties.customType);
                metrics_inc(libType, listType, null);
              } catch(e) { Components.utils.reportError(e); }

            } else {
              /* FIXME: implement non-go-to-url behaviour */
              Components.utils.reportError(
                "ServicePane.loadSelectedNode: unable to " + 
                "handle the selected node");
            }
          }
        ]]></body>
      </method>
      <method name="isMediaTabURL">
        <parameter name="aURL"/>
        <body><![CDATA[
          if (!aURL) {
            return Components.results.NS_ERROR_INVALID_ARG;
          }
          var url = aURL;
          if (aURL instanceof Components.interfaces.nsIURI) {
            url = aURL.spec;
          }
          if (!(/chrome:\/\//.test(url))) {
            // not chrome
            return false;
          }
          var node = this.mService.getNodeForURL(url);
          if (!node) return false;
          return true;
        ]]></body>
      </method>
      
      <!-- drag-and-drop helpers -->
      <method name="_onDragGesture">
        <parameter name="event"/>
        <parameter name="node"/>
        <body><![CDATA[
          var transferable = {};
          if (node && this.mService.onDragGesture(node.id, transferable)) {
            transferable = transferable.value;
            var transArray = Components.classes["@mozilla.org/supports-array;1"]
                                       .createInstance(Components.interfaces.nsISupportsArray);
            transArray.AppendElement(transferable);
            
            // Oh Lordy lordy, I'm so glad I could just steal this from 
            // nsDragAndDrop.js instead of having to write it myself.
            var region = null;
            if (event.originalTarget.localName == "treechildren") {
              // let's build the drag region
              var tree = event.originalTarget.parentNode;
              try {
                region = Cc["@mozilla.org/gfx/region;1"]
                          .createInstance(Ci.nsIScriptableRegion);
                region.init();
  
                var obo = tree.treeBoxObject;
                var bo = obo.treeBody.boxObject;
                var sel= obo.view.selection;
  
                region.unionRect(bo.x, (obo.rowHeight * sel.currentIndex + bo.y),
                                 bo.width, obo.rowHeight);
  
                //and finally, clip the result to be sure we don't spill over...
                region.intersectRect(bo.x, bo.y, bo.width, bo.height);
  
              } catch(ex) {
                dump("Error while building selection region: " + ex + "\n");
                region = null;
              }
            }
            
            var dragAction = this._dragService.DRAGDROP_ACTION_COPY +
                             this._dragService.DRAGDROP_ACTION_MOVE;
            this._dragService.invokeDragSessionWithImage(event.target, transArray,
                region, dragAction,
                null, 0, 0,
                event);
            
            event.preventDefault();
          }
        ]]></body>
      </method>
      
      <method name="_onDragOver">
        <parameter name="event"/>
        <parameter name="aTree"/>
        <parameter name="aNode"/>
        <body><![CDATA[
          var position = this.computeEventPosition(event, aTree, aNode);
          var element = position.element;
          // actually we want the treerow element which is the child
          element = element.childNodes[0];
          var node = position.node;
          var orientation = position.orientation;
  
          // make sure we are tracking the right element
          if (this._dragOverElement != element) {
            if (this._dragOverElement) {
              // we are now over another element - let us restore its properties
              this._dragOverElement.setAttribute('properties',
                  this._dragOverElement.getAttribute('savedproperties'));
              this._dragOverElement.removeAttribute('savedproperties');
            }
            // save the new element
            this._dragOverElement = element;
            // and save its properties
            element.setAttribute('savedproperties',
                element.getAttribute('properties'));
          }
  
          // set the property based on the orientation
          // the properties are chosen based on:
          //   http://developer.mozilla.org/en/docs/XUL_Tutorial:Styling_a_Tree
          var properties = '';
          if (orientation == -1) {
            properties = 'dropBefore';
          } else if (orientation == 1) {
            properties = 'dropAfter';
          } else {
            properties = 'dropOn';
          }
  
          // ask the backend if we are allowed to drop here
          if (!this.mService.canDrop(node.id,
              this._dragService.getCurrentSession(), orientation, window)) {
            // if not, do not set any visual properties
            properties = '';
            this._dragService.canDrop = false;
          } else {
            this._dragService.canDrop = true;
          }
  
          element.setAttribute('properties',
              element.getAttribute('savedproperties') + ' ' + properties);
          // we handle the drop, do not let the default dnd handler get the event
          event.stopPropagation();
        ]]></body>
      </method>
    </implementation>
    <handlers>
      <handler event="contextmenu"><![CDATA[
      // work out what tree node was clicked on
      var obj={}, row={}, col={};
      this.mTree.treeBoxObject.getCellAt(event.clientX, event.clientY,
                         row, col, obj);

      // clear the popup menu
      while (this.mPopup.lastChild) {
        DOMUtils.destroyNode(this.mPopup.lastChild);
        this.mPopup.removeChild(this.mPopup.lastChild);
      }

      var node = this.getNodeForRow(row.value);
      if (node) {
        // ask the service to fill in the popup for this node
        this.mService.fillContextMenu(node.id, this.mPopup, window);
      } else {
        // hmm, fill the popup with the contents of the "new stuff" menu
        this.mService.fillNewItemMenu(null, this.mPopup, window);
      }

      // show the popup menu
      document.popupNode = null;
      this.mPopup.showPopup(document.documentElement,
                  event.screenX+5, event.screenY,
                  'context', null, null, null);

      event.stopPropagation();
      event.preventBubble();
      event.preventDefault();

      ]]></handler>
      <handler event="select"><![CDATA[
        var node = this.getNodeForRow(this.mTree.currentIndex);
        // ask the service to notify the modules about selection changes
        this.mService.onSelectionChanged(node?node.id:null, this.mTree, window);
      ]]></handler>
      <handler event="keypress"><![CDATA[
        if (event.keyCode == Components.interfaces.nsIDOMKeyEvent.DOM_VK_ENTER ||
            event.keyCode == Components.interfaces.nsIDOMKeyEvent.DOM_VK_RETURN) {
          this.loadSelectedNode(event);
        }
      ]]></handler>
      <handler event="click" clickcount="1" button="0"><![CDATA[
        // only handle the click if it occured on a treechildren element,
        // this avoids handling a click when it occured on a child piece of
        // ui (for instance, on a contextmenu item).  also be sure the click
        // was actually over an item, otherwise the selected node will load
        // even though it wasn't clicked.
        if (event.originalTarget.tagName == "treechildren") {
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX, event.clientY, row, col, obj);

          if ((obj.value != 'twisty') && (row.value >= 0)) {
            this.loadSelectedNode(event);
          }
        }
      ]]></handler>
      <handler event="click" clickcount="1" button="1">
        <![CDATA[
        // ditto
        if (event.originalTarget.tagName == "treechildren") {
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX, event.clientY, row, col, obj);

          if ((obj.value != 'twisty') && (row.value >= 0)) {
            this.loadSelectedNode(event);
          }
        }
      ]]>
      </handler>
      <handler event="click" clickcount="2" button="0"><![CDATA[
        var node = this.getNodeForRow(this.mTree.currentIndex);
        if (node && node.editable) {
          this.startEditingNode(node);
        }
      ]]></handler>

      <!-- drag and drop handling -->
      <handler event="draggesture"><![CDATA[
        var row = { }
        var col = { }
        var child = { }
        this.mTree.treeBoxObject.getCellAt(event.pageX, event.pageY, row, col, child);
        if (col.value == null) {
          // not a valid column; e.g., the scrollbar
          return;
        }
        var node = this.getNodeForRow(row.value);
        
        this._onDragGesture(event, node);
      ]]></handler>
      <handler event="dragover"><![CDATA[
        this._onDragOver(event);
      ]]></handler>
      <handler event="dragenter"><![CDATA[
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
      <handler event="dragexit"><![CDATA[
        // if there is a highlighted element let us restore its state
        if (this._dragOverElement) {
          this._dragOverElement.setAttribute('properties',
              this._dragOverElement.getAttribute('oldproperties'));
          this._dragOverElement.removeAttribute('savedproperties');
          this._dragOverElement = null;
        }
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
      <handler event="dragdrop"><![CDATA[
        var position = this.computeEventPosition(event);
        var node = position.node;
        var orientation = position.orientation;
        var session = this._dragService.getCurrentSession();
        if (this.mService.canDrop(node.id, session, orientation, window)) {
          this.mService.onDrop(node.id, session, orientation, window);
        }
        this._dragService.endDragSession(true);
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
    </handlers>
  </binding>


  <binding id="proxyTreePane">
    <content>
      <tree xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
            flex="1" class="servicepane-tree" anonid="proxytree"
            datasources="rdf:null" ref="SB:Root"
            hidecolumnpicker="true" seltype="single"
            mousethrough="never"
            onclick="if (gServicePane) gServicePane.onProxyClick(event)"
            >
        <treecols>
          <treecol primary="true" flex="1"/>
        </treecols>
        <template>
          <rule>
            <conditions>
              <content uri="?start" />
              <member container="?start" child="?node" />
              <triple subject="?node"
                      predicate="http://home.netscape.com/NC-rdf#Name"
                      object="?name" />
              <triple subject="?node"
                      predicate="http://songbirdnest.com/rdf/servicepane#Hidden"
                      object="false" />
            </conditions>
            <bindings>
              <binding subject="?node"
                       predicate="http://home.netscape.com/NC-rdf#Icon"
                       object="?icon" />
              <binding subject="?node"
                       predicate="http://songbirdnest.com/rdf/servicepane#Open"
                       object="?open" />
              <binding subject="?node"
                       predicate="http://songbirdnest.com/rdf/servicepane#Properties"
                       object="?properties" />
            </bindings>
            <action>
              <treechildren flex="1" properties="dropOn">
                <treeitem open="true" uri="?node" nodeid="?node">
                  <treerow>
                    <treecell label="?name" src="?icon" properties="?properties"/>
                  </treerow>
                </treeitem>
              </treechildren>
            </action>
          </rule>
        </template>
      </tree>
    </content>
    <implementation>
      <field name="_tree">
        document.getAnonymousElementByAttribute(this, 'anonid', 'proxytree');
      </field>
      <field name="_servicepane">gServicePane</field>
      <field name="_treepane">this._servicepane.mTreePane</field>
      <field name="_service">
        Components.classes['@songbirdnest.com/servicepane/service;1']
                  .getService(Components.interfaces.sbIServicePaneService);
      </field>
      <field name="_dragService">
        Components.classes['@mozilla.org/widget/dragservice;1']
                  .getService(Components.interfaces.nsIDragService);
      </field>
      <method name="getNodeForRow">
        <parameter name="row" />
        <body><![CDATA[
          if (row < 0) {
            return null;
          }

          // If this is a dont-build-content tree, use this:
          //var id = this.mTree.builderView.getResourceAtIndex(row).Value;

          var element = this._tree.contentView.getItemAtIndex(row);
          if (element && element.hasAttribute('nodeid')) {
            return this._service.getNode(element.getAttribute('nodeid'));
          } else {
            return null;
          }
        ]]></body>
      </method>
    </implementation>
    <handlers>
      <handler event="draggesture"><![CDATA[
        var row = { }
        var col = { }
        var child = { }
        this._tree.treeBoxObject.getCellAt(event.pageX, event.pageY, row, col, child);
        if (col.value == null) {
          // not a valid column; e.g., the scrollbar
          return;
        }
        var node = this.getNodeForRow(row.value);
        this._treepane._onDragGesture(event, node);
      ]]></handler>
      <handler event="dragover"><![CDATA[
        var row = { }
        var col = { }
        var child = { }
        this._tree.treeBoxObject.getCellAt(event.pageX, event.pageY, row, col, child);
        if (col.value == null) {
          // not a valid column; e.g., the scrollbar
          return;
        }
        var node = this.getNodeForRow(row.value);
        this._treepane._onDragOver(event, this._tree, node);
      ]]></handler>
      <handler event="dragenter"><![CDATA[
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
      <handler event="dragexit"><![CDATA[
        // if there is a highlighted element let us restore its state
        if (this._treepane._dragOverElement) {
          this._treepane._dragOverElement.setAttribute('properties',
              this._treepane._dragOverElement.getAttribute('oldproperties'));
          this._treepane._dragOverElement.removeAttribute('savedproperties');
          this._treepane._dragOverElement = null;
        }
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
      <handler event="dragdrop"><![CDATA[
        var row = { }
        var col = { }
        var child = { }
        this._tree.treeBoxObject.getCellAt(event.pageX, event.pageY, row, col, child);
        if (col.value == null) {
          // not a valid column; e.g., the scrollbar
          return;
        }
        var node = this.getNodeForRow(row.value);
        var position = this._treepane.computeEventPosition(event, this._tree, node);
        node = position.node;
        var orientation = position.orientation;
        var session = this._dragService.getCurrentSession();
        if (this._service.canDrop(node.id, session, orientation, window)) {
          this._service.onDrop(node.id, session, orientation, window);
        }
        this._dragService.endDragSession(true);
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
        
        // tell the parent to deal with the drop
        var parent = this.parentNode;
        if (parent instanceof Element) {
          var newEvent = document.createEvent("MouseEvent");
          newEvent.initMouseEvent("dragdrop", true, false, event.view,
                                  event.detail, event.screenX, event.screenY,
                                  event.clientX, event.clientY,
                                  event.ctrlKey, event.altKey,
                                  event.shiftKey, event.metaKey, 
                                  event.button, event.relatedTarget);
          parent.dispatchEvent(newEvent);
        }
      ]]></handler>
    </handlers>
  </binding>

  <binding id="toolbar">
    <content>
      <!-- Service Pane Button Bar, Buttons for adding a new service or playlist-->
      <!-- For now just hijacking the file menu implementation.. -->
      <!-- TODO: over state, up arrow, remove periods from all IDs -->
      <xul:hbox id="servicepane_toolbar_box" class="servicepane-toolbar-box">
        <xul:sb-clickhold-button class="servicepane-toolbar-newitem-button" anonid="clickhold" flex="1">
          <xul:menupopup anonid="popup" popupanchor="topleft" popupalign="bottomleft"/>
        </xul:sb-clickhold-button>
      </xul:hbox>
    </content>
    <implementation>
      <constructor><![CDATA[
        var service = Components.classes['@songbirdnest.com/servicepane/service;1']
          .getService(Components.interfaces.sbIServicePaneService);
        this._service = service;
        
        this._dragService = Cc['@mozilla.org/widget/dragservice;1']
                            .getService(Ci.nsIDragService);
        
        
        this._clickHold = document.getAnonymousElementByAttribute(this, 'anonid', 'clickhold');
        this._popup     = document.getAnonymousElementByAttribute(this, 'anonid', 'popup');
        
        service.fillNewItemMenu(null, this._popup, window);
        
        // Make the button look like the first item in the list.
        var item = this._popup.firstChild;
        if (!item) {
          /* bad news */
          return;
        }
        
        this._clickHold.setAttribute('label', item.getAttribute('label'));
        // FIXME: this is needed for styling but sucks
        this._clickHold.setAttribute('id', item.getAttribute('id'));

      ]]></constructor>
      <field name="_clickHold">null</field>
    </implementation>
    <handlers>
      <handler event="command"><![CDATA[
        for (var item = this._popup.firstChild;
             item; item = item.nextSibling) {
          if (event.originalTarget == item) {
            // the event was heading for a menu item
            return;
          }
        }
        // this wasn't heading to any of our children - let's do the first one
        this._popup.firstChild.doCommand();
      ]]></handler>
      <handler event="dragenter"><![CDATA[
        var session = this._dragService.getCurrentSession();
        
        var supported = DNDUtils.isSupported(session,
          ["application/x-sb-transfer-media-list",
           "application/x-sb-transfer-media-items"]);
        if (supported) {
          var element = this._clickHold.parentNode;
          this._dragService.canDrop = true;
          element.setAttribute("dropOn", "true");

          // we handle the drop, do not let the default dnd handler get the event
          event.stopPropagation();
        }
      ]]></handler>
      <handler event="dragexit"><![CDATA[
        var element = this._clickHold.parentNode;
        element.removeAttribute("dropOn");

        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
      <handler event="dragdrop"><![CDATA[
  try {
    var element = event.target;
    
    var session = this._dragService.getCurrentSession();
    
    // Note that this is called by our tree observer
    var dnd = Cc["@songbirdnest.com/Songbird/DndSourceTracker;1"]
                .getService(Ci.sbIDndSourceTracker);
  
    // handle mediaitem drops
    var data = DNDUtils.getTransferDataForFlavour("application/x-sb-transfer-media-list",
                                              session);
    if (data) {
      var context = dnd.getSourceSupports(data)
                       .QueryInterface(Ci.sbIMediaListTransferContext);
      
      var mediaList = SBNewPlaylist();
      mediaList.addAll(context.list);
      
      return;
    }
  
    data = DNDUtils.getTransferDataForFlavour("application/x-sb-transfer-media-items",
                                              session);
    if (data) {
      var context = dnd.getSourceSupports(data)
                       .QueryInterface(Ci.sbIMediaItemsTransferContext);

      var mediaList = SBNewPlaylist();
      mediaList.addSome(context.items);

      return;
    }

    // handle external drops
    var dropHandlerListener = {
      onDropComplete: function(aTargetList,
                               aImportedInLibrary,
                               aDuplicates,
                               aInsertedInMediaList,
                               aOtherDropsHandled) { 
        // show the standard report on the status bar
        return true;
      },
      onFirstMediaItem: function(aTargetList, aFirstMediaItem) {}
    };

    ExternalDropHandler.dropOnList(window, 
                                   session, 
                                   this.mediaList, 
                                   position, 
                                   dropHandlerListener);
                                   
    event.stopPropagation();
  } catch(e) { Components.utils.reportError(e); }
      ]]></handler>
    </handlers>
  </binding>

</bindings>
