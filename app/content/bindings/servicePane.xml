<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
//
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2008 POTI, Inc.
// http://songbirdnest.com
//
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
//
// Software distributed under the License is distributed
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either
// express or implied. See the GPL for the specific language
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
//
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE window SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="servicepane">
    <content>
      <xul:vbox id="sb_servicepane" class="servicepane-outer-box" flex="1">
        <xul:vbox id="sb_servicepane_box" class="servicepane-inner-box" flex="1">
          <xul:vbox id="sb_servicepane_treepane"
                style="-moz-binding:url(#treepane)" flex="1"
                anonid="treepane"
                mousethrough="never"
                xbl:inherits="browser"/>
          <children/>
        </xul:vbox>
        <xul:sb-displaypane-splitter
                collapse="after"
                orient="vertical"
                resizeafter="closest"
                id="displaypane_servicepane_bottom_splitter"
                menuid="displaypane_servicepane_bottom_menu" />
        <xul:sb-displaypane id="displaypane_servicepane_bottom"
                            label="&displaypane.name.servicepane;"
                            splitter="displaypane_servicepane_bottom_splitter"
                            contentgroup="servicepane"/>
      </xul:vbox>
      <!-- menupopup needs to be outside the vbox otherwise it
           gets height adjusted to 0 when the splitter is 
           adjusted -->
      <xul:menupopup id="displaypane_servicepane_bottom_menu"
                     class="menulist-menupopup">
        <xul:sb-displaypane-content-menuitems
                     paneid="displaypane_servicepane_bottom" />
      </xul:menupopup>
    </content>
    <implementation>
      <constructor>
          <![CDATA[
        Components.utils.import("resource://app/jsmodules/DOMUtils.jsm");

        window.gServicePane = this;
      ]]></constructor>

      <method name="getSelectedNode">
        <body><![CDATA[return this.mTreePane.getSelectedNode();]]></body>
      </method>

      <method name="startEditingNode">
        <parameter name="aNode"/>
        <body><![CDATA[return this.mTreePane.startEditingNode(aNode);]]></body>
      </method>

      <method name="getURLName">
        <parameter name="aURL"/>
        <body><![CDATA[return this.mTreePane.getURLName(aURL);]]></body>
      </method>

      <method name="getURLImage">
        <parameter name="aURL"/>
        <body><![CDATA[return this.mTreePane.getURLImage(aURL);]]></body>
      </method>

      <method name="getURLProperties">
        <parameter name="aURL"/>
        <body><![CDATA[return this.mTreePane.getURLProperties(aURL);]]></body>
      </method>
      
      <method name="initSpringLoadPanel">
        <parameter name="aPanel"/>
        <body><![CDATA[
          setTimeout(function(){
            var tree = document.getAnonymousElementByAttribute(
                         aPanel.lastChild,
                         "anonid", "proxytree");
            if (tree.view)
              tree.view.selection.clearSelection();
  
            while (tree.database.GetDataSources().hasMoreElements()) {
              tree.database.RemoveDataSource(
                  tree.database.GetDataSources().getNext());
            }
    
            var service = Components.classes['@songbirdnest.com/servicepane/service;1']
                                    .getService(Components.interfaces.sbIServicePaneService);
            // add the datasource from the service
            tree.database.AddDataSource(service.dataSource);
            tree.ref = service.root.id;
    
            // and force a rebuild
            tree.builder.rebuild();
          }, 0);
          
          // Set the height and width of the floating servicepane panel:
          var panel = document.getElementById("service_pane_spring_load_panel");
          
          var height = gBrowser.boxObject.height + gBrowser.tabStrip.boxObject.height;
          var width = SBDataGetStringValue("splitter.servicepane_splitter.before.width");
          panel.style.height = height + "px";
          panel.style.width = width + "px";
        ]]></body>
      </method>
      
      <method name="onProxyClick">
        <!-- the spring-loaded copy of the tree was clicked on -->
        <parameter name="event"/>
        <body><![CDATA[
          var proxyTree = event.target;
          while (proxyTree && !(proxyTree instanceof Components.interfaces.nsIDOMXULTreeElement))
            proxyTree = proxyTree.parentNode;
          var row = {}, col = {}, obj = {};
          // need to manually find the node, because the real tree may have
          // collapsed rows
          proxyTree.boxObject.getCellAt(event.clientX, event.clientY, row, col, obj);
          if ((obj.value == 'twisty') || (row.value < 0)) {
            return;
          }
          var elem = proxyTree.view.getItemAtIndex(row.value);
          var nodeid = elem.getAttribute("nodeid");
          if (nodeid) {
            var node = this.mTreePane.mService.getNode(nodeid);
            this.mTreePane.loadNode(node, event);
          }
          var panel = document.getElementById("service_pane_spring_load_panel");
          panel.hidePopup();
        ]]></body>
      </method>
      
      <property name="open">
        <getter>
        <![CDATA[
          var elId = this.mSplitter.getAttribute("collapseelement");
          return !document.getElementById(elId).collapsed;
        ]]>
        </getter>
        <setter>
        <![CDATA[
          var elId = this.mSplitter.getAttribute("collapseelement");
          var el = document.getElementById(elId);
          el.collapsed = !val;

          SBDataSetBoolValue('splitter.servicepane_splitter.collapsed',
                             el.collapsed);
          // If we are opening the service pane, make sure we highlight the
          // appropriate node.
          if(val) {
            // Is there a servicepane node for the current tab?
            var node = this.mTreePane.browser.selectedTab.servicePaneNode;
            if (node) {
              this.mTreePane.highlightNode(node);
            }
          }
          ]]>
        </setter>
      </property>

      <field name="doneInit">false</field>
      
      <field name="mTreePane">
        document.getAnonymousElementByAttribute(this, 'anonid', 'treepane');
      </field>
      <field name="mToolbar">
        document.getAnonymousElementByAttribute(this, 'anonid', 'toolbar');
      </field>
      <field name="mSplitter">
        document.getElementById('servicepane_splitter');
      </field>
    </implementation>
   </binding>



  <binding id="treepane">
    <content>
      <xul:tree class="servicepane-tree" anonid="tree" flex="1"
            datasources="rdf:null" ref="SB:Root"
            hidecolumnpicker="true" seltype="single"
            mousethrough="never"
            >
        <!-- hide the column header - is there a better way? -->
        <xul:treecols style="height:0px">
          <xul:treecol primary="true" flex="1"
                 hideheader="true"
                 />
        </xul:treecols>
        <xul:template>
          <xul:rule>
            <xul:conditions>
              <xul:content uri="?start" />
              <xul:member container="?start" child="?node" />
              <xul:triple subject="?node"
                    predicate="http://home.netscape.com/NC-rdf#Name"
                    object="?name" />
              <xul:triple subject="?node"
                    predicate="http://songbirdnest.com/rdf/servicepane#Hidden"
                    object="false" />
            </xul:conditions>
            <xul:bindings>
              <xul:binding subject="?node"
                     predicate="http://home.netscape.com/NC-rdf#Icon"
                     object="?icon" />
              <xul:binding subject="?node"
                     predicate="http://songbirdnest.com/rdf/servicepane#Open"
                     object="?open" />
              <xul:binding subject="?node"
                     predicate="http://songbirdnest.com/rdf/servicepane#Properties"
                     object="?properties" />
            </xul:bindings>
            <xul:action>
              <xul:treechildren flex="1" properties="dropOn">
                <xul:treeitem open="?open" uri="?node" nodeid="?node">
                  <xul:treerow>
                    <xul:treecell label="?name" src="?icon" properties="?properties"/>
                  </xul:treerow>
                </xul:treeitem>
              </xul:treechildren>
            </xul:action>
          </xul:rule>
        </xul:template>
      </xul:tree>
      <xul:popupset>
        <xul:popup anonid="popup"  onpopupshown="onPopupShown(event);" />
      </xul:popupset>
    </content>
    <implementation implements="nsIXULBuilderListener,nsIRDFObserver">
      <constructor>
            <![CDATA[
        // get the tree node
        this.mTree = document.getAnonymousElementByAttribute(this, 'anonid', 'tree');
        // get the popup node
        this.mPopup = document.getAnonymousElementByAttribute(this, 'anonid', 'popup');
        // clear out the old datasources from the tree

        this.mService =
          Components.classes['@songbirdnest.com/servicepane/service;1']
          .getService(Components.interfaces.sbIServicePaneService);
        this.mService.init();

        while (this.mTree.database.GetDataSources().hasMoreElements()) {
          this.mTree.database.RemoveDataSource(
              this.mTree.database.GetDataSources().getNext());
        }

        // add the datasource from the service
        this.mTree.database.AddDataSource(this.mService.dataSource);
        this.mTree.ref = this.mService.root.id;

        // and force a rebuild
        this.mTree.builder.rebuild();
        
        // add a listener to set up the selected node when the tree rebuilds
        // (see mozilla bug 331505)
        this.mTree.builder.addListener(this);
        
        var rdfsource = 
          this.mTree.builder.datasource
              .QueryInterface(Components.interfaces.nsIRDFDataSource);
        
        rdfsource.AddObserver(this);

        var sp = this;
        // this is evil. really. i feel guilty.
        // let's replace the tree's stopEditing function with our own
        // that actually saves off the data
        this.mTree._stopEditing = this.mTree.stopEditing;
        this.mTree.stopEditing = function evilStopEditing(accept) {
          /* debugging output - really useful for debugging: */
          /*
          dump('accept: '+accept+'\n');
          dump('this._editingColumn: '+this._editingColumn+'\n');
          dump('this._editingRow: '+this._editingRow+'\n');
          dump('this.inputField.value: '+this.inputField.value+'\n');
          dump('this.inputField.hidden: '+this.inputField.hidden+'\n');
          dump('this.hasAttribute("editing"): '+this.hasAttribute("editing")+'\n');
          */

          if (!this._editingColumn)
            return;

          var node = null;
          var newName = null;

          if (accept && this._editingRow != -1 &&
              this._editingColumn && !this.inputField.hidden &&
              this.hasAttribute('editing')) {
            node = sp.getNodeForRow(this._editingRow);
            newName = this.inputField.value;
          }

          // Always set accept to false, since we leave it
          // up to the service pane service to determine
          // what changes
          this._stopEditing(false);

          // Give the new name to the service pane.
          if (node) {
            sp.mService.onRename(node.id, newName);
          }
        }

        // If we have a browser, set up listeners to monitor the location
        if (sp.browser) {
          this._onBrowserTabChangeListener = function(e) {
            sp.onBrowserTabChange(e);
          }
          function windowOnLoad() {
            sp.browser.addEventListener("TabContentChange", 
                  sp._onBrowserTabChangeListener, false);

            gServicePane.doneInit = true;
            window.removeEventListener('load', windowOnLoad, false);
          }
          window.addEventListener('load', windowOnLoad, false);
        }

        // xbl slight of hand
        this.mTree._changeOpenState = this.mTree.changeOpenState;
        this.mTree.changeOpenState = function (row, openState) {
          this._changeOpenState(row, openState);
          sp.getNodeForRow(row).isOpen = sp.mTree.view.isContainerOpen(row);
        }

        // Namespace for BookmarksServicePaneService attributes.
        this.BSP = 'http://songbirdnest.com/rdf/bookmarks#';
      ]]></constructor>
      <destructor><![CDATA[
        this.mService.onSelectionChanged(null, this.mTree, window);

        // Remove the browser event listener
        if (this.browser) {
          this.browser.removeEventListener("TabContentChange",
            this._onBrowserTabChangeListener, false);
        }
        
        // remove the rebuild selection listener
        this.mTree.builder.removeListener(this);
        
        var rdfsource = 
          this.mTree.builder.datasource
              .QueryInterface(Components.interfaces.nsIRDFDataSource);
        
        rdfsource.RemoveObserver(this);

        this.mTree.stopEditing = this.mTree._stopEditing;
        this.mTree._stopEditing = null;

        this.mTree.changeOpenState = this.mTree._changeOpenState;
        this.mTree._changeOpenState = null;

        this.mTree.database.RemoveDataSource(this.mService.dataSource);
      ]]></destructor>

      <field name="_dragService"><![CDATA[
        Components.classes['@mozilla.org/widget/dragservice;1']
            .getService(Components.interfaces.nsIDragService);
      ]]></field>

      <method name="getURLName">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.name : aURL;
        ]]></body>
      </method>

      <method name="getURLImage">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.image : null;
        ]]></body>
      </method>

      <method name="getURLProperties">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.properties : "";
        ]]></body>
      </method>

      <method name="getSelectedNode">
        <body><![CDATA[
          return this.getNodeForRow(this.mTree.currentIndex);
        ]]></body>
      </method>

      <!-- Attempt to trigger in-cell editing on the cell
           corresponding to the given sbIServicePaneNode
        -->
      <method name="startEditingNode">
        <parameter name="aNode"/>
        <body><![CDATA[
          aNode.parentNode.isOpen = true;
          // TODO: do we need to scroll to the row?

          // Ensure the node is highlighted and start editing it
          var index = this.getRowForNode(aNode);
          if (index >= 0 && aNode.editable) {
            this.highlightNode(aNode);
            this.mTree.startEditing(index, this.mTree.columns[0]);
            return true;
          }
          return false;
        ]]></body>
      </method>

      <method name="getNodeForRow">
        <parameter name="row" />
        <body><![CDATA[
          if (row < 0) {
            return null;
          }

          // If this is a dont-build-content tree, use this:
          //var id = this.mTree.builderView.getResourceAtIndex(row).Value;

          var element = this.mTree.contentView.getItemAtIndex(row);
          if (element && element.hasAttribute('nodeid')) {
            return this.mService.getNode(element.getAttribute('nodeid'));
          } else {
            return null;
          }
        ]]></body>
      </method>

      <method name="getRowForNode">
        <parameter name="node" />
        <body><![CDATA[
          if (!node) {
            return -1;
          }

          // If this is a dont-build-content tree, use this:
          //return this.mTree.builderView.getIndexOfResource(node.resource);

          var element = document.getAnonymousElementByAttribute(this, 'nodeid', node.id);
          return this.mTree.view.getIndexOfItem(element);
        ]]></body>
      </method>

      <!-- the element we're currently dragging over -->
      <field name="_dragOverElement">null</field>

      <field name="_browser">null</field>
      <property name="browser">
        <getter><![CDATA[
          if (!this._browser) {
            this._browser = document.getElementById(this.getAttribute('browser'));
          }
          return this._browser;
        ]]></getter>
      </property>

      <!-- Highlight/select the row corresponding to the given service node.
           Pass null to clear the selection -->
      <method name="highlightNode">
        <parameter name="aNode" />
        <body><![CDATA[
          // we only want to allow highlighting if we aren't currently editing
          // and the tree is showing.
          if (this.mTree.hasAttribute("editing") ||
              !this.mTree.view) {
            return;
          }

          if (aNode) {
            var row = this.getRowForNode(aNode);
            if (row >= 0) {
              this.mTree.view.selection.select(row);
            } else {
              this.mTree.view.selection.clearSelection();
            }
          } else {
            this.mTree.view.selection.clearSelection();
          }
        ]]></body>
      </method>


      
      <!-- Called when the content of the current browser tab is changed.
           This occurs when the user swiches tabs, or loads an new page 
           in the existing tab.  Note that on page load this method is called
           both at load start and at load complete. -->
      <method name="onBrowserTabChange">
        <body><![CDATA[
          this._highlightSelectedNode();
        ]]></body>
      </method>
      
      
      
      <!-- somewhat inspired by nsTreeBodyFrame::ComputeDropPosition -->
      <method name="computeEventPosition">
        <parameter name="event" />
        <parameter name="aTree"/>
        <parameter name="aNode"/>
        <body><![CDATA[
        // deal with optional arguments
        var tree = aTree || this.mTree;

        // what cell are we over?
        var row = { }, col = { }, child = { };
        tree.treeBoxObject.getCellAt(event.pageX, event.pageY, row, col, child);

        // what node is that?
        var node = aNode || this.getNodeForRow(row.value);

        // where is that cell?
        var x = { }, y = { }, width = { }, height = { };
        tree.treeBoxObject.getCoordsForCellItem(row.value, col.value,
                                                'cell', x, y, width, height);

        // what element is that?
        var element = tree.contentView.getItemAtIndex(row.value);

        // where in the cell are we?
        var position = (event.pageY - y.value -
                        tree.treeBoxObject.treeBody.boxObject.y);
        position = position / height.value;

        // so lets work out the orientation. the rules the real tree drag and
        // drop uses is:
        //   isContainer:
        //     <0.25: before
        //     >0.75: after
        //     else: on
        //   else:
        //     <0.5: before
        //     >0.5: after
        var orientation;
        if (node.isContainer) {
          if (position <= 0.25) {
            orientation = -1;
          } else if (position >= 0.75) {
            orientation = 1;
          } else {
            orientation = 0;
          }
        } else {
          if (position <= 0.5) {
            orientation = -1;
          } else {
            orientation = 1;
          }
        }

        return { row: row.value,
                 node: node,
                 orientation: orientation,
                 element: element };
        ]]></body>
      </method>
      <method name="onPopupShown">
        <parameter name="event" />
        <body>
          <![CDATA[
          var gotstuff = false;
          for (var i=0;i<this.mPopup.childNodes.length;i++) {
            var e = this.mPopup.childNodes[i];
            if (e.hidden) continue;
            gotstuff = true;
          }
          if (!gotstuff)
            this.mPopup.hidePopup();
          ]]>
        </body>
      </method>
      <method name="selectAndLoadNode">
        <parameter name="node"/>
        <parameter name="event"/>
        <body><![CDATA[
          this.highlightNode(node);  // also unhighlights other nodes
          this.loadNode(node, event);
        ]]></body>
      </method>
      <method name="loadSelectedNode">
        <parameter name="event"/>
        <body><![CDATA[
          var node = this.getNodeForRow(this.mTree.currentIndex);
          if (node) {
            this.loadNode(node, event);
          }
        ]]></body>
      </method>
      <method name="isLoadableNode">
        <parameter name="node"/>
        <body><![CDATA[
          if (node.url)
            return true;
          var libraryServicePane = 
            Components.classes['@songbirdnest.com/servicepane/library;1']
            .getService(Components.interfaces.sbILibraryServicePaneService);
          var mediaList = libraryServicePane.getLibraryResourceForNode(node);
          if (mediaList)
            return true;
          var SP_NS = "http://songbirdnest.com/rdf/servicepane#";
          var eventType = node.getAttributeNS(SP_NS, "eventType");
          if (eventType)
            return true;
          return false;
        ]]></body>
      </method>
      <method name="loadNode">
        <parameter name="node"/>
        <parameter name="event"/>
        <body><![CDATA[
          // If this node has a URL, just load it in the browser
          if (node.url) {
            var target = null;
            if (this.isMediaTabURL(node.url)) {
              target = "_media";
              this.browser.selectedTab = this.browser.mediaTab;
            } else if (event.button == 1) {
              // Middle click.
              target = "_blank";
            }
            this.browser.loadURI(node.url, null, null, event, target);

            if( node.getAttributeNS(this.BSP, "Imported") == 'true' ) {

              //This enables us to know if we're packaging bookmarks
              //that people like or hate while not tracking any bookmarks they create.
              //See http://bugzilla.songbirdnest.com/show_bug.cgi?id=4021

              // changed to loadNode from click as there are ways other than clicking
              // to get here.

              try {
                metrics_inc("app.servicepane.loadnode.bookmarks", node.url, null);
              } catch(e) { Components.utils.reportError(e); }
            }
            
          // If no URL, apply special handling
          } else {
            // If there is a media list for this node, hand it off to the 
            // browser to display somehow.
            // I'm told that this hack is fine, as it will one day be replaced
            // with the playlist commands system.
            var libraryServicePane = 
              Components.classes['@songbirdnest.com/servicepane/library;1']
              .getService(Components.interfaces.sbILibraryServicePaneService);
            var mediaList = libraryServicePane.getLibraryResourceForNode(node);
            if (mediaList) {
              const NS_SP = "http://songbirdnest.com/rdf/servicepane#";
              var view = LibraryUtils.createStandardMediaListView(mediaList);
              if (node.hasAttributeNS(NS_SP, "mediaListViewConstraints")) {
                // set up the constraints
                var builder = Cc["@songbirdnest.com/Songbird/Library/ConstraintBuilder;1"]
                                .createInstance(Ci.sbILibraryConstraintBuilder);
                try {
                  builder.parseFromString(node.getAttributeNS(NS_SP,
                                                              "mediaListViewConstraints"));
                  view.filterConstraint = builder.get();
                } catch (e) {
                  // boo, the constraints are bad, use standard instead
                  view.filterConstraint = LibraryUtils.standardFilterConstraint;
                }
              }
              var tab = this.browser.loadMediaList(mediaList,
                                                   event,
                                                   "_media",
                                                   view);
              this.browser.selectedTab = tab;

              // Record list type metrics for some reason.
              // See http://bugzilla.songbirdnest.com/show_bug.cgi?id=4021
              // changed to loadNode from click as there are ways other than clicking
              // to get here.
              try {
                var listType = mediaList.getProperty(SBProperties.customType);
                var libType = mediaList.library.getProperty(SBProperties.customType);
                metrics_inc("app.servicepane.loadnode.medialist", libType + "." + listType, null);
              } catch(e) { Components.utils.reportError(e); }

            } else {
              // we have no handler for this service pane node load
              // dispatch an event people can listen for and don't report
              let event = document.createEvent("XULCommandEvent");
              event.QueryInterface(Components.interfaces.nsIDOMXULCommandEvent);
              event.initCommandEvent("servicepane-loadnode",
                                     event.bubble,
                                     false,
                                     event.view,
                                     event.detail,
                                     event.ctrlKey,
                                     event.altKey,
                                     event.shiftKey,
                                     event.metaKey,
                                     event);
              this.dispatchEvent(event);
              
              var SP_NS = "http://songbirdnest.com/rdf/servicepane#";
              var eventType = node.getAttributeNS(SP_NS, "eventType");
              if (eventType) {
                var event = document.createEvent("UIEvent");
                event.initUIEvent(eventType, true, true, window, 0);
                window.dispatchEvent(event);
              }
            }
          }
        ]]></body>
      </method>
      <method name="isMediaTabURL">
        <parameter name="aURL"/>
        <body><![CDATA[
          if (!aURL) {
            return Components.results.NS_ERROR_INVALID_ARG;
          }
          if (!this.browser.mediaTab) {
            // no media tab, can't be a media tab url
            return false;
          }
          var url = aURL;
          if (aURL instanceof Components.interfaces.nsIURI) {
            url = aURL.spec;
          }
          if (!(/chrome:\/\//.test(url))) {
            // not chrome
            return false;
          }
          const PREF_FIRSTRUN_URL = "songbird.url.firstrunpage";
          if (url == Application.prefs.getValue(PREF_FIRSTRUN_URL, null)) {
            // first run url, sure this can be a media tab
            return true;
          }
          var node = this.mService.getNodeForURL(url);
          if (!node) return false;
          return true;
        ]]></body>
      </method>
      <!-- context menu helper -->
      <method name="_onContextMenu">
        <parameter name="event" />
        <body><![CDATA[
          // work out what tree node was clicked on
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX, event.clientY,
                             row, col, obj);

          // clear the popup menu
          while (this.mPopup.lastChild) {
            DOMUtils.destroyNode(this.mPopup.lastChild);
            this.mPopup.removeChild(this.mPopup.lastChild);
          }

          var node = this.getNodeForRow(row.value);
          if (node) {
            // ask the service to fill in the popup for this node
            this.mService.fillContextMenu(node.id, this.mPopup, window);
          } else {
            // hmm, fill the popup with the contents of the "new stuff" menu
            this.mService.fillNewItemMenu(null, this.mPopup, window);
          }

          // show the popup menu
          document.popupNode = null;
          this.mPopup.showPopup(document.documentElement,
                      event.screenX+5, event.screenY,
                      'context', null, null, null);

          // ensure the node is highlighted last to prevent select from being
          // fired before pop up is shown.
          if (node) {
            this.highlightNode(node);
          }

          event.stopPropagation();
          event.preventDefault();
        ]]></body>
      </method>
      <!-- enter/return keypress helper -->
      <method name="_onEnterKeypress">
        <parameter name="event"/>
        <body><![CDATA[
          if (this.mTree.hasAttribute("editing") ||
              !this.mTree.view) {
            var row = this.mTree._editingRow;
            var node = this.getNodeForRow(row);
            
            this.mTree.stopEditing(true);
   
            // Reselect and load the node since we'll lose
            // the selection when the tree rebuilds.
            this.selectAndLoadNode(node, event);
            this.mTree.focus();
            
            event.preventDefault();
            event.stopPropagation();
            return;
          }

          this.loadSelectedNode(event);
          event.preventDefault();
          event.stopPropagation();
        ]]></body>
      </method>
      <!-- drag-and-drop helpers -->
      <method name="_onDragGesture">
        <parameter name="event"/>
        <parameter name="node"/>
        <body>
          <![CDATA[
          var transferable = {};
          if (node && this.mService.onDragGesture(node.id, transferable)) {
            transferable = transferable.value;
            var transArray = Components.classes["@mozilla.org/supports-array;1"]
                                       .createInstance(Components.interfaces.nsISupportsArray);
            transArray.AppendElement(transferable);
            
            // Oh Lordy lordy, I'm so glad I could just steal this from 
            // nsDragAndDrop.js instead of having to write it myself.
            var region = null;
            if (event.originalTarget.localName == "treechildren") {
              // let's build the drag region
              var tree = event.originalTarget.parentNode;
              try {
                region = Cc["@mozilla.org/gfx/region;1"]
                          .createInstance(Ci.nsIScriptableRegion);
                region.init();
  
                var obo = tree.treeBoxObject;
                var bo = obo.treeBody.boxObject;
                var sel= obo.view.selection;
  
                region.unionRect(bo.x, (obo.rowHeight * sel.currentIndex + bo.y),
                                 bo.width, obo.rowHeight);
  
                //and finally, clip the result to be sure we don't spill over...
                region.intersectRect(bo.x, bo.y, bo.width, bo.height);
  
              } catch(ex) {
                dump("Error while building selection region: " + ex + "\n");
                region = null;
              }
            }
            
            var dragAction = this._dragService.DRAGDROP_ACTION_COPY +
                             this._dragService.DRAGDROP_ACTION_MOVE;
            this._dragService.invokeDragSessionWithImage(event.target, transArray,
                region, dragAction,
                null, 0, 0,
                event);
            
            event.preventDefault();
          }
        ]]>
        </body>
      </method>

      <method name="_onDragOver">
        <parameter name="event"/>
        <parameter name="aTree"/>
        <parameter name="aNode"/>
        <body>
          <![CDATA[
          var position = this.computeEventPosition(event, aTree, aNode);
          var element = position.element;
          // actually we want the treerow element which is the child
          element = element.childNodes[0];
          var node = position.node;
          var orientation = position.orientation;
  
          // make sure we are tracking the right element
          if (this._dragOverElement != element) {
            if (this._dragOverElement) {
              // we are now over another element - let us restore its properties
              this._dragOverElement.setAttribute('properties',
                  this._dragOverElement.getAttribute('savedproperties'));
              this._dragOverElement.removeAttribute('savedproperties');
            }
            // save the new element
            this._dragOverElement = element;
            // and save its properties
            element.setAttribute('savedproperties',
                element.getAttribute('properties'));
          }
  
          // set the property based on the orientation
          // the properties are chosen based on:
          //   http://developer.mozilla.org/en/docs/XUL_Tutorial:Styling_a_Tree
          var properties = '';
          if (orientation == -1) {
            properties = 'dropBefore';
          } else if (orientation == 1) {
            properties = 'dropAfter';
          } else {
            properties = 'dropOn';
          }
  
          // ask the backend if we are allowed to drop here
          if (!this.mService.canDrop(node.id,
              this._dragService.getCurrentSession(), orientation, window)) {
            // if not, do not set any visual properties
            properties = '';
            this._dragService.canDrop = false;
          } else {
            this._dragService.canDrop = true;
          }
  
          element.setAttribute('properties',
              element.getAttribute('savedproperties') + ' ' + properties);
          // we handle the drop, do not let the default dnd handler get the event
          event.stopPropagation();
        ]]>
        </body>
      </method>


      <!-- to trigger selection highlighting -->
      <method name="_highlightSelectedNode">
        <body>
          <![CDATA[
          try {
            // Is there a servicepane node for the current tab?
            var node = this._browser.selectedTab.servicePaneNode;
          
            if (node) {
              this.highlightNode(node);
            }
          } catch (e) {
            Components.utils.reportError(e); 
          }
        ]]>
        </body>
      </method>

      <!-- nsIXULBuilderListener -->
      <method name="willRebuild"/>
      <method name="didRebuild">
        <parameter name="aBuidler"/>
        <body>
          <![CDATA[
          this._highlightSelectedNode();
        ]]>
        </body>
      </method>

      <!-- nsIRDFObserver -->
      <method name="onAssert">
        <body>
          <![CDATA[
          this._highlightSelectedNode();
        ]]>
        </body>
      </method>
      <method name="onUnassert">
        <body>
          <![CDATA[
          this._highlightSelectedNode();
        ]]>
        </body>
      </method>
      <method name="onChange">
        <body>
          <![CDATA[
          this._highlightSelectedNode();
        ]]>
        </body>
      </method>
      <method name="onMove">
        <body/>
      </method>
      <method name="onBeginUpdateBatch">
        <body/>
      </method>
      <method name="onEndUpdateBatch">
        <body/>
      </method>
    </implementation>
    <handlers>
      <handler event="contextmenu"><![CDATA[
        if (this.mTree.hasAttribute("editing") ||
            !this.mTree.view) {
          this.mTree.stopEditing(true);
        }

        this._onContextMenu(event);
      ]]></handler>
      <handler event="select"><![CDATA[
        // don't handle select events for elements other than the tree (e.g.,
        // not for the cell edit textbox)
        if (event.originalTarget != this.mTree)
          return;

        // don't handle selection changes when the popup menu is open.
        if(this.mPopup.state != "closed") {
          return;
        }

        var node = this.getNodeForRow(this.mTree.currentIndex);

        // ask the service to notify the modules about selection changes
        this.mService.onSelectionChanged(node?node.id:null, this.mTree, window);
        
        event.preventDefault();
        event.stopPropagation();
      ]]></handler>
      <handler event="keypress" keycode="VK_ENTER" phase="capturing"><![CDATA[
        this._onEnterKeypress(event);
      ]]> </handler>
      <handler event="keypress" keycode="VK_RETURN" phase="capturing"><![CDATA[
        this._onEnterKeypress(event);
      ]]></handler>
      <handler event="mousedown" clickcount="1" button="0" phase="capturing"><![CDATA[
        // If the user is clicking on a non-loadable node in the servicepane
        // then suppress the event, otherwise let it pass through
        if (event.originalTarget.tagName == "treechildren") {
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX,
                                             event.clientY,
                                             row,
                                             col,
                                             obj);
          
          if ((obj.value != 'twisty') && (row.value >= 0)) {
            var node = this.getNodeForRow(row.value);
            if (!node || !this.isLoadableNode(node)) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      ]]></handler>
      <handler event="click" clickcount="1" button="0" phase="capturing"><![CDATA[
        if (event.originalTarget.tagName == "treechildren") {
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX,
                                             event.clientY,
                                             row,
                                             col,
                                             obj);

          if ((obj.value != 'twisty') && (row.value >= 0)) {
            var node = this.getNodeForRow(row.value);
            if (node) {
              if (this.isLoadableNode(node)) {
                this.selectAndLoadNode(node, event);
              }
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }        
      ]]></handler>
      <handler event="click" clickcount="1" button="1" phase="capturing"><![CDATA[
        if (event.originalTarget.tagName == "treechildren") {
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX,
                                             event.clientY,
                                             row,
                                             col,
                                             obj);

          if ((obj.value != 'twisty') && (row.value >= 0)) {
            var node = this.getNodeForRow(row.value);
            if (node) {
              this.selectAndLoadNode(node, event);
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }        
      ]]></handler>
      <handler event="mousedown" clickcount="1" button="2" phase="capturing"><![CDATA[
        // we have to suppress this event to avoid unwanted 'select' events
        // being fired from the base binding.
        event.preventDefault();
        event.stopPropagation();
      ]]></handler>
      <handler event="click" clickcount="1" button="2"><![CDATA[
        if (this.mTree.hasAttribute("editing") ||
            !this.mTree.view) {
          this.mTree.stopEditing(true);
        }

        this._onContextMenu(event);
      ]]></handler>
      <handler event="click" clickcount="2" button="0"><![CDATA[
        if (event.originalTarget.tagName == "treechildren") {
          var obj={}, row={}, col={};
          this.mTree.treeBoxObject.getCellAt(event.clientX,
                                             event.clientY,
                                             row,
                                             col,
                                             obj);

          // ensure the node that was clicked is selected and loaded and is the
          // one to be edited
          if ((obj.value != 'twisty') && (row.value >= 0)) {
            var node = this.getNodeForRow(row.value);
            if (node) {
              // Since we'll be manually selecting in this case
              // we have to suppress the 'select' event.
              if (this.isLoadableNode(node)) {
                this.mTree.view.selection.selectEventsSuppressed = true;
                this.selectAndLoadNode(node, event);
                this.mTree.view.selection.selectEventsSuppressed = false;
              } else {
                if (node.isContainer)
                  node.isOpen = !node.isOpen;
                  if (node.isOpen)
                    this._highlightSelectedNode();
              }
              
              if (node.editable)
                this.startEditingNode(node);

              event.preventDefault();
            }
          }
        }
      ]]></handler>

      <!-- drag and drop handling -->
      <handler event="draggesture"><![CDATA[
        // don't allow drag gestures with the popup menu open.
        if(this.mPopup.state != "closed") {
          return;
        }
        var row = { }
        var col = { }
        var child = { }
        this.mTree.treeBoxObject.getCellAt(event.pageX, event.pageY, row, col, child);
        if (col.value == null) {
          // not a valid column; e.g., the scrollbar
          return;
        }
        var node = this.getNodeForRow(row.value);
        
        this._onDragGesture(event, node);
      ]]></handler>
      <handler event="dragover"><![CDATA[
        this._onDragOver(event);
      ]]></handler>
      <handler event="dragenter"><![CDATA[
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
      <handler event="dragexit"><![CDATA[
        // if there is a highlighted element let us restore its state
        if (this._dragOverElement) {
          this._dragOverElement.setAttribute('properties',
              this._dragOverElement.getAttribute('oldproperties'));
          this._dragOverElement.removeAttribute('savedproperties');
          this._dragOverElement = null;
        }
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
      <handler event="dragdrop"><![CDATA[
        var position = this.computeEventPosition(event);
        var node = position.node;
        var orientation = position.orientation;
        var session = this._dragService.getCurrentSession();
        if (this.mService.canDrop(node.id, session, orientation, window)) {
          this.mService.onDrop(node.id, session, orientation, window);
        }
        this._dragService.endDragSession(true);
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
    </handlers>
  </binding>


  <binding id="proxyTreePane">
    <content>
      <tree xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
            flex="1" class="servicepane-tree" anonid="proxytree"
            datasources="rdf:null" ref="SB:Root"
            hidecolumnpicker="true" seltype="single"
            mousethrough="never"
            onclick="if (gServicePane) gServicePane.onProxyClick(event)"
            >
        <treecols>
          <treecol primary="true" flex="1"/>
        </treecols>
        <template>
          <rule>
            <conditions>
              <content uri="?start" />
              <member container="?start" child="?node" />
              <triple subject="?node"
                      predicate="http://home.netscape.com/NC-rdf#Name"
                      object="?name" />
              <triple subject="?node"
                      predicate="http://songbirdnest.com/rdf/servicepane#Hidden"
                      object="false" />
            </conditions>
            <bindings>
              <binding subject="?node"
                       predicate="http://home.netscape.com/NC-rdf#Icon"
                       object="?icon" />
              <binding subject="?node"
                       predicate="http://songbirdnest.com/rdf/servicepane#Open"
                       object="?open" />
              <binding subject="?node"
                       predicate="http://songbirdnest.com/rdf/servicepane#Properties"
                       object="?properties" />
            </bindings>
            <action>
              <treechildren flex="1" properties="dropOn">
                <treeitem open="true" uri="?node" nodeid="?node">
                  <treerow>
                    <treecell label="?name" src="?icon" properties="?properties"/>
                  </treerow>
                </treeitem>
              </treechildren>
            </action>
          </rule>
        </template>
      </tree>
    </content>
    <implementation>
      <field name="_tree">
        document.getAnonymousElementByAttribute(this, 'anonid', 'proxytree');
      </field>
      <field name="_servicepane">gServicePane</field>
      <field name="_treepane">this._servicepane.mTreePane</field>
      <field name="_service">
        Components.classes['@songbirdnest.com/servicepane/service;1']
                  .getService(Components.interfaces.sbIServicePaneService);
      </field>
      <field name="_dragService">
        Components.classes['@mozilla.org/widget/dragservice;1']
                  .getService(Components.interfaces.nsIDragService);
      </field>
      <method name="getNodeForRow">
        <parameter name="row" />
        <body><![CDATA[
          if (row < 0) {
            return null;
          }

          // If this is a dont-build-content tree, use this:
          //var id = this.mTree.builderView.getResourceAtIndex(row).Value;

          var element = this._tree.contentView.getItemAtIndex(row);
          if (element && element.hasAttribute('nodeid')) {
            return this._service.getNode(element.getAttribute('nodeid'));
          } else {
            return null;
          }
        ]]></body>
      </method>
    </implementation>
    <handlers>
      <handler event="draggesture"><![CDATA[
        var row = { }
        var col = { }
        var child = { }
        this._tree.treeBoxObject.getCellAt(event.pageX, event.pageY, row, col, child);
        if (col.value == null) {
          // not a valid column; e.g., the scrollbar
          return;
        }
        var node = this.getNodeForRow(row.value);
        this._treepane._onDragGesture(event, node);
      ]]></handler>
      <handler event="dragover"><![CDATA[
        var row = { }
        var col = { }
        var child = { }
        this._tree.treeBoxObject.getCellAt(event.pageX, event.pageY, row, col, child);
        if (col.value == null) {
          // not a valid column; e.g., the scrollbar
          return;
        }
        var node = this.getNodeForRow(row.value);
        this._treepane._onDragOver(event, this._tree, node);
      ]]></handler>
      <handler event="dragenter"><![CDATA[
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
      <handler event="dragexit"><![CDATA[
        // if there is a highlighted element let us restore its state
        if (this._treepane._dragOverElement) {
          this._treepane._dragOverElement.setAttribute('properties',
              this._treepane._dragOverElement.getAttribute('oldproperties'));
          this._treepane._dragOverElement.removeAttribute('savedproperties');
          this._treepane._dragOverElement = null;
        }
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
      <handler event="dragdrop"><![CDATA[
        var row = { }
        var col = { }
        var child = { }
        this._tree.treeBoxObject.getCellAt(event.pageX, event.pageY, row, col, child);
        if (col.value == null) {
          // not a valid column; e.g., the scrollbar
          return;
        }
        var node = this.getNodeForRow(row.value);
        var position = this._treepane.computeEventPosition(event, this._tree, node);
        node = position.node;
        var orientation = position.orientation;
        var session = this._dragService.getCurrentSession();
        if (this._service.canDrop(node.id, session, orientation, window)) {
          this._service.onDrop(node.id, session, orientation, window);
        }
        this._dragService.endDragSession(true);
        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
    </handlers>
  </binding>

  <binding id="toolbar">
    <content>
      <!-- Service Pane Button Bar, Buttons for adding a new service or playlist-->
      <!-- For now just hijacking the file menu implementation.. -->
      <!-- TODO: over state, up arrow, remove periods from all IDs -->
      <xul:hbox id="servicepane_toolbar_box" class="servicepane-toolbar-box">
        <xul:button class="servicepane-toolbar-newitem-button"
                    tooltiptext="&tooltip.servicepane.newnode;"
                    anonid="clickhold" flex="1" type="sb-clickhold">
          <xul:menupopup anonid="popup" popupanchor="topleft" popupalign="bottomleft"/>
        </xul:button>
      </xul:hbox>
    </content>
    <implementation>
      <constructor><![CDATA[
        var service = Components.classes['@songbirdnest.com/servicepane/service;1']
          .getService(Components.interfaces.sbIServicePaneService);
        this._service = service;
        
        this._dragService = Cc['@mozilla.org/widget/dragservice;1']
                            .getService(Ci.nsIDragService);
        
        
        this._clickHold = document.getAnonymousElementByAttribute(this, 'anonid', 'clickhold');
        this._popup     = document.getAnonymousElementByAttribute(this, 'anonid', 'popup');
        
        service.fillNewItemMenu(null, this._popup, window);
        
        // Make the button look like the first item in the list.
        var item = this._popup.firstChild;
        if (!item) {
          /* bad news */
          return;
        }
        
        this._clickHold.setAttribute('label', item.getAttribute('label'));
        // FIXME: this is needed for styling but sucks
        this._clickHold.setAttribute('id', item.getAttribute('id'));

      ]]></constructor>
      <field name="_clickHold">null</field>
    </implementation>
    <handlers>
      <handler event="command"><![CDATA[
        /**
         * NOTE: _DO NOT_ copy this code.  If you find that this is useful
         * elsewhere, _move_ this to some place generic and can be reused.
         */

        if (event.originalTarget.parentNode == this._popup) {
          // the event was heading for a menu item
          return;
        }
        // this wasn't heading to any of our children - let's find the best fit
        // defined as the first menu item with all of the specified modifiers
        // pressed with the greatest number of modifiers given
        var modifiers = {"": true};
        if (event.altKey)
          modifiers["alt"] = true;
        if (event.shiftKey)
          modifiers["shift"] = true;
        if (event.ctrlKey)
          modifiers["ctrl"] = true;
        if (event.metaKey)
          modifiers["meta"] = true;

        var kKeyCodeToName = {};
        kKeyCodeToName[KeyEvent.DOM_VK_CONTROL] = "ctrl";
        kKeyCodeToName[KeyEvent.DOM_VK_ALT] = "alt";
        kKeyCodeToName[KeyEvent.DOM_VK_SHIFT] = "shift";
        kKeyCodeToName[KeyEvent.DOM_VK_META] = "meta";

        var accelKey = Application.prefs.getValue("ui.key.accelKey", -1);
        if (kKeyCodeToName[accelKey] in modifiers) {
          modifiers["accel"] = true;
        }
        var accessKey = Application.prefs.getValue("ui.key.chromeAccess", -1);
        if (accessKey == -1) {
          accessKey = Application.prefs.getValue("ui.key.generalAccessKey", -1);
        }
        if (accessKey in kKeyCodeToName &&
            kKeyCodeToName[accessKey] in modifiers)
        {
          modifiers["access"] = true;
        }
        
        // modifiers is now a set of modifiers that have been pressed.
        // now keep an array of matched popups; the index is the number of matching
        // modifier keys, and the value is the first menupopup to match
        var matches = [];
        
        for (var popup = this._popup.firstChild; popup; popup = popup.nextSibling) {
          var matchCount = 0;
          for each (var modifier in popup.getAttribute("modifiers").split(/\s+/)) {
            if (!(modifier in modifiers)) {
              // this modifier is not pressed
              matchCount = Number.NEGATIVE_INFINITY;
              break;
            } else if ("" != modifier) {
              ++matchCount;
            }
          }
          if (matchCount >= 0 && !(matchCount in matches)) {
            matches[matchCount] = popup;
          }
        }
        
        var selectedPopup = matches[matches.length - 1];
        if (selectedPopup) {
          var newEvent = document.createEvent("XULCommandEvent");
          newEvent.initCommandEvent(event.type, event.bubbles, event.cancelable,
                                    event.view, event.detail, event.ctrlKey,
                                    event.altKey, event.shiftKey, event.metaKey,
                                    (event.sourceEvent || event));
          return selectedPopup.dispatchEvent(newEvent);
        }
      ]]></handler>
      <handler event="dragenter"><![CDATA[
        var session = this._dragService.getCurrentSession();
        
        var supported = DNDUtils.isSupported(session,
          ["application/x-sb-transfer-media-list",
           "application/x-sb-transfer-media-items"]);
        if (supported) {
          var element = this._clickHold;
          this._dragService.canDrop = true;
          element.setAttribute("dropon", "true");

          // we handle the drop, do not let the default dnd handler get the event
          event.stopPropagation();
        }
      ]]></handler>
      <handler event="dragexit"><![CDATA[
        var element = this._clickHold;
        element.removeAttribute("dropon");

        // we handle the drop, do not let the default dnd handler get the event
        event.stopPropagation();
      ]]></handler>
      <handler event="dragdrop"><![CDATA[
  try {
    var element = event.target;
    
    var session = this._dragService.getCurrentSession();
    
    // Note that this is called by our tree observer
    var dnd = Cc["@songbirdnest.com/Songbird/DndSourceTracker;1"]
                .getService(Ci.sbIDndSourceTracker);
  
    // handle mediaitem drops
    var data = DNDUtils.getTransferDataForFlavour("application/x-sb-transfer-media-list",
                                              session);
    if (data) {
      var context = dnd.getSourceSupports(data)
                       .QueryInterface(Ci.sbIMediaListTransferContext);
      
      var mediaList = SBNewPlaylist();
      mediaList.addAll(context.list);

      event.stopPropagation();
      return;
    }
  
    data = DNDUtils.getTransferDataForFlavour("application/x-sb-transfer-media-items",
                                              session);
    if (data) {
      var context = dnd.getSourceSupports(data)
                       .QueryInterface(Ci.sbIMediaItemsTransferContext);

      var mediaList = SBNewPlaylist();
      mediaList.addSome(context.items);

      event.stopPropagation();
      return;
    }

    // handle external drops
    var dropHandlerListener = {
      onDropComplete: function(aTargetList,
                               aImportedInLibrary,
                               aDuplicates,
                               aInsertedInMediaList,
                               aOtherDropsHandled) { 
        // show the standard report on the status bar
        return true;
      },
      onFirstMediaItem: function(aTargetList, aFirstMediaItem) {}
    };

    var mediaList = SBNewPlaylist();
    var position = 0;
    ExternalDropHandler.dropOnList(window, 
                                   session, 
                                   mediaList, 
                                   position, 
                                   dropHandlerListener);
    
    event.stopPropagation();
  } catch(e) { Components.utils.reportError(e); }
      ]]></handler>
    </handlers>
  </binding>

</bindings>
