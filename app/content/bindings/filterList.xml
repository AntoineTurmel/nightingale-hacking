<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
//
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2008 POTI, Inc.
// http://songbirdnest.com
//
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
//
// Software distributed under the License is distributed
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either
// express or implied. See the GPL for the specific language
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
//
// END SONGBIRD GPL
//
 */
-->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="filterlist">
    <content>
      <xul:hbox id="sb-filterlist" class="filterlist" flex="1" xbl:inherits="class">
        <xul:tree
          id="sb-filterlist-tree"
          class="sb-filterlist-tree"
          sbid="filter_tree"
          flex="1"
          onselect="_onFilterListSelect(event);"
          ondblclick="_onFilterListDblClick(event);"
          enableColumnDrag="false"
          xbl:inherits="class,enableColumnDrag,hidecolumnpicker"
        >
          <xul:treecols sbid="treeColumns" xbl:inherits="class"/>
          <xul:treechildren/>
        </xul:tree>
      </xul:hbox>
    </content>

    <implementation type="application/x-javascript" name="songbird_filterlist" implements="sbICascadeFilterSetListener,sbILocalDatabaseTreeViewListener">

      <constructor>
      </constructor>

      <destructor>
<![CDATA[
  if (this._isBound) {
    this.cfs.removeListener(this);
    
    this.tree.view.removeListener(this);

    // Force the tree to forget about the view.  This is required in the case
    // where we are going to immediately load a new tree using the same view.
    // When this happens nsTreeBodyFrame will get a Destroy() call *after*
    // the new tree is loaded, causing the view to be reset.
    // See Bug 8001 for details.
    this.tree.view = null;
    this.tree = null;
  }
]]>
      </destructor>

      <field name="tree">document.getAnonymousElementByAttribute(this, 'sbid', 'filter_tree');</field>

      <!-- The filter set this filter is part of -->
      <field name="cfs">null</field>

      <!-- The index of the filter within the set -->
      <field name="index">null</field>

      <!-- Property and property info this filter list is filtering -->
      <field name="_property">null</field>
      <field name="_propertyInfo">null</field>

      <!-- If this filterlist is bound to anything -->
      <field name="_isBound">false</field>

      <field name="_XUL_NS" readonly="true">
        "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
      </field>
      <field name="_Cc"     readonly="true">Components.classes</field>
      <field name="_Ci"     readonly="true">Components.interfaces</field>
      <field name="_Cr"     readonly="true">Components.results</field>

      <method name="bind">
        <parameter name="cfs"/>
        <parameter name="index"/>
        <body>
<![CDATA[
  if (this._isBound) {
    throw new Error("already bound");
  }
  this.setAttribute("sbtype", "filterlist");
  this.cfs = cfs;
  this.index = index;
  this._property = cfs.getProperty(index);
  this.tree.view = cfs.getTreeView(index);
  this.tree.view.addListener(this);

  // Get the property info for the property
  var pm = this._Cc["@songbirdnest.com/Songbird/Properties/PropertyManager;1"]
                   .getService(this._Ci.sbIPropertyManager);
  this._propertyInfo = pm.getPropertyInfo(this._property);

  // Add the column for the property to the tree
  var treeColumns = document.getAnonymousElementByAttribute(this, "sbid", "treeColumns");
  
  while (treeColumns.lastChild) 
    treeColumns.removeChild(treeColumns.lastChild);

  var treecol = document.createElementNS(this._XUL_NS, "treecol");
  treecol.setAttribute("bind", this._property);
  treecol.setAttribute("flex", "1");
  treecol.setAttribute("sortDirection", "ascending");
  treeColumns.appendChild(treecol);
  this.treecol = treecol;

  this._updateColumnLabel(this.index);
  
  // Remove our selection if we are updated
  this.cfs.addListener(this);
  this._isBound = true;
]]>
        </body>
      </method>

      <method name="changeProperty">
        <parameter name="property"/>
        <body>
          <![CDATA[
            // if nothing changed, do not actually do anything
            if (this._property == property)
              return;
              
            this._property = property;

            this.cfs.changeFilter(this.index, property);
            this.tree.view = this.cfs.getTreeView(this.index);

            // Get the property info for the property
            var pm = this._Cc["@songbirdnest.com/Songbird/Properties/PropertyManager;1"]
                            .getService(this._Ci.sbIPropertyManager);
            this._propertyInfo = pm.getPropertyInfo(this._property);

            // get columns parent
            var treeColumns = document.getAnonymousElementByAttribute(this, "sbid", "treeColumns");

            // Remove old column
            while (treeColumns.lastChild)
              treeColumns.removeChild(treeColumns.lastChild);
              
            // create dummy column
            var treecol = document.createElementNS(this._XUL_NS, "treecol");
            treecol.setAttribute("label", "...");
            treecol.setAttribute("flex", "1");
            treeColumns.appendChild(treecol);
            
            this._changingProperty = true;
          ]]>
        </body>
      </method>

      <method name="_saveCascadeFilterState">
        <body>
          <![CDATA[
            var array = [];
            for ( var i = 0, end = this.cfs.length; i < end; i++ ) {
              var property = this.cfs.getProperty(i);
              if ( property.length > 0 )
                array.push( property );
            }
            var serialize = array.join(";");
            SBDataSetStringValue( "library.filterset", serialize );
          ]]>
        </body>
      </method>

      <method name="_updateColumnLabel">
        <body>
          <![CDATA[
            var n = this.cfs.getValueCount(this.index, true); 
            var itemsstr;
            switch (n) {
              case 0:
                itemsstr = SBString("library.noitem", "no items");
                break;
              case 1:
                itemsstr = n + " " + SBString("library.oneitem", "item");
                break;
              default:
                itemsstr = n + " " + SBString("library.manyitem", "items");
                break;
            }
            this.treecol.setAttribute("label", this._propertyInfo.displayName + " (" + itemsstr + ")");
          ]]>
        </body>
      </method>
      
      <method name="_onFilterListSelect">
        <parameter name="event"/>
        <body>
<![CDATA[
  var ldbtv = this.tree.view.QueryInterface(this._Ci.sbILocalDatabaseTreeView);
  if (ldbtv.selectionChanging) {
    return;
  }

  var count = this.cfs.getValueCount(this.index, true);
  var sel = this.tree.view.selection;
  var values = [];
  var rangeCount = sel.getRangeCount();
  for (var i = 0; i < rangeCount; i++) {
    var min = {};
    var max = {};
    sel.getRangeAt(i, min, max);

    // If the "all" row is selected, clear the values for this filter
    if (min.value == 0) {
      this.cfs.set(this.index, [], 0);
      return;
    }

    for (var j = min.value; j <= max.value; j++) {
      // The actual number of rows in the view can lag behind the number of
      // rows in the tree, so make sure we don't select those
      if (j - 1 < count) {
        var value = this.cfs.getValueAt(this.index, j - 1);
        values.push(value);
      }
    }
  }
  this.cfs.set(this.index, values, values.length);
]]>
        </body>
      </method>

      <method name="_onFilterListDblClick">
        <body>
          <![CDATA[
           // Send a play event and hope someone cares
           var event = document.createEvent("Events");
           event.initEvent("Play", true, true);
           this.dispatchEvent(event);
          ]]>
        </body>
      </method>
      
      <method name="onChange">
        <body>
<![CDATA[
  // do nothing
]]>
        </body>
      </method>

      <method name="onValuesChanged">
        <parameter name="aIndex"/>
        <body>
<![CDATA[
  if (aIndex == this.index) {
    this._updateColumnLabel();
  }
]]>
        </body>
      </method>

      <method name="onRebuild">
        <body>
          <![CDATA[
            // do nothing
          ]]>
        </body>
      </method>

      <method name="didRebuild">
        <body>
          if (this._changingProperty) {
            this._changingProperty = false;

            var treeColumns = document.getAnonymousElementByAttribute(this, "sbid", "treeColumns");

            // Remove dummy column
            while (treeColumns.lastChild)
              treeColumns.removeChild(treeColumns.lastChild);

            // Add real column
            var treecol = document.createElementNS(this._XUL_NS, "treecol");
            treecol.setAttribute("bind", this._property);
            treecol.setAttribute("sortDirection", "ascending");
            treecol.setAttribute("sortActive", "true");
            treecol.setAttribute("flex", "1");
            treeColumns.appendChild(treecol);
            this.treecol = treecol;

            this._updateColumnLabel(this.index);
            this._saveCascadeFilterState();
          }
          
          //XXXlone - remove this when bug 8015 is closed

          // When there is a selection on this filterlist, and the user removes
          // all the resulting mediaitems from his playlist widget, all previously
          // selected items in the filterlist disapear automatically, and we
          // want to reselect the ALL item. This is supposed to happen automatically
          // but does not because the check for this condition relies on testing
          // whether the selection is empty or not (in sbFilterTreeSelection::CheckIsSelectAll),
          // although that happens before the selection is actually cleared (in 
          // sbLocalDatabaseTreeView::OnGetGuidByIndex). The fix for now, until
          // bug 8015 is closed, is to cause a call to CheckIsSelectAll to occur again
          // by calling adjustSelection with benign values (as soon as possible, since 
          // the selection will be cleared right when we return from here). If after that call, 
          // the selection is cleared, it's because the ALL item was reselected. 
          // In this case, empty the filter.
          
          var curIndex = this.tree.view.selection.currentIndex;
          // if we are already on ALL, there is no need for any of this.
          if (curIndex != 0) {
            setTimeout(function(o) {
              o.tree.view.selection.adjustSelection(-1, 0);
              var newIndex = o.tree.view.selection.currentIndex;
              if (newIndex == 0) {
                o.cfs.set(o.index, [], 0);
              }
            }, 0, this);
          }
        </body>
      </method>

    </implementation>

  </binding>

  <binding id="columnpicker" display="xul:button"
           extends="chrome://global/content/bindings/tree.xml#tree-base">
    <content>
      <xul:image class="tree-columnpicker-icon"/>
      <xul:menupopup anonid="popup">
      </xul:menupopup>
    </content>
    <implementation>
      <method name="buildPopup">
        <parameter name="aPopup"/>
        <body>
          <![CDATA[
            while (aPopup.childNodes.length)
              aPopup.removeChild(aPopup.firstChild);

            var refChild = aPopup.firstChild;

            // look for the filterlist that owns us
            var node = this;
            while (node && node.getAttribute("sbtype") != "filterlist")
              node = node.parentNode;
            var filterlist = node;

            // Get the property info for the property
            var pm = Components.classes["@songbirdnest.com/Songbird/Properties/PropertyManager;1"]
                            .getService(Components.interfaces.sbIPropertyManager);

            var cm = Components.classes["@mozilla.org/categorymanager;1"]
                               .getService(Components.interfaces.nsICategoryManager);
            var propEnumerator = cm.enumerateCategory("filter-list-picker-properties");
            var props = [];
            while (propEnumerator.hasMoreElements()) {
              var propertyID = propEnumerator.getNext()
                                             .QueryInterface(Components.interfaces.nsISupportsCString);
              props.push(pm.getPropertyInfo(propertyID));
            }

            props.sort(function(a, b) {
              if (a.displayName < b.displayName) {
                return -1;
              }
              else if (a.displayName > b.displayName) {
                return 1;
              }
              else {
                return 0;
              }
            });

            for (var i = 0; i < props.length; i++) {
              var propertyInfo = props[i];

              if (propertyInfo.userViewable) {
                var popupChild = document.createElement("menuitem");
                
                popupChild.setAttribute("type", "checkbox");
                popupChild.setAttribute("label", propertyInfo.displayName);
                popupChild.setAttribute("property", propertyInfo.id);
                popupChild.setAttribute("type", "radio");
                
                if (propertyInfo.id == filterlist._property)
                    popupChild.setAttribute("checked", "true");
                    
                aPopup.insertBefore(popupChild, refChild);
              }
            }
          ]]>
        </body>
      </method>
    </implementation>

    <handlers>
      <handler event="command">
        <![CDATA[
          if (event.originalTarget == this) {
            var popup = document.getAnonymousElementByAttribute(this, "anonid", "popup");
            this.buildPopup(popup);
            popup.showPopup(this, -1, -1, "popup", "bottomright", "topright");
          }
          else {
            // look for the filterlist that owns us
            var node = this;
            while (node && node.getAttribute("sbtype") != "filterlist")
              node = node.parentNode;
            var filterlist = node;

            filterlist.changeProperty(event.originalTarget.getAttribute("property"));
          }
        ]]>
      </handler>
    </handlers>

  </binding>

</bindings>


