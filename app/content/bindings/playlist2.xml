<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
//
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
//
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
//
// Software distributed under the License is distributed
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either
// express or implied. See the GPL for the specific language
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
//
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE window SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="playlist2">
    <content>
      <stack flex="1" xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
      <vbox sbid="loading_box" pack="end" align="right" flex="1" class="sb_faceplate">
          <vbox id="loading_box" class="sb_faceplate" flex="1">
            <label id="loading_text" flex="1" value=""/>
          </vbox>
        </vbox>
        <vbox flex="1" class="sb_faceplate" style="margin: 0px;padding: 0px;">
          <!-- Playlist Filters -->
          <hbox sbid="filter_parent" style="min-height: 60px;" flex="1" hidden="false">
          </hbox>

          <sb-smart-splitter
            id="horz_splitter"
            sbid="filter_splitter"
            state="open"
            collapse="before"
            resizebefore="closest"
            resizeafter="closest"
            hidden="true"
            metricscategory="player"
            metricsid="collapse.library"
          >
            <grippy/>
          </sb-smart-splitter>

          <!--
            onscroll="onPlaylistScroll( event );"
            -->
          <!-- Playlist Tree -->
          <tree
            xbl:inherits="enableColumnDrag=enableColumnDrag,hidecolumnpicker=hidecolumnpicker"
            id="playlist_tree"
            sbid="playlist_tree"
            flex="3"
            onselect="_onPlaylistSelectClick(event);"
            onclick="_onPlaylistClick(event);"
            ondblclick="_onPlaylistDblClick(event);"
            oncontextmenu="_onPlaylistContextClick(event);"
            onkeypress="_onPlaylistKeypress(event);"
          >
            <treecols sbid="treecols"/>
            <treechildren/>
          </tree>

          <!-- Playlist Toolbar -->
          <hbox id="playlist_toolbar_bkg" sbid="playlist_toolbar">
            <hbox id="playlist_toolbar" sbid="toolbar_parent" flex="1" oncommand="onToolbarCommand( event )" style="overflow: hidden;">
            </hbox>
          </hbox>

          <!-- Popupset -->
          <popupset>
            <!-- Context Popup -->
            <popup
              id="playlist_context_popup"
              sbid="playlist_context_popup"
              onpopupshown="onPopupShown( event );"
              onpopuphidden="onPopupHidden( event );"
              oncommand="onPlaylistContextMenu( event );"
            >
              <menuseparator id="playlist_context_before" sbid="playlist_context_before"/>
              <menu id="playlist.context.search" label="&playlist.context.search;">
                <menupopup id="playlist.popup.search">
                  <menuitem id="search_popup_term" sbid="search_popup_term" label="" disabled="true"/>
                  <menuseparator/>
                  <menuitem id="search.popup.dogpile"
                    label="dogpile" class="menuitem-iconic" image="chrome://service-icons/skin/dogpile.ico"
                />
                  <menuitem id="search.popup.elbows"
                    label="elbo.ws" class="menuitem-iconic" image="chrome://service-icons/skin/elbows.ico"
                />
                  <menuitem id="search.popup.mefeedia"
                    label="mefeedia" class="menuitem-iconic" image="http://www.mefeedia.com/favicon.ico"
                />
                  <menuitem id="search.popup.google"
                    label="Google" class="menuitem-iconic" image="chrome://service-icons/skin/google.ico"
                />
                  <menuitem id="search.popup.yahoo"
                    label="Yahoo!" class="menuitem-iconic" image="chrome://service-icons/skin/yahoo.ico"
                />
                  <menuitem id="search.popup.wiki"
                    label="Wikipedia" class="menuitem-iconic" image="chrome://service-icons/skin/default.ico"
                />
                  <menuitem id="search.popup.emusic"
                    label="eMusic" class="menuitem-iconic" image="chrome://service-icons/skin/emusic.ico"
                />
<!--                  <menuitem id="search.popup.creativecommons"
                    label="Creative Commons" class="menuitem-iconic" image="http://creativecommons.org/favicon.ico"
                /> -->
                </menupopup>
              </menu>
              <menu id="playlist.context.lyrics" label="&playlist.context.lyrics;">
                <menupopup id="playlist.popup.lyrics">
                  <menuitem id="lyrics_popup_term" sbid="lyrics_popup_term" label="" disabled="true"/>
                  <menuseparator/>
                  <menuitem id="lyrics.popup.google"
                    label="Google" class="menuitem-iconic" image="chrome://service-icons/skin/google.ico"
                  />
                </menupopup>
              </menu>
              <children/>
            </popup>
          </popupset>
        </vbox>
        </stack>
        </content>

    <implementation type="application/x-javascript" name="songbird_playlist2">

      <constructor>
<![CDATA[
  // Set up the columns
  this._setupColumns();

  // Attach event handler closures
  var self = this;

  // Attach a attribute modified event handler to the treecols element.  This
  // allows us to be notified when the user drags a column (the "dragging"
  // attribute on a child element is set and it then removed) or when one is
  // resized (the width attribute changes) or when a column is hidden/shown
  // (the "hidden" attribute changes).  Save the column spec attributes when\
  // this happens.
  this._onColumnMutationClosure = function(event) {
    self._onColumnMutation(event);
  };
  this._treecols.addEventListener("DOMAttrModified",
                                  this._onColumnMutationClosure,
                                  false);

]]>

<!--        
        <![CDATA[
      try
      {
        // Load the javascript we want to use
        var jsLoader = Components.classes["@mozilla.org/moz/jssubscript-loader;1"].getService(Components.interfaces.mozIJSSubScriptLoader);
        jsLoader.loadSubScript( "chrome://songbird/content/scripts/songbird_interfaces.js", this );
        jsLoader.loadSubScript( "chrome://songbird/content/scripts/messagebox.js", this );
        jsLoader.loadSubScript( "chrome://songbird/content/scripts/dragAndDrop.js", this );
        jsLoader.loadSubScript( "chrome://global/content/nsDragAndDrop.js", this );
        jsLoader.loadSubScript( "chrome://global/content/nsTransferable.js", this );

        // register to get the willRebuild and didRebuild messages
        this.tree.builder.addListener(this);

        // These are all the possible column ids whose cell content we can use as unique ids (for saveSelection/restoreSelection)
        this._selection_key_array = Array("id", "uuid", "playlist_uuid", "playlist_id", "row_id");

        this._lastviewsummary = "";
        this.lastfiltersstate = "open";

        this.bindDataRemotes();
        if ( this._constructed ) dump("playlist.xml - constructor - THIS SHOULD NEVER GET CALLED\n"); // ???
        this._constructed = true; // ???

        this._onFilterDblClickClosure = function(event) {
          self.onFilterDblClick(event);
        };
        this._onPlaylistDblClickClosure = function(event) {
          self.onPlaylistDblClick(event);
        };
        this._onDragClosure = function(event) {
          self.onDrag(event);
        };
        this.addEventListener("dblclick", this._onPlaylistDblClickClosure, false);
        this.addEventListener("draggesture", this._onDragClosure, false);

        var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"].getService(Components.interfaces.nsIStringBundleService);
        var songbirdStrings = sbs.createBundle("chrome://songbird/locale/songbird.properties");
        this.str_tracksaddedto = "tracks added to"
        this.str_trackaddedto = "track added to"
        this.str_notracksaddedto = "No tracks added to"
        this.str_library = "Library";
        this.str_playlist = "Playlist";
        this.str_trackalreadypresent = "track already present";
        this.str_tracksalreadypresent = "tracks already present";
        try {
          this.str_tracksaddedto = songbirdStrings.GetStringFromName("library.tracksaddedto");
          this.str_trackaddedto = songbirdStrings.GetStringFromName("library.trackaddedto");
          this.str_notracksaddedto = songbirdStrings.GetStringFromName("library.notracksaddedto");
          this.str_trackalreadypresent = songbirdStrings.GetStringFromName("library.trackalreadypresent");
          this.str_tracksalreadypresent = songbirdStrings.GetStringFromName("library.tracksalreadypresent");
          this.str_library = songbirdStrings.GetStringFromName("library");
          this.str_playlist = songbirdStrings.GetStringFromName("playlist");
        } catch (err) { /* ignore error, we have default strings */ }
      }
      catch ( err )
      {
        dump( "playlist.xml - constructor - " + err );
      }
      ]]>
-->
      </constructor>

      <destructor>
<![CDATA[
  // Remove event listeners
  this._treecols.removeEventListener("DOMAttrModified",
                                     this._onColumnMutationClosure,
                                      false);
]]>
      <!--
      <![CDATA[
/*
        //SB_LOG("playlist.xml", "destroying [" + this.ref + "]");
      try {
        if ( ! this._constructed )
        {
          dump("playlist.xml - destructor - THIS SHOULD NEVER GET CALLED\n");
          return; // ???
        }

        var e = document.createEvent("Events");
        e.initEvent("playlist-destroy", false, true);
        this.dispatchEvent(e);

        for (var s=0;s<this.splitters.length;s++) {
          this.splitters[s].removeEventListener("mousemove", this.onFilterSplitterMove, true);
          this.splitters[s].removeEventListener("mousedown", this.onFilterSplitterDown, true);
          this.splitters[s].removeEventListener("mouseup", this.onFilterSplitterUp, true);
        }
        this.splitters = null;

        // no more didRebuild/willRebuild messages
        if (this.tree.builder)
          this.tree.builder.removeListener(this);

        // remove ourself from watching the tree's view (toggle state, selection notification... )
        if (this.tree.view && this.addedObserver) {
          this.tree.view.removeObserver(this);
          this.addedObserver = false;
        }

        if (this.m_dndSourceTracker)
          this.m_dndSourceTracker.unregisterDnDSource(this);

        // detach mouse listeners from drag list
        this.stopWatchingDragObjects();

        // detach from the DataRemote
        this.unbindDataRemotes();

        this._constructed = false; // ???
        this.m_queryObj = null;
        this._commands = null;

        this.removeEventListener("dblclick", this._onPlaylistDblClickClosure, false);
        this.removeEventListener("draggesture", this._onDragClosure, false);

        for(var i=0;i<this.filters.length;i++) {
          var filter = this.filters[i];
          filter.removeEventListener("dblclick", this._onFilterDblClickClosure, true);
          filter.removeEventListener("filterlist-filterchange", this.sendFilterChangeEvent, true);
        }
        this._onPlaylistDblClickClosure = null;
        this._onDragClosure - null;
        this._onFilterDblClickClosure = null;

      } catch (err) {
        dump("playlist.xml - destructor: " + err + "\n");
      }
*/
      ]]>
-->
      </destructor>

      <!-- The media list view this playlist is showing -->
      <field name="mediaListView">null;</field>

      <!-- The anonymous xul tree element -->
      <field name="tree" readonly="true">
        document.getAnonymousElementByAttribute(this, "sbid", "playlist_tree");
      </field>

      <!-- Holds the text value of the cell that was right clicked -->
      <field name="context_term">""</field>

      <!-- Store the last clicked row and column so we know which cell to edit
           when we are asked to start an edit -->
      <field name="edit_row">0;</field>
      <field name="edit_col">0;</field>

      <!-- Last click time and row index.  This is used to time the slow click
           to inline edit -->
      <field name="_lastClickIndex">0</field>
      <field name="_lastClickTimestamp">0</field>

      <!-- Sortcuts for various anonymous elements -->
      <field name="_context_popup" readonly="true">
        document.getAnonymousElementByAttribute(this, "sbid", "playlist_context_popup");
      </field>
      <field name="_loading_box" readonly="true">
        document.getAnonymousElementByAttribute(this, "sbid", "loading_box");
      </field>
      <field name="_treecols" readonly="true">
        document.getAnonymousElementByAttribute(this, "sbid", "treecols");
      </field>

      <field name="_toolbarbuttons">new Array();</field>
      <field name="_menuitems">new Array();</field>

      <!-- Cached reference to the Songbird string bundle -->
      <field name="_stringbundle">null;</field>
      <field name="_commands">null;</field>

      <!-- Coordinates of the last shown content menu popup -->
      <field name="_context_x">-1</field>
      <field name="_context_y">-1</field>

      <!--
      <field name="context_item"></field>
      <field name="popup_showing">false</field>
      <field name="guid">""</field>
      <field name="table">""</field>
      <field name="type">""</field>
      <field name="base_type">""</field>
      <field name="description">""</field>
      <field name="readable_name">""</field>
      <field name="filters">new Array();</field>
      <field name="splitters">new Array();</field>
      <field name="m_Library">null</field>
      <field name="m_PlaylistManager">null</field>
      <field name="source">null</field>
      <field name="_saved_selection">null</field>
      <field name="_saved_nitems">null</field>
      <field name="_dragobjects">null</field>
      <field name="_selection_key">""</field>
      <field name="_selection_key_array">""</field>
      <field name="restoring_selection">false</field>
      <field name="_addto_added_count">0</field>
      <field name="_addto_existed_count">0</field>
      <field name="m_dndSourceTracker">null</field>
      <field name="paused_scanning">false</field>
      <field name="sortorder">""</field>
      <field name="sortdirection">""</field>
-->
      <field name="_Cc"     readonly="true">Components.classes</field>
      <field name="_Ci"     readonly="true">Components.interfaces</field>
      <field name="_XUL_NS" readonly="true">"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"</field>

      <!-- Initialization and Control -->
      <method name="bind">
        <parameter name="mediaListView"/>
        <parameter name="commands"/>
        <parameter name="resize"/>
        <parameter name="collapse"/>
        <parameter name="refsuffix"/>
        <body>
<![CDATA[
  // Set the tree's view to the tree of the supplied media list view
  this.mediaListView = mediaListView;
  this.tree.view = mediaListView.treeView;
/*

        var hsplitter = document.getAnonymousElementByAttribute(this, 'sbid', 'filter_splitter');
        hsplitter.setAttribute("stateid", "horz_splitter_" + this.ref);
        hsplitter.restoreLastState();

        / *
        // this is wrong, getFilter returns filter *values*, we should use getFilterColumn instead.
        // also, some usage of playlist.xml may not want autocreation of filterlists from the source,
        // so, disable this code until we have a use case that makes it clear if/how we should autoreload the filters

        // If the source says we have filters, use them.
        if ( filters == null )
        {
          var num = this.source.getNumFilters( ref );
          if ( num > 0 )
          {
            filters = new Array();
            for ( var i = 0; i < num; i++ )
            {
              filters.push( this.source.getFilter( ref, i ) );
            }
          }
        }
        * /

        if ( filters && filters.length )
        {
          for ( var i = 0; i < filters.length; ++i )
          {
            this.addFilter( filters[ i ], feed );
          }
        }
        else
        {
          // These should be hidden
          var parent = document.getAnonymousElementByAttribute(this, 'sbid', 'filter_parent');
          parent.hidden = true;
          var splitter = document.getAnonymousElementByAttribute(this, 'sbid', 'filter_splitter');
          splitter.hidden = true;
        }

        // Tell the playlist source to feed the filters.
        if ( feed )
        {
          this.source.executeFeed( ref );
        }
*/
        // Clear out the old commands
        var toolbar = document.getAnonymousElementByAttribute(this, 'sbid', 'playlist_toolbar');
        toolbar.hidden = true;

        if (!this.forcedcommands)
        {
          // And add the new ones
          this._commands = commands;

          // See if there is one registered specifically for this table
/*
          var cmds = this.source.getPlaylistCommands( this.guid, this.table, this.type );
          if ( cmds )
          {
            this._commands = cmds;
          }
*/
        }
        else
        {
          this._commands = this.forcedcommands;
        }
        // Make sure it does what we think it does.
        if ( this._commands )
        {
          this._commands = this._commands.QueryInterface( this._Ci.sbIPlaylistCommands );
        }
        this._deferRefresh = false;
        this.refreshCommands();

        // If boolean true, read from the XUL file.
        if ( resize == true )
        {
          resize = this.getAttribute( "resize_height" );
        }
        // If an integer
        if ( parseInt( resize ) > 0 )
        {
          this.height = resize;
        }
        if (this.previousSibling) {
          if ( collapse > 0 )
          {
            this.previousSibling.setAttribute( "state", "collapsed" );
          }
          else if ( collapse != null )
          {
            this.previousSibling.setAttribute( "state", "open" );
          }
        }
      ]]>
        </body>
      </method>

      <method name="startCellEditing">
        <body>
<![CDATA[
  if (this.edit_row >= 0 && this.edit_col.index >= 0) {
    this.tree.startEditing(this.edit_row, this.edit_col);
  }
]]>
        </body>
      </method>

      <method name="_onColumnMutation">
        <parameter name="event"/>
        <body>
<![CDATA[
  if((event.attrName == "dragging" && event.newValue == "") ||
     event.attrName == "width" || event.attrName == "hidden") {
    this._saveColumnSettings();
  }
]]>
        </body>
      </method>

      <method name="_setupColumns">
        <body>
<![CDATA[
  // Read the "column-list" attribute to determine which columns are to be
  // shown and in which order
  var columnListAttr = this.getAttribute("column-list");
  var columnMap = [];
  var hasColumnSpec = false;

  if (columnListAttr) {
    hasColumnSpec = true;
    var a = columnListAttr.split(" ");
    a.forEach(function(e) {
      columnMap.push({
        property: e
      });
    });
  }

  // Read the "column-widths" property which is a space delimited list of
  // integers that correspond to the columns in the "column-list" attribute
  if (hasColumnSpec) {
  var columnWidthsAttr = this.getAttribute("column-widths");
    if (columnWidthsAttr) {
      var a = columnWidthsAttr.split(" ", columnMap.length);
      a.forEach(function(e, index) {
        if (!isNaN(e)) {
          columnMap[index].width = parseInt(e);
        }
      });
    }
  }

  // Read the "column-sort" attribute which is a property name, a space, and
  // then "a" for ascending and "d" for descending
  var columnSortAttr = this.getAttribute("column-sort");
  var columnSortProperty;
  var columnSortDirection;
  if (columnSortAttr) {
    var a = columnSortAttr.split(" ", 2);
    if (a.length == 2) {
      columnSortProperty  = a[0];
      columnSortDirection = a[1] == "a";
    }
  }

  // Get the list of columns from the property manager and add them to the
  // tree
  var allColumns = [
    "http://songbirdnest.com/data/1.0#artistName",
    "http://songbirdnest.com/data/1.0#albumName",
    "http://songbirdnest.com/data/1.0#trackName",
    "http://songbirdnest.com/data/1.0#duration",
    "http://songbirdnest.com/data/1.0#genre",
    "http://songbirdnest.com/data/1.0#track",
    "http://songbirdnest.com/data/1.0#year",
    "http://songbirdnest.com/data/1.0#lastPlayTime",
    "http://songbirdnest.com/data/1.0#playCount",
    "http://songbirdnest.com/data/1.0#contentUrl"];
  var numColumns = allColumns.length;

  // Add the columns that have saved settings, keeping track of which column
  // were added
  var alreadyAdded = {};
  var addedColumns = 0;
  columnMap.forEach(function(columnInfo) {
    this._appendColumn(columnInfo.property,
                       columnInfo.property.split("#")[1],
                       false,
                       columnInfo.width,
                       numColumns - addedColumns > 1);
    alreadyAdded[columnInfo.property] = true;
    addedColumns++;
  }, this);

  // Add the rest of the columns from the property manager.  Note if there was
  // any saved column info, add these additional columns as hidden, otherwise
  // show them
  allColumns.forEach(function(property) {
    if (!alreadyAdded[property]) {
      this._appendColumn(property,
                         property.split("#")[1],
                         hasColumnSpec,
                         null,
                         numColumns - addedColumns > 1);
      addedColumns++;
    }
  }, this);

  // TODO: set the saved sort
]]>
        </body>
      </method>

      <method name="_appendColumn">
        <parameter name="property"/>
        <parameter name="label"/>
        <parameter name="isHidden"/>
        <parameter name="width"/>
        <parameter name="addSplitter"/>
        <body>
<![CDATA[
  var treecol = document.createElementNS(this._XUL_NS, "treecol");
  treecol.setAttribute("bind", property);
  treecol.setAttribute("label", label);
  treecol.setAttribute("flex", "1");
  if (width) {
    treecol.setAttribute("width", width);
  }

  if (isHidden) {
    treecol.setAttribute("hidden", "true");
  }

  this._treecols.appendChild(treecol);

  if (addSplitter) {
    var splitter = document.createElementNS(this._XUL_NS, "splitter");
    splitter.setAttribute("class", "tree-splitter");
    this._treecols.appendChild(splitter);
  }
]]>
        </body>
      </method>

      <method name="_saveColumnSettings">
        <body>
<![CDATA[
  var columns = [];

  var treecolList = this._treecols.getElementsByTagNameNS(this._XUL_NS,
                                                          "treecol");

  // Gather the column information for the columns that are not hidden
  for (var i = 0; i < treecolList.length; i++) {
    var col = treecolList[i];
    if (col.getAttribute("hidden") != "true") {
      columns.push({
        property: col.getAttribute("bind"),
        ordinal:  col.getAttribute("ordinal"),
        width:    col.width
      });
    }
  }

  // Sort the column list by ordinal
  columns.sort(function(a, b) { return a.ordinal - b.ordinal; });

  var columnList = [];
  var columnWidths = [];
  columns.forEach(function(col) {
    columnList.push(col.property);
    columnWidths.push(col.width)
  });

  this.setAttribute("column-list", columnList.join(" "));
  this.setAttribute("column-widths", columnWidths.join(" "));
]]>
        </body>
      </method>

      <method name="refreshCommands">
        <parameter name="stateonly"/>
        <body>
          <![CDATA[
//      try
//      {

        // Sometimes we get here before the tree is properly built.  That's bad.
        if (this.tree.view == null)
        {
          // So if we're supposed to build the items here, remember that and quit.
          if (!stateonly)
            this._laststateonly = false;
          return;
        }
        // And build them the next time it's time to refresh (this function gets called alot)
        if (!this._laststateonly)
        {
          stateonly = false;
          this._laststateonly = true;
        }

        // Convert null to bool.
        if (!stateonly)
          stateonly = false;

        // If our internal objects are out of sync, rebuild.
        if (this._toolbarbuttons.length == 0 || this._menuitems.length == 0 || this._toolbarbuttons.length != this._commands.getNumCommands())
          stateonly = false;

        // Get the parents
        var toolbar = document.getAnonymousElementByAttribute(this, 'sbid', 'playlist_toolbar');
        var parent = document.getAnonymousElementByAttribute(this, 'sbid', 'toolbar_parent');
        var popup = document.getAnonymousElementByAttribute(this, 'sbid', 'playlist_context_popup');
        var before = document.getAnonymousElementByAttribute(this, 'sbid', 'playlist_context_before');

        // If deferring refresh, skip it
        if ( this._deferRefresh )
        {
          // make a note that we need to refresh when the popup goes away
          this._needRefresh = true;
          // So if we're supposed to build the items here, remember that and quit.
          if (!stateonly)
            this._laststateonly = false;
          return;
        }
        this._needRefresh = false;

        if (!stateonly) {
          toolbar.hidden = true;
          // Remove old elements
          this.removeCommands();
        }

        if ( this._commands )
        {
          // Once we get here, tell the commands who we are.
          if (!stateonly) this._commands.setPlaylist( this );

          // And make all the new stuff
          var num = this._commands.getNumCommands();
          for ( var i = 0; i < num; i++ )
          {
            var toolbarbutton;
            var menuitem;
            if (!stateonly)
            {
              // If we get here, show the toolbar
              toolbar.hidden = false;

              // What id?
              var obj_id = this._commands.getCommandId( i );

              var toolbarbutton_type = "button";
              var menuitem_type = "menuitem";

              if ( obj_id == "*separator*" )
              {
                toolbarbutton_type = "spacer";
                menuitem_type = "menuseparator";
              }

              // Create a toolbarbutton
              toolbarbutton = document.createElement( toolbarbutton_type );
              toolbarbutton.setAttribute( "id", obj_id );
              toolbarbutton.setAttribute( "sbtype", "command" ); // to find it easily, later
              toolbarbutton.setAttribute( "class", "sb_faceplate" ); // Make them fully skinned buttons.

              // And a menuitem
              menuitem = document.createElement( menuitem_type );
              menuitem.setAttribute( "id", obj_id );
              menuitem.setAttribute( "sbtype", "command" );
              menuitem.setAttribute( "class", "menuitem-iconic" ); // Icons are set in the css using the id

              // No label unless you have a label
              var cmd_text = this._commands.getCommandText( i );
              if ( cmd_text.length > 0 )
              {
                if ( cmd_text[ 0 ] == "&" )
                {
                  cmd_text = this._getString(cmd_text.substr(1, cmd_text.length), "");
                }
                toolbarbutton.setAttribute( "label", cmd_text );
                menuitem.setAttribute( "label", cmd_text );
              }

              // No label unless you have a label
              var cmd_flex = this._commands.getCommandFlex( i );
              if ( cmd_flex > 0 )
              {
                toolbarbutton.setAttribute( "flex", cmd_flex );
//                menuitem.setAttribute( "flex", cmd_flex );
              }

              // No tooltip unless you have a tooltip
              var tooltip_text = this._commands.getCommandToolTipText( i );
              if ( tooltip_text.length > 0 )
              {
                if ( tooltip_text[ 0 ] == "&" )
                {
                  tooltip_text = this._getString(tooltip_text.substr(1, tooltip_text.length), "");
                }
                ///*
                //    These cause the crashy if they're up while updating.  :(
                //
                //  toolbarbutton.setAttribute( "tooltiptext", tooltip_text );
                //  menuitem.setAttribute( "tooltiptext", tooltip_text );
                //*/
              }
            }
            else
            {
              toolbarbutton = this._toolbarbuttons[i];
              menuitem = this._menuitems[i];
            }

            if ( this._commands.getCommandEnabled( i ) )
            {
              toolbarbutton.setAttribute( "disabled", "false" );
              menuitem.setAttribute( "disabled", "false" );
            }
            else
            {
              toolbarbutton.setAttribute( "disabled", "true" );
              menuitem.setAttribute( "disabled", "true" );
            }

            // Add them to the parents
            if (!stateonly)
            {
              this._toolbarbuttons.push( toolbarbutton );
              this._menuitems.push( menuitem );
              parent.appendChild( toolbarbutton );
              popup.insertBefore( menuitem, before );
            }
          }

          if ( this._toolbarbuttons.length != this._commands.getNumCommands() )
          {
            dump( "ERROR: TOOLBARBUTTONS OUT OF SYNCH!\n" );
          }
        }
//      }
//      catch( err )
//      {
//        alert( "playlist.xml - refreshCommands - " + err );
//      }
      ]]>
        </body>
      </method>

      <method name="setDeferRefresh">
        <body>
          <![CDATA[
            try
            {
              this._deferRefresh = true;
            }
            catch( err )
            {
              alert( "playlist.xml - setDeferRefresh - " + err );
            }
          ]]>
        </body>
      </method>

      <method name="clearDeferRefresh">
        <body>
          <![CDATA[
            try
            {
              this._deferRefresh = false;
              if (this._needRefresh)
                this.refreshCommands(false);
            }
            catch( err )
            {
              alert( "playlist.xml - clearDeferRefresh - " + err );
            }
          ]]>
        </body>
      </method>

      <method name="removeCommands">
        <body>
<![CDATA[
  // Delete the toolbar commands
  var parent = document.getAnonymousElementByAttribute(this, 'sbid', 'toolbar_parent');
  var command_nodes = parent.getElementsByAttribute( 'sbtype', 'command' );
  // command_nodes is a live array, removing children from parent auto removes items from it
  while ( command_nodes.length > 0 )
  {
    var node = command_nodes.item( 0 );
    parent.removeChild(node);
  }
  this._toolbarbuttons.length = 0; // clear the array??

  // Delete the popup commands
  var popup = document.getAnonymousElementByAttribute(this, 'sbid', 'playlist_context_popup');
  command_nodes = popup.getElementsByAttribute( 'sbtype', 'command' );
  while ( command_nodes.length > 0 )
  {
    var node = command_nodes.item( 0 );
    popup.removeChild(node);
  }
  this._menuitems.length = 0; // clear the array??
]]>
        </body>
      </method>
<!--
      <method name="addFilter">
        <parameter name="meta_column"/>
        <parameter name="feed"/>
        <body>
          <![CDATA[
      try
      {
        // These should be shown
        var thesplitter = document.getAnonymousElementByAttribute(this, 'sbid', 'filter_splitter');
        thesplitter.hidden = false;
        var parent = document.getAnonymousElementByAttribute(this, 'sbid', 'filter_parent');
        parent.hidden = false;

        // Add a splitter
        if ( this.filters.length > 0 )
        {
          var splitter = document.createElement( "sb-smart-splitter" );
          splitter.setAttribute( "id", "filter_splitter" );
          splitter.setAttribute( "stateid", "filter_splitter_" + this.ref );
          splitter.setAttribute( "state", "open" );
          splitter.setAttribute( "resizebefore", "closest" );
          splitter.setAttribute( "resizeafter", "closest" );
          splitter.setAttribute( "collapse", "before" );

          var grippy = document.createElement( "grippy" );

          splitter.appendChild( grippy );
          parent.appendChild( splitter );

          splitter.addEventListener("mousemove", this.onFilterSplitterMove, true);
          splitter.addEventListener("mousedown", this.onFilterSplitterDown, true);
          splitter.addEventListener("mouseup", this.onFilterSplitterUp, true);

          this.splitters.push( splitter);
        }

        // Add a filterlist
        var filterlist = document.createElement( "filterlist" );
        filterlist.setAttribute( "id", meta_column + "_filter" );
        filterlist.setAttribute( "enableColumnDrag", "false" );
        filterlist.setAttribute( "hidecolumnpicker", "true" );
        filterlist.setAttribute( "flex", "1" );

        parent.appendChild( filterlist );

        // The ref for the filter contains the column header identifier
        var ref = this.ref + "_" + meta_column;

        // This preps the Playlistsource for the XUL Tree Builder to hook up
        // and only listen to changes to this ref.
        this.source.incomingObserver( ref, filterlist );

        // There is a VERY delicate ordering here that breaks if you start
        // moving things around. If you do, make sure you test thoroughly.
        filterlist.source = this.source;
        filterlist.index = this.filters.length;
        filterlist.column = meta_column;
        filterlist.datasources = "rdf:playlist";
        filterlist.playlist = this;
        filterlist.ref_pl = this.ref;

        // setting the ref causes a rebuild of the filter and a
        // select to happen, which calls setFilter, so you BETTER have index,
        // ref and column set before setting the ref.
        filterlist.ref = ref;

        filterlist.addEventListener( "dblclick", this._onFilterDblClickClosure, true );
        filterlist.addEventListener( "filterlist-filterchange", this.sendFilterChangeEvent, true );

        // We still need to call setFilter here despite it getting called from
        // the setting of ref above, otherwise the filters will not draw
        if ( feed )
        {
          this.source.setFilter( this.ref,
                                 filterlist.index,
                                 "",
                                 filterlist.ref,
                                 filterlist.column );
        }

        filterlist.builder.refresh();

        this.filters.push( filterlist );
        thesplitter.restoreLastState( true );
      }
      catch( err )
      {
        alert( "playlist.xml - addFilter - " + err );
      }
      ]]>
        </body>
      </method>
-->

<!--
    <method name="onFilterSplitterMove">
      <parameter name="event"/>
      <body>
        <![CDATA[
          var state = this.getAttribute( "state" );
          if (state != "collapsed" && this.down && this.lastPos) {
            if (event.screenX > this.lastPos) { this.setAttribute("collapse", "after"); }
            if (event.screenX < this.lastPos) { this.setAttribute("collapse", "before"); }
          }
          this.lastPos = event.screenX;
        ]]>
      </body>
    </method>

    <method name="onFilterSplitterUp">
      <body>
        this.down = 0;
        this.lastPos = null;
      </body>
    </method>

    <method name="onFilterSplitterDown">
      <body>
        this.down = 1;
      </body>
    </method>
-->

      <!-- Tree Manipulation Functions -->

      <method name="removeColumns">
        <body><![CDATA[
          var treeColumnElement =
            document.getAnonymousElementByAttribute(this, "sbid", "treeColumns");
          this.removeAllChildren(treeColumnElement);
        ]]></body>
      </method>

      <method name="removeRows">
        <body><![CDATA[
          var treeRowElement =
            document.getAnonymousElementByAttribute(this, "sbid", "treeRow");
          this.removeAllChildren(treeRowElement);
        ]]></body>
      </method>

      <!-- Removes all children of the given DOM node -->
      <method name="removeAllChildren">
        <parameter name="parentNode"/>
        <body><![CDATA[
          // Bail out if there are no children
          if (!parentNode.hasChildNodes())
            return;

          // Loop through and remove all the children
          var childNodes = parentNode.childNodes;
          var childCount = childNodes.length;
          for(var index = 0; index < childCount; index++) {
            var child = childNodes.item(0);
            parentNode.removeChild(child);
          }
        ]]></body>
      </method>

      <!-- Selection save/restore - HACK -->

      <method name="saveSelection">
        <body>
          <![CDATA[
          try
          {
            if (this.tree.columns && this.tree.columns.count > 0 && this.tree.view.rowCount > 0) {
              var column
              // pick a column whose content we will use as unique identifier
              for (var k=0;k<this._selection_key_array.length;k++)
              {
                column = this.tree.columns.getNamedColumn(this._selection_key_array[k]);
                if (column != null)
                {
                  this._selection_key = this._selection_key_array[k];
                  break;
                }
              }
              // save selection array, this is potentially slow if many items are selected
              if (column != null) {
                this._saved_selection = Array();
                this._saved_selection.position = Array();
                this._saved_selection.all = false;
                this._saved_selection.ranges = Array();
                this._saved_nitems = this.tree.view.rowCount;
                this._saved_order = this.source.getOrder(this.ref); // save the old order, if it is empty and the new is empty as well then we will be able to reselect much faster
                var rangeCount = this.tree.view.selection.getRangeCount();
                for (var i=0; i < rangeCount; i++) {
                  var start = {};
                  var end = {};
                  this.tree.view.selection.getRangeAt( i, start, end );
                  if (start.value == -1 || end.value == -1) {
                    continue;
                  }
                  this._saved_selection.ranges.push([start.value, end.value]);
                  if (start.value == 0 && end.value == this.tree.view.rowCount-1) this._saved_selection.all = true;
                  else {
                    for( var c = start.value; c <= end.value; c++ )
                    {
                      if (c >= this.tree.view.rowCount)
                      {
                        return; //alert( "playlist.xml - saveSelection - selection item c (" + c + ") is not in range! (rowCount = " + this.tree.view.rowCount + ")");
                      }
                      try
                      {
                        var value = this.tree.view.getCellText( c, column );
                      }
                      catch ( e )
                      {
                        alert( "Error? " + column + " - " + c + "\r\n" + e );
                        return;  // wtf?!
                      }
                      this._saved_selection.push(value);
                      this._saved_selection.position.push(c);
                    }
                  }
                }
                // did our selection just get screwed for no reason ? this happens when all selection ranges are invalid ! eek !!
                if (rangeCount > 0 && this._saved_selection.length == 0) {
                  // fix the internal selection ranges, or we'll keep getting (-1,-1)'s :(
                  this.tree.view.selection.clearSelection();
                }
              }
            }
          }
          catch( err )
          {
            alert( "playlist.xml - saveSelection" + err );
          }
        ]]>
        </body>
      </method>

      <method name="restoreSelection">
        <body>
          <![CDATA[
          try
          {
            this.restoring_selection = true;

            //dump("start restore\n");
            if (this._saved_selection != null &&
                this._saved_selection.ranges &&
                this._saved_selection.ranges.length > 0 &&
                this.tree.columns &&
                this.tree.columns.count > 0 &&
                this.tree.view.rowCount > 0) {

              // use the key we picked in saveSelection
              var column = this.tree.columns.getNamedColumn(this._selection_key);
              if (column != null) {

                // restore selection from array

                // first try to restore from selection ranges. this can only be done for unsorted
                // playlists, because sorted playlists may move the items in a rebuild.
                // an exception to this is when *all* items are selected, then it doesn't matter if
                // the items moved since all should be reselected (but this is only true if the number
                // of items did not change)

                if ((this._saved_order == "" && this.source.getOrder(this.ref) == "") ||
                    (this._saved_selection.all && this._saved_nitems == this.tree.view.rowCount)) {

                  while (this._saved_selection.ranges.length > 0) {
                    var item = this._saved_selection.ranges.pop();
                    var start = item[0];
                    var end = item[1];
                    this.tree.view.selection.rangedSelect(start, end, true);
                  }

                } else {

                  // next try to restore based on the item's position in the list.
                  // for each item, check that the unique value is still the one it was

                  var by_position_failed = false;

                  while (this._saved_selection.length > 0) {
                    var value = this._saved_selection.pop();
                    var row = this._saved_selection.position.pop();

                    // Dumb tryblock because sometimes getCellText throws an error on an "Invalid Value"?
                    var failed = false;
                    var cell = "";
                    try {
                      cell = this.tree.view.getCellText( row, column );
                    } catch (e) {
                      dump( "WARNING: playlist.xml<restoreSelection>: " +
                            "getCellText(" + row + ", " + column + ") FAILED, " +
                            "this.tree.view.rowCount = " + this.tree.view.rowCount + "\n");
                      failed = true;
                    }

                    if (!failed && value == cell) {
                      // the item at that position is still the right item, select it
                      this.tree.view.selection.rangedSelect(row, row, true);
                    } else {
                      // an item has changed position, put it back in the list and stop trusting item positions
                      this._saved_selection.push(value);
                      this._saved_selection.position.push(row);
                      by_position_failed = true;
                      break;
                    }
                  }

                  if (by_position_failed) {

                    // last, if neither of the previous method succeeded (which implies some items moved around),
                    // ask the playlist source to find the previously recorded values and return an array of new rows
                    // this is potentially slow for really big libraries on slow machines

                    var nrows = {};
                    var rows = this.source.getRefRowsByColumnValues(this.ref, this._selection_key, this._saved_selection.length, this._saved_selection, nrows);

                    for (var i=0;i<nrows.value;i++) {
                      var row = rows[i];
                      if (row == -1) continue;
                      this.tree.view.selection.rangedSelect(row, row, true);
                    }
                  }
                }
              }
            }

            //dump("end restore\n");

            this.restoring_selection = false;
          }
          catch( err )
          {
            alert( "playlist.xml - restoreSelection - " + err );
          }
        ]]>
        </body>
      </method>

      <method name="findCell">
        <parameter name="column"/>
        <parameter name="value"/>
        <body>
          <![CDATA[
          try
          {
            // Instead of a linear search, try a shortcut.
            if ( column.id == "row_id" )
            {
              return value - 1;
            }
            var row = this.source.getRefRowByColumnValue(this.ref, column.id, value);
            return row;
          }
          catch( err )
          {
            alert( "playlist.xml - findCell - " + err );
          }
          return -1;
        ]]>
        </body>
      </method>

      <!-- Drag Objects watcher -->

      <method name="registerDragObject">
        <parameter name="obj"/>
        <body>
          <![CDATA[
          try
          {
            if (this._dragobjects == null) this._dragobjects = Array();
            this._dragobjects.push(obj);
          }
          catch( err )
          {
            alert( "playlist.xml - registerDragObject - " + err );
          }
        ]]>
        </body>
      </method>

      <method name="startWatchingDragObjects">
        <body>
          <![CDATA[
          try {
            var dragObjects = this._dragobjects;
            if (dragObjects) {
              var count = dragObjects.length;
              for (var i = 0; i < count; i++) {
                var dragObject = dragObjects[i];
                if (dragObject.addEventListener) {
                  dragObject.addEventListener("mouseup", this.dragObjectMouseUp, true);
                  dragObject.addEventListener("mousedown", this.dragObjectMouseDown, true);
                }
              }
            }
          }
          catch(err) {
            alert("playlist.xml - startWatchingDragObjects - " + err);
          }
        ]]>
        </body>
      </method>

      <method name="stopWatchingDragObjects">
        <body>
          <![CDATA[
          try
          {
            if (this._dragobjects != null)
            {
              for (var i=0; i<this._dragobjects.length;i++)
              {
                this._dragobjects[i].removeEventListener("mouseup", this.dragObjectMouseUp, true);
                this._dragobjects[i].removeEventListener("mousedown", this.dragObjectMouseDown, true);
              }
              this._dragobjects = null;
            }
          }
          catch( err )
          {
            alert( "playlist.xml - stopWatchingDragObjects - " + err );
          }
        ]]>
        </body>
      </method>

      <method name="dragObjectMouseUp">
        <body>
          document.__PlaylistXBL_DragObjectDown__ = null;
        </body>
      </method>

      <method name="dragObjectMouseDown">
        <body>
          document.__PlaylistXBL_DragObjectDown__ = this;
        </body>
      </method>

      <method name="isAnyDragObjectDown">
        <body>
          <![CDATA[
          var ret = 0;
          try
          {
            if (this._dragobjects != null) {
              var o = document.__PlaylistXBL_DragObjectDown__;
              for (var i=0; i<this._dragobjects.length;i++)
              {
                if (o == this._dragobjects[i])
                {
                  ret = 1;
                  break;
                }
              }
            }
          }
          catch( err )
          {
            alert( "playlist.xml - isAnyDragObjectDown - " + err );
          }
          return ret;
        ]]>
        </body>
      </method>

      <!-- Event yellers -->

      <method name="sendPlayEvent">
        <body>
          <![CDATA[
      try
      {
        var e = document.createEvent("Events");
        e.initEvent("playlist-play", false, true);
        this.dispatchEvent(e);
      }
      catch( err )
      {
        alert( "playlist.xml - sendPlayEvent - " + err )
      }
      ]]>
        </body>
      </method>

      <method name="sendEscEvent">
        <body>
          <![CDATA[
          try
          {
            var e = document.createEvent("Events");
            e.initEvent("playlist-esc", false, true);
            this.dispatchEvent(e);
          }
          catch( err )
          {
            alert( "playlist.xml - sendEscEvent - " + err )
          }
          ]]>
        </body>
      </method>

      <method name="sendEditorEvent">
        <body>
          <![CDATA[
          try
          {
            var e = document.createEvent("Events");
            e.initEvent("playlist-editor", false, true);
            this.dispatchEvent(e);
          }
          catch( err )
          {
            alert( "playlist.xml - sendEditorEvent - " + err )
          }
          ]]>
        </body>
      </method>

      <method name="sendBurnToCDEvent">
        <body>
          <![CDATA[
          try
          {
            var e = document.createEvent("Events");
            e.initEvent("playlist-burntocd", false, true);
            this.dispatchEvent(e);
          }
          catch( err )
          {
            alert( "playlist.xml - sendBurnToCDEvent - " + err )
          }
          ]]>
        </body>
      </method>

      <!-- Tree event listeners -->

      <method name="onToolbarCommand">
        <parameter name="evt"/>
        <body>
          <![CDATA[
          try
          {
            if ( this._commands )
            {
              this._commands.onCommand( evt );
            }
          }
          catch( err )
          {
            alert( "playlist.xml - onToolbarCommand - " + err );
          }
        ]]>
        </body>
      </method>

      <method name="_onPlaylistDblClick">
        <parameter name="evt"/>
        <body>
<![CDATA[
  // Check to see that the user double clicked on a row
  var row = {};
  var col = {};
  var obj = {};
  var b = this.tree.treeBoxObject;
  b.getCellAt(evt.clientX, evt.clientY, row, col, obj);

  if (row.value >= 0) {
    var gPPS = this._Cc["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                       .getService(this._Ci.sbIPlaylistPlayback);
    gPPS.playView(this.mediaListView, row.value);
  }
]]>
        </body>
      </method>

      <method name="onFilterDblClick">
        <parameter name="evt"/>
        <body>
          <![CDATA[
          try
          {
            if( this.pointInTreeRows( evt.target.tree, evt.clientX, evt.clientY ) )
            {
              var playlist = evt.target.playlist;

              if ( playlist )
              {
                document.__PlaylistXBL_DragObjectDown__ = playlist; // YUCK YUCK YUCK YUCK (note the absence of "f")
                var txt = "document.__PlaylistXBL_DragObjectDown__.tree.view.selection.currentIndex = 0;"
                txt += "document.__PlaylistXBL_DragObjectDown__.tree.view.selection.select( 0 );"
                txt += "document.__PlaylistXBL_DragObjectDown__.sendPlayEvent();"
                // Play it in awhile, after the tree updates.
                setTimeout( txt, 250 );
              }
            }
          }
          catch( err )
          {
            alert( "playlist.xml - onFilterDblClick - " + err );
          }
        ]]>
        </body>
      </method>

      <method name="_onPlaylistKeypress">
        <parameter name="evt"/>
        <body>
          <![CDATA[
          try
          {
            //dump("charcode = " + evt.charCode + " - keycode = " + evt.keyCode + "\n");
            if (evt.charCode == 97 && evt.ctrlKey) {  // ctrl-a
              this.tree.view.selection.selectAll();
            } else {
              switch ( evt.keyCode )
              {
                case KeyEvent.DOM_VK_DELETE:
                case KeyEvent.DOM_VK_BACK_SPACE:
                  if ( this.tree.currentIndex != -1 )
                  {
                    this._removeSelectedTracks();
                  }
                  break;
                case KeyEvent.DOM_VK_RETURN:
                case KeyEvent.DOM_VK_ENTER:
                  if ( this.tree.currentIndex != -1 )
                  {
                    this.sendPlayEvent();
                  }
                  break;
                case KeyEvent.DOM_VK_ESCAPE:
                  {
                    this.sendEscEvent();
                  }
                  break;
              }
            }
          }
          catch( err )
          {
            alert( "playlist.xml - onPlaylistKeypress - " + err );
          }
        ]]>
        </body>
      </method>

      <method name="_onPlaylistContextClick">
        <parameter name="evt"/>
        <body>
          <![CDATA[
          try {
            // If there is no actual commands, do not allow the context menu to pop.
            if (!this._commands || this._commands.getNumCommands() == 0) return;

            const COLUMN_TITLE = "title";
            const CONTEXT_IDS = ["playlist_context_before",
                                 "playlist.context.search",
                                 "playlist.context.lyrics"];

            // Small helper to loop through a list of the ids for the context
            // menu items and show or hide each element.
            //
            // aShow - a boolean specifying if items are to be shown or
            //           hidden. Defaults to true.
            function showContextItems(aShow) {
              if (aShow === undefined)
                aShow = true;

              var items = CONTEXT_IDS;
              var count = items.length;
              for (var index = 0; index < count; index++) {
                var id = items[index];
                var item = document.getElementById(id);
                if (!item)
                  continue;

                var isHidden = item.hasAttribute("hidden");

                if (aShow && isHidden) {
                  item.removeAttribute("hidden");
                }
                else if (!aShow && !isHidden) {
                  item.setAttribute("hidden", "true");
                }
              }
            }

            var tree = this.tree;
            if (tree.currentIndex < 0)
              return;

            // XXX: do we need a version of this?
            //this.hidePlaylistEdit();

            // First, get the row and column clicked.
            var childElement = {}, rowObject = {}, columnObject = {};
            tree.treeBoxObject.getCellAt(evt.clientX, evt.clientY, rowObject,
                                         columnObject, childElement);

            // Bail if we got a bad result
            if (rowObject.value == -1)
              return;

            // Store the last clicked cell
            this.edit_row = rowObject.value;
            this.edit_col = columnObject.value;

            var cellText =
              tree.view.getCellText(rowObject.value, columnObject.value);

            // XXX: What to do here?
            if (!cellText) {
              // If we couldn't get text from the cell then we'll try to pull it
              // out another way
              var titleColumn = tree.columns.getNamedColumn(COLUMN_TITLE);
              if (titleColumn)
                cellText = tree.view.getCellText(tree.currentIndex, titleColumn);
            }

            // Make sure that everyone knows about our context
            this.context_term = cellText;
            SBDataSetStringValue("playlist.context.term", cellText);

            if (cellText) {
              var searchHeader = this._getString("playlist.context.searchheader", "Search");
              var lyricsHeader = this._getString("playlist.context.lyricsheader", "Lyrics");

              var searchTerm =
                document.getAnonymousElementByAttribute(this, 'sbid', 'search_popup_term');
              searchTerm.label = searchHeader + ": " + cellText;

              var lyricsTerm =
                document.getAnonymousElementByAttribute(this, 'sbid', 'lyrics_popup_term');
              lyricsTerm.label = lyricsHeader + ": " + cellText;

              // Make sure that the search and lyrics menus are visible
              showContextItems(true);
            }
            else {
              // We couldn't get any context, so hide the search and lyrics
              // menu items.
              showContextItems(false);
            }

            // XXX: The coords given to the showPopup() method are relative to
            // the browser iframe, so compute the difference.  This may be a
            // bug, possibly related to bmo 362403
            var bo = document.getBoxObjectFor(document.documentElement);
            this._context_x = evt.screenX - bo.screenX;
            this._context_y = evt.screenY - bo.screenY;

            //dump("this._context_x = " + this._context_x + "\n");
            //dump("this._context_y = " + this._context_y + "\n");

            this._context_popup.showPopup(tree, this._context_x, this._context_y,
                                          "context", null, null, null);

            //dump("this._context_popup.boxObject.screenX = " + this._context_popup.boxObject.screenX + "\n");
            //dump("this._context_popup.boxObject.screenY = " + this._context_popup.boxObject.screenY + "\n");
          }
          catch( e )
          {
            dump("playlist.xml - onPlaylistContextClick:\nException = " + e + "\n");
          }
        ]]>
        </body>
      </method>

      <method name="_onPlaylistSelectClick">
        <parameter name="evt"/>
        <body>
          <![CDATA[
          try
          {
            //dump("onPlaylistSelectClick\r\n");

            // If we have commands, allow them to update
            if ( ! this.restoring_selection )
            {
              this.refreshCommands();
            }
/* XXX: we should be able to do better than this
            // If we select too many items, we need to pause the scanning.
            var count = 0;
            if (this.tree.view)
            {
              var rangeCount = this.tree.view.selection.getRangeCount();
              for (var i=0; i < rangeCount; i++)
              {
                var start = {};
                var end = {};
                this.tree.view.selection.getRangeAt( i, start, end );
                count += end.value - start.value + 1;
              }
            }
            if ( count > 50 )
            {
              if ( ! this.paused_scanning )
              {
                // increment the backscan pause value.
                SBDataIncrementValue( "backscan.paused" );
                this.paused_scanning = true;
              }
            }
            else
            {
              if ( this.paused_scanning )
              {
                // decrement the backscan.pause value to a floor of 0
                SBDataDecrementValue( "backscan.paused", 0 );
                this.paused_scanning = false;
              }
            }
*/
            if (!this.restoring_selection) {
              var e = document.createEvent("Events");
              e.initEvent("playlist-selchange", false, true);
              this.dispatchEvent(e);
            }
          }
          catch( err )
          {
            alert( "playlist.xml - onPlaylistSelectClick - " + err );
          }
        ]]>
        </body>
      </method>

    <method name="_onPlaylistClick">
      <parameter name="evt"/>
      <body>
        <![CDATA[
          try
          {
            dump("onPlaylistClick\n");

            if ( evt.button == 0 && this.tree.currentIndex != -1 )
            {
              var obj = {}, row = {}, col = {};
              this.tree.treeBoxObject.getCellAt( evt.clientX, evt.clientY, row, col, obj );
              // If the "obj" has a value, it is a cell.  Otherwise, it could be anything.
              if ( obj.value )
              {
                if (this.tree.view.isEditable(row.value, col.value))
                {
                  // Remember the row and column
                  this.edit_row = row.value;
                  this.edit_col = col.value;
                  if (this.edit_col.id == "rating")
                  {
                    var width = this.edit_col.element.boxObject.width;
                    var dist = evt.screenX - this.edit_col.element.boxObject.screenX;
                    // 4 pixels offsets
                    width -= 8;
                    dist -= 4;
                    var ret = Math.round(dist / width * 100);
                    if (ret < 0) ret = 0; if (ret > 100) ret = 100;
                    this.setCellRating(this.edit_row, this.edit_col, ret);
                  }
                  else if ( this.tree.currentIndex == this._lastClickIndex  )
                  {
                    var delay = evt.timeStamp - this._lastClickTimestamp;
                    if ( delay > 1000 && delay < 2000 )
                    {
                      this.startCellEditing();
                    }
                  }
                }
              }
            }
            this._lastClickIndex = this.tree.currentIndex;
            this._lastClickTimestamp = evt.timeStamp;
          }
          catch( err )
          {
            alert( "playlist.xml - onPlaylistClick - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="onPlaylistScroll">
      <parameter name="evt"/>
      <body>
        <![CDATA[
          try
          {
            alert( "Scroll:" + evt );
            this.hidePlaylistEdit();
          }
          catch( err )
          {
            alert( "playlist.xml - onPlaylistScroll - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="onPlaylistContextMenu">
      <parameter name="evt"/>
      <body>
        <![CDATA[
          try
          {
            this.context_item = null;
            if ( ! evt.target )
            {
              return;
            }
            this.context_item = document.getAnonymousElementByAttribute(this, 'id', evt.target.id);
            metrics_inc("playlist.context", this.context_item.getAttribute("id"), null);
            if ( evt.target.getAttribute( "sbtype" ) == "command" )
            {
              if ( this._commands ) // I hope so!
              {
                this._commands.onCommand( evt );
              }
            }
          }
          catch( err )
          {
            alert( "playlist.xml - onPlaylistContextMenu - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="onPopupShown">
      <parameter name="evt"/>
      <body>
        <![CDATA[
          try
          {
            this.setDeferRefresh();
          }
          catch( err )
          {
            alert( "playlist.xml - onPlaylistContextMenu - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="onPopupHidden">
      <parameter name="evt"/>
      <body>
        <![CDATA[
          try
          {
            this.clearDeferRefresh();
          }
          catch( err )
          {
            alert( "playlist.xml - onPlaylistContextMenu - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="onPlaylistEditChange">
      <body>
        <![CDATA[
          try
          {
          }
          catch( err )
          {
            alert( "playlist.xml - onPlaylistEditChange - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="onPlaylistEditKeypress">
      <body>
        <![CDATA[
          try
          {
            alert( "key" );
          }
          catch( err )
          {
            alert( "playlist.xml - onPlaylistEditKeypress - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="addToPlaylist">
      <body>
        <![CDATA[
          try
          {
            // Make a data object to get the playlist to add to from the dialog
            var add_to_playlist_data = new Object();
            // Open the modal dialog
            var chromeFeatures = "chrome,centerscreen"
            SBOpenModalDialog("chrome://songbird/content/xul/add_to_playlist.xul", "add_to_playlist", chromeFeatures, add_to_playlist_data );
            if ( add_to_playlist_data.retval == "ok" )
            {
              // add them !
              var playlist = add_to_playlist_data.playlist;
              this.addToPlaylistOrLibrary(playlist);
              this.reportAddedTracks(true);
            }
          }
          catch( err )
          {
            alert( "playlist.xml - addToPlaylist - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="addToLibrary">
      <body>
        <![CDATA[
          try
          {
            this.addToPlaylistOrLibrary();
            this.reportAddedTracks(false);
          }
          catch( err )
          {
            alert( "playlist.xml - addToPlaylist - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="reportAddedTracks">
      <parameter name="toplaylist"/>
      <body>
        <![CDATA[
          var msg;
          if (toplaylist) {
            // if sending to a playlist, we can have duplicate entries, so dont report that some tracks already existed
            var totalcount = this._addto_added_count + this._addto_existed_count;
            msg = "" + totalcount + " ";
            switch (totalcount) {
              case 0: msg = this.str_notracksaddedto; break;
              case 1: msg += this.str_trackaddedto; break;
              default: msg += this.str_tracksaddedto; break;
            }
            msg += " " + this.str_playlist.toLowerCase();
          } else {
            // but if sending to a library, there cant be any dups
            msg = "" + this._addto_added_count + " ";
            switch (totalcount) {
              case 0: msg = this.str_notracksaddedto; break;
              case 1: msg += this.str_trackaddedto; break;
              default: msg += this.str_tracksaddedto; break;
            }
            msg += " " + this.str_library.toLowerCase();
            if (this._addto_existed_count > 0) msg += " (" + this._addto_existed_count + " " + ((this._addto_existed_count > 1) ? this.str_tracksalreadypresent : this.str_trackalreadypresent) + ")";
          }
          SBDataSetStringValue("faceplate.status.override.text", "");
          SBDataSetStringValue("faceplate.status.override.text", msg);
          SBDataSetStringValue("faceplate.status.override.style", "font-weight: bold;");
        ]]>
      </body>
    </method>

    <method name="addToPlaylistOrLibrary">
      <parameter name="playlist"/>
      <body>
        <![CDATA[
          try
          {
            var MediaLibrary = new Components.Constructor("@songbirdnest.com/Songbird/MediaLibrary;1", "sbIMediaLibrary");
            var mediaLibrary = (new MediaLibrary()).QueryInterface(Components.interfaces.sbIMediaLibrary);

            var queryObj = Components.classes["@songbirdnest.com/Songbird/DatabaseQuery;1"].createInstance();
            queryObj = queryObj.QueryInterface(Components.interfaces.sbIDatabaseQuery);
            queryObj.setDatabaseGUID("songbird");

            mediaLibrary.setQueryObject(queryObj);

            var PlaylistManager = new Components.Constructor("@songbirdnest.com/Songbird/PlaylistManager;1", "sbIPlaylistManager");
            var playlistManager = new PlaylistManager();
            playlistManager = playlistManager.QueryInterface(Components.interfaces.sbIPlaylistManager);

            var thePlaylist;
            if (playlist != null) thePlaylist = playlistManager.getPlaylist(playlist, queryObj);

            if (playlist != null && thePlaylist == null)
            {
              alert("playlist.xml - addToPlaylistOrLibrary - Playlist '" + playlist + "' not found!");
              return;
            }

            // Add the tracks to it
            var urlcolumn = this.tree.columns.getNamedColumn("url");
            var uuidcolumn = this.tree.columns.getNamedColumn("uuid");
            if (urlcolumn) // it is okay if uuidcolumn does not exist, but url is our fallback
            {
              var metadataintersection_ids = Array();
              var metadataintersection_cols = Array();

              // are the tracks coming from a different db ? if so, compute the intersection of metadata columns between the source
              // and destination db, so that the insertion can use it later to insert the proper data in the destination db
              if (this.guid != "songbird")
              {
                mediaLibrary.getColumnInfo();
                var destcols = queryObj.getResultObject();
                var srccols;

                var thisPlaylist = playlistManager.getPlaylist(this.table, this.m_queryObj);
                if (!thisPlaylist) { // playlist not found ? this is a library then
                  var _mediaLibrary = (new MediaLibrary()).QueryInterface(Components.interfaces.sbIMediaLibrary);
                  var _queryObj = Components.classes["@songbirdnest.com/Songbird/DatabaseQuery;1"].createInstance();
                  _queryObj = _queryObj.QueryInterface(Components.interfaces.sbIDatabaseQuery);
                  _queryObj.setDatabaseGUID(this.guid);
                  _mediaLibrary.setQueryObject(_queryObj);
                  _mediaLibrary.getColumnInfo();
                  srccols = _queryObj.getResultObject();
                } else {
                  thisPlaylist.getColumnInfo();
                  srccols = this.m_queryObj.getResultObject();
                }

                for (var i=0;i<destcols.getRowCount();i++)
                {
                  var columnid = destcols.getRowCell(i, 0);
                  if (columnid == "uuid" || columnid == "url" || columnid == "service_uuid" || columnid == "id" || columnid == "row_id") continue;
                  for (var j=0;j<srccols.getRowCount();j++)
                  {
                    if (columnid == srccols.getRowCell(j, 0))
                    {
                      metadataintersection_ids.push(columnid);
                      metadataintersection_cols.push(this.tree.columns.getNamedColumn(columnid));
                      break;
                    }
                  }
                }
              }
              queryObj.resetQuery();
              var params = Array(mediaLibrary, thePlaylist, urlcolumn, uuidcolumn, metadataintersection_ids, metadataintersection_cols);
              this._addto_added_count = 0;
              this._addto_existed_count = 0;
              if (!(this.table == "library" && this.guid == "songbird") && this.tree.view.selection.getRangeCount() == 0)
                this.processAll(this.processSelection_addToPlaylistOrLibrary, params);
              else
                this.processSelection(this.processSelection_addToPlaylistOrLibrary, params);

              queryObj.execute();
            }
            else
            {
              alert("playlist.xml - addToPlaylistOrLibrary - no url column");
              return;
            }
          }
          catch( err )
          {
            alert( "playlist.xml - addToPlaylistOrLibrary - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="_processSelection">
      <parameter name="func"/>
      <parameter name="params"/>
      <body>
        <![CDATA[
          try
          {
            var first = -1;
            this.processSelection_rowcount = 0;
            var rangeCount = this.tree.view.selection.getRangeCount();
            for (var i=0; i < rangeCount; i++)
            {
              var start = {};
              var end = {};
              this.tree.view.selection.getRangeAt( i, start, end );
              if (end.value != -1 && start.value != -1) this.processSelection_rowcount += (end.value-start.value)+1;
              if (first == -1 || start.value < first) first = start.value;
              for( var c = start.value; c <= end.value; c++ )
              {
                if (c > this.tree.view.rowCount)
                {
                  continue;
                }
                func.apply(this, [c, params]);
              }
            }
            this.tree.view.selection.clearSelection();
            return first;
          }
          catch( err )
          {
            alert( "playlist.xml - processSelection - " + err );
          }
          return -1;
        ]]>
      </body>
    </method>

    <method name="processAll">
      <parameter name="func"/>
      <parameter name="params"/>
      <body>
        <![CDATA[
          try
          {
            var rowCount = this.tree.view.rowCount;
            for (var i=0; i < rowCount; i++)
            {
              func(this, i, params);
            }
          }
          catch( err )
          {
            alert( "playlist.xml - processAll - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="processSelection_addToPlaylistOrLibrary">
      <parameter name="_this"/>
      <parameter name="item"/>
      <parameter name="params"/>
      <body>
        <![CDATA[
          try
          {
            var mediaLibrary = params[0];
            var thePlaylist = params[1];
            var urlcolumn = params[2];
            var uuidcolumn = params[3];
            var metadataintersection_ids = params[4];
            var metadataintersection_cols = params[5];

            var guid;

            // metadataintersection is empty if the destination library is the same as the source library
            if (uuidcolumn && metadataintersection_cols.length == 0)
            {
              guid = _this.tree.view.getCellText( item, uuidcolumn );
              _this._addto_existed_count++;
            }
            else
            {
              var url = _this.tree.view.getCellText( item, urlcolumn );
              if (metadataintersection_cols.length != 0)
              {
                var values = new Array();
                var r = mediaLibrary.findByURL(url);
                if (r && r != "")
                {
                  _this._addto_existed_count++;
                }
                else
                {
                  _this._addto_added_count++;
                }
                // source playlist has its own library, use the intersection of available metadata in source and
                // destination libraries as the metadata for the insertion in the the destination library
                for (var i=0;i<metadataintersection_cols.length;i++)
                {
                  values.push(_this.tree.view.getCellText( item, metadataintersection_cols[i] ));
                }
                guid = mediaLibrary.addMedia( url, metadataintersection_ids.length, metadataintersection_ids, values.length, values, false, true );
              }
              else
              {
                // item is already in destination library, but we didnt have a uuid column,
                // ask the library for the guid associated with this url
                guid = mediaLibrary.addMedia( url, 0, null, 0, null, false, true );
                _this._addto_existed_count++;
              }
            }

            if (thePlaylist)
            {
              thePlaylist.addByGUID( guid, "songbird", -1, false, true );
            }
          }
          catch( err )
          {
            alert( "playlist.xml - processSelection_addToPlaylistOrLibrary - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="_removeSelectedTracks">
      <body>
<![CDATA[
  var ml = this.mediaListView.mediaList;

  // Check to see if our media list is a sbILocalDatabaseSimpleMediaList
  var sml;
  try {
    sml = ml.QueryInterface(this._Ci.sbILocalDatabaseSimpleMediaList);
  }
  catch(e) {
    // do nothing
  }

  ml.beginUpdateBatch();

  // Process the selection backwards so we don't change the indexes as we
  // delete them
  try {
    var rangeCount = this.tree.view.selection.getRangeCount();
    for (var i = rangeCount - 1; i >= 0; i--) {
      var start = {};
      var end = {};
      this.tree.view.selection.getRangeAt(i, start, end);
      for (var j = end.value; j >= start.value; j--) {
        if (sml) {
          // Get the ordinal of the item from the view
          var ordinal = sml.getOrdinalByIndex(j);

          // Remove the item from the underlying list by ordinal
          sml.removeByOrdinal(ordinal);
        }
        else {
          // Delete the item from the list using its guid
          var ldbmlv = this.mediaListView.QueryInterface(this._Ci.sbILocalDatabaseMediaListView);
          var guid = ldbmlv.getGuidByIndex(j);
          var item = ml.getItemByGuid(guid);
          ml.remove(item);
        }
      }
    }
  }
  finally {
    ml.endUpdateBatch();
  }
]]>
      </body>
    </method>

    <method name="setDnDSourceTracker">
      <parameter name="tracker"/>
      <body>
        if (this.m_dndSourceTracker == tracker)
        {
          return;
        }
        else
        {
          if (this.m_dndSourceTracker != null)
          {
            this.m_dndSourceTracker.unregisterDnDSource(this);
            this.m_dndSourceTracker = null;
          }
        }
        this.m_dndSourceTracker = tracker;
        if (tracker != null) tracker.registerDnDSource(this);
      </body>
    </method>

    <method name="getDnDSourceIndex">
      <body>
        if (this.m_dndSourceTracker != null) return this.m_dndSourceTracker.getDnDSourceIndex(this);
        return -1;
      </body>
    </method>

    <method name="onDrag">
      <parameter name="evt"/>
      <body>
        <![CDATA[
          try
          {
            //
            //  Do something interesting to indicate the drag of a column?
            //

            // Disable dragging from the download playlist
            if(this.guid == "downloadDB") {
              return;
            }

            if( this.pointInTreeRows( this.tree, evt.clientX, evt.clientY ) )
            {
              // Heheh, only drag if you're dragging a cell.  Otherwise, don't screw with the scrollbar

              // also, if we are dragging from the inside of the tree body, only accept to start the dnd if there is a selection
              // this will avoid empty dragdrops when dragging from below the last item (if there is a selection, dragging
              // from bellow the last item does not cancel the selection)
              if (this.tree.view.selection.getRangeCount() != 0) {
                this.nsDragAndDrop.startDrag(evt, this.sbIPlaylistDragObserver);
              }
            }
          }
          catch( err )
          {
            alert( "playlist.xml - onDrag - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="getViewSummary">
      <body>
        <![CDATA[
          var ret = "";
          try
          {
            if (this.source && this.ref != "")
            {
              ret = this.guid + ";" + this.table;
              var n = this.source.getNumFilters(this.ref);
              ret += ";" + n;
              for (var i=0;i<n;i++)
                ret += ";" + this.source.getFilter(this.ref, i);
              ret += "|" + this.source.getSearchString(this.ref);
            }
          }
          catch( err )
          {
            alert( "playlist.xml - getViewSummary - " + err );
          }
          return ret;
        ]]>
      </body>
    </method>

    <method name="syncPlaylistIndex">
      <parameter name="scroll"/>
      <body>
        <![CDATA[
          try
          {
            // if this playlist is the currently playing one, set selection to the playing item
            // lone> should this really be testing this.playingRef ?? why not this.ref ?
            if ( this.playlistRef && this.playlistRef.stringValue == this.playingRef.stringValue )
            {
              var url = this.playUrl.stringValue;
              var row = this.findUrl(url);
              if (row != -1)
              {
                this.tree.view.selection.clearSelection();
                this.tree.view.selection.rangedSelect(row, row, true);
                if (scroll)
                {
                  var box = this.tree.treeBoxObject;
                  box.ensureRowIsVisible(row);
                }
              }
            }
          }
          catch (err)
          {
            alert( "playlist.xml - onPlayUrlChange - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="findUrl">
      <parameter name="url"/>
      <body>
        <![CDATA[
          try
          {
            if ( this.tree.columns ) {
              var urlcolumn = this.tree.columns.getNamedColumn("url");
              if (urlcolumn != null)
              {
                var row = this.findCell(urlcolumn, url);
                return row;
              }
            }
          }
          catch (err)
          {
            alert( "playlist.xml - findUrl - " + err );
          }
          return -1;
        ]]>
      </body>
    </method>

    <method name="findRowIdByUrl">
      <parameter name="url"/>
      <body>
        <![CDATA[
          try
          {
            var i = this.findUrl(url);
            if (i != -1) {
              var idcolumn = this.tree.columns.getNamedColumn("row_id");
              if (idcolumn != null)
              {
                var rowid = this.tree.view.getCellText( i, idcolumn );
                return rowid - 1;
              }
            }
          }
          catch (err)
          {
            alert( "playlist.xml - findRowIdByUrl - " + err );
          }
          return -1;
        ]]>
      </body>
    </method>

    <method name="setCellRating">
      <parameter name="row"/>
      <parameter name="col"/>
      <parameter name="rating"/>
      <body>
        <![CDATA[
          try
          {
            // Find the url column.
            var filter = "uuid";
            var filter_column = this.tree.columns ? this.tree.columns[filter] : filter;
            var filter_value = this.tree.view.getCellText( this.tree.currentIndex, filter_column );

            var the_table_column = col.id;
            var the_new_value = rating;

            var aDBQuery = Components.classes["@songbirdnest.com/Songbird/DatabaseQuery;1"].createInstance(Components.interfaces.sbIDatabaseQuery);
            var aMediaLibrary = Components.classes["@songbirdnest.com/Songbird/MediaLibrary;1"].createInstance(Components.interfaces.sbIMediaLibrary);

            if ( ! aDBQuery || ! aMediaLibrary)
              return;

            aDBQuery.setAsyncQuery(true);
            aDBQuery.setDatabaseGUID(this.guid);
            aMediaLibrary.setQueryObject(aDBQuery);

            aMediaLibrary.setValueByGUID(filter_value, the_table_column, the_new_value, false);
          }
          catch (err)
          {
            alert( "playlist.xml - setCellRating - " + err );
          }
          return;
        ]]>
      </body>
    </method>


    <method name="ensurePlaylistExists">
      <body>
        <![CDATA[
        var found = true;
        if (this.table.length > 0 && this.guid.length > 0) {
          found = false;
          var queryObj = Components.classes["@songbirdnest.com/Songbird/DatabaseQuery;1"].createInstance();
          queryObj = queryObj.QueryInterface(Components.interfaces.sbIDatabaseQuery);
          queryObj.setDatabaseGUID(this.guid);
          var PlaylistManager = new Components.Constructor("@songbirdnest.com/Songbird/PlaylistManager;1", "sbIPlaylistManager");
          var playlistManager = new PlaylistManager();
          playlistManager = playlistManager.QueryInterface(Components.interfaces.sbIPlaylistManager);
          playlistManager.getAllPlaylistList( queryObj );
          var resultset = queryObj.getResultObject();
          if (this.table == "library")
            found = true;
          else
            for ( var i = 0; i < resultset.getRowCount(); i++ ) {
              if ( this.table == resultset.getRowCellByColumn( i, "name" ) ) {
                found = true;
                break;
              }
            }

          if ( !found )
          {
            var e = document.createEvent("Events");
            e.initEvent("playlist-noplaylist", false, true);
            this.dispatchEvent(e);
          }
        }
        return found;
        ]]>
        </body>
      </method>

    <method name="syncColumnSortIndicator">
      <body>
        <![CDATA[
          if (this._treecols) {
            var cols = this._treecols.childNodes;
            for (var i=0;i<cols.length;i++) {
              if (cols[i].getAttribute("id") == this.sortorder) {
                cols[i].setAttribute("sortDirection", (this.sortdirection == "asc") ? "ascending" : "descending");
              } else {
                cols[i].setAttribute("sortDirection", "natural");
              }
            }
          }
        ]]>
      </body>
    </method>

    <method name="bindDataRemotes">
      <body>
        <![CDATA[
          // Create and bind data remotes
          this.playingRef = SB_NewDataRemote( "playing.ref", null );
          this.playlistRef = SB_NewDataRemote( "playlist.ref", null );
          this.playUrl = SB_NewDataRemote( "faceplate.play.url", null );
        ]]>
      </body>
    </method>

    <method name="unbindDataRemotes">
      <body>
        <![CDATA[
          if (this.playUrl) {
            this.playUrl.unbind();
            this.playUrl = null;
          }
        ]]>
      </body>
    </method>

    <method name="resetFilterLists">
      <body>
        <![CDATA[
          var n = this.filters.length;
          for (var i=0;i<n;i++) {
            this.source.setFilter( this.ref, i, "", this.filters[i].ref, this.filters[i].column);
          }
          this.source.executeFeed( this.ref );
        ]]>
      </body>
    </method>

    <method name="sendFilterChangeEvent">
      <parameter name="event"/>
      <body>
        <![CDATA[
          var e = document.createEvent("Events");
          e.initEvent("playlist-filterchange", false, true);
          this.dispatchEvent(e);
        ]]>
      </body>
    </method>

    <method name="pointInTreeRows">
      <parameter name="tree"/>
      <parameter name="mouseX"/>
      <parameter name="mouseY"/>
        <body>
        <![CDATA[
          // Make sure the user actually double clicked on a tree cell.
          // Previously this used getCellAt() on the tree, however, it was
          // unreliable.  This code compares the mouse position with the box
          // object of the contaier of the tree's rows (which excludes the
          // column headers and scroll bar)
          var treeRows = document.getAnonymousElementByAttribute(tree, "class", "tree-rows");
          if(!treeRows) {
              return false;
          }
          var treeBodyBox = document.getAnonymousElementByAttribute(treeRows, "class", "tree-bodybox");
          if(!treeBodyBox) {
              return false;
          }
          var bo = treeBodyBox.boxObject;
          if(mouseX >= bo.x && mouseX <= (bo.x + bo.width) &&
             mouseY >= bo.y && mouseY <= (bo.y + bo.height)) {
             return true;
          }
          else {
            return false;
          }
        ]]>
        </body>
      </method>

      <method name="deselectAll">
        <body>
        <![CDATA[
          this.tree.view.selection.clearSelection();
        ]]>
        </body>
      </method>

      <method name="_getString">
        <parameter name="name"/>
        <parameter name="defaultValue"/>
        <body>
<![CDATA[
  if (!this._stringbundle) {
    var src = "chrome://songbird/locale/songbird.properties";
    var stringBundleService = this._Cc["@mozilla.org/intl/stringbundle;1"]
                                  .getService(this._Ci.nsIStringBundleService);
    this._stringbundle = stringBundleService.createBundle(src);
  }

  try {
    return this._stringbundle.GetStringFromName(name);
  }
  catch(e) {
    return defaultValue;
  }
]]>
        </body>
      </method>

      <method name="_di">
        <parameter name="o"/>
        <body>
<![CDATA[
 for(var i in this._Ci) {
   try {
     o.QueryInterface(this._Ci[i]);
     dump(i + "\n");
   }
   catch(e) {
   }
 }
]]>
        </body>
      </method>

    </implementation>

  </binding>

</bindings>
