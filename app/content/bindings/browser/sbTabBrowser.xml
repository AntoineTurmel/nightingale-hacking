<?xml version="1.0"?>
<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl"
[
<!ENTITY % songbirdDTD SYSTEM "chrome://songbird/locale/songbird.dtd">
%songbirdDTD;
]
>
<!--
//
// BEGIN SONGBIRD GPL
//
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2008 POTI, Inc.
// http://songbirdnest.com
//
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
//
// Software distributed under the License is distributed
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either
// express or implied. See the GPL for the specific language
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
//
// END SONGBIRD GPL
//
-->

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="sb-tabbrowser" extends="chrome://songbird/content/bindings/browser/tabBrowserCompat.xml#tabbrowser-compat">
    <implementation implements="sbITabBrowser">
      <constructor><![CDATA[
        window.gBrowser = this;

        if (!window.SBProperties)
          Components.utils.import("resource://app/jsmodules/sbProperties.jsm");
        if (!window.kPlaylistCommands) 
          Components.utils.import("resource://app/jsmodules/kPlaylistCommands.jsm");
        if (!window.LibraryUtils) 
          Components.utils.import("resource://app/jsmodules/sbLibraryUtils.jsm");
        if (!window.ArrayConverter) 
          Components.utils.import("resource://app/jsmodules/ArrayConverter.jsm");
        if (!window.XPCOMUtils) 
          Components.utils.import("resource://app/jsmodules/XPCOMUtils.jsm");

        /* load the tab progress listener object
         * this is used to trigger notifyTabContentChange() / saveTabState()
         * and to set various data remotes on location change, such as toolbar
         * button states and setting <sb-tabbrowser>.loading
         */
        var subscriptLoader = Components.classes["@mozilla.org/moz/jssubscript-loader;1"]
                                        .getService(Components.interfaces.mozIJSSubScriptLoader);
        var scope = {};
        subscriptLoader.loadSubScript("chrome://songbird/content/bindings/browser/SBTabProgressListener.js", scope);
        this.webProgressListener = new scope.SBTabProgressListener(this);
        this.addProgressListener(this.webProgressListener,
            Components.interfaces.nsIWebProgress.NOTIFY_LOCATION |
            Components.interfaces.nsIWebProgress.NOTIFY_STATE_ALL);

        this.loading = false;
        
        // we moved the strip container to the tabs binding
        var strip = document.getAnonymousElementByAttribute(this, "anonid", "strip");
        if (strip && strip.collapsed) {
          // don't collapse the outer box, collapse the inner <tabs> element instead
          strip.collapsed = false;
          this.mStrip.collapsed = true;
        }
        if (this.hasAttribute("tabstrip")) {
          this.mStrip = document.getElementById(this.getAttribute("tabstrip"));
        }
        
        scope = {};
        subscriptLoader.loadSubScript("chrome://songbird/content/bindings/browser/SBSessionStore.js", scope);
        this._sessionStore = scope.SBSessionStore;

        /* we want to know when the window has finished opening so we can
          restore tabs and other fun stuff
        */
        this.windowLoadEventListener = {
          tabbrowser: this,
          document: document,
          handleEvent: function(event) {
            if (event.target != this.document) {
              return;
            }
            this.tabbrowser._sessionStore.restoreTabState(this.tabbrowser);
            
            // workaround for bug 8097
            this.tabbrowser.selectedTab = this.tabbrowser.mTabs[0];
          }
        }
        window.addEventListener('load', this.windowLoadEventListener, true);

        /* load the remote API handler bits
         * this provides the onRemoteAPI() method that is pretty self-contained
         * which is then triggered by the "remoteapi" DOM event.  It is used to
         * let the user accept remote API requests (currently, as a notification
         * box)
         */
        scope = {};
        subscriptLoader.loadSubScript("chrome://songbird/content/bindings/browser/SBRemoteAPIHandler.js", scope);
        this.onRemoteAPI = scope.onRemoteAPI;
        window.addEventListener("remoteapi", this.onRemoteAPI, true);

        // tell appshell how to open new tabs (sb bug 3757)
        scope = {};
        subscriptLoader.loadSubScript("chrome://songbird/content/bindings/browser/BrowserDOMWindow.js", scope);
        window.QueryInterface(Components.interfaces.nsIDOMChromeWindow).browserDOMWindow =
          new scope.BrowserDOMWindow(this);

        this.selectedBrowser.webNavigation.sessionHistory =
            Components.classes["@mozilla.org/browser/shistory;1"]
            .createInstance(Components.interfaces.nsISHistory);
        this.browsers[0].removeAttribute("disablehistory");

        // force tabbed mode
        this.enterTabbedMode();
        
        // display pane
        XML.prettyPrinting = false;
        var xml =  <sb-smart-splitter collapse="after" orient="vertical" resizeafter="closest"
                                      id="displaypane_contentpane_bottom_splitter"
                                      xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
                     <grippy/>
                   </sb-smart-splitter>;
        var doc = (new DOMParser()).parseFromString(xml.toXMLString(), "application/xml");
        var splitter = document.importNode(doc.documentElement, true);
        this.parentNode.appendChild(splitter);

        xml = <sb-displaypane id="displaypane_contentpane_bottom" contentgroup="contentpane"
                              splitter="displaypane_contentpane_bottom_splitter"
                              xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"/>;
        doc = (new DOMParser()).parseFromString(xml.toXMLString(), "application/xml");
        var pane = document.importNode(doc.documentElement, true);
        
        // evil hack to get the localizable name from the dtd
        pane.setAttribute("label", ]]>"&displaypane.name.browser;"<![CDATA[);
        this.parentNode.appendChild(pane);
        
        // manually restore the height if set (because the two elements are inserted dynamically
        // and thus when the restore was attempted the pane didn't exist yet)
        if (!pane.collapsed) {
          splitter.restoreLastState(true);
        }

        // add a service pane listener to keep in sync with changes there
        // for example, if a playlist is renamed, if there are open tabs for that playlist
        // they should be retitled.
        var self = this;
        this._servicePaneService = 
            Components.classes['@songbirdnest.com/servicepane/service;1']
            .getService(Components.interfaces.sbIServicePaneService);
        this._servicePaneService.init(); // TODO: make service pane init itself
        this._servicePaneListener = {
          nodePropertyChanged: function(aNodeId, aPropertyName) {
            var SP_NS = 'http://songbirdnest.com/rdf/servicepane#';
            var NC_NS = 'http://home.netscape.com/NC-rdf#';
            if (aPropertyName != SP_NS+'Properties' &&
                aPropertyName != NC_NS+'Name' &&
                aPropertyName != SP_NS+'Image') {
              // we only care about Properties and Image changing
              return;
            }

            // go through the tabs
            var tab = self.tabContainer.firstChild;
            while(tab) {
              // looking for one associated with the node that changed
              if (tab.servicePaneNode && 
                  tab.servicePaneNode.id == aNodeId) {
                // and apply its properties
                tab.applyPropertiesFromServicePaneNode();
              }
              tab = tab.nextSibling;
            }
          },
          QueryInterface: XPCOMUtils.generateQI([Ci.sbIServicePaneListener])
        }
        this._servicePaneService.addListener(this._servicePaneListener);
      ]]></constructor>
      <destructor><![CDATA[

        // remove service pane listener        
        this._servicePaneService.removeListener(this._servicePaneListener);
        this._servicePaneService = null;

        this.removeProgressListener(this);

        window.removeEventListener('load', this.windowLoadEventListener, true);

        window.removeEventListener("remoteapi", this.onRemoteAPI, true);
        window.QueryInterface(Components.interfaces.nsIDOMChromeWindow)
              .browserDOMWindow = null;
      ]]></destructor>

      <field name="_sessionStore">null</field>
      <field name="_servicePaneService">null</field>
      
      <!-- Override tabBrowser.setTabTitle in order to support
           service pane icons and titles for chrome URLs -->
      <method name="setTabTitle">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            var browser = this.getBrowserForTab(aTab);
            var crop = "end";
            var title = browser.contentTitle;

            if (!title) {
              if (browser.currentURI.spec) {
              
                //XXXAus: Looks like we have a chrome URL. Let's try and see if it has 
                //a pretty name registered with the service pane so that we can match what
                //the location bar will have (ie, Library, not chrome://songbird[...]).
                if (browser.currentURI.scheme == "chrome") {
                  // If we have a servicepane node, use it for the title
                  var servicePaneNode = aTab.servicePaneNode
                  if (servicePaneNode && servicePaneNode.name) {
                    title = servicePaneNode.name;
                  }
                }
              
                //XXXAus: Looks like the service pane didn't have a pretty name for 
                //this chrome URI. Let's fallback to using the URI itself. This also
                //works for all other types of schemes (http, ftp, etc).
                if (!title) {
                  try {
                    title = this.mURIFixup.createExposableURI(browser.currentURI).spec;
                  } catch(ex) {
                    title = browser.currentURI.spec;
                  }
                }
              }

              if (title && title != "about:blank") {
                // At this point, we now have a URI.
                // Let's try to unescape it using a character set
                // in case the URI is not ASCII.
                try {
                  var characterSet = browser.contentDocument.characterSet;
                  const textToSubURI = Components.classes["@mozilla.org/intl/texttosuburi;1"]
                                                 .getService(Components.interfaces.nsITextToSubURI);
                  title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);
                } catch(ex) { /* Do nothing. */ }

                crop = "center";

              } else // Still no title?  Fall back to our untitled string.
                title = this.mStringBundle.getString("tabs.untitled");
            }

            aTab.label = title;
            aTab.setAttribute("crop", crop);
          ]]>
        </body>
      </method>

      <method name="_checkTarget">
        <parameter name="aTarget"/>
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
            var returnValue = aTarget;
            
            if ("_media" == aTarget) {
              if (this.mediaTab) {
                // force media things in the media tab
                return "_media";
              } else {
                // there's no media tab
                returnValue = "_top";
              }
            }
            
            if (aEvent) {
              // if an event as supplied infer where we want to load this URI
              //
              var isMac = window.navigator.platform.match(/^Mac/) == 'Mac';
              var middleButton = aEvent?(aEvent.button == 1):false;
              var modifierKey = aEvent?(isMac?aEvent.metaKey:aEvent.ctrlKey):false;

              if (middleButton || modifierKey) {
                returnValue = "_blank";
              }
            }

            // check to see if tabs are allowed
            if (returnValue == '_blank' &&
                !this.mPrefs.getBoolPref('browser.tabs.enabled')) {
              returnValue = '_top';
            }

            return returnValue;
          ]]>
        </body>
      </method>
      
      <!-- the public interface for loading URLs.
           this overrides the implementation in tabBrowser.xml#tabbrowser
           it takes the existing aURI, aReferrerURI and aCharset arguments
           and optionally an aEvent and aMediaListView.

           aMediaListView will be provided to the tab and used if a
           media page or web playlist is loaded.
           -->
      <method name="loadURI">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aEvent"/>
        <parameter name="aDefaultLocation"/>
        <parameter name="aMediaListView"/>
        <body>
          <![CDATA[
          
            // If this is a request for the old sbLibaryPage
            // redirect it to the new page showing the main library 
            // TODO delete this post 0.5
            if (aURI && aURI.indexOf &&
                aURI.indexOf("chrome://songbird/content/xul/sbLibraryPage.xul") == 0)
            {
              Components.utils.reportError("TabBrowser.loadURI was called for" +
                    " sbLibraryPage.xul! Use gBrowser.loadMediaList instead.");
                    
              this.loadMediaList(LibraryUtils.mainLibrary, aEvent, 
                    aDefaultLocation);
              return;
            }

          
            var retval = null;
            var defaultLocation = aDefaultLocation;
            if (!defaultLocation) {
              defaultLocation = "_top";
            }
            var where = this._checkTarget(defaultLocation, aEvent);
            

            // make sure the referrer is an nsIURI
            if (aReferrerURI == '') {
              aReferrerURI = null;
            } else {
              if (typeof(aReferrerURI) == 'string') {
                aReferrerURI = (Components
                    .classes["@mozilla.org/network/io-service;1"]
                    .getService(Components.interfaces.nsIIOService)
                    .newURI(aReferrerURI, aCharset, null));
              }
            }

            // if we plan on opening it in the media tab, find it
            if (where == "_media") {
              where = this.mediaTab;
            }

            // Now, actually open the URI
            if (where == "_blank") {
              var tab = this.loadOneTab(aURI, aReferrerURI, aCharset, null, null, null);
              tab._viewForPage = aMediaListView;
              tab._isNewViewForPage = true;
              retval = tab;
            } else if (where == "_top") {
              this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
              this.mCurrentTab._viewForPage = aMediaListView;
              this.mCurrentTab._isNewViewForPage = true;
              retval = this.mCurrentTab;
              
            // If aDefaultLocation is a tab, load there
            } else if (where && where.linkedBrowser) {
              var tab = where;
              tab.linkedBrowser.loadURI(aURI, aReferrerURI, aCharset);
              tab._viewForPage = aMediaListView;
              tab._isNewViewForPage = true;
              retval = tab;
            } else {
              // eek! unknown target
            }
            return retval;
          ]]>
        </body>
      </method>
      
      <!-- override <tabbrowser>::removeTab to prevent the media tab from being
           removed
           -->
      <method name="removeTab">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            if (aTab == this.mediaTab) {
              return;
            }
            var proto = this;
            while (proto && ("removeTab" in proto) && proto.removeTab == this.removeTab) {
              proto = proto.__proto__;
            }
            if (proto)
              return proto.removeTab.apply(this, arguments);
            return;
          ]]>
        </body>
      </method>

      <!-- Use a Media Page to display the given list and
           (optional) view. 
        -->
      <method name="loadMediaList">
        <parameter name="aMediaList"/>
        <parameter name="aEvent"/>
        <parameter name="aDefaultLocation"/>
        <parameter name="aMediaListView"/>
        <parameter name="aPageURL"/>
        <body>
          <![CDATA[
            // If we weren't passed a view, create one
            if (aMediaListView == null) {
              aMediaListView = LibraryUtils.createStandardMediaListView(aMediaList);
            }

            var mgr = Components.classes["@songbirdnest.com/Songbird/MediaPageManager;1"]
                                .getService(Components.interfaces.sbIMediaPageManager);

            // If a page URL was provided, confirm that it is allowed for this medialist
            if (aPageURL) {
              var found = false;
              for each (var page in ArrayConverter.JSArray(mgr.getAvailablePages(aMediaList))) {
                if (aPageURL.indexOf(page.QueryInterface(Components.interfaces.sbIMediaPageInfo)
                        .contentUrl) == 0) {
                  found = true;
                  break;
                }
              }
              if (!found){
                aPageURL = null;
              }            
            }
            
            // If no URL, get the default from the page manager
            if (!aPageURL) {
              var page = mgr.getPage(aMediaList);
              aPageURL = page.contentUrl;
            }
            
            // If not already present, attach the guids to the querystring 
            // so that the page gets a unique browser history entry.  
            // I would have preferred to use a # instead of a querystring, 
            // but anchors are ignored in loadURI.
            if (aPageURL.indexOf("libraryGUID=") == -1) {
              if (aPageURL.indexOf("?") != -1) {
                aPageURL += "&";
              } else {
                aPageURL += "?";
              }
              aPageURL += "libraryGUID=" + escape(aMediaList.library.guid) +
                          "&listGUID=" + escape(aMediaList.guid);
            }
            
            return this.loadURI(aPageURL, null, null, aEvent, 
                                   aDefaultLocation, aMediaListView);
          ]]>
        </body>
      </method>
      

      <!-- Reveal the given index in the given sbIMediaListView  -->
      <method name="showIndexInView">
        <parameter name="aMediaListView"/>
        <parameter name="aHighlightIndex"/>
        <body>
          <![CDATA[
            if (!(aMediaListView instanceof Ci.sbIMediaListView) ||
                !(aHighlightIndex >= 0)) {
              throw new Error("showIndexInView requires a media list view and index");
            }
              
            // If we already have a tab for this view, show it there
            var tab = this.getTabForView(aMediaListView);          
            if (tab) {
              this.selectedTab = tab;
              if (tab.mediaPage) {
                tab.mediaPage.highlightItem(aHighlightIndex);
              } else if (tab.outerPlaylist) {
                var tree = tab.outerPlaylist.tree;
                tree.treeBoxObject.ensureRowIsVisible(aHighlightIndex);
                tree.view.selection.select(aHighlightIndex);
              }
            
            // Not already visible.  Load and highlight.
            } else {
              // If the view is for a web media list, load the origin page.
              // Otherwise, load the media list.
              var mediaList = aMediaListView.mediaList;
              if (mediaList.library.equals(LibraryUtils.webLibrary) &&
                  (mediaList.getProperty(SBProperties.isList) == "1")) {
                aMediaListView.selection.selectOnly(aHighlightIndex);
                var originPage = mediaList.getProperty(SBProperties.originPage);
                this.loadURI(originPage,
                             null,
                             null,
                             null,
                             null,
                             aMediaListView);
              } else {
                var tab = this.loadMediaList(aMediaListView.mediaList, null, 
                                             null, aMediaListView);
                tab._highlightViewIndexOnLoad = aHighlightIndex;
              }
            }
          ]]>
        </body>
      </method>
      

      <!-- Get the web playlist for the current tab -->
      <property name="currentOuterPlaylist" readonly="true"
                onget="return this.mCurrentTab.outerPlaylist" />

      <!-- Get the sbIMediaPage for the current tab -->
      <property name="currentMediaPage" readonly="true"
                onget="return this.mCurrentTab.mediaPage" />

      <!-- Get the sbIMediaListView for the current tab.
           May come from the web playlist or media page. -->
      <property name="currentMediaListView" readonly="true"
                onget="return this.mCurrentTab.mediaListView" />




      <field name="_loading">SB_NewDataRemote("faceplate.loading", null)</field>
      <property name="loading"
                onget="return this._loading.boolValue"
                onset="this._loading.boolValue = val;" />

      <method name="getTabForView">
        <parameter name="aView" />
        <body><![CDATA[        
          // Search open tabs for an sbIMediaListView that is showing the given view
          var tabs = this.mTabs;
          var tab;
          for (var i = 0; i < tabs.length; i++) {
            tab = tabs[i];
            if (tab.mediaListView && tab.mediaListView == aView) {
              return tab;
            }
          }
          return null;
        ]]></body>
      </method>

      <!-- Sends a "TabContentChange" event from the current tab. 
           Called when the user switches tabs, and before and after
           a new page is loaded in the current tab.
           
           Use this event if you want to track what the user is
           viewing in the tab browser.
           
           This event is needed because:
             * nsIWebProgressListener does not provide access to 
               the changing tab
             * "load" is dispatched only for tab favicons
             * "TabSelect" is dispatched only on tab change, not on 
                new content
       -->
      <method name="notifyTabContentChange">
        <body>
        <![CDATA[
          var event = document.createEvent("Events");
          event.initEvent("TabContentChange", true, false);
          this.dispatchEvent(event);
          
          this._updateFindbarState();
          
          // Update the loading status of the web-toolbar items:
          this.loading = this.mIsBusy;
          
          document.commandDispatcher.updateCommands("tabchange");
        ]]></body>
      </method>
      
      <method name="_updateFindbarState">
        <body>
          <![CDATA[
            // If we are about to show a media page, let's supress the findbar. 
            // Calling |closeFindbar()| simply hides the findbar from
            // the content view and saves the contents of the search.
            if (this.isSelectedTabMediaPage() && !this.isFindbarHidden) {
              this.closeFindbar();
              this._mFindbarIsSuppressed = true;
            }
            // Now the tab content that we are switching to is not a media page
            // and we have suppressed the findbar - it's time to show it now.
            else if (!this.isSelectedTabMediaPage() && this._mFindbarIsSuppressed) {
              this.showFindbar();
              this._mFindbarIsSuppressed = false;
            }
          ]]>
        </body>
      </method>
      
      <method name="isSelectedTabMediaPage">
        <body>
          <![CDATA[
            return this.selectedTab &&
                   this.selectedTab.mediaPage != null;
          ]]>
        </body>
      </method>
      
      <!-- a bunch of methods from browser_xbl_temp.js / songbird_hack.js.
           I'm not convinced they belong here, but till we refactor a couple
           more things there's nowhere better for them to go. -->
           
      <!-- Handles playing the given URL by adding it to the web
           library, and if possible playing it from the current 
           web playlist.
        -->
      <method name="_playExternalUrl">
        <parameter name="aURL" />
        <parameter name="aTryWeb" />
        <body>
            <![CDATA[

          // figure out if the url is in the webplaylist
          var currentPlaylist = this.currentOuterPlaylist;
          
          if (aTryWeb && currentPlaylist)
          {
            var currentView = currentPlaylist.getListView();
            
            // Try to see if we've already found and scanned this url
            var listener = {
              foundItem: null,
              onEnumerationBegin: function onEnumerationBegin() {
                if (this.foundItem) {
                  return Components.interfaces.sbIMediaListEnumerationListener.CANCEL;
                }
                else {
                  return Components.interfaces.sbIMediaListEnumerationListener.CONTINUE;
                }
              },
              onEnumeratedItem: function onEnumeratedItem(list, item) {
                this.foundItem = item;
                return Components.interfaces.sbIMediaListEnumerationListener.CANCEL;
              },
              onEnumerationEnd: function onEnumerationEnd() {
              }
            };

            var currentMediaList = currentView.mediaList;
            
            currentMediaList.enumerateItemsByProperty(SBProperties.originURL, aURL, listener );
            currentMediaList.enumerateItemsByProperty(SBProperties.contentURL, aURL, listener );

            if (listener.foundItem) {
              gPPS.playView(currentView, 
                            currentView.getIndexForItem(listener.foundItem));
              return;
            }
          } 
          
          // otherwise, play the url as external (added to the db, 
          // plays the library from that point on)
          // if the url is already in the lib, it is not added twice
          var item = SBImportURLIntoWebLibrary(aURL);
          
          var view = LibraryUtils.createStandardMediaListView(LibraryUtils.webLibrary);

          var index = view.getIndexForItem(item);
          
          // If we have a browser, try to show the view
          if (window.gBrowser) {
            gBrowser.showIndexInView(view, index);
          }
          
          // Play the item
          gPPS.playView(view, index);
          
        ]]></body>
      </method>


      <!-- Called when the user clicks on a media URL in a web page.
           Handles playing from the web playlist, opening as a playlist, etc. 
        -->
      <method name="handleMediaURL">
        <parameter name="aURL" />
        <parameter name="aShouldBeginPlayback" />
        <parameter name="forcePlaylist" />
        <parameter name="target" />
        <parameter name="referrer" />
        <body><![CDATA[
          var retval = false;
          try
          {
            var ioService =
              Components.classes["@mozilla.org/network/io-service;1"]
                        .getService(Components.interfaces.nsIIOService);
            var uri;
            try {
              uri = ioService.newURI(aURL, null, null);
            }
            catch(e) {
            }

            // Stick playlists in the service pane (for now).
            if ( uri && (forcePlaylist || gPPS.isPlaylistURL( uri.spec )) )
            {
              var library = null;
              var scheme = uri.scheme;

              if ( scheme != "file" &&
                   scheme != "resource" &&
                   scheme != "chrome" &&
                   scheme != "jar" ) {
                library = LibraryUtils.webLibrary;
              }
              else {
                library = Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                          .getService(Components.interfaces.sbILibraryManager).mainLibrary;
              }

              // Check to see if this playlist already exists
              var propertyArray =
                Components.classes["@songbirdnest.com/Songbird/Properties/MutablePropertyArray;1"]
                          .createInstance(Components.interfaces.sbIMutablePropertyArray);
              propertyArray.appendProperty(SBProperties.isList, "1");
              propertyArray.appendProperty(SBProperties.originURL, uri.spec);

              var getFirstListener = {
                item: null,
                onEnumerationBegin: function() {
                },
                onEnumeratedItem: function(list, item) {
                  this.item = item;
                  return Components.interfaces.sbIMediaListEnumerationListener.CANCEL;
                },
                onEnumerationEnd: function() {
                }
              };

              library.enumerateItemsByProperties(propertyArray,
                                                 getFirstListener );

              // If we found a matching list, clear it, otherwise create it
              var mediaList;
              if (getFirstListener.item) {
                mediaList = getFirstListener.item;
                mediaList.clear();
              }
              else {
                if ( scheme == "http" ){
                  mediaList = this.mCurrentTab.outerPlaylist.mediaList;
                  if (mediaList) {
                    mediaList.clear();
                    this.selectedTab.outerPlaylistShowing = true;
                    var locationBar = document.getElementById("location_bar");
                    locationBar.uri = aURL;
                  }
                }
                
                if (!mediaList) {
                  mediaList = library.createMediaList("simple");
                  mediaList.name = gPPS.convertURLToDisplayName(aURL);
                  mediaList.setProperty("http://songbirdnest.com/data/1.0#originURL", uri.spec);
                }
              }

              var playlistReaderManager =
                Components.classes["@songbirdnest.com/Songbird/PlaylistReaderManager;1"]
                          .getService(Components.interfaces.sbIPlaylistReaderManager);
              var playlistReaderListener =
                Components.classes["@songbirdnest.com/Songbird/PlaylistReaderListener;1"]
                          .createInstance(Components.interfaces.sbIPlaylistReaderListener);

              // Create this closure here to prevent this object from getting garbage
              // collected too soon.  The playlist reader uses the nsIWebBrowserPersist
              // component that does _not_ addref this listener :(
              var playlist_observer = {
                observe: function ( aSubject, aTopic, aData ) {
                  if (aTopic.indexOf("error") != -1) {
                    // if we get an error parsing a page we thought was a 
                    // playlist then we were probably wrong. let's just load
                    // it in the browser
                    gBrowser.loadURI(aURL, referrer, null, null, target);
                  }
                  else {
                    var array =
                      Components.classes["@songbirdnest.com/moz/xpcom/threadsafe-array;1"]
                                .createInstance(Components.interfaces.nsIMutableArray);
                    for (var i = 0; i < mediaList.length; i++) {
                      array.appendElement(mediaList.getItemByIndex(i), false);
                    }

                    // Send the items in the new media list to the metadata scanner
                    var metadataJobManager =
                      Components.classes["@songbirdnest.com/Songbird/MetadataJobManager;1"]
                                .getService(Components.interfaces.sbIMetadataJobManager);
                    var metadataJob = metadataJobManager.newJob(array, 5);

                    // Start playback
                    var view = mediaList.createView();
                    gPPS.playView(view, 0);
                  }
                }
              };

              playlistReaderListener.playWhenLoaded = aShouldBeginPlayback;
              playlistReaderListener.observer = playlist_observer;
              playlistReaderListener.mediaMimetypesOnly = true;
              playlistReaderManager.originalURI = uri;
              playlistReaderManager.loadPlaylist(uri, mediaList, null, false, playlistReaderListener);
              retval = true;
            }
            // Everything else gets played directly.
            else if ( gPPS.isMediaURL( aURL ) )
            {
              this._playExternalUrl(aURL, true);
              retval = true;
            }
          }
          catch ( err )
          {
            alert("sb-tabbrowser::handleMediaURL(" + aURL + "); " + err );
          }
          return retval;
        ]]></body>
      </method>
      
      <!--
        Show a notification message.  If the given notification already exists
        (but not necessarily shown), show it with an updated message.  Note that
        only the message (and not the icon, priority, or buttons) get updated.
        -->
      <method name="showNotification">
        <parameter name="aBrowser"/>
        <parameter name="aNotificationName"/>
        <parameter name="aMessage"/>
        <parameter name="aIconURL"/>
        <parameter name="aPriority"/>
        <parameter name="aButtons"/>
        <body><![CDATA[
          var browser = aBrowser;
          if (aBrowser instanceof Document) {
            // given a document; find the containing <browser> instead
            browser = this.getBrowserForDocument(aBrowser);
          } else if (aBrowser instanceof Components.interfaces.nsIDocShell) {
            // given a random docshell, try to find a <browser> that holds
            // an ancestor
            for (var i = 0; i < this.browsers.length; ++i) {
              // walk up the docshell tree to see if the <browser> we have is a parent
              var targetDocShell = aBrowser.QueryInterface(Components.interfaces.nsIDocShellTreeItem);
              browser = this.getBrowserAtIndex(i);
              while (targetDocShell && browser.docShell != targetDocShell) {
                targetDocShell = targetDocShell.parent;
              }
              if (browser.docShell == targetDocShell)
                break;
              browser = null;
            }
          }
          if (!browser) {
            throw Components.interfaces.NS_ERROR_INVALID_ARG;
          }
          
          var notificationBox = this.getNotificationBox(browser);
          var notification = notificationBox
                                   .getNotificationWithValue(aNotificationName);
          if (!notification) {
            // if there isn't a notification object, make one and append it
            notification = notificationBox.appendNotification(aMessage,
                                                              aNotificationName,
                                                              aIconURL,
                                                              aPriority,
                                                              aButtons);
          } else {
            // if there is a notification object set it's text.
            // this has the side effect of showing it if it was dismissed
            notification.message = aMessage;
          }
          return notification;
        ]]></body>
      </method>

      <!-- sbITabBrowser -->
      <method name="getTabForDocument">
        <parameter name="aDocument" />
        <body><![CDATA[
          var numTabs = this.mTabs.length;
          for ( var index = 0; index < numTabs; index++ ) {
            if ( this.mTabs[index]
                     .linkedBrowser
                     .contentDocument == aDocument ) {
              return this.mTabs[index];
            }
          }
          return null;
        ]]></body>
      </method>

      <!-- media tab handling -->
      <property name="mediaTab">
        <getter><![CDATA[
          if (!this.hasAttribute("hasmediatab"))
            return null;
          return this.mTabs[0];
        ]]></getter>
      </property>
      <field name="_lastNonMediaTab">null</field>
      <method name="isMediaTabURL">
        <parameter name="aURL"/>
        <body><![CDATA[
          if (!aURL) {
            return Components.results.NS_ERROR_INVALID_ARG;
          }
          if (!this.mediaTab) {
            // we don't have a media tab
            return false;
          }
          var url = aURL;
          if (aURL instanceof Components.interfaces.nsIURI) {
            url = aURL.spec;
          }
          if (!(/chrome:\/\//.test(url))) {
            // not chrome
            return false;
          }
          var node = this._servicePaneService.getNodeForURL(url);
          if (!node) return false;
          return true;
        ]]></body>
      </method>
      
      <!-- context menu handler -->
      <field name="_urlForHTMLContextMenu">null</field>
      <method name="onHTMLContextMenu">
        <parameter name="target" />
        <body><![CDATA[
          if ( this._urlForHTMLContextMenu ) {
            var v = target.getAttribute( "id" );
            switch ( v ) {
              case "html.context.open":
                // can be track or playlist
                // try dealing with media, might just be web content.
                if ( !this.handleMediaURL(this._urlForHTMLContextMenu, true, false, null, this.currentURI.spec) )
                {
                  this.loadURI(this._urlForHTMLContextMenu, this.currentURI.spec, null);
                }
              break;
              case "html.context.opentab":
                // can be track or playlist
                // try dealing with media, might just be web content.
                if ( !this.handleMediaURL(this._urlForHTMLContextMenu, true, false, '_blank', this.currentURI.spec) )
                {
                  this.loadOneTab(this._urlForHTMLContextMenu, this.currentURI, null, null, null, null);
                }
                break;
              case "html.context.openexternal":
                  var externalLoader = (Components
                           .classes["@mozilla.org/uriloader/external-protocol-service;1"]
                          .getService(Components.interfaces.nsIExternalProtocolService));
                  var nsURI = (Components
                          .classes["@mozilla.org/network/io-service;1"]
                          .getService(Components.interfaces.nsIIOService)
                          .newURI(this._urlForHTMLContextMenu, null, null));
                  externalLoader.loadURI(nsURI, null);
              break;
              case "html.context.play":
                // can be track or playlist
                this.handleMediaURL(this._urlForHTMLContextMenu, true, false);
              break;
              case "html.context.download":
                // figure out the media item for the url
                var currentPlaylist = this.currentOuterPlaylist;
                if (currentPlaylist)
                {
                  var currentView = currentPlaylist.getListView();
                  // Try to see if we've already found and scanned this url
                  var listener = {
                    item: null,
                    onEnumerationBegin: function onEnumerationBegin() {
                      if (this.item) {
                        return Components.interfaces.sbIMediaListEnumerationListener.CANCEL;
                      }
                      else {
                        return Components.interfaces.sbIMediaListEnumerationListener.CONTINUE;
                      }
                    },
                    onEnumeratedItem: function onEnumeratedItem(list, item) {
                      this.item = item;
                      return Components.interfaces.sbIMediaListEnumerationListener.CANCEL;
                    },
                    onEnumerationEnd: function onEnumerationEnd() {
                    }
                  };

                  var currentMediaList = currentView.mediaList;
                  
                  currentMediaList.enumerateItemsByProperty(SBProperties.originURL, this._urlForHTMLContextMenu, listener );
                  if (!listener.item)
                    currentMediaList.enumerateItemsByProperty(SBProperties.contentURL, this._urlForHTMLContextMenu, listener );

                  if (listener.item) {
                    var ddh =
                      Components.classes["@songbirdnest.com/Songbird/DownloadDeviceHelper;1"]
                                .getService(Components.interfaces.sbIDownloadDeviceHelper);
                    ddh.downloadItem(listener.item);
                  }
                }
              break;
              case "html.context.playlist":
                // Add playlists to the service pane (force it as a playlist)
                this.handleMediaURL(this._urlForHTMLContextMenu, false, true);
              break;
              case "html.context.copytoclipboard":
                var clipboard = Components.classes["@mozilla.org/widget/clipboardhelper;1"].getService(Components.interfaces.nsIClipboardHelper);
                clipboard.copyString(this._urlForHTMLContextMenu);
              break;
            }
            this._urlForHTMLContextMenu = null; // clear it because now we're done.
          }
        ]]></body>
      </method>

      <field name="_popupShowing">false</field>
      <method name="onContextPopupShowing">
        <parameter name="popup" />
        <parameter name="event" />
        <body><![CDATA[
          window.gContextMenu = new ContentAreaContextMenu(popup, window.getBrowser()); 
          this._popupShowing = gContextMenu.shouldDisplay;
          return this._popupShowing;
        ]]></body>
      </method>

      <method name="onContextPopupHiding">
        <parameter name="popup"/>
        <body>
          <![CDATA[
          window.gContextMenu = null; 
          this._popupShowing = false;
        ]]></body>
      </method>


      <!-- Override tabBrowser.xul homepage.  Uses mozilla.org by default -->
      <property name="homePage">
        <getter><![CDATA[
          return Application.prefs.get("browser.startup.homepage").value;
        ]]></getter>
        <setter><![CDATA[
          Application.prefs.setValue("browser.startup.homepage", val);
        ]]></setter>
      </property>
      <method name="goHome">
        <body><![CDATA[
          this.loadURI(this.homePage, null, null);
        ]]></body>
      </method>
      
      <!-- Override tabBrowser.xul to support moving the tab strip outside -->
      <method name="onTitleChanged">
        <parameter name="evt"/>
        <body>
          <![CDATA[
            /* |this| is the <browser> */
            if (evt.target != this.contentDocument)
              return;

            var tabBrowser = document.getBindingParent(this);

            var tab = document.getAnonymousElementByAttribute(tabBrowser, "linkedpanel", this.parentNode.id);
            if (!tab) {
              tab = tabBrowser.mTabContainer.getElementsByAttribute("linkedpanel", this.parentNode.id)[0];
            }
            tabBrowser.setTabTitle(tab);

            if (tab == tabBrowser.mCurrentTab)
              tabBrowser.updateTitlebar();
          ]]>
        </body>
      </method>

      <field name="_strip">
        document.getAnonymousElementByAttribute(this, "anonid", "tabcontainer");
      </field>
      <property name="mStrip">
        <setter>
          <![CDATA[
            // override the onerror attribute because it asks for binding parent
            function tab_onerror(event) {
              gBrowser.addToMissedIconCache(this.getAttribute('image'));
              this.setIcon(null);
            }
            
            if (!val) {
              throw Components.results.NS_ERROR_INVALID_ARG;
            }
            // we can't just move stuff around the DOM, because then anonymous
            // nodes magically become real.  And breaks all sorts of things.
            var selectedTab = this.mTabBox.selectedTab;
            if (this._strip != val) {
              this._strip.collapsed = true;
              while (val.firstChild) {
                val.removeChild(val.firstChild);
              }
              while (this._strip.firstChild) {
                var tab = this._strip.firstChild;
                var linkedBrowser = tab.linkedBrowser;
                val.appendChild(tab);
                tab.setAttribute("onerror", "(" + uneval(tab_onerror) + ").call(this, event)");
                if (!(tab.linkedBrowser)) {
                  tab.linkedBrowser = linkedBrowser;
                }
              }
              this._strip.style.MozBinding = "";
            }
            this._strip = this.mTabContainer = val;
            val._tabbrowser = this; // setting the private property!
            this.mTabs = this.mTabContainer.childNodes;
            this.mTabBox._tabs = this.mTabContainer;
            this.mTabBox.selectedTab = selectedTab;
          ]]>
        </setter>
        <getter>
          return this._strip;
        </getter>
      </property>

    </implementation>

    <handlers>
      <handler event="click" phase="capturing" ><![CDATA[
        // inspired by contentAreaClick in ffox browser.js
        if (!event.isTrusted || event.getPreventDefault()) {
          return true;
        }

        if (this._popupShowing || event.button == 2) {
          // if we're showing a popup or about to show one, let's do nothing
          return true;
        }

        var target = event.target;
        var linkNode = null;

        if (target instanceof HTMLAnchorElement ||
            target instanceof HTMLAreaElement ||
            target instanceof HTMLLinkElement) {
          if (target.hasAttribute("href")) {
            linkNode = target;
          }

          // backwards compat - use the outermost link node
          var parent = target.parentNode;
          while (parent) {
            if (parent instanceof HTMLAnchorElement ||
                parent instanceof HTMLAreaElement ||
                parent instanceof HTMLLinkElement) {
                if (parent.hasAttribute("href")) {
                  linkNode = parent;
                }
            }
            parent = parent.parentNode;
          }
        } else {
          linkNode = event.originalTarget;
          while (linkNode && !(linkNode instanceof HTMLAnchorElement)) {
            linkNode = linkNode.parentNode;
          }
          // <a> cannot be nested.  So if we find an anchor without an
          // href, there is no useful <a> around the target
          if (linkNode && !linkNode.hasAttribute("href")) {
            linkNode = null;
          }
        }

        var wrapper = null;
        var href = null;
        var target = null;
        if (linkNode) {
          href = linkNode.href;
          if (linkNode.hasAttribute('target')) {
            target = linkNode.getAttribute('target');
          }
        } else {
          // Try simple XLink
          var realHref, baseURI;
          linkNode = target;
          while (linkNode) {
            if (linkNode.nodeType == Node.ELEMENT_NODE) {
              wrapper = linkNode;

              realHref = wrapper.getAttributeNS("http://www.w3.org/1999/xlink", "href");
              if (realHref) {
                href = realHref;
                baseURI = wrapper.baseURI
              }
            }
            linkNode = linkNode.parentNode;
          }
          if (href) {
            var ioService = Components.classes["@mozilla.org/network/io-service;1"]
                .getService(Components.interfaces.nsIIOService);
            var base = ioService.newURI(baseURI, null, null);
            href = ioService.newURI(base.resolve(href), null, null).spec;
          }
        }

        if (href) {
          // get the document that this event originated in
          var doc = event.target.ownerDocument;

          var secMan = Components.classes["@mozilla.org/scriptsecuritymanager;1"]
              .getService(Components.interfaces.nsIScriptSecurityManager);
          secMan.checkLoadURIStrWithPrincipal(doc.nodePrincipal, href,
              Components.interfaces.nsIScriptSecurityManager.STANDARD);

          // get the referrer if we can
          var referrer = doc ? doc.documentURIObject : null;
          
          // we need to handle playlists and media items specially
          if ( gPPS.isPlaylistURL(href) ||
               gPPS.isMediaURL(href) ) {
            this.handleMediaURL(href, false, false, target, referrer);
            event.stopPropagation();
            event.preventDefault();
          } else {
            var where = this._checkTarget(target, event);
            if (where &&
                this.loadURI(href, referrer, null, event, target)) {
              event.stopPropagation();
              event.preventDefault();
            }
          }

        }
        return true;
      ]]></handler>
    </handlers>
  </binding>

</bindings>
