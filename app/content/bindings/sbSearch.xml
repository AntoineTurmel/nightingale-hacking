<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">


  
  <!-- Songbird Search Widget
  
       Extends the Firefox searchbar widget to add "search as you type" functionality
       and other Songbird customizations.
       
       Unlike the Firefox searchbar, this widget fires a "search" event instead of
       dispatching search queries itself.  This allows gSearchHandler (in searchHandler.js)
       to provide special processing for the Songbird internal search engine.
       
       See dependencies/vendor/mozilla/browser/components/search/content/search.xml
    -->
  <binding id="sb-searchbar"
           extends="chrome://browser/content/search/search.xml#searchbar">
    <implementation>
      

      <!-- Map of engine names to booleans.
           Used to determine which engines send searches
           on input idle. -->
      <field name="_liveSearchEngines">new Object();</field>
      
      <!-- Map of engine names to display strings.
           Used by overrideEngineDisplayText() -->
      <field name="_engineDisplayText">new Object();</field>
      
      <!-- When true, causes searches to be sent automatically after
           a short delay -->      
      <property name="liveSearchMode">
        <getter><![CDATA[ 
          return this.isInLiveSearchMode(this.currentEngine);
        ]]></getter>
      </property>  
      
      
      
      
      <!-- Replace base currentEngine setter so that changing engines immediately
           executes the current query -->
      <property name="currentEngine"
                onset="">
        <getter><![CDATA[
          var currentEngine = this.searchService.currentEngine;
          // Return a dummy engine if there is no currentEngine
          return currentEngine || {name:"", uri:null};
        ]]></getter>
        <setter><![CDATA[
          this.searchService.currentEngine = val; 

          // Set the live search indicator attribute
          // according to the state of the new engine
          this.updateLiveSearchAttribute();

          // If there was a query, then run it immediately
          if (this.value != "" & this.getAttribute("empty") != "true") 
          {
            // Pretend the user hit enter
            this.handleSearchCommand(null);
          }
          
          return val;
        ]]></setter>        
      </property>      
      
      
  
      
      <!-- Override the normal get method in order to manage
           the "empty" and "livesearchmode" attributes for this
           element.
        -->
      <property name="value">
        <getter><![CDATA[
          if (this.getAttribute("empty") == "true") {
            return "";
          }
          return this._textbox.value;
        ]]></getter>      
        <setter><![CDATA[
          // Make sure to remove the "empty" attribute if someone is setting
          // the search bar value to a non-empty string. Similarly, we need to
          // add the "empty" attribute if someone is clearing the search box,
          // but only if the search box currently doesn't have focus.
          if (val) {
            this.removeAttribute("empty");
            this._textbox.value = val;
          }
          else {
            if (this._textbox.hasAttribute("focused")) {
              // Just clear the textbox
              this._textbox.value = "";
            }
            else {
              // Display the current engine
              this._textbox._displayCurrentEngine();
            }
          }
          
          this.updateLiveSearchAttribute();

          return val;
        ]]></setter>
      </property>      
      

      

      <!-- Overrides the text displayed when a given engine is active
           and nothing has been entered in the textbox.  
           Setting aText null causes the default text to be restored
        -->
      <method name="setEngineDisplayText">
        <parameter name="aEngine"/>
        <parameter name="aText"/>
        <body><![CDATA[
           // Add text to the engine name -> text map
           this._engineDisplayText[aEngine.name] = aText;
           
           // Replace the standard display text function
           // with our own
           this._replaceDisplayCurrentEngine();
        ]]></body>
      </method>    




      <!-- Has the given engine been flagged for live search -->
      <method name="isInLiveSearchMode">
        <parameter name="aEngine"/>
        <body><![CDATA[         
          if (aEngine.name && aEngine.name in this._liveSearchEngines 
              && this._liveSearchEngines[aEngine.name] == true)
          {
            return true;
          }
          return false;
        ]]></body>
      </method>    





      <!-- Flag the given engine for live search ("search as you type")
        -->   
      <method name="setLiveSearchMode">
        <parameter name="aEngine"/>
        <parameter name="aEnabled"/>
        <body><![CDATA[
          this._liveSearchEngines[aEngine.name] = aEnabled;
        
          // If the given engine is currently active then 
          // set the livesearch indicator attribute appropriately.          
          // This can be used to apply a special CSS style.
          if (this.currentEngine == aEngine) {
            this.updateLiveSearchAttribute();
          }
        ]]></body>
      </method>    



      <!-- Update the livesearchmode element attribute.
           This attribute is set true when the current search
           engine is in live search mode and the user has
           entered at least one character in the search box.
        -->   
      <method name="updateLiveSearchAttribute">
        <body><![CDATA[
          var enable = (this.liveSearchMode && this.value != "");
          this.setAttribute("livesearchmode", (enable) ? "true" : "false");                  
        ]]></body>
      </method> 
          
      

      <!-- Override the method responsible for executing searches
           so that we can splice in internal search support 
        -->   
      <method name="handleSearchCommand">
        <parameter name="aEvent"/>
        <body><![CDATA[
          var textBox = this._textbox;
          var textValue = this.value;

          this.updateLiveSearchAttribute();

          // Go-button clicks in live search mode clear the search terms
          if (this.liveSearchMode && aEvent 
              && aEvent.originalTarget.getAttribute("anonid") == "search-go-button")
          {
            this.value = "";
            this._sendSearchEvent();
            return;
          }

          // Save the current value in the form history
          if (textValue) {
            textBox._formHistSvc.addEntry(textBox.getAttribute("autocompletesearchparam"),
                                          textValue);
          }
                    
          // Add your eggs here...
          if ( textValue == "migmigmig" )  { alert( ".gge retsaE" ); } 
          else if ( textValue == "mattmattmatt" )  { alert( "Eggstereast." ); } 
                              
          this._sendSearchEvent();
        ]]></body>
      </method>

          
          
      <!-- Dispatch a search event -->
      <method name="_sendSearchEvent">
        <body><![CDATA[
          metrics_inc("search.widget", this.currentEngine.name, null);        
          var e = document.createEvent("Events");
          e.initEvent("search", false, true);
          this.dispatchEvent(e);
        ]]></body>
      </method>      
      
      
      <!-- Ensure that the FF default _displayCurrentEngine
           function has been replaced with our own.
           This allows overriding of the default display text.
           Since we want to avoid forking the mozilla search.xml
           we do this at runtime. Yay javascript.           
        -->
      <method name="_replaceDisplayCurrentEngine">
        <body><![CDATA[
          // If the function has already been replaced 
          // then do nothing.
          if (this._textbox._originalDisplayCurrentEngine) {
            return;
          }
          
          // Save the original function so that we can use it for 
          // cases when the engine text has not been overridden
          this._textbox._originalDisplayCurrentEngine = 
                    this._textbox._displayCurrentEngine;
          
          // Replace textbox function with one that will 
          // first check this._engineDisplayText
          this._textbox._displayCurrentEngine = function() {
            // See FF searchbar.xml _displayCurrentEngine
            var searchbar = this._getParentSearchbar();
            var text = searchbar._engineDisplayText[searchbar.currentEngine.name];

            // If no override text has been provided, then use the 
            // original display text function
            if (text == null) {
              this._originalDisplayCurrentEngine();
              return;
            }
           
            // Otherwise set the textbox to display
            // the given text.
            searchbar.setAttribute("empty", "true");
            var searchTextbox = this;
            setTimeout(function() {
              if (searchbar.getAttribute("empty") == "true")
                searchTextbox.value = text;
            }, 0);
          };
        ]]></body>
      </method>        
      
      
      <!-- Called when a Songbird search is selected, and a short delay has passed since
           the last keystroke.  Provides "search as you type" functionality. 
         -->
      <method name="_onSearchEditIdle">
        <body>
        <![CDATA[
          if (this.liveSearchMode)
          {
            this._sendSearchEvent();
            
            this.updateLiveSearchAttribute();
          }
        ]]>
        </body>
      </method>      
    </implementation>
    
    <handlers>

      <!-- Capture focus on the autocomplete textbox so that we can
           immediately pop out the autocomplete box 
        -->
      <handler event="focus" phase="capturing"><![CDATA[
        const target = event.originalTarget;
        
        this.setAttribute("focused", "true");
        
        if (target.getAttribute("class").indexOf("autocomplete-textbox") != -1) {
          
          // Make sure the songbird autocomplete source has been added
          // to the textbox.
          if (!this._textbox._hasSongbirdAutoCompleter) {
            this._textbox.setAttribute("autocompletesearch", 
                      "search-autocomplete songbird-autocomplete");
            this._textbox._hasSongbirdAutoCompleter = true;
          } 
          
          // If the textbox is empty then show the autocomplete
          if (this.getAttribute("empty") == "true") {          

            // Defer launching the popup so that we don't end up 
            // refocusing and textbox and screwing up the 
            // text displayed on empty=true
            if (!this._waitingForPopup) {
              this._waitingForPopup = true;
              setTimeout(function(o) { 
                  o._textbox.toggleHistoryPopup(); 
                  o._waitingForPopup = false;
                }, 10, this);
            }
          }                  
        }
      ]]></handler>
      
      <handler event="blur" phase="capturing"><![CDATA[
        if (this.hasAttribute("focused")) {
          this.removeAttribute("focused");        
        }  
      ]]></handler>      

    
      <!-- Starts the idle search timer after keypress when in live search mode  -->
      <handler event="keypress"><![CDATA[

        if (!this.liveSearchMode) {
          return;
        }
          
        switch ( event.keyCode )
        {
          case 9:  // Tab
          case 19: // Break
          case 37: // Arrows
          case 38:
          case 39:
          case 40:
          case 35: // End
          case 36: // Home
          case 45: // Insert
          case 33: // PgUp
          case 34: // PgDn
          case 112:// F1-F12
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
          case 123:
          case 27: // Esc
          case 13: // Return
            break;      
          default:
            if ( this._editIdleInterval )
            {
              clearInterval( this._editIdleInterval );
            }
            this._editIdleInterval = setInterval( 
              function(o) { 
                clearInterval( o._editIdleInterval );
                o._onSearchEditIdle(); 
              }, 1000, this);
            break;      
        }
      ]]></handler>    
    </handlers>
  </binding>  






  <!--
    A menupopup that offers to run the given search using the
    installed search plugins.
    
    Attributes:
      label      - Adds an extra disabled menuitem at the top of the list
                   to act as a context label.
      searchterm - The term to search for if the user selects a search engine
      enginetags - Include only search engines with any of the given tags.
  -->
  <binding id="sb-search-menupopup" 
           extends="chrome://global/content/bindings/popup.xml#popup">
    <implementation type="application/x-javascript">


      <property name="searchService" readonly="true">
        <getter><![CDATA[
          if (!this._ss) {
            const nsIBSS = Components.interfaces.nsIBrowserSearchService;
            this._ss =
                 Components.classes["@mozilla.org/browser/search-service;1"]
                           .getService(nsIBSS);
          }
          return this._ss;
        ]]></getter>
      </property>


      <property name="currentEngine" readonly="true">
        <getter><![CDATA[
          // Return a dummy engine if there is no currentEngine
          return this._currentEngine || {name:"", uri:null};
        ]]></getter>       
      </property>      
      
      
      <!-- Get the current search query. -->
      <property name="value" readonly="true">
        <getter><![CDATA[
          return this.getAttribute("searchterm");
        ]]></getter>      
      </property>    


      <!--
        Called just before the popup appears.
      -->
      <method name="onPopupShowing">
        <body>
          <![CDATA[
            this._cleanMenu();
            this._buildMenu();
          ]]>
        </body>
      </method>


      <!--
        Called when a child menuitem is selected.  
      -->
      <method name="onCommand">
        <parameter name="item"/>
        <body>
          <![CDATA[
            // If the user clicked on a menuitem, then launch the search
            if (item.engine) {
              this._currentEngine = item.engine;
              this._sendSearchEvent();
            } else {
              dump("sb-search-menupopup: oncommand: unknown menu item\n");
            }
          ]]>
        </body>
      </method>


      <!-- Dispatch an event with the alias of the current search engine -->
      <method name="_sendSearchEvent">
        <body><![CDATA[              
          metrics_inc("search.menu", this._currentEngine.name, null);
          var e = document.createEvent("Events");
          e.initEvent("search", false, true);
          this.dispatchEvent(e);
        ]]></body>
      </method>   
      

      <!-- Get rid of all the children of this menupopup -->
      <method name="_cleanMenu">
        <body>
          <![CDATA[
            var children = this.childNodes;
            for (var i = children.length - 1; i >= 0; --i) {
              this.removeChild(children[i]);
            }
          ]]>
        </body>
      </method>


      <!--
        Populates this menupopup with menuitems allowing 
        search engine selection
      -->
      <method name="_buildMenu">
        <body>
          <![CDATA[
            var popup = this;

            const kXULNS =
                "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";

            // If a label was given, stick it in a disabled menuitem
            // at the top of the list, and then add a separator.
            var label = this.getAttribute("label");
            if (label && label != "") {
              var menuitem = document.createElementNS(kXULNS, "menuitem");
              menuitem.setAttribute("label", label);
              menuitem.setAttribute("disabled", "true");
              popup.appendChild(menuitem);
              popup.appendChild(document.createElementNS(kXULNS, "menuseparator"));
            }

            // Append visible engines
            this._engines = this._getEngines();
            for (var i = 0; i < this._engines.length; i++) {
              var menuitem = document.createElementNS(kXULNS, "menuitem");
              var name = this._engines[i].name;
              menuitem.setAttribute("label", name);
              menuitem.setAttribute("id", name);
              menuitem.setAttribute("name", "search-menupopup-engine");
              menuitem.setAttribute("class", "menuitem-iconic searchbar-engine-menuitem");
              if (this._engines[i].iconURI)
                menuitem.setAttribute("src", this._engines[i].iconURI.spec);
              popup.appendChild(menuitem, popup.firstChild);
              menuitem.engine = this._engines[i];
            }          
          ]]>
        </body>
      </method>
      
      <!--
        Gets an array of search engines to use in this menu.
        If enginetags has been specified then the list will only
        include engines containing at least one of the given tags. 
        If not, then all visible untagged search engines will be used.
      -->
      <method name="_getEngines">
        <body>
          <![CDATA[
            var engines;
        
            // If some tags were specified then only get
            // engines that have at least one of the tags
            var tags = this.getAttribute("enginetags");
            if (tags) 
            {
              // Build a regex that matches if a string contains
              // any of the given tags
              tags = tags.replace(" ", "|");
              var tagRegex = new RegExp("^(.* )?(" + tags + ")( .*)?$");

              function hasTag(engine) {
                return tagRegex.test(engine.tags);
              };
              
              // Get all search engines and then filter
              // using our regular expression
              engines = this.searchService
                            .getEngines({ })
                            .filter(hasTag);
            }
            // Otherwise include all visible untagged search engines
            else 
            {             
              function hasTags(engine) {
                return engine.tags == "";
              };
              
              engines = this.searchService
                            .getVisibleEngines({ })
                            .filter(hasTags);
            }
 
            return engines;
          ]]>
        </body>
      </method>      


    </implementation>
    
    <handlers>
      <handler event="command">
        <![CDATA[
          this.onCommand(event.target);
          
          // We've handled this event, so prevent
          // others from hearing about it.
          event.stopPropagation();
          event.preventDefault();
        ]]>
      </handler>
      <handler event="popupshowing">
        <![CDATA[
          if (event.target == this) {
            this.onPopupShowing();
          }
        ]]>
      </handler>
      <handler event="popuphidden">
        <![CDATA[        
          if (event.target == this) {
            // Should we do anything here?
          }
        ]]>
      </handler>
    </handlers>
  </binding>


  
  

</bindings>
