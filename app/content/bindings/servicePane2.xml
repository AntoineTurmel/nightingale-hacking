<?xml version="1.0" encoding="UTF-8"?>
<!--
/*
 *=BEGIN SONGBIRD GPL
 *
 * This file is part of the Songbird web player.
 *
 * Copyright(c) 2005-2010 POTI, Inc.
 * http://www.songbirdnest.com
 *
 * This file may be licensed under the terms of of the
 * GNU General Public License Version 2 (the ``GPL'').
 *
 * Software distributed under the License is distributed
 * on an ``AS IS'' basis, WITHOUT WARRANTY OF ANY KIND, either
 * express or implied. See the GPL for the specific language
 * governing rights and limitations.
 *
 * You should have received a copy of the GPL along with this
 * program. If not, go to http://www.gnu.org/licenses/gpl.html
 * or write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 *=END SONGBIRD GPL
 */
-->

<!--
  -TODO:
  - Bug 18545
  -  1. Create 3 bindings (done)
  -   i.   Service Pane (done)
  -   ii.  Service Pane Group (done)
  -   iii. Service Pane Node (done)
  -  2. Migrate functionality of old service pane to new service pane
  -  3. Context menus for nodes.
  -  4. Edit names for nodes.
  -  5. Ability to highlight nodes.
  - Bug 18548
  -  1. Toggle node visibility when clicking on toggle image in header of group.
  - Bug 18551
  -  1. Make sure we can change the badge on nodes easily.
  - Bug 18552
  -  1. Make sure we can change the image on nodes easily.
  -->

<!DOCTYPE window SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:xbl="http://www.mozilla.org/xbl">

  <!--
    - \brief ServicePaneNodeBadge is a single badge attached to a
    - ServicePaneNode.  It contains a text label, image, and an associated
    - action.  If the image is null, then the text label will be used.
    - When the badge is clicked, the action will be taken if one is defined.
    -->
  <binding id="servicepane-node-badge">
    <content mousethrough="never">
      <xul:hbox class="servicepane-node-badge">
        <xul:label sbid="servicepane-node-badge-label"
                   class="servicepane-node-badge-label"/>
        <xul:image sbid="servicepane-node-badge-image"
                   class="servicepane-node-badge-image"
                   hidden="true"/>
      </xul:hbox>
    </content>

    <implementation>
      <constructor>
      <![CDATA[
          if (this.hasAttribute("badgeImage")) {
            this.badgeImage = this.getAttribute("badgeImage");
          }
          if (this.hasAttribute("badgeLabel")) {
            this.badgeLabel = this.getAttribute("badgeLabel");
          }
          this.badgeAction = null;
      ]]>
      </constructor>

      <!--
        - \brief Gets an element in this binding that has the sbid matching the
        -   anonID parameter.
        - \param anonID Anonymous id of the element requested (matches sbid)
        - \return element if found, or null if not
        -->
      <method name="_getElement">
        <parameter name="anonID"/>
        <body><![CDATA[
          return document.getAnonymousElementByAttribute(this,
                                                         "sbid",
                                                         anonID);
        ]]></body>
      </method>

      <!--
        - \brief Updates the badge depending on the values of the elements. If
        - the image has no src then we show the label and hide the image, if the
        - image has a src then we hide the label and show the image.
        -->
      <method name="_update">
        <body><![CDATA[
          let imageNode = this._getElement("servicepane-node-badge-image");
          let textNode = this._getElement("servicepane-node-badge-label");
          if (this.hasAttribute("badgeImage")) {
            imageNode.removeAttribute("hidden");
            textNode.setAttribute("hidden", true);
          }
          else {
            imageNode.setAttribute("hidden", true);
            textNode.removeAttribute("hidden");
          }
        ]]></body>
      </method>

      <!--
        - \brief property for the image of this badge.
        -->
      <property name="badgeImage">
        <getter><![CDATA[
          let imageNode = this._getElement("servicepane-node-badge-image");
          return this.getAttribute("badgeImage");
        ]]></getter>
        <setter><![CDATA[
          let imageNode = this._getElement("servicepane-node-badge-image");
          let textNode = this._getElement("servicepane-node-badge-label");
          this.setAttribute("badgeImage", val);
          imageNode.style.listStyleImage = "url('" + val + "')";
          this._update();
          return val;
        ]]></setter>
      </property>

      <!--
        - \brief property for the text of this badge
        -->
      <property name="badgeLabel">
        <getter><![CDATA[
          let textNode = this._getElement("servicepane-node-badge-label");
          return imageNode.value;
        ]]></getter>
        <setter><![CDATA[
          let textNode = this._getElement("servicepane-node-badge-label");
          this.removeAttribute("badgeImage");
          textNode.value = val;
          this._update();
          return val;
        ]]></setter>
      </property>

    </implementation>

    <handlers>
      <handler event="click">
      <![CDATA[
        if (event.button == 0) {
          if (this.badgeAction) {
            try {
              this.badgeAction();
            } catch (e) {
              dump("Badge action exception: " + e + "\n");
            }
            event.stopPropagation();
            event.preventDefault();
          }
        }
      ]]>
      </handler>
    </handlers>


  </binding>

   <!--
    - \brief ServicePaneNode is a single entry attached to a ServicePaneGroup.
    - it contains an icon, label and an arbitrary # of ServicePaneNodeBadges.
    - When the user clicks the node the url attached to this node will launch
    - in the browser if any.  If the node is already selected and the user
    - clicks it, the node should be renamed.
    -->
  <binding id="servicepane-node">
    <content mousethrough="never">
      <xul:vbox class="servicepane-node" flex="1">

        <xul:hbox class="servicepane-node-info" mousethrough="always">
          <xul:image class="servicepane-node-container-arrow"
                     flex="0"
                     mousethrough="never"
                     onclick="toggleContainer(event)" />
          <xul:image class="servicepane-node-image"
                     xbl:inherits="src=image" flex="0" />
          <xul:stack sbid="servcepane-node-stack" flex="1">
            <xul:hbox flex="1">
              <xul:label class="servicepane-node-label"
                         crop="end"
                         flex="1"
                         mousethrough="never"
                         xbl:inherits="value=label"/>
              <xul:spacer flex="1" />
              <xul:hbox class="servicepane-node-badges"
                        sbid="servicepane-node-badges" flex="1" />
            </xul:hbox>

            <!-- that onblur event is a little confusing.  the event bubbles up
                 so that it fires for both the HTML input element & the XUL
                 element.  we check the original target to make sure it's the
                 right element (e.g. where textboxBlur() is defined -->
            <xul:textbox class="servicepane-node-textbox"
                         sbid="servicepane-node-textbox"
                         xbl:inherits="value=label"
                         flex="1"
                         onkeypress="textboxKeypress(event)"
                         onblur="if (event.originalTarget != this) textboxBlur(event)"
                         hidden="true" />
          </xul:stack>
        </xul:hbox>

        <xul:vbox sbid="servicepane-node-children"
                  class="servicepane-node-children"
                  mousethrough="never">
          <children />
        </xul:vbox>

      </xul:vbox>
    </content>

    <implementation>
      <constructor>
        <![CDATA[
          // TODO: Check for a better way to load. (stevo)
          // This is here because we can not call nodeData until the binding has
          // been applied.

          // If this element has a node id then load up the data from the node
          // we are always expected to be in the service pane under a group at
          // this point so we call up the DOM of nodes.
          try {
            if (this.hasAttribute("nodeid")) {
              var nodeID = this.getAttribute("nodeid");
              if (this.parentNode)
                this.nodeData = this.parentNode.getNode(nodeID);
            } else {
              // If we have no node data, then hide by default.
              this.setAttribute("hidden", true);
            }

            this._textbox = this._getElement("servicepane-node-textbox");
            this._textbox.realParent = this;
            this.mService =
              Components.classes['@songbirdnest.com/servicepane/service;1']
              .getService(Components.interfaces.sbIServicePaneService);
            this.mDragService = 
              Components.classes['@mozilla.org/widget/dragservice;1']
              .getService(Components.interfaces.nsIDragService);

            // Determine how much to indent this node
            let spacer = this._getElement("servicepane-node-spacer");
            let indent = -1;
            let parent = this.nodeData.parentNode;
            while (parent) {
              indent++;
              parent = parent.parentNode;
            }
            this.setAttribute("indent", indent);
          } catch (e) {
            dump("Exception: " + e + "\n");
          }
        ]]>
      </constructor>

      <!--
        - \brief Hold the actual node data for this node so we can reference it
        -   whenever we need
        -->
      <field name="_nodeData">null</field>

      <!--
        - \brief The node ID
        -->
      <field name="nodeId">this._nodeData.id</field>

      <!--
        - \brief Get the servicepane element itself
        -->
      <property name="_servicePane">
        <getter><![CDATA[
          let parent = this.parentNode;
          while (parent && parent.tagName != "sb-servicepane")
            parent = parent.parentNode;
          return parent;
        ]]></getter>
      </property>

      <!--
        - \brief Gets an element in this binding that has the sbid matching the
        -   anonID parameter.
        - \param anonID Anonymous id of the element requested (matches sbid)
        - \return element if found, or null if not
        -->
      <method name="_getElement">
        <parameter name="anonID"/>
        <body><![CDATA[
          return document.getAnonymousElementByAttribute(this,
                                                         "sbid",
                                                         anonID);
        ]]></body>
      </method>

      <!--
        - \brief sbIServicePaneNode data associated with this node
        -->
      <property name="nodeData">
        <getter><![CDATA[
          return this._nodeData;
        ]]></getter>
        <setter><![CDATA[
          // val should be a sbIServicePaneNode object
          this._nodeData = val;
          if (this._nodeData) {
            // Set up the elements
            this.setAttribute("image", this._nodeData.image);
            this.setAttribute("label", this._nodeData.displayName);
            this.setAttribute("collapsed", !this._nodeData.isOpen);

            // Hide the node if it should be hidden
            if (this._nodeData.hidden) {
              this.setAttribute("hidden", true);
            } else if (this.hasAttribute("hidden")) {
              this.removeAttribute("hidden");
            }

            this.className += this._nodeData.className;
          }
          else {
            this.setAttribute("image", "");
            this.setAttribute("label", "");
            this.setAttribute("hidden", "true");
            this.setAttribute("collapsed", false);
          }
          return this._nodeData;
        ]]></setter>
      </property>

      <!--
        - \brief The browser we are linked to if any.
        -->
      <field name="_browser">null</field>
      <property name="browser">
        <getter><![CDATA[
          if (!this._browser) {
            this._browser = document.getElementById(this.getAttribute('browser'));
          }
          return this._browser;
        ]]></getter>
      </property>

      <!--
        - \brief If this is a container, toggle the open/closed state.
        -->
      <method name="toggleContainer">
        <parameter name="event"/>
        <body><![CDATA[
          // First see if we've actually got children, if not - then bail
          if (!this.firstChild)
            return;

          this.nodeData.isOpen = !this.nodeData.isOpen;
          event.stopPropagation();
          event.preventDefault();
        ]]></body>
      </method>

      <!--
        - \brief Load the URL associated with this node in the browser if
        - available.
        -->
      <method name="loadNodeURL">
        <parameter name="event"/>
        <body><![CDATA[
          if (!this.browser)
            return; // Nothing to do if we don't have a browser.

          // Style the node as active (which means first removing any
          // styles from any currently active node
          this._servicePane.makeNodeActive(this.nodeData);

          // If this node has a URL, just load it in the browser
          if (this._nodeData.url) {
            var target = null;
            if (LibraryUtils.isMediaTabURL(this._nodeData.url, this.browser)) {
              target = "_media";
              this.browser.selectedTab = this.browser.mediaTab;
            } else if (event.button == 1) {
              // Middle click.
              target = "_blank";
            }
            this.browser.loadURI(this._nodeData.url, null, null, event, target);

          // If no URL, apply special handling
          } else {
            // If there is a media list for this node, hand it off to the
            // browser to display somehow.
            // I'm told that this hack is fine, as it will one day be replaced
            // with the playlist commands system.
            var libraryServicePane =
              Components.classes['@songbirdnest.com/servicepane/library;1']
              .getService(Components.interfaces.sbILibraryServicePaneService);
            var mediaList = libraryServicePane.getLibraryResourceForNode(this._nodeData);
            if (mediaList) {
              const NS_SP = "http://songbirdnest.com/rdf/servicepane#";
              var view = LibraryUtils.createStandardMediaListView(mediaList);
              if (this._nodeData.hasAttributeNS(NS_SP,
                                                "mediaListViewConstraints")) {
                // set up the constraints
                var builder = Components.classes["@songbirdnest.com/Songbird/Library/ConstraintBuilder;1"]
                                        .createInstance(Components.interfaces.sbILibraryConstraintBuilder);
                try {
                  builder.parseFromString(
                    this._nodeData.getAttributeNS(NS_SP,
                                                  "mediaListViewConstraints"));
                  view.filterConstraint = builder.get();
                } catch (e) {
                  // boo, the constraints are bad, use standard instead
                  view.filterConstraint = LibraryUtils.standardFilterConstraint;
                }
              }
              var tab = this.browser.loadMediaList(mediaList,
                                                   event,
                                                   "_media",
                                                   view);
              this.browser.selectedTab = tab;

              // Record list type metrics for some reason.
              // See http://bugzilla.songbirdnest.com/show_bug.cgi?id=4021
              // changed to loadNode from click as there are ways other than clicking
              // to get here.
              try {
                var listType = mediaList.getProperty(SBProperties.customType);
                var libType = mediaList.library.getProperty(SBProperties.customType);
                metrics_inc("app.servicepane.loadnode.medialist", libType + "." + listType, null);
              } catch(e) { Components.utils.reportError(e); }

            } else {
              // we have no handler for this service pane node load
              // dispatch an event people can listen for and don't report
              let event = document.createEvent("XULCommandEvent");
              event.QueryInterface(Components.interfaces.nsIDOMXULCommandEvent);
              event.initCommandEvent("servicepane-loadnode",
                                     event.bubble,
                                     false,
                                     event.view,
                                     event.detail,
                                     event.ctrlKey,
                                     event.altKey,
                                     event.shiftKey,
                                     event.metaKey,
                                     event);
              this.dispatchEvent(event);

              var SP_NS = "http://songbirdnest.com/rdf/servicepane#";
              var eventType = this._nodeData.getAttributeNS(SP_NS, "eventType");
              if (eventType) {
                let event = document.createEvent("UIEvent");
                event.initUIEvent(eventType, true, true, window, 0);
                window.dispatchEvent(event);
              }
            }
          }
        ]]></body>
      </method>

      <!--
        - \brief Creates a badge element.
        - \param badgeLabel - Value to set the badge to (can be null)
        - \param badgeImage - Image to set the badge to (can be null)
        - \return newly created badge element
        -->
      <method name="_createBadge">
        <parameter name="badgeLabel"/>
        <parameter name="badgeImage"/>
        <body><![CDATA[
          var XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          var newBadge = document.createElementNS(XULNS,
                                                  "sb-servicepane-node-badge");
          if (badgeLabel)
            newBadge.setAttribute("badgeLabel", badgeLabel);
          if (badgeImage)
            newBadge.setAttribute("badgeImage", badgeImage);
          return newBadge;
        ]]></body>
      </method>

      <!--
        - \brief Appends a badge element to the node.
        - \param badgeLabel - Value to set the badge to (can be null)
        - \param badgeImage - Image to set the badge to (can be null)
        - \return newly appended badge element.
        -->
      <method name="appendBadge">
        <parameter name="badgeLabel"/>
        <parameter name="badgeImage"/>
        <parameter name="badgeAction"/>
        <body><![CDATA[
          var newBadge = this._createBadge(badgeLabel, badgeImage);
          var badgeContainer = this._getElement("servicepane-node-badges");
          badgeContainer.appendChild(newBadge);
          if (badgeAction) {
            newBadge.setAttribute("mousethrough", "never");
            newBadge.badgeAction = badgeAction;
          }
          return newBadge;
        ]]></body>
      </method>

      <!--
        - \brief Removes a badge element.
        - \param index - Index of the badge to remove.
        - \return copy of removed badge.
        -->
      <method name="removeBadge">
        <parameter name="index"/>
        <body><![CDATA[
          var oldChild = null;
          var badgeContainer = this._getElement("servicepane-node-badges");
          if (badgeContainer.childNodes.length > index) {
            oldChild = badgeContainer.removeChild(badgeContainer.childNodes[index]);
          }
          return oldChild;
        ]]></body>
      </method>

      <!--
        - \brief Inserts a badge element before an existing one.
        - \param badgeLabel - Value to set the badge to (can be null)
        - \param badgeImage - Image to set the badge to (can be null)
        - \param beforeIndex - Index of badge to insert a new badge before.
        - \return newly appended badge element.
        -->
      <method name="insertBadgeBefore">
        <parameter name="badgeLabel"/>
        <parameter name="badgeImage"/>
        <parameter name="beforeIndex"/>
        <body><![CDATA[
          var badgeContainer = this._getElement("servicepane-node-badges");
          if (beforeIndex > 0 &&
              beforeIndex < badgeContainer.childNodes.length) {
            var newBadge = this._createBadge(badgeLabel, badgeImage);
            badgeContainer.insertBefore(newBadge,
                                        badgeContainer.childNodes[beforeIndex]);
          }
          return newBadge;
        ]]></body>
      </method>
      
      <method name="setAsDropTarget">
        <parameter name="isdroptarget"/>
        <body>
          if (isdroptarget) {
            if (this.className.search(/\bdroptarget\b/) == -1) {
              this.className += " droptarget";
            }
          } else {
            this.className = this.className.replace(/\bdroptarget\b/g,'');
          }
        </body>
      </method>

      <method name="textboxBlur">
        <parameter name="event"/>
        <body><![CDATA[
          if (this._textbox.getAttribute("hidden"))
            return;
          this._textbox.value = this.getAttribute("label");
          this._textbox.setAttribute("hidden", true);
          this._servicePane.mService.onRename(this.nodeData, null);
          event.stopPropagation();
          event.preventDefault();
        ]]></body>
      </method>

      <method name="textboxKeypress">
        <parameter name="event"/>
        <body><![CDATA[
          switch (event.keyCode) {
            case 27: // escape
              // reset changes & exit editing mode
              this._textbox.value = this.getAttribute("label");
              this._textbox.setAttribute("hidden", true);
              this._servicePane.mService.onRename(this.nodeData, null);
              break;
            case 13: // enter
              // save changes & exit editing mode
              this.setAttribute("label", this._textbox.value);
              this._textbox.setAttribute("hidden", true);
              this._servicePane.mService.onRename(this.nodeData,
                                                  this._textbox.value);
              this.loadNodeURL(event);
              break;
          }
        ]]></body>
      </method>

      <!-- drag-and-drop helpers -->
      <method name="_onDragGesture">
        <parameter name="event"/>
        <body>
          <![CDATA[
          var transferable = {};
          if (this.mService.onDragGesture(this.nodeData, transferable)) {
            transferable = transferable.value;
            var transArray = Components.classes["@mozilla.org/supports-array;1"]
                                       .createInstance(Components.interfaces.nsISupportsArray);
            transArray.AppendElement(transferable);
            
            var region = null;
            // let's build the drag region
            try {
              region = Components.classes["@mozilla.org/gfx/region;1"]
                        .createInstance(Components.interfaces.nsIScriptableRegion);
              region.init();

              var bo = this.boxObject;

              region.unionRect(bo.x, bo.y, bo.width, bo.height);

            } catch(ex) {
              dump("Error while building drag region: " + ex + "\n");
              region = null;
            }
            
            var dragAction = this.mDragService.DRAGDROP_ACTION_COPY +
                             this.mDragService.DRAGDROP_ACTION_MOVE;
            this.mDragService.invokeDragSessionWithImage(this, 
                                                         transArray,
                                                         region, dragAction,
                                                         null, 0, 0,
                                                         event);
            
            event.preventDefault();
          }
        ]]>
        </body>
      </method>

      <!-- begin nsDragAndDropObserver -->
      <method name="getSupportedFlavours">
        <body>
        <![CDATA[
          var flavourSet;
          flavourSet = new FlavourSet();
          flavourSet.appendFlavour("application/x-sb-transfer-media-item");
          flavourSet.appendFlavour("application/x-sb-transfer-media-list");
          flavourSet.appendFlavour("application/x-sb-transfer-media-items");
          flavourSet.appendFlavour("application/x-sb-transfer-disable-download");
          return flavourSet;
        ]]>
        </body>
      </method>

      <method name="canDrop">
        <parameter name="event"/>
        <parameter name="session"/>
        <body><![CDATA[
          return this.mService.canDrop(this.nodeData,
                                       this.mDragService.getCurrentSession(),
                                       0, 
                                       window);
        ]]></body>
      </method>


      <method name="onDragOver">
        <parameter name="event"/>
        <parameter name="flavour"/>
        <parameter name="session"/>
        <body>
        <![CDATA[
          if (session.sourceNode != event.target &&
              this.canDrop(event, session))
            this.setAsDropTarget(true);
        ]]>
        </body>
      </method>

      <method name="onDragExit">
        <parameter name="event"/>
        <parameter name="session"/>
        <body>
          this.setAsDropTarget(false);
        </body>
      </method>

      <method name="onDrop">
        <parameter name="event"/>
        <parameter name="session"/>
        <body><![CDATA[
          this.mService.onDrop(this.nodeData,
                               this.mDragService.getCurrentSession(),
                               0, 
                               window);
        ]]></body>
      </method>

      <method name="getNode">
        <parameter name="nodeID"/>
        <body><![CDATA[
          return this.parentNode.getNode(nodeID);
        ]]></body>
      </method>
 
    </implementation>

    <handlers>
      <handler event="click">
      <![CDATA[
        if (event.button == 0) {
          // if we're the active node, & the user clicked on the label
          // then rename
          if (this._servicePane.getActiveNode() == this.nodeData &&
              this.nodeData.editable &&
              event.originalTarget.tagName == "xul:label")
            this._servicePane.startEditingNode(this.nodeData);
          // otherwise load 
          else
            this.loadNodeURL(event);

          event.stopPropagation();
          event.preventDefault();
        }
      ]]>
      </handler>

      <handler event="contextmenu">
      <![CDATA[
        this._servicePane.openContextMenu(event, this.nodeId);
      ]]>
      </handler>

      <!-- drag and drop handling -->
      <handler event="draggesture"><![CDATA[
        // don't allow drag gestures with the popup menu open.
        if (this.mPopup && 
            this.mPopup.state != "closed") {
          return;
        }
        this._onDragGesture(event);
      ]]></handler>

      <handler event="dragover">
        nsDragAndDrop.dragOver(event, this);
        this._servicePane.needScroll(event);
        event.stopPropagation();
      </handler>

      <handler event="dragdrop">
        nsDragAndDrop.drop(event, this);
        event.stopPropagation();
      </handler>

      <handler event="dragexit">
        nsDragAndDrop.dragExit(event, this);
        event.stopPropagation();
      </handler>

    </handlers>

  </binding>

  <binding id="servicepane-group">
    <content mousethrough="never">
      <xul:vbox id="group" class="servicepane-group" >
        <xul:hbox id="hbox-header" class="servicepane-group-header">
          <xul:hbox class="servicepane-group-header-wrapper"
                    onclick="toggleVisibility(event)" flex="1">
            <xul:description class="servicepane-group-label"
                       xbl:inherits="xbl:text=label"/>
            <xul:spacer flex="1" />
          </xul:hbox>
          <xul:image sbid="servicepane-group-header-image"
                     onclick="newPlaylist(event)" />
        </xul:hbox>
        <xul:vbox class="servicepane-group-overflow-container">
          <xul:vbox class="servicepane-group-nodes"
                    sbid="groupNodes" xbl:inherits="open" flex="1">
            <children /> <!-- servicepane-nodes -->
          </xul:vbox>
        </xul:vbox>
      </xul:vbox>
    </content>

    <implementation>
      <constructor><![CDATA[
        this._groupNodes = this._getElement("groupNodes");
        this._visible = true;

        this.image = null;
        // Special handling for the SB:Playlists group
        if (this.id == "SB:Playlists") {
          this.image = this._getElement("servicepane-group-header-image");
          this.image.className = "sb-servicepane-new-playlist";
        }

        this.servicePane = this.parentNode;

        var self = this;
        this.keyListener = function(e) {
          if (!self.image)
            return;

          if (e.altKey) {
            self.image.setAttribute("altKey", "true");
          } else {
            self.image.removeAttribute("altKey");
          }
        }

        window.addEventListener("keydown", this.keyListener, false);
        window.addEventListener("keyup", this.keyListener, false);
      ]]></constructor>

      <destructor><![CDATA[
        window.removeEventListener("keydown", this.keyListener, false);
        window.removeEventListener("keyup", this.keyListener, false);
      ]]></destructor>

      <method name="newPlaylist">
        <parameter name="event" />
        <body><![CDATA[
          if (event.altKey) {
            SBNewSmartPlaylist();
          } else {
            if (gBrowser &&
                gBrowser.selectedTab &&
                gBrowser.selectedTab.mediaListView)
            {
              enumerator = gBrowser.selectedTab
                .mediaListView
                .selection
                .selectedMediaItems;
            }

            SBNewPlaylist(enumerator);
          }
        ]]></body>
      </method>

      <property name="visible">
        <getter><![CDATA[
          return this._visible;
        ]]></getter>
        <setter><![CDATA[
          this._visible = val;
          if (this._visible) {
            this.animateTo(this._groupNodes, 0, 0, this._height, 5, true);
          } else {
            this._height = this._groupNodes.boxObject.height;
            this.animateTo(this._groupNodes, this._height, this._height, 0, 5, false);
          }
        ]]></setter>
      </property>
      
      <method name="animateTo">
        <parameter name="element" />
        <parameter name="orig" />
        <parameter name="from" />
        <parameter name="to" />
        <parameter name="interval" />
        <parameter name="dir" />
        <body><![CDATA[
          var self = this;
          try {
            if (dir) {
              if (from < to) {
                let diff = to - from;
                interval = diff/2;
                let newdim = from + interval;
                if (newdim >= to || interval < 5)
                  newdim = to;

                let marginTop = to - newdim; 
                element.style.marginTop = "-" + marginTop + "px";
                setTimeout(function() {
                    self.animateTo(element, orig, newdim, to, interval, dir);
                    }, 40);
              } else {
                element.style.marginTop = "-" + orig + "px";
                self.removeAttribute("collapsedChildren");
              }
            } else {
              if (from > to) {
                let diff = from - to;
                interval = diff/2;
                let newdim = from - interval;
                if (newdim <= to || interval < 3)
                  newdim = to;

                let marginTop = orig - newdim;
                element.style.marginTop = "-" + marginTop + "px";
                setTimeout(function() {
                    self.animateTo(element, orig, newdim, to, interval, dir);
                    }, 40);
              } else {
                element.style.marginTop = "-" + orig + "px";
                self.setAttribute("collapsedChildren", true);
              }
            }
          } catch (e) {
            dump("Exception: " + e + "\n\n\n");
          }
        ]]></body>
      </method>

      <method name="_getElement">
        <parameter name="anonID"/>
        <body><![CDATA[
          return document.getAnonymousElementByAttribute(this,
                                                         "sbid",
                                                         anonID);
        ]]></body>
      </method>

      <method name="getNode">
        <parameter name="nodeID"/>
        <body><![CDATA[
          return this.parentNode.getNode(nodeID);
        ]]></body>
      </method>

      <method name="toggleVisibility">
        <parameter name="event" />
        <body><![CDATA[
          this.visible = !this.visible;
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="dragover"><![CDATA[
        // If there is an existing expanded group that isn't us, then
        // collapse it
        if (this.servicePane._collapsedGroup &&
            this.servicePane._collapsedGroup != this)
        {
          this.servicePane._collapsedGroup._collapseOnDragExit = null;
          this.servicePane._collapsedGroup.visible = false;
          this.servicePane._collapsedGroup = null;
        }

        // If we have an existing timer running for a group that isn't us,
        // clear it
        if (this.servicePane._timer &&
            this.servicePane._timerGroup &&
            this.servicePane._timerGroup != this)
        {
          this.servicePane.log("Existing timer found, clearing");
          clearTimeout(this.servicePane._timer);
          this.servicePane._timer = null;
        }

        if (!this.visible && !this._expandTimerRunning) {
          this.servicePane.log("Collapsed group found: " + this.id +
                               ", setting expand timer for 1s");
          var self = this;
          // Flag a timer as running
          this._expandTimerRunning = true;
          this.servicePane._timerGroup = this;
          this.servicePane._timer = setTimeout(function() {
              // Make the group visible
              self.servicePane.log("Expanding group: " + self.id);
              self.visible = true;
              self._collapseOnDragExit = true;
              self.servicePane._collapsedGroup = self;
              self._expandTimerRunning = null;
              self.servicePane._timerGroup = null;
              self.servicePane._timer = null;
            }, 750);
          event.stopPropagation();
        }
      ]]></handler>

      <handler event="dragexit"><![CDATA[
        if (!event.relatedTarget)
          return;
        let relation = this.compareDocumentPosition(event.relatedTarget);
        if (this._expandTimerRunning &&
            !((relation & this.DOCUMENT_POSITION_CONTAINS) ||
              (relation & this.DOCUMENT_POSITION_CONTAINED_BY)))
        {
          // We've exited the group, so cancel any existing timer
          this.servicePane.log("Exited group: " + this.id + ", clearing timer");
          clearTimeout(this.servicePane._timer);
          this._expandTimerRunning = null;
          this.servicePane.timer = null;
          this.servicePane._timerGroup = null;
        }

        /* Auto-collapse if we auto-expanded */
        if (this._collapseOnDragExit &&
            !((relation & this.DOCUMENT_POSITION_CONTAINS) ||
              (relation & this.DOCUMENT_POSITION_CONTAINED_BY)))
        {
          this.visible = false;
          this._collapseOnDragExit = null;
          this.servicePane._collapsedGroup = null;
        }
      ]]></handler>
    </handlers>
  </binding>

  <binding id="servicepane">
    <content mousethrough="never" wheelvolume="false">
      <xul:vbox id="sb_servicepane" class="servicepane-outer-box" flex="1">
        <xul:scrollbox id="sb_servicepane_box"
                  orient="vertical"
                  sbid="innerbox"
                  class="servicepane-inner-box"
                  flex="1">
          <children /> <!-- servicepane-group elements -->
        </xul:scrollbox>
        <xul:sb-displaypane-splitter
                collapse="after"
                orient="vertical"
                resizeafter="closest"
                id="displaypane_servicepane_bottom_splitter"
                menuid="displaypane_servicepane_bottom_menu" />
        <xul:sb-displaypane id="displaypane_servicepane_bottom"
                            label="&displaypane.name.servicepane;"
                            splitter="displaypane_servicepane_bottom_splitter"
                            contentgroup="servicepane"/>
      </xul:vbox>
      <!-- menupopup needs to be outside the vbox otherwise it
           gets height adjusted to 0 when the splitter is
           adjusted -->
      <xul:menupopup id="displaypane_servicepane_bottom_menu"
                     class="menulist-menupopup">
        <xul:sb-displaypane-content-menuitems
                     paneid="displaypane_servicepane_bottom" />
      </xul:menupopup>

      <!-- context menu popup -->
      <xul:popupset>
        <xul:popup sbid="popup"
                   onpopupshown="onPopupShown(event);"
                   onpopuphidden="onPopupHidden(event);" />
      </xul:popupset>
    </content>

    <implementation>
      <constructor>
      <![CDATA[
        window.gServicePane = this;

        // Setup logging
        Components.utils.import("resource://app/jsmodules/DebugUtils.jsm");
        this.log = DebugUtils.generateLogFunction("ServicePane", 4);
        this.noisyLog = DebugUtils.generateLogFunction("ServicePane", 5);

        this.mService =
          Components.classes['@songbirdnest.com/servicepane/service;1']
          .getService(Components.interfaces.sbIServicePaneService);
        this.mService.init();

        this.loadServicePane();

        // save the popup node
        this.mPopup = document.getAnonymousElementByAttribute(this,
                                                              'sbid',
                                                              'popup');
        this.mInnerBox = document.getAnonymousElementByAttribute(this,
                                                                 'sbid',
                                                                 'innerbox');
        /* Add a listener to the root node so we know to update when the
           hierarchy of nodes changes */
        this._mutationListener.element = this;
        this.mService.root.addMutationListener(this._mutationListener);

        /* Add a listener to the tabbrowser so we highlight the proper
           nodes on location changes */
        if (this.browser) {
          let sp = this;
          this._onBrowserTabChangeListener = function(e) {
            sp.onBrowserTabChange(e);
          }
          this.browser.addEventListener("TabContentChange",
                                        this._onBrowserTabChangeListener,
                                        false);
        }
      ]]>
      </constructor>

      <destructor>
      <![CDATA[
        if (this.browser) {
          this.browser.removeEventListener("TabContentChange",
                                           this._onBrowserTabChangeListener,
                                           false);
        }
        this.mService.root.removeMutationListener(this._mutationListener);
      ]]>
      </destructor>

      <!-- sbIServicePaneMutationListener & sbIServicePaneListener -->
      <field name="_mutationListener">
      <![CDATA[
        ({
          element: null,
          // Old interface, deprecated
          hiddenAttributeChanged: function(node, oldVal, newVal) {
          },

          // Old interface, deprecated
          isOpenAttributeChanged: function(node, oldVal, newVal) {
          },

          attrModified: function(node, attrName, namespace, oldVal, newVal) {
            if (oldVal == newVal)
              return;

            // attempt to find the DOM node in the SP, bail otherwise
            let domNode = this.element.getDOMNode(node.id);
            if (!domNode)
              return;

            switch (attrName) {
              case "hidden":
                if (newVal == "false") {
                  domNode.removeAttribute("hidden");
                } else if (newVal == "true") {
                  domNode.setAttribute("hidden", true);
                }
                break;

              case "name":
                domNode.setAttribute("label", newVal);
                break;

              case "image":
                domNode.setAttribute("image", newVal);
                break;

              case "class":
                domNode.className = newVal;
                break;

              case "isOpen":
                if (node.firstChild) {
                  // update the classes
                  if (oldVal == "true")
                    domNode.className =
                            domNode.className.replace(/\bopen\b/g, '');
                  else
                    // could be null or false
                    domNode.className =
                            domNode.className.replace(/\bclosed\b/g, '');

                  // update the childNodes container's visibility
                  let box = domNode._getElement("servicepane-node-children");
                  if (newVal == "true") {
                    domNode.className += " open";
                    box.removeAttribute("hidden");
                  } else {
                    // could be null or false
                    domNode.className += " closed";
                    box.setAttribute("hidden", "true");
                  }
                }
                break;

              default:
                /* Can be useful, but noisy */
                this.element.noisyLog("Unhandled node attribute change: " +
                                 attrName + " from '" + oldVal + "' => '" +
                                 newVal + "'");
                break;
            }
          },

          nodeInserted: function(node, parent) {
            if (!parent || parent == this.element.mService.root) {
              let newGroup = this.element.createGroup(node);
              this.element.log("New top level group: " + node.id);
              this.element.appendChild(newGroup);
            } else {
              this.element.log("New node: " + node.id);
              /* find the node representing the parent */
              let parentNode = this.element.getDOMNode(parent.id);
              if (!parentNode) {
                this.element.log("\tNo parent node found, skipping..");
                return;
              }
              this.element.log("Parent node is: " +
                               parentNode.getAttribute("nodeid"));
              let newnode = this.element.createNode(node, parentNode);

              // If it's ejectable let's add the right badge
              if (node.getAttribute("ejectable") == "true") {
                newnode.appendBadge(null,
                        "chrome://songbird/skin/service-pane/eject.png",
                        function() {
                          node.dispatchEvent("eject")
                        });
              }
            }

            // The new node may already have children associated with it, so
            // let's go look for those & add them to the hierarchy
            let childNode = node.firstChild;

            if (childNode && (parent != this.element.mService.root))
            {
              // If this has children, and the parent isn't a root node, then
              // it's a container, make the container arrow visible
              this.element.log("Got a child (" + childNode.id + ") and a " +
                               "non-root parent: " + parent.id);
              node.className += " container open";
              node.isOpen = true;
            } else if (parent.parentNode &&
                       parent.parentNode != this.element.mService.root)
            {
              // Or if the parent's parent isn't the root node, then make the
              // parent node's container arrow visible
              this.element.log("Parent's parentNode isn't root: " +
                               parent.parentNode.id);
              parent.className += " container open";
              parent.isOpen = true;
            }
            while (childNode) {
              this.element.log("\tChild node found: " + childNode.id);
              this.nodeInserted(childNode, node);
              childNode = childNode.nextSibling;
            }
          },

          nodeRemoved: function(node, parent) {
            this.element.log("\tAttempting to remove node : " + node.id +
                             " from " + parent.id);

            try {
              // find the DOM node representing this servicepane node
              let domNode = this.element.getDOMNode(node.id);

              // was this node active?
              let active = null;
              if (domNode)
                active = domNode.className.match(/\bactive\b/);
              else
                this.element.log("\tUnable to find a DOM node for " + node.id);

              // remove the actual node
              if (domNode && domNode.parentNode) {
                this.element.log("\tDOM nodes map to removing " + domNode.id +
                                 " from " + domNode.parentNode.id);
                domNode.parentNode.removeChild(domNode);
              }
            } catch (e) {
              dump("Exception: " + e + "\n");
            }
            // XXXtodo
            // if the node was active, then the browser will have gone back
            // in history and loaded the previously loaded page.  check the
            // servicepane to see if we have a node that matches the page,
            // and if so - visually highlight/select it
          },
        })
      ]]>
      </field>

      <!-- The ID of the active node, or null if none -->
      <field name="_activeNodeID">null</field>

      <!-- The ID of the highlighted node, or null if none -->
      <field name="_highlightedNodeID">null</field>

      <!-- The node we're currently editing -->
      <field name="_editingNode">null</field>

      <!--
        TODO: Change the use of these functions so we can remove the
        mTreePane dependency (not to be confused with the T-PAIN dependency).
        mTreePane is used for the following:
        isMediaTabURL(url) - SBSessionStore.js#298
        loadNode(node, null) - mainPlayerWindow.js#445, deviceSupport.js#477
      -->
      <field name="mTreePane">null</field>

      <!-- Splitter between the service pane and the content on the main view
           in the Purple Rain/Gonzo feathers. -->
      <field name="mSplitter">
        document.getElementById('servicepane_splitter');
      </field>

      <!--
        - \brief Create a group that may hold nodes
        -->
      <method name="createGroup">
        <parameter name="nodeData"/>
        <body><![CDATA[
          var XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          var newGroup = document.createElementNS(XULNS, "sb-servicepane-group");
          newGroup.setAttribute("label", nodeData.displayName);
          newGroup.setAttribute("nodeid", nodeData.id);
          newGroup.setAttribute("id", nodeData.id);
          if (!nodeData.isOpen) {
            newGroup.setAttribute("open", false);
          }
          if (nodeData.hidden) {
            newGroup.setAttribute("hidden", true);
          }
          return newGroup;
        ]]></body>
      </method>

      <!--
        - \brief Create a node that belongs to another node or group
        -->
      <method name="createNode">
        <parameter name="nodeData"/>
        <parameter name="parentNode"/>
        <body><![CDATA[
          var XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          var newNode = document.createElementNS(XULNS,"sb-servicepane-node");
          newNode.setAttribute("nodeid", nodeData.id);
          if (this.hasAttribute("browser")) {
            newNode.setAttribute("browser", this.getAttribute("browser"));
          }
          if (parentNode) {
            parentNode.appendChild(newNode);
          }

          return newNode;
        ]]></body>
      </method>

      <!--
        - \brief Inital load of the service pane, this will create the groups
        - and fill them with nodes as defined.
        -->
      <method name="loadServicePane">
        <body><![CDATA[
          if (!this.mService) {
            this.mService =
              Components.classes['@songbirdnest.com/servicepane/service;1']
              .getService(Components.interfaces.sbIServicePaneService);
            this.mService.init();
          }

          var XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";

          this.log("********** SERVICEPANE ROOT **********");
          var groupEntry = this.mService.root.firstChild;
          while (groupEntry && groupEntry != this.mService.root.lastChild) {
            this.log("|- " + groupEntry.id);
            // Create the group and set the state
            var newgroup = this.createGroup(groupEntry);

            // Create the nodes in this group
            var nodeEntry = groupEntry.firstChild;
            while (nodeEntry) {
              this.log("\t|- " + nodeEntry.id);
              this.createNode(nodeEntry, newgroup);
              nodeEntry = nodeEntry.nextSibling;
            }

            this.appendChild(newgroup);
            groupEntry = groupEntry.nextSibling;
          }
        ]]></body>
      </method>

      <!--
        - \brief Get the node from an id.
        - \param nodeID is the id of the node.
        - \return the sbIServicePaneNode from the id.
        -->
      <method name="getNode">
        <parameter name="nodeID"/>
        <body><![CDATA[
          return this.mService.getNode(nodeID);
        ]]></body>
      </method>

      <method name="getDOMNode">
        <parameter name="nodeID"/>
        <body><![CDATA[
          let spNode = this.getElementsByAttribute("nodeid", nodeID)[0];
          return spNode;
        ]]></body>
      </method>

      <!--
        - \brief Get the active node if any.
        - \return sbIServicePaneNode of the active node, or null if none
        -->
      <method name="getSelectedNode">
        <body><![CDATA[
          return this.getActiveNode();
        ]]></body>
      </method>

      <method name="getActiveNode">
        <body><![CDATA[
          if (this._activeNodeID) {
            return this.mService.getNode(this._activeNodeID);
          }
          else {
            return null;
          }
        ]]></body>
      </method>

      <method name="getHighlightedNode">
        <body><![CDATA[
          if (this._highlightedNodeID) {
            return this.mService.getNode(this._highlightedNodeID);
          }
          else {
            return null;
          }
        ]]></body>
      </method>

      <!-- to trigger selection highlighting -->
      <method name="_makeSelectedNodeActive">
        <body>
          <![CDATA[
          try {
            // Is there a servicepane node for the current tab?
            let node = this._browser.selectedTab.servicePaneNode;

            // if we didn't find a node, try looking it up by URL
            if (!node) {
              let uri = this._browser.selectedTab.linkedBrowser.currentURI.spec;
              node = this.mService.getNodeForURL(uri);
            }

            // if we still didn't find a node, try looking it up by medialist
            if (!node && this._browser.selectedTab.mediaListView) {
              let librarySPS = Cc['@songbirdnest.com/servicepane/library;1']
                                 .getService(Ci.sbILibraryServicePaneService);
              node = librarySPS.getNodeFromMediaListView(
                                 this._browser.selectedTab.mediaListView);
            }

            if (node) {
              this.makeNodeActive(node);
            }
          } catch (e) {
            Components.utils.reportError(e);
          }
        ]]>
        </body>
      </method>

      <!--
        - \brief Deselect any currently selected node(s) and select the
        - passed in node
        -->
      <method name="makeNodeActive">
        <parameter name="newNode"/>
        <body><![CDATA[
          if (!newNode)
            return;

          // Remove the 'active' CSS class from the currently active node
          let activeNode = this.getActiveNode();

          if (activeNode == newNode)
            return;

          if (this._editingNode) {
            // don't save any changes
            this._editingNode._textbox.setAttribute("hidden", true);
            this._editingNode._textbox.value =
                 this._editingNode.getAttribute("label");
            this.mService.onRename(this._editingNode.nodeData, null);
            this._editingNode = null;
          }

          if (activeNode) {
            let domNode = this.getDOMNode(activeNode.id);
            domNode.className = domNode.className.replace(/\bactive\b/g, '');
          }

          // Add the 'active' class to the new node
          newNode.className += " active";
          this._activeNodeID = newNode.id;
          return newNode;
        ]]></body>
      </method>

      <!--
        - \brief Dehighlight any currently highlighted node(s) and
        - highlight the passed in node
        -->
      <method name="makeNodeHighlighted">
        <parameter name="newNode"/>
        <body><![CDATA[
          // Remove the 'highlight' CSS from the currently highlighted node
          let highlightedNode = this.getHighlightedNode();

          if (highlightedNode == newNode)
            return;

          if (highlightedNode) {
            let domNode = this.getDOMNode(highlightedNode.id);
            domNode.className = domNode.className.replace(/\bhighlighted\b/g,'');
          }

          // Add the 'highlighted' class to the new node
          newNode.className += " highlighted";
          this._highlightedNodeID = newNode.nodeData.id;
          return newNode;
        ]]></body>
      </method>

      <!--
        - \brief Highlight a node as being active
        -->
      <method name="highlightNode">
        <parameter name="aNode"/>
        <body><![CDATA[
          this.makeNodeActive(aNode);
        ]]></body>
      </method>

      <!--
        - \brief Start editing a nodes name, this may not be enabled if the
        -        node is read only.
        - \return true if editing started, false if not able to edit.
        -->
      <method name="startEditingNode">
        <parameter name="aNode"/>
        <body><![CDATA[
          if (!aNode || !aNode.editable)
            return false;

          try {
            // are we editing any other nodes currently?
            if (this._editingNode) {
              // don't save any changes
              this._editingNode._textbox.setAttribute("hidden", true);
              this._editingNode._textbox.value =
                   this._editingNode.getAttribute("label");
              this.mService.onRename(this._editingNode.nodeData, null);
              this._editingNode = null;
            }

            // XXXstevel might not need this if servicepane can auto-highlight
            // the right node from tabbrowser
            // highlight this node
            //this.makeNodeActive(aNode);

            // notify servicepane service that we're about to rename the node
            this.mService.onBeforeRename(aNode);

            // start editing this node
            this._editingNode = this.getDOMNode(aNode.id);
            this._editingNode._textbox.removeAttribute("hidden");
            this._editingNode._textbox.value =
                 this._editingNode.getAttribute("label");
            this._editingNode._textbox.select();
            return true;
          } catch (e) {
            dump("Exception: " + e + "\n");
            this._editingNode = null;
            return false;
          }
        ]]></body>
      </method>

      <!--
        - \brief Get the name of a node that has a particular URL.
        - \param aURL URL to search for in the nodes.
        - \return name of the node, or aURL if no node found.
        -->
      <method name="getURLName">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.name : aURL;
        ]]></body>
      </method>

      <!--
        - \brief Get the image of a node that has a particular URL.
        - \param aURL URL to search for in the nodes.
        - \return image of the node, or null if no node found.
        -->
      <method name="getURLImage">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.image : null;
        ]]></body>
      </method>

      <!--
        - \brief Get the properties of a node that has a particular URL.
        - \param aURL URL to search for in the nodes.
        - \return properties of the node, or "" if no node found.
        -->
      <method name="getURLProperties">
        <parameter name="aURL"/>
        <body><![CDATA[
          var node = this.mService.getNodeForURL(aURL);
          return (node) ? node.properties : "";
        ]]></body>
      </method>

      <!-- Called when the content of the current browser tab is changed.
           This occurs when the user swiches tabs, or loads an new page 
           in the existing tab.  Note that on page load this method is called
           both at load start and at load complete. -->
      <method name="onBrowserTabChange">
        <body><![CDATA[
          this._makeSelectedNodeActive();
        ]]></body>
      </method>

      <!-- Popup menu methods -->
      <method name="onPopupShown">
        <parameter name="event" />
        <body>
          <![CDATA[
          let visibleChildren = false;
          for (var i=0;i<this.mPopup.childNodes.length;i++) {
            let thisChild = this.mPopup.childNodes[i];
            if (thisChild.hidden)
              continue;
            visibleChildren = true;
            break;
          }
          if (!visibleChildren)
            this.mPopup.hidePopup();
          ]]>
        </body>
      </method>

      <method name="onPopupHidden">
        <parameter name="event" />
        <body>
          <![CDATA[
          //this.mPopup.hidePopup();
          // Remove the 'highlight' CSS from the currently highlighted node
          let highlightedNode = this.getHighlightedNode();
          if (highlightedNode) {
            let domNode = this.getDOMNode(highlightedNode.id);
            domNode.className = domNode.className.replace(/\bhighlighted\b/g,'');
          }

          this._highlightedNodeID = null;
          ]]>
        </body>
      </method>

      <method name="openContextMenu">
        <parameter name="event" />
        <parameter name="nodeId" />
        <body>
          <![CDATA[
          // clear the popup menu
          while (this.mPopup.lastChild) {
            DOMUtils.destroyNode(this.mPopup.lastChild);
            this.mPopup.removeChild(this.mPopup.lastChild);
          }

          // if we got passed a DOM node, then fill the context menu with
          // the context menu options defined by the service handling the
          // node.  otherwise, fill the popup with the contents of the
          // "new stuff" menu
          if (nodeId) {
            let node = this.getNode(nodeId);
            this.makeNodeHighlighted(this.getDOMNode(nodeId));
            this.mService.fillContextMenu(node, this.mPopup, window);
          } else {
            this.mService.fillNewItemMenu(null, this.mPopup, window);
          }

          // show the popup menu
          document.popupNode = null;
          this.mPopup.showPopup(document.documentElement,
                                event.screenX + 5,
                                event.screenY + 5,
                                'context', null, null, null);

          // XXXstevel: should we select/highlight the node?
          event.stopPropagation();
          event.preventDefault();
          ]]>
        </body>
      </method>

      <!--
        - \brief State of the service pane, open or closed.
        -->
      <property name="open">
        <getter>
        <![CDATA[
          var elId = this.mSplitter.getAttribute("collapseelement");
          return !document.getElementById(elId).collapsed;
        ]]>
        </getter>
        <setter>
        <![CDATA[
          var elId = this.mSplitter.getAttribute("collapseelement");
          var el = document.getElementById(elId);
          el.collapsed = !val;

          SBDataSetBoolValue('splitter.servicepane_splitter.collapsed',
                             el.collapsed);
          // If we are opening the service pane, make sure we highlight the
          // appropriate node.
          if(val) {
            // Is there a servicepane node for the current tab?
            //var node = this.mTreePane.browser.selectedTab.servicePaneNode;
            //if (node) {
            //  this.mTreePane.highlightNode(node);
            //}
          }
          ]]>
        </setter>
      </property>

      <field name="_browser">null</field>
      <property name="browser">
        <getter><![CDATA[
          if (!this._browser) {
            this._browser = document.getElementById(this.getAttribute('browser'));
          }
          return this._browser;
        ]]></getter>
      </property>
      
      <method name="needScroll">
        <parameter name="event" />
        <body><![CDATA[
          let scrollbox =
              this.mInnerBox.boxObject.QueryInterface(Ci.nsIScrollBoxObject);
          
          // If we're near the bottom or top of the servicepane, then scroll as
          // needed
          if (event.screenY <= this.boxObject.screenY + 20)
          {
            scrollbox.scrollBy(0, -10);
          } else if (event.screenY >=
                    (this.boxObject.screenY+this.mInnerBox.boxObject.height-20))
          {
            scrollbox.scrollBy(0, 10);
          }
          event.stopPropagation();
        ]]></body>
      </method>

    </implementation>
    
    <handlers>
      <handler event="dragover"><![CDATA[
        this.needScroll(event);
      ]]></handler>

      <handler event="dragdrop">
        event.stopPropagation();
      </handler>

      <handler event="dragexit"><![CDATA[
        // If we've exited the servicepane, then relatedTarget is null so
        // clear any timers we've got running
        if (this._timer && !event.relatedTarget) {
          this.log("Exited servicepane, canceling auto-expand timer");
          clearTimeout(this._timer);
          this._timer = null;
          this._timerGroup._expandTimerRunning = null;
          this._timerGroup = null;
        }

        if (this._collapsedGroup && !event.relatedTarget) {
          this._collapsedGroup._collapseOnDragExit = null;
          this._collapsedGroup.visible = false;
          this._collapsedGroup = null;
        }
      ]]></handler>
    </handlers>

  </binding>

</bindings>
