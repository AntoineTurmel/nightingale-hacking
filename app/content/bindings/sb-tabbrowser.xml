<?xml version="1.0"?>
<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl"
[
<!ENTITY % songbirdDTD SYSTEM "chrome://songbird/locale/songbird.dtd">
%songbirdDTD;
]
>
<!--
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
-->

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="sb-tabbrowser" extends="chrome://songbird/content/bindings/tabbrowser.xml#tabbrowser">
    <implementation implements="nsIWebProgressListener,sbITabBrowser">
      <constructor><![CDATA[
        this.addProgressListener(this,
            Components.interfaces.nsIWebProgress.NOTIFY_LOCATION |
            Components.interfaces.nsIWebProgress.NOTIFY_STATE_ALL);
        /* FIXME: how should this work?
        this._progressFilter.addProgressListener(this,
            Components.interfaces.nsIProgressListener.NOTIFY_ALL);
        this.addProgressListener(this._progressFilter);
        */
        this.loading = false;
        
        /* we need to track when events change */
        this.tabChangeEventListener = {
          tabbrowser: this,
          timer_period: 200, // fire after 1/5th of a second
          timer: null,
          handleEvent: function(event) {
            if (event.attrName == 'selectedIndex' &&
                event.prevValue != event.newValue &&
                !this.timer) {
              this.timer = Components.classes['@mozilla.org/timer;1']
                  .createInstance(Components.interfaces.nsITimer);
              this.timer.initWithCallback(this, this.timer_period,
                  Components.interfaces.nsITimer.TYPE_ONE_SHOT);
              
            }
          },
          notify: function(timer) {
            //this.tabbrowser._loaded();
            this.timer = null;
          }
        };
        this.mTabBox.addEventListener("DOMAttrModified",
            this.tabChangeEventListener, false);

        window.addEventListener("remoteapi", this.onRemoteAPI, true);

        this.webNavigation.sessionHistory =
            Components.classes["@mozilla.org/browser/shistory;1"]
            .createInstance(Components.interfaces.nsISHistory);
        this.browsers[0].removeAttribute("disablehistory");
        
        // force tabbed mode
        this.enterTabbedMode();
      ]]></constructor>
      <destructor><![CDATA[
        this.closeBalloonTip();
        this.removeProgressListener(this);
        if (this.tabChangeEventListener) {
          if (this.tabChangeEventListener.timer) {
            this.tabChangeEventListener.timer.cancel();
          }
          this.mTabBox.removeEventListener("DOMAttrModified",
              this.tabChangeEventListener, false);
        }
        window.removeEventListener("remoteapi", this.onRemoteAPI, true);
      ]]></destructor>
      

      <!-- the public interface for loading URLs.
           this overrides the implementation in tabbrowser.xml#tabbrowser
           it takes the existing aURI, aReferrerURI and aCharset arguments
           and optionally an aEvent handler
           -->
      <method name="loadURI">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aEvent"/>
        <parameter name="aDefaultLocation"/>
        <body>
          <![CDATA[
            var where = aDefaultLocation?aDefaultLocation:'current';
            if (aEvent) {
              // if an event as supplied infer where we want to load this URI
              //
              var isMac = window.navigator.platform.match(/^Mac/) == 'Mac';
              var middleButton = aEvent?(aEvent.button == 1):false;
              var modifierKey = aEvent?(isMac?aEvent.metaKey:aEvent.ctrlKey):false;
              
              if (middleButton || modifierKey) {
                where = "tab";
              }
            }
            
            // make sure the referrer is an nsIURI
            if (aReferrerURI == '') {
              aReferrerURI = null;
            } else {
              if (typeof(aReferrerURI) == 'string') {
                aReferrerURI = (Components
                    .classes["@mozilla.org/network/io-service;1"]
                    .getService(Components.interfaces.nsIIOService)
                    .newURI(aReferrerURI, aCharset, null));
              }
            }
            
            
            // Policy goes here
            
            // check to see if tabs are allowed
            if (where == 'tab' &&
                !this._prefsService.getBoolPref('browser.tabs.enabled')) {
              where = 'current';
            }
            
            // Now, actually open the URI
            if (where == "tab") {
              this.loadOneTab(aURI, aReferrerURI, aCharset, null, null, null);
            } else if (where == "external") {
              var externalLoader = (Components
                    .classes["@mozilla.org/uriloader/external-protocol-service;1"]
                    .getService(Components.interfaces.nsIExternalProtocolService));
              var nsURI = (Components
                    .classes["@mozilla.org/network/io-service;1"]
                    .getService(Components.interfaces.nsIIOService)
                    .newURI(aURI, aCharset, null));
              externalLoader.loadURI(nsURI, null);
            } else if (where == "current") {
              this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
            } else {
              // eek! unknown target
            }
          ]]>
        </body>
      </method>
      
      
      <field name="_progressFilter">
        Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
            .createInstance(Components.interfaces.nsIWebProgress)
      </field>
      
      <field name="_prefsService">
        Components.classes["@mozilla.org/preferences-service;1"].
                getService(Components.interfaces.nsIPrefBranch);
      </field>

      <field name="_servicepane">null</field>
      <property name="servicepane">
        <getter><![CDATA[
          if (!this._servicepane) {
            this._servicepane =
                document.getElementById(this.getAttribute('servicepane'));
          }
          return this._servicepane;
        ]]></getter>
      </property>
      
      
      <property name="playlist">
        <getter><![CDATA[
          return this.currentOuterPlaylist;
        ]]></getter>
      </property>


      <!-- Get the playlist element from within the document in the current tab.
           Returns null if no playlist element is available 
        -->
      <property name="currentInnerPlaylist" readonly="true"
                onget="return this.mCurrentTab.innerPlaylist" />
      
      <!-- get the web playlist for the current tab -->
      <property name="currentOuterPlaylist" readonly="true"
                onget="return this.mCurrentTab.outerPlaylist" />
      
      <!-- get the current page playlist if one exists or the current web
           playlist if that's all we have -->
      <property name="currentPlaylist" readonly="true">
        <getter><![CDATA[
          var pl = this.currentInnerPlaylist;
          if (!pl) {
            pl = this.currentOuterPlaylist;
          }
          return pl;
        ]]></getter>
      </property>
      
      <!-- control the visibility of the web playlist on the current tab -->
      <property name="currentOuterPlaylistShowing"
                onget="return this.mCurrentTab.outerPlaylistShowing"
                onset="this.mCurrentTab.outerPlaylistShowing = val" />
            
      <property name="playlistTree" readonly="true">
        <getter><![CDATA[
          var pl = this.currentPlaylist;
          if (pl) {
            return pl.tree;
          } else {
            return null;
          }
        ]]></getter>
      </property>
      
      
      


      <field name="_loading">SB_NewDataRemote("faceplate.loading", null)</field>
      <property name="loading"
                onget="return this._loading.boolValue"
                onset="this._loading.boolValue = val;" />
      
      <property name="showWebPlaylist">
        <getter><![CDATA[
          // the value is stored in a data remote
          return SBDataGetBoolValue('browser.playlist.show');
        ]]></getter>
        <setter><![CDATA[
          // boolify the value that's passed in
          return;
        
          var value = (val)?true:false;
          
          this.currentOuterPlaylistShowing = value;
          
          if (!value) {
            // if the balloontip for the webplaylist is shown, close it
            this.closeBalloonTip();
            // if we're hiding the web playlist then unhook it from the UI
            if (this.playlist) {
              this.playlist.datasources = "";
              this.playlist.ref = "";
            }
          } else {
            // open the balloontip if needed
            this.openBalloonTip();
          }
        ]]></setter>
      </property>

      <!-- These should match the values in sbLibraryManager.h -->
      <field name="PREF_WEB_LIBRARY">"songbird.library.web"</field>
      <field name="PREF_DOWNLOAD_LIBRARY">"songbird.library.download"</field>
      
      <field name="_downloadList">null</field>
      <property name="downloadList">
        <getter><![CDATA[
          if (this._downloadList) {
            return this._downloadList;
          }
          
          var guid = this._getUnicodeStringPref(this.PREF_DOWNLOAD_LIBRARY);
          
          var libraryManager =
            Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                      .getService(Components.interfaces.sbILibraryManager);
          var mainLibrary = libraryManager.mainLibrary;

          return this._downloadList = mainLibrary.getMediaItem(guid);
        ]]></getter>
      </property>
      
      <field name="_webLibrary">null</field>
      <property name="webLibrary">
        <getter><![CDATA[
          if (this._webLibrary) {
            return this._webLibrary;
          }
          
          var guid = this._getUnicodeStringPref(this.PREF_WEB_LIBRARY);
          
          var libraryManager =
            Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                      .getService(Components.interfaces.sbILibraryManager);

          return this._webLibrary = libraryManager.getLibrary(guid);
        ]]></getter>
      </property>
      
      <method name="getTabForView">
        <parameter name="aView" />
        <body><![CDATA[
          var parent = {}, page = {};
          var viewMap =
              Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
              .getService(Components.interfaces.sbIMediaListViewMap);
          viewMap.getContext(aView, parent, page );
          
          // find the tab
          var tab = null;
          var browser = null;
          for (var i=0; i<this.browsers.length; i++) {
            // iterate through the browsers
            browser = this.browsers[i];
            if (browser == parent.value) {
              tab = this.tabContainer.childNodes[i];
              break;
            }
          }
          
          // if we found a tab, lets see if the history entry we got back
          if (tab) {
            var history = browser.webNavigation.sessionHistory;
            var entry = history.getEntryAtIndex(history.index, false);
            page.value.QueryInterface(Components.interfaces.nsIHistoryEntry);
            
            // if the current history entry for the tab is the same as the
            // history entry we got back from the view map then the tab should
            // be currently showing the view map. Right?
            if (page.value == entry) {
              return tab;
            }
          }
          return null;
        ]]></body>
      </method>

      <!-- implementation of nsIWebProgressListener -->
      <method name="onLocationChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aLocation" />
        <body><![CDATA[
          try {
            // for some reason we need to do this dance to get scrollbars to
            // show up
            var nsIScrollable = Components.interfaces.nsIScrollable;
            var scrollable = this.webNavigation.QueryInterface(nsIScrollable);        
            scrollable.setDefaultScrollbarPreferences(nsIScrollable.ScrollOrientation_Y,
                                                      nsIScrollable.Scrollbar_Auto);
            scrollable.setDefaultScrollbarPreferences(nsIScrollable.ScrollOrientation_X,
                                                      nsIScrollable.Scrollbar_Auto);
          
            if (this.webNavigation.sessionHistory) {
              SBDataSetBoolValue('browser.cangoback', this.webNavigation.canGoBack);
              SBDataSetBoolValue('browser.cangofwd', this.webNavigation.canGoForward);
            }
            
            // Clear the playlist tree variable so we are not confused.
            //this.playlistTree = null;
            theLibraryPlaylist = null;
            // hack, to let play buttons find the visible playlist if needed
            document.__CURRENTPLAYLIST__ = null;
            
            // Disable the "add to playlist" button until we see that there is anything to add.
            SBDataSetBoolValue('browser.canplaylist', false);
            this.showWebPlaylist = false;
      
            // Clear the playlist tree variable so we are not confused.
            //this.playlistTree = null;
            theLibraryPlaylist = null;
            // hack, to let play buttons find the visible playlist if needed
            document.__CURRENTPLAYLIST__ = null;
            
            // Nothing in the status text
            theStatusText.stringValue = "";
            
            // set the context-menu based on the chromeyness of the location
            if (aLocation.scheme == 'chrome') {
              this.mCurrentBrowser.contextMenu = null;
            } else {
              this.mCurrentBrowser.contextMenu = this.getAttribute('contentcontextmenu');
            }
          }
          catch ( err )
          {
            alert( "sb-tabbrowser::onLocationChange\n\n" + err );
          }
        ]]></body>
      </method>
      
      <method name="onProgressChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aCurSelfProgress" />
        <parameter name="aMaxSelfProgress" />
        <parameter name="aCurTotalProgress" />
        <parameter name="aMaxTotalProgress" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>
      
      <method name="onSecurityChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>

      <method name="onStateChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aStatus" />
        <body><![CDATA[
          const nsIWebProgressListener =
            Components.interfaces.nsIWebProgressListener;
      
          if (aState & nsIWebProgressListener.STATE_START) {
            // Start the spinner if necessary
            this.loading = true;
            
            // cancel the previous page scan
            //CancelAsyncWebDocument(this.href_loop);

          }
          else if (aState & nsIWebProgressListener.STATE_STOP) {
            // Stop the spinner if necessary
            this.loading = false;
          }
        ]]></body>
      </method>

      <method name="onStatusChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aMessage" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>
      
      
      <!-- a bunch of methods from browser_xbl_temp.js / songbird_hack.js.
           I'm not convinced they belong here, but till we refactor a couple
           more things there's nowhere better for them to go. -->
      <method name="playExternalUrl">
        <parameter name="the_url" />
        <parameter name="tryweb" />
        <body><![CDATA[
          //SB_LOG("songbird_hack.js", "playExternalUrl: " + the_url);
          var PPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);
          // figure out if the url is in the webplaylist
          if (tryweb && theWebPlaylist && !theWebPlaylist.hidden) 
          {
            var row = theWebPlaylist.findRowIdByUrl(the_url);
            if (row != -1) 
            {
              // if so, play the ref, from that entry's index
              PPS.playRef("NC:webplaylist_webplaylist", row);
            }
          } else {
            // otherwise, play the url as external (added to the db, plays the library from that point on)
            PPS.playAndImportURL(the_url); // if the url is already in the lib, it is not added twice
          }
        ]]></body>
      </method>
      
      <method name="handleMediaURL">
        <parameter name="aURL" />
        <parameter name="aShouldBeginPlayback" />
        <parameter name="forcePlaylist" />
        <body><![CDATA[
          var retval = false;
          try
          {
            var ioService =
              Components.classes["@mozilla.org/network/io-service;1"]
                        .getService(Components.interfaces.nsIIOService);
            var uri;
            try {
              uri = ioService.newURI(aURL, null, null);
            }
            catch(e) {
            }

            // Stick playlists in the service pane (for now).
            if ( uri && (forcePlaylist || gPPS.isPlaylistURL( uri.spec )) )
            {
              var library =
                Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                          .getService(Components.interfaces.sbILibraryManager).mainLibrary;

              // Check to see if this playlist already exists
              var propertyArray =
                Components.classes["@songbirdnest.com/Songbird/Properties/PropertyArray;1"]
                          .createInstance(Components.interfaces.sbIPropertyArray);
              propertyArray.appendProperty("http://songbirdnest.com/data/1.0#isList", "1");
              propertyArray.appendProperty("http://songbirdnest.com/data/1.0#originURL", uri.spec);

              var getFirstListener = {
                item: null,
                onEnumerationBegin: function() {
                  return true;
                },
                onEnumeratedItem: function(list, item) {
                  this.item = item;
                  return false;
                },
                onEnumerationEnd: function() {
                  return true;
                }
              };

              library.enumerateItemsByProperties(propertyArray,
                                                 getFirstListener,
                                                 Components.interfaces.sbIMediaList.ENUMERATIONTYPE_LOCKING);

              // If we found a matching list, clear it, otherwise create it
              var mediaList;
              if (getFirstListener.item) {
                mediaList = getFirstListener.item;
                mediaList.clear();
              }
              else {
                mediaList = library.createMediaList("simple");
                mediaList.name = gPPS.convertURLToDisplayName(aURL);
                mediaList.setProperty("http://songbirdnest.com/data/1.0#originURL", uri.spec);
                mediaList.write();
              }

              var playlistReaderManager =
                Components.classes["@songbirdnest.com/Songbird/PlaylistReaderManager;1"]
                          .getService(Components.interfaces.sbIPlaylistReaderManager);
              var playlistReaderListener =
                Components.classes["@songbirdnest.com/Songbird/PlaylistReaderListener;1"]
                          .createInstance(Components.interfaces.sbIPlaylistReaderListener);

              // Create this closure here to prevent this object from getting garbage
              // collected too soon.  The playlist reader uses the nsIWebBrowserPersist
              // component that does _not_ addref this listener :(
              var playlist_observer = {
                observe: function ( aSubject, aTopic, aData ) {
                  if (aTopic.indexOf("error") != -1) {
                    var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
                                                  .getService(Components.interfaces.nsIPromptService);
                    promptService.alert(null,
                                        "Playlist Error",
                                        "Unable to read playlist file - please try again later.");
                  }
                  else {
                    var array =
                      Components.classes["@mozilla.org/array;1"]
                                .createInstance(Components.interfaces.nsIMutableArray);
                    for (var i = 0; i < mediaList.length; i++) {
                      array.appendElement(mediaList.getItemByIndex(i), false);
                    }

                    // Send the items in the new media list to the metadata scanner
                    var metadataJobManager =
                      Components.classes["@songbirdnest.com/Songbird/MetadataJobManager;1"]
                                .getService(Components.interfaces.sbIMetadataJobManager);
                    var metadataJob = metadataJobManager.newJob(array, 5);
                  }
                }
              };

              playlistReaderListener.playWhenLoaded = aShouldBeginPlayback;
              playlistReaderListener.observer = playlist_observer;
              playlistReaderListener.mediaMimetypesOnly = true;
              playlistReaderManager.originalURI = uri;
              playlistReaderManager.loadPlaylist(uri, mediaList, null, false, playlistReaderListener);
              retval = true;
            }
            // Everything else gets played directly.
            else if ( gPPS.isMediaURL( aURL ) )
            {
              this.playExternalUrl(aURL, true);
              retval = true;
            }
          }
          catch ( err )
          {
            alert("sb-tabbrowser::handleMediaURL(" + aURL + "); " + err );
          }
          return retval;
        ]]></body>
      </method>

      <method name="onRemoteAPI">
        <parameter name="event" />
        <body><![CDATA[
          // Add code here to check the prefs system to see if we should notify
          // the user that the RemoteAPI was accessed. Do it via the
          // notificationbox
          // todo: get strings from stringBundle
          //       talk to koshi and see if there is any particular styling/messaging
          //       see browser/base/content/browser.js#738
          //       hook up an action to do when the user clicks through, probably launch prepanel
          var notificationName = "remoteapi-called";
          var messageString = "RemoteAPI was called";
          var browser = event.currentTarget.gBrowser.getBrowserForDocument(event.target);
          var notificationBox = browser.parentNode;
          var notification = notificationBox.getNotificationWithValue(notificationName);
          if (!notification) {
            // if there isn't a notfication object, make one and append it
            const priority = notificationBox.PRIORITY_WARNING_MEDIUM;
            notificationBox.appendNotification( messageString,
                                                notificationName,
                                                null,
                                                priority,
                                                null);
          } else {
            // if there is a notification object set it's text.
            // this has the side effect of showing it if it was dismissed
            notification.message = messageString;
          }
        ]]></body>
      </method>
      
      <!-- sbITabBrowser -->
      <method name="getTabForDocument">
        <parameter name="aDocument" />
        <body><![CDATA[
          var numTabs = this.mTabContainer.childNodes.length;
          for ( var index = 0; index < numTabs; index++ ) {
            if ( this.mTabContainer
                     .childNodes[index]
                     .linkedBrowser
                     .contentDocument == aDocument ) {
              return this.mTabContainer.childNodes[index];
            }
          }
          return null;
        ]]></body>
      </method>
      
      <!-- context menu handler -->
      <method name="onHTMLContextMenu">
        <parameter name="target" />
        <body><![CDATA[
          if ( this.theHTMLContextURL ) {
            var v = target.getAttribute( "id" );
            switch ( v ) {
              case "html.context.open":
                // can be track or playlist
                // try dealing with media, might just be web content.
                if ( !this.handleMediaURL(this.theHTMLContextURL, true, false) )
                {
                  // should we add the referrer?
                  this.loadURI(this.theHTMLContextURL, null, null);
                }
              break;
              case "html.context.opentab":
                // can be track or playlist
                // try dealing with media, might just be web content.
                if ( !this.handleMediaURL(this.theHTMLContextURL, true, false) )
                {
                  // should we add the referrer?
                  this.loadOneTab(this.theHTMLContextURL, null, null, null, null, null);
                }
                break;
              case "html.context.openexternal":
                  var externalLoader = (Components
                           .classes["@mozilla.org/uriloader/external-protocol-service;1"]
                          .getService(Components.interfaces.nsIExternalProtocolService));
                  var nsURI = (Components
                          .classes["@mozilla.org/network/io-service;1"]
                          .getService(Components.interfaces.nsIIOService)
                          .newURI(this.theHTMLContextURL, null, null));
                  externalLoader.loadURI(nsURI, null);
              break;
              case "html.context.play":
                // can be track or playlist
                this.handleMediaURL(this.theHTMLContextURL, true, false);
              break;
              case "html.context.add":
                gPPS.importURL(this.theHTMLContextURL);
              break;
              case "html.context.playlist":
                // Add playlists to the service pane (force it as a playlist)
                this.handleMediaURL(this.theHTMLContextURL, false, true);
              break;
              case "html.context.copytoclipboard":
                var clipboard = Components.classes["@mozilla.org/widget/clipboardhelper;1"].getService(Components.interfaces.nsIClipboardHelper);
                clipboard.copyString(this.theHTMLContextURL);
              break;
            }
            this.theHTMLContextURL = null; // clear it because now we're done.
          }
        ]]></body>
      </method>
      
      <!-- this method extracts the target url of click event targetted at html -->
      <method name="GetHREFFromEvent">
        <parameter name="evt" />
        <body><![CDATA[
          var the_href = "";
          try
          {
            var node = evt.target;
            while ( node ) // Walk up from the event target to find the A? 
            {
              if ( node.href )
              {
                the_href = node.href;
                break;
              }
              node = node.parentNode;
            }
          }
          catch ( err )
          {
            alert( err );
          }
          return the_href;
        ]]></body>
      </method>
      
      <field name="theHTMLContextURL">null</field>
      <!-- used in async_webplaylist.js -->
      <method name="onLinkOver">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a contextual on a media url and attempt to play it
          var the_url = this.GetHREFFromEvent( evt )
          theStatusText.stringValue = the_url;
          if ( gPPS.isMediaURL( the_url ) || gPPS.isPlaylistURL( the_url ) )
          {
            theStatusStyle.stringValue = "font-weight: bold;";
          }
          else
          {
            theStatusStyle.stringValue = "font-weight: normal;";
          }
        ]]></body>
      </method>
      <!-- used in async_webplaylist.js -->
      <method name="onLinkOut">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a contextual on a media url and attempt to play it
          theStatusText.stringValue = "";
        ]]></body>
      </method>
      <!-- used in async_webplaylist.js -->
      <method name="onLinkContext">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a contextual on a media url and attempt to play it
          try
          {
            var theHTMLPopup = document.getElementById( "html_context_menu" );
            this.theHTMLContextURL = this.GetHREFFromEvent( evt );
            
            // Disable "Add" if the url isn't media or is already there.
            var disabled = "true";
            if ( gPPS.isMediaURL( this.theHTMLContextURL ) && ! SBUrlExistsInDatabase( this.theHTMLContextURL ) )
            {
              disabled = "false"
            }
            document.getElementById( "html.context.add" ).setAttribute( "disabled", disabled );
            
            theHTMLPopup.showPopup(this, this.boxObject.screenX + evt.clientX + 5,
                                   this.boxObject.screenY + evt.clientY,
                                   "context", null, null );
          }
          catch ( err )
          {
            alert( err );
          }
        ]]></body>
      </method>
      <!-- used in async_webplaylist.js -->
      <method name="onMediaClick">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a click on a media url and attempt to play it
          this.handleMediaURL(this.GetHREFFromEvent(evt), true, false);
          evt.stopPropagation();
          evt.preventDefault();
        ]]></body>
      </method>
      
      
      <!-- override navigation methods from tabbrowser for fun and profit -->
      <!-- I'm not convinced these are actually required -->
      <method name="goBack">
        <body><![CDATA[
          // Disable the "add to playlist" button until we see that there is anything to add.
          SBDataSetBoolValue("browser.canplaylist", false);
          this.showWebPlaylist = false;
          return this.mCurrentBrowser.goBack();
        ]]></body>
      </method>
      <method name="goForward">
        <body><![CDATA[
          // Disable the "add to playlist" button until we see that there is anything to add.
          SBDataSetBoolValue("browser.canplaylist", false);
          this.showWebPlaylist = false;
          return this.mCurrentBrowser.goForward();
        ]]></body>
      </method>
      <method name="reload">
        <body><![CDATA[
          return this.mCurrentBrowser.reload();
        ]]></body>
      </method>
      <method name="stop">
        <body><![CDATA[
          return this.mCurrentBrowser.stop();
        ]]></body>
      </method>
      <property name="homePage">
        <getter><![CDATA[
          var homepage = null;
          var defaultHomepage = "http://www.songbirdnest.com/birdhouse/";
          
          try {
            if (this._prefsService.getPrefType("browser.startup.homepage") == prefs.PREF_STRING) {
              homepage = this._prefsService.getCharPref("browser.startup.homepage");
            }
          } catch (e) { }
          
          if (homepage == null || homepage == '') {
            homepage = "http://www.songbirdnest.com/birdhouse/";
          }
          
          return homepage
        ]]></getter>
        <setter><![CDATA[
          this._prefsService.setCharPref("browser.startup.homepage", val);
        ]]></setter>
      </property>
      <method name="goHome">
        <body><![CDATA[
          this.loadURI(this.homePage, null, null);
        ]]></body>
      </method>

      <method name="openBalloonTip">
        <body><![CDATA[
          if (!SBDataGetBoolValue("balloontip.firstwebplaylist.shown")) {
            this.balloontip = new BalloonTip;
            var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"].getService(Components.interfaces.nsIStringBundleService);
            var songbirdStrings = sbs.createBundle("chrome://songbird/locale/songbird.properties");
            var title = "Found media."
            var text = "Songbird has found the following playable tracks."
            try {
              title = songbirdStrings.GetStringFromName("balloontip.firstwebplaylist.title");
              text = songbirdStrings.GetStringFromName("balloontip.firstwebplaylist.text");
            } catch (e) { }
            this.balloontip.showText(text, this.playlist, title, 'balloon-icon-songbird', null, -1);
            SBDataSetBoolValue("balloontip.firstwebplaylist.shown", true);
          }
        ]]></body>
      </method>
      
      <method name="closeBalloonTip">
        <body><![CDATA[
          if (this.balloontip) {
            this.balloontip.closeTip();
            this.balloontip = null;
          }
        ]]></body>
      </method>
      
      <method name="_getUnicodeStringPref">
        <parameter name="prefKey"/>
        <body><![CDATA[
          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefBranch2);
          return prefs.getComplexValue(prefKey, Components.interfaces.nsISupportsString);
        ]]></body>
      </method>

    </implementation>
    
    <handlers>
      <handler event="click"><![CDATA[
        // inspired by contentAreaClick in ffox browser.js
        if (!event.isTrusted || event.getPreventDefault()) {
          return true;
        }
        
        var target = event.target;
        var linkNode = null;
        
        if (target instanceof HTMLAnchorElement ||
            target instanceof HTMLAreaElement ||
            target instanceof HTMLLinkElement) {
          if (target.hasAttribute("href")) {
            linkNode = target;
          }
     
          // backwards compat - use the outermost link node
          var parent = target.parentNode;
          while (parent) {
            if (parent instanceof HTMLAnchorElement ||
                parent instanceof HTMLAreaElement ||
                parent instanceof HTMLLinkElement) {
                if (parent.hasAttribute("href")) {
                  linkNode = parent;
                }
            }
            parent = parent.parentNode;
          }
        } else {
          linkNode = event.originalTarget;
          while (linkNode && !(linkNode instanceof HTMLAnchorElement)) {
            linkNode = linkNode.parentNode;
          }
          // <a> cannot be nested.  So if we find an anchor without an
          // href, there is no useful <a> around the target
          if (linkNode && !linkNode.hasAttribute("href")) {
            linkNode = null;
          }
        }
        
        
        var wrapper = null;
        var href = null;
        var target = null;
        if (linkNode) {
          href = linkNode.href;
          if (linkNode.hasAttribute('target')) {
            target = linkNode.getAttribute('target');
          }
        } else {
          // Try simple XLink
          var realHref, baseURI;
          linkNode = target;
          while (linkNode) {
            if (linkNode.nodeType == Node.ELEMENT_NODE) {
              wrapper = linkNode;
     
              realHref = wrapper.getAttributeNS("http://www.w3.org/1999/xlink", "href");
              if (realHref) {
                href = realHref;
                baseURI = wrapper.baseURI
              }
            }
            linkNode = linkNode.parentNode;
          }
          if (href) {
            var ioService = Components.classes["@mozilla.org/network/io-service;1"]
                .getService(Components.interfaces.nsIIOService);
            var base = ioService.newURI(baseURI, null, null);
            href = ioService.newURI(base.resolve(href), null, null).spec;
          }
        }
        
        if (href) {
          // get the document that this event originated in
          var doc = event.target.ownerDocument;
          
          var secMan = Components.classes["@mozilla.org/scriptsecuritymanager;1"]
              .getService(Components.interfaces.nsIScriptSecurityManager);
          secMan.checkLoadURIStrWithPrincipal(doc.nodePrincipal, href,
              Components.interfaces.nsIScriptSecurityManager.STANDARD);
          
          // get the referrer if we can
          var referrer = doc ? doc.documentURIObject : null;
          
          var where = 'current';
          if (target == '_blank' || target == '_new') {
            where = 'tab';
          }
          
          this.loadURI(href, referrer, null, event, where);
          event.stopPropagation();
        }
        return true;
      ]]></handler>
    </handlers>
  </binding>


  <!-- these are from globalBindings.xml -->
  <binding id="tabbrowser-tab" extends="chrome://songbird/content/bindings/tabbrowser.xml#tabbrowser-tab">
    <content closetabtext="&tabs.closeTab;">
      <xul:hbox class="tab-image-left" xbl:inherits="selected"/>
      <xul:hbox flex="1" class="tab-image-middle" align="center" xbl:inherits="selected">
        <xul:stack class="tab-icon">
          <xul:image xbl:inherits="validate,src=image" class="tab-icon-image"/>
          <xul:image class="tab-extra-status"/>
        </xul:stack>
        <xul:label flex="1" xbl:inherits="value=label,crop,accesskey" crop="right" class="tab-text"/>
      </xul:hbox>
      <xul:toolbarbutton anonid="close-button" class="tab-close-button" tabindex="-1"/>
      <xul:hbox class="tab-image-right" xbl:inherits="selected"/>
    </content>
    <implementation implements="nsIWebProgressListener,sbITabBrowserTab">
      <constructor><![CDATA[
        // right after all the constructors run...
        var self = this;
        window.setTimeout(function () { self.createOuterPlaylist(); }, 0);
        this._hrefLoop = null;
        this._onplaylistplay = { 
          _that: null, 
          handleEvent: function( event ) { this._that.onPlaylistPlay(event); } 
        }; this._onplaylistplay._that = this; 
      ]]></constructor>
     <destructor><![CDATA[
        if (this.previousInnerPlaylist) {
          this.previousInnerPlaylist.removeEventListener("playlist-play", this._onplaylistplay, true);
          this.previousInnerPlaylist.removeEventListener("playlist-editor", this.onPlaylistEditor, true);
          this.previousInnerPlaylist = null;
        }
     ]]></destructor>
      
      <field name="_browserStatusFilter"><![CDATA[
        Components.classes['@mozilla.org/appshell/component/browser-status-filter;1']
        .createInstance(Components.interfaces.nsIWebProgress);
        if (this._hrefLoop) {
        }
      ]]></field>
      
      <field name="_webLibraryCache">null</field>
      <property name="_webLibrary">
        <getter><![CDATA[
          if (this._webLibraryCache) {
            return this._webLibraryCache;
          }
          
          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefBranch2);
          var guid = prefs.getComplexValue("songbird.library.web",
                                           Components.interfaces.nsISupportsString);
          
          var libraryManager =
            Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                      .getService(Components.interfaces.sbILibraryManager);

          return (this._webLibraryCache = libraryManager.getLibrary(guid));
        ]]></getter>
      </property>
      
      <field name="_downloadListCache">null</field>
      <property name="_downloadList">
        <getter><![CDATA[
          if (this._downloadListCache) {
            return this._downloadListCache;
          }
          
          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefBranch2);
          var guid = prefs.getComplexValue("songbird.library.download",
                                           Components.interfaces.nsISupportsString);
          
          var libraryManager =
            Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                      .getService(Components.interfaces.sbILibraryManager);
          
          var mainLibrary = libraryManager.mainLibrary;

          return (this._downloadListCache = mainLibrary.getMediaItem(guid));
        ]]></getter>
      </property>

      <method name="createOuterPlaylist">
        <body><![CDATA[
          /* from mainwin.xul:
            <sb-smart-splitter id="playlist_web_split" hidden="true" state="open" resizebefore="closest" resizeafter="closest" target="after" collapse="after">
              <grippy/>
            </sb-smart-splitter>
            
            
            <vbox id="playlist_web_vbox" height="200" hidden="true" minheight="0" _resize_height="200">
              <playlist2 
                id="playlist_web" 
                height="105"
                flex="1"
                hidden="true"
                enableColumnDrag="true"
                persist="columnSpec"
                editable="true"
                minheight="0"
                columnSpec="http://songbirdnest.com/data/1.0#ordinal 20 a " +
                           "http://songbirdnest.com/data/1.0#trackName 395 " +
                           "http://songbirdnest.com/data/1.0#duration 50 " +
                           "http://songbirdnest.com/data/1.0#artistName 222 " +
                           "http://songbirdnest.com/data/1.0#albumName 222 " +
                           "http://songbirdnest.com/data/1.0#genre 70");
                _resize_height="105"
              />
            </vbox>
          */
          
          // get the notification box around the browser
          var nbox = this.linkedBrowser.parentNode;
          
          var dummybox = document.createElement('vbox');
          nbox.appendChild(dummybox);
          
          this._plbox = document.createElement('vbox');
          this._plbox.setAttribute('hidden', 'false');
          
          // make the splitter
          this._splitter = document.createElement('sb-smart-splitter');
          this._splitter.setAttribute('class', 'playlist_web_split');
          this._splitter.setAttribute('hidden', 'false');
          this._splitter.setAttribute('state', 'open');
          this._splitter.setAttribute('resizebefore', 'closest');
          this._splitter.setAttribute('resizeafter', 'closest');
          this._splitter.setAttribute('target', 'after');
          this._splitter.setAttribute('collapse', 'after');
          this._splitter.appendChild(document.createElement('grippy'));
          this._plbox.appendChild(this._splitter);
          
          // make the vbox
          this._vbox = document.createElement('vbox');
          this._vbox.setAttribute('class', 'playlist_web_vbox');
          this._vbox.setAttribute('height', '200');
          this._vbox.setAttribute('hidden', 'false');
          this._vbox.setAttribute('minheight', '0');
          
          // make the playlist
          this._playlist = document.createElement('playlist2');
          this._playlist.setAttribute('class', 'playlist_web');
          this._playlist.setAttribute('height', '105');
          this._playlist.setAttribute('flex', '1');
          this._playlist.setAttribute('hidden', 'false');
          this._playlist.setAttribute('enableColumnDrag', 'true');
          this._playlist.setAttribute('persist', 'columnSpec');
          this._playlist.setAttribute('editable', 'true');
          this._playlist.setAttribute('minheight', '0');
          this._playlist.setAttribute('columnSpec',
              'http://songbirdnest.com/data/1.0#ordinal 20 a ' +
              'http://songbirdnest.com/data/1.0#trackName 395 ' +
              'http://songbirdnest.com/data/1.0#duration 50 ' +
              'http://songbirdnest.com/data/1.0#artistName 222 ' +
              'http://songbirdnest.com/data/1.0#albumName 222 ' +
              'http://songbirdnest.com/data/1.0#genre 70');

          // add some events, eh?
          this._playlist.addEventListener("playlist-play", this._onplaylistplay, true);
          this._playlist.addEventListener("playlist-editor", this.onPlaylistEditor, true);
          // FIXME: remove the event listener on the destructor, I guess
          
          // put it all together
          this._vbox.appendChild(this._playlist);
          this._plbox.appendChild(this._vbox);
          
          // wire up the browser status filter
          this.linkedBrowser.webProgress.addProgressListener(this._browserStatusFilter,
              Components.interfaces.nsIWebProgress.NOTIFY_ALL);
          this._browserStatusFilter.addProgressListener(this,
              Components.interfaces.nsIWebProgress.NOTIFY_ALL);
          
          nbox.appendChild(this._plbox);
          
          this.outerPlaylistShowing = true;
        ]]></body>
      </method>
      
      <!-- sbITabBrowserTab -->
      <property name="outerPlaylist" readonly="true">
        <getter><![CDATA[
          return this._playlist;
        ]]></getter>
      </property>

      <method name="getPlaylist">
        <body><![CDATA[
          if ( this.innerPlaylist ) {
            return this.innerPlaylist;
          } else {
            return this._playlist;
          }
        ]]></body>
      </method>
      
      <property name="outerPlaylistShowing">
        <getter><![CDATA[
          return (this._plbox.getAttribute("hidden") == 'false');
        ]]></getter>
        <setter><![CDATA[
        dump('\n\n\n\n\nsetting outerWebPlaylistShowing to: '+val+'\n');
          var hidden = val?"false":"true";
          /*
          this._splitter.setAttribute('hidden', hidden);
          this._vbox.setAttribute('hidden', hidden);
          this._playlist.setAttribute('hidden', hidden);
          */
          this._plbox.setAttribute('hidden', hidden);
        ]]></setter>
      </property>
      
      <!-- sbITabBrowserTab -->
      <property name="innerPlaylist" readonly="true">
        <getter><![CDATA[
          if (this.linkedBrowser.currentURI.scheme != 'chrome') {
            // only chrome urls can supply a playlist
            return null;
          }
          // Get the document from the current browser tab
          var playlistDocument = this.linkedBrowser.contentDocument;
          if (playlistDocument == null) {
            return null;
          }
          
          // Get the playlist element from within the current tab      
          // TODO change this
          var playlist = playlistDocument.getElementById("playlist_test");
          if (playlist == null) {
            return null;
          }
          
          // Remove security wrappers
          if (playlist.wrappedJSObject) {
            playlist = playlist.wrappedJSObject;
          }
              
          return playlist;
        ]]></getter>
      </property>
      
      <field name="scanProgress">-1</field>
      
      <method name="clearOuterPlaylist">
        <body><![CDATA[
          // hide the outer playlist
          CancelAsyncWebDocument(this._hrefLoop);
          this._hrefLoop = null;
          PlaylistShowing = false;
          this.scanProgress = -1;
        ]]></body>
      </method>
      
      
      <method name="scanWebPage">
        <body><![CDATA[
          // only scrape http & https
          if (this.linkedBrowser.currentURI.scheme != 'http' &&
              this.linkedBrowser.currentURI.scheme != 'https' &&
              this.linkedBrowser.currentURI.scheme != 'file') {
            this.outerPlaylistShowing = false;
            return;
          }

          if (!SBDataGetBoolValue('webplaylist.enabled')) {
            // or not
            return;
          }
          
          // Set the filter to the current URI.
          var propArray =
            Components.classes["@songbirdnest.com/Songbird/Properties/PropertyArray;1"]
                      .createInstance(Components.interfaces.sbIPropertyArray);
          propArray.appendProperty("http://songbirdnest.com/data/1.0#originURL",
                                   this.linkedBrowser.currentURI.spec);
                             
          // See if we're supposed to be restoring a view or making a new one
          var viewMap =
            Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
                      .getService(Components.interfaces.sbIMediaListViewMap);
                      
          // Now all I have to do is find something resembling a usefully unique key.
          var browser = this.linkedBrowser;
          var history = browser.webNavigation.sessionHistory;
          var entry = history.getEntryAtIndex( history.index, false );
          
          // Is there something to restore?
          var skipScan = true;
          var view = viewMap.getView( browser, entry );
          if ( view == null )
          {
            // If not, create the view
            view = this._webLibrary.createView();
            view.setFilters(propArray);
            // And save it
            viewMap.setView( browser, entry, view );
            skipScan = false;
          }

          // Otherwise, don't show the web playlist until we see some tracks.
          this.outerPlaylistShowing = false;
          
          // Bind the Web Playlist UI element to the subscribed playlist
          SBWebPlaylistCommands.m_Playlist = this.outerPlaylist;
          this.outerPlaylist.outerWindow = window;
          this.outerPlaylist.bind(view, SBWebPlaylistCommands,
                                  SBDataGetIntValue("browser.playlist.height"),
                                  SBDataGetBoolValue("browser.playlist.collapsed"));

          // Force it to redraw (grr)
          this.outerPlaylist.tree.boxObject.invalidate();
          
          // If we're restoring a view, don't do anything else
          if ( skipScan )
          {
            // Only show it if there's something to see.
            if ( view.length > 0 )
              this.outerPlaylistShowing = true;
            return;
          }

          // scrape the document.
          var context = {
            tab: this,
            pt: 0,
            get progressTotal() {
              return this.pt;
            },
            set progressTotal(p) {
              this.pt = p;
              this.setProgress();
            },
            pc: 0,
            get progressCurrent() {
              return this.pc;
            },
            set progressCurrent(p) {
              this.pc = p;
              this.setProgress();
            },
            setProgress: function setProgress() {
              this.tab.scanProgress = (1.0*this.pc)/this.pt;
            },
            sp: false,
            get showPlaylist() {
              return this.sp;
            },
            set showPlaylist(s) {
              this.tab.outerPlaylistShowing = s;
              this.sp = s;
            }
          };
          this.scanProgress = 0;
          this._hrefLoop = AsyncWebDocument(this.linkedBrowser.contentDocument,
                                            view, this._hrefLoop, context);
          

        ]]></body>
      </method>
      
      <field name="applyThisView">null</field>

      <method name="setUpInnerPlaylist">
        <body><![CDATA[ try {
          var playlist = this.innerPlaylist;
          playlist.outerWindow = window;
          if ( playlist.mediaListView ) // New API
          {
            var viewMap =
              Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
                        .getService(Components.interfaces.sbIMediaListViewMap);
                        
            // Now all I have to do is find something resembling a usefully unique key.
            var browser = this.linkedBrowser;
            var history = browser.webNavigation.sessionHistory;
            var entry = history.getEntryAtIndex( history.index, false );
            
            // someone wants us to apply a view
            if (this.applyThisView) {
              playlist.bind(this.applyThisView, playlist.commands);
              // save this mapping I guess 
              viewMap.setView(browser, entry, this.applyThisView);
              this.applyThisView = null;
            } else {
              // Is there something to restore?
              var restore = viewMap.getView( browser, entry );
              if ( restore == null )
              {
                // Save the current view if there is nothing to restore
                viewMap.setView( browser, entry, playlist.mediaListView );
                playlist.refreshCommands();
              }
              else
              {
                // Otherwise, restore it.
                var commands = playlist.commands;
                playlist.bind( restore.clone(), commands );
              }
            }
          }
          
          // add some events, eh?
          if (this.previousInnerPlaylist) {
            this.previousInnerPlaylist.removeEventListener("playlist-play", this._onplaylistplay, true);
            this.previousInnerPlaylist.removeEventListener("playlist-editor", this.onPlaylistEditor, true);
            this.previousInnerPlaylist = null;
          }
          playlist.addEventListener("playlist-play", this._onplaylistplay, true);
          playlist.addEventListener("playlist-editor", this.onPlaylistEditor, true);
          this.previousInnerPlaylist = playlist;
          
          // Wait until after the bind call?
          if ( playlist.ref == "" )
          {
            return;
          }
          
          //
          // THE RETURN ABOVE IS ALWAYS HIT!!  THE CODE BELOW WON'T RUN!!
          //
          
          // Drag and Drop tracker object
          playlist.setDnDSourceTracker(sbDnDSourceTracker);

          // Remember some values
          theLibraryPlaylist = playlist;
          this.playlistTree = playlist = playlist.tree;
          SBDataSetStringValue('playlist.ref', playlist.getAttribute( "ref" )); // is this set yet?
  
          // Set the current selection
          theLibraryPlaylist.syncPlaylistIndex(false);
  
          // And remember that we did this
          installed_listener = true;
          } catch( e ) { alert( "tabbrowser::setUpInnerPlaylist\n\n" + e ); }]]></body>
      </method>
      
      <field name="_swappedPlaylistView">null</field>
      
      <method name="switchToWebPlaylistView">
        <body><![CDATA[
          metrics_inc("player", "urlslurp", null);

          var view;
          if (this._swappedPlaylistView) {
            view = this._swappedPlaylistView;
            this._swappedPlaylistView = null;
          }
          else {
            // This code should never run unless someone calls this function
            // manually outside of the SBDownloadCommands object.

            view = this._webLibrary.createView();
            
            // Set the filter to the current URL.
            var propArray =
              Components.classes["@songbirdnest.com/Songbird/Properties/PropertyArray;1"]
                        .createInstance(Components.interfaces.sbIPropertyArray);
            propArray.appendProperty("http://songbirdnest.com/data/1.0#originURL",
                                     this.linkedBrowser.currentURI.spec);

            view.setFilters(propArray);
          }
          
          this.outerPlaylist.bind(view, SBWebPlaylistCommands,
                                  SBDataGetIntValue("browser.playlist.height"),
                                  SBDataGetBoolValue("browser.playlist.collapsed"));
        ]]></body>
      </method>

      <method name="switchToDownloadView">
        <body><![CDATA[
          metrics_inc("player", "downloads", null);
          
          // Make sure the download device has been added to the commands object.
          if (!SBDownloadCommands.m_Device) {
            var deviceManager =
              Components.classes["@songbirdnest.com/Songbird/DeviceManager;1"]
                        .getService(Components.interfaces.sbIDeviceManager);
            
            downloadDevice =
              deviceManager.getDeviceByCategory("Songbird Download Device");
            
            SBDownloadCommands.m_Device = downloadDevice;
          }
          
          // Save this for later if we swap back.
          this._swappedPlaylistView = this.outerPlaylist.mediaListView;
          
          var view = this._downloadList.createView();
          
          this.outerPlaylist.bind(view, SBDownloadCommands,
                                  SBDataGetIntValue("browser.playlist.height"),
                                  SBDataGetBoolValue("browser.playlist.collapsed"));
        ]]></body>
        </method>

      <!-- nsIWebProgressListener implementation -->
      <method name="onLocationChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aLocation" />
        <body><![CDATA[
        ]]></body>
      </method>
      
      <method name="onProgressChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aCurSelfProgress" />
        <parameter name="aMaxSelfProgress" />
        <parameter name="aCurTotalProgress" />
        <parameter name="aMaxTotalProgress" />
        <body><![CDATA[ ]]></body>
      </method>
      
      <method name="onSecurityChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <body><![CDATA[ ]]></body>
      </method>

      <method name="onStateChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aStatus" />
        <body><![CDATA[
          const nsIWebProgressListener =
            Components.interfaces.nsIWebProgressListener;

          if (!(aState & nsIWebProgressListener.STATE_IS_WINDOW)) {
            // not interested
            return;
          }
      
          if (aState & nsIWebProgressListener.STATE_START) {
            this.clearOuterPlaylist();

            // see if the notification box is up, remove it if so.
            // removing it with removeNotification(notification) causes all
            // subsequent notifications to not show up.
            var notificationName = "remoteapi-called";
            var notificationBox = this.linkedBrowser.parentNode;
            var notification = notificationBox.getNotificationWithValue(notificationName); 
            if ( notification )
              notificationBox.removeAllNotifications(true);

          } else if (aState & nsIWebProgressListener.STATE_STOP) {
            if (this.innerPlaylist) {
              this.setUpInnerPlaylist();
            } else {
              this.scanWebPage();
            }
          }
        ]]></body>
      </method>

      <method name="onStatusChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aMessage" />
        <body><![CDATA[ ]]></body>
      </method>
      
      <method name="onPlaylistEditor">
        <parameter name="evt"/>
        <body>
        <![CDATA[ 
          var playlist = evt.target;
          if ( playlist.wrappedJSObject )
            playlist = playlist.wrappedJSObject;
          
            var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
                              .getService(Components.interfaces.nsIWindowMediator);
            var theTE = wm.getMostRecentWindow("track_editor");
            if (theTE) {
              theTE.focus();
            } else {
              const TEURL = "chrome://songbird/content/xul/trackeditor.xul";
              const TEFEATURES = "chrome,dialog=no,resizable=no";
              SBOpenWindow(TEURL, "track_editor", TEFEATURES, playlist); 
            }
        ]]>
        </body>
      </method>
      
      <method name="onPlaylistPlay">
        <parameter name="evt"/>
        <body>
        <![CDATA[ 
          var target = evt.target;
          if ( target.wrappedJSObject )
          {
            target = target.wrappedJSObject;
          }
          this.playPlaylistIndex( target.tree.currentIndex, target );
        ]]>
        </body>
      </method>
      
      <method name="playPlaylistIndex">
        <parameter name="index"/>
        <parameter name="playlist"/>
        <body>
        <![CDATA[ 
          try
          {
            if (!playlist) playlist = gBrowser.currentPlaylist;
            if (!playlist) return;
            
            if (index < 0) {
              // if no track is selected start playing from the first one
              index = 0;
            }
            
            var PPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);
            PPS.playView(playlist.mediaListView, index);
          }
          catch ( err )
          {
            alert( err );
          }
        ]]>
        </body>
      </method>
    





    </implementation>
    <handlers>
      <handler event="TabClose"><![CDATA[
      
        // When we drop the tab, release all of the associated views stored in the map.
        Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
                  .getService(Components.interfaces.sbIMediaListViewMap)
                  .releaseViews(event.target.linkedBrowser);
      
        // clean up listeners
        this.linkedBrowser.webProgress.removeProgressListener(this._browserStatusFilter);
        this._browserStatusFilter.addProgressListener(this);
      ]]></handler>
    </handlers>
  </binding>
  
   <binding id="tabbrowser-tabs"  
            extends="chrome://songbird/content/bindings/tabbrowser.xml#tabbrowser-tabs">
    <content>
      <xul:stack flex="1" class="tabs-stack">
        <xul:vbox>
          <xul:spacer flex="1"/>
          <xul:hbox class="tabs-bottom" align="center"/>
        </xul:vbox>
        <xul:vbox>
          <xul:hbox>
            <xul:stack>
              <xul:spacer class="tabs-left"/>
            </xul:stack>
            <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1" style="min-width: 1px;" class="tabbrowser-arrowscrollbox">
              <children/>
            </xul:arrowscrollbox>
            <xul:stack align="center" pack="end">
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035 
              -->
              <xul:hbox style="position: relative;">
                <xul:hbox flex="1" class="tabs-alltabs-box" 
                          anonid="alltabs-box"/>
              </xul:hbox>
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035 
              -->
              <xul:hbox style="position: relative;">
                <xul:hbox flex="1" class="tabs-alltabs-box-animate" 
                          anonid="alltabs-box-animate"/>
              </xul:hbox>
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035 
              -->
              <xul:hbox style="position: relative;">
                <xul:toolbarbutton class="tabs-alltabs-button"
                                   type="menu"
                                   anonid="alltabs-button"
                                   tooltipstring="&tabs.listAllTabs;">
                  <xul:menupopup class="tabs-alltabs-popup"
                                 anonid="alltabs-popup" position="after_end"/>
                </xul:toolbarbutton>
              </xul:hbox>
            </xul:stack>
            <xul:hbox class="tabs-closebutton-box" align="center" pack="end" anonid="tabstrip-closebutton">
              <xul:toolbarbutton class="close-button tabs-closebutton"/>
            </xul:hbox>
          </xul:hbox>
          <xul:spacer class="tabs-bottom-spacer"/>
        </xul:vbox>
      </xul:stack>
    </content>
  </binding>

</bindings>
