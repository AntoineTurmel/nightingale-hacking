<?xml version="1.0"?>
<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl"
[
<!ENTITY % songbirdDTD SYSTEM "chrome://songbird/locale/songbird.dtd">
%songbirdDTD;
]
>
<!--
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
-->

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="sb-tabbrowser" extends="chrome://songbird/content/bindings/tabbrowser.xml#tabbrowser">
    <implementation implements="nsIWebProgressListener,sbITabBrowser">
      <constructor><![CDATA[
        if (typeof(SBProperties) == "undefined") {
          Components.utils.import("resource://app/components/sbProperties.jsm");
          if (!SBProperties)
            throw new Error("Import of sbProperties module failed");
        }

        this.addProgressListener(this,
            Components.interfaces.nsIWebProgress.NOTIFY_LOCATION |
            Components.interfaces.nsIWebProgress.NOTIFY_STATE_ALL);

        this.loading = false;
        
        /* we need to track when events change */
        this.tabChangeEventListener = {
          tabbrowser: this,
          timer_period: 200, // fire after 1/5th of a second
          timer: null,
          handleEvent: function(event) {
            if (event.attrName == 'selectedIndex' &&
                event.prevValue != event.newValue &&
                !this.timer) {
              this.timer = Components.classes['@mozilla.org/timer;1']
                  .createInstance(Components.interfaces.nsITimer);
              this.timer.initWithCallback(this, this.timer_period,
                  Components.interfaces.nsITimer.TYPE_ONE_SHOT);
              
            }
          },
          notify: function(timer) {
            //this.tabbrowser._loaded();
            this.timer = null;
          }
        };
        this.mTabBox.addEventListener("DOMAttrModified",
            this.tabChangeEventListener, false);

        window.addEventListener("remoteapi", this.onRemoteAPI, true);

        // tell appshell how to open new tabs (sb bug 3757)
        var self = this;
        window.QueryInterface(Components.interfaces.nsIDOMChromeWindow)
              .browserDOMWindow = {
          openURI: function browserDOMWindow_openURI(aURI, aOpener, aWhere, aContext) {
            // XXX Mook: for now, just always open in new tab (ignore aWhere)
            if (aURI instanceof Components.interfaces.nsIURI)
              aURI = aURI.spec;
            // XXX Mook: if the tab isn't loaded in the background,
            // onLocationChange freaks out; so we focus it later if needed
            var newTab = self.loadOneTab("about:blank", null, null, null, true, false);
            var newWindow = self.getBrowserForTab(newTab).docShell
                                .QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                                .getInterface(Components.interfaces.nsIDOMWindow);
            try {
              var loadflags = (aContext == Components.interfaces.nsIBrowserDOMWindow.OPEN_EXTERNAL) ?
                         Components.interfaces.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL :
                         Components.interfaces.nsIWebNavigation.LOAD_FLAGS_NONE;
              if (aOpener) {
                var referrer =
                        Components.classes["@mozilla.org/network/io-service;1"]
                                  .getService(Components.interfaces.nsIIOService)
                                  .newURI(aOpener.location, null, null);
              }
              if (!aURI)
                aURI = "about:blank";
              newWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                       .getInterface(Components.interfaces.nsIWebNavigation)
                       .loadURI(aURI, loadflags, referrer, null, null);
            } catch(e) {
            }
            var loadInBackground = self._prefsService
                                       .getBoolPref("browser.tabs.loadDivertedInBackground");
            if (!loadInBackground) {
              self.selectedTab = newTab;
            }
            return newWindow;
          },
          isTabContentWindow: function browserDOMWindow_isTabContentWindow(aWindow) {
            for (var ctr = 0; ctr < self.browsers.length; ctr++)
              if (self.browsers.item(ctr).contentWindow == aWindow)
                return true;
            return false;
          }
        };
        
        this.webNavigation.sessionHistory =
            Components.classes["@mozilla.org/browser/shistory;1"]
            .createInstance(Components.interfaces.nsISHistory);
        this.browsers[0].removeAttribute("disablehistory");
        
        // force tabbed mode
        this.enterTabbedMode();
      ]]></constructor>
      <destructor><![CDATA[
        this.removeProgressListener(this);
        if (this.tabChangeEventListener) {
          if (this.tabChangeEventListener.timer) {
            this.tabChangeEventListener.timer.cancel();
          }
          this.mTabBox.removeEventListener("DOMAttrModified",
              this.tabChangeEventListener, false);
        }
        window.removeEventListener("remoteapi", this.onRemoteAPI, true);
        window.QueryInterface(Components.interfaces.nsIDOMChromeWindow)
              .browserDOMWindow = null;
      ]]></destructor>
      

      <!-- the public interface for loading URLs.
           this overrides the implementation in tabbrowser.xml#tabbrowser
           it takes the existing aURI, aReferrerURI and aCharset arguments
           and optionally an aEvent and aMediaListView.  
           
           aMediaListView will be provided to the tab and used if a 
           playlist is loaded.
           -->
      <method name="loadURI">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aEvent"/>
        <parameter name="aDefaultLocation"/>
        <parameter name="aMediaListView"/>
        <body>
          <![CDATA[
            var where = aDefaultLocation?aDefaultLocation:'current';
            if (aEvent) {
              // if an event as supplied infer where we want to load this URI
              //
              var isMac = window.navigator.platform.match(/^Mac/) == 'Mac';
              var middleButton = aEvent?(aEvent.button == 1):false;
              var modifierKey = aEvent?(isMac?aEvent.metaKey:aEvent.ctrlKey):false;
              
              if (middleButton || modifierKey) {
                where = "tab";
              }
            }
            
            // make sure the referrer is an nsIURI
            if (aReferrerURI == '') {
              aReferrerURI = null;
            } else {
              if (typeof(aReferrerURI) == 'string') {
                aReferrerURI = (Components
                    .classes["@mozilla.org/network/io-service;1"]
                    .getService(Components.interfaces.nsIIOService)
                    .newURI(aReferrerURI, aCharset, null));
              }
            }
            
            
            // Policy goes here
            
            // check to see if tabs are allowed
            if (where == 'tab' &&
                !this._prefsService.getBoolPref('browser.tabs.enabled')) {
              where = 'current';
            }
            
            // Now, actually open the URI
            if (where == "tab") {
              var tab = this.loadOneTab(aURI, aReferrerURI, aCharset, null, null, null);
              tab.viewForNextPlaylist = aMediaListView;
            } else if (where == "external") {
              var externalLoader = (Components
                    .classes["@mozilla.org/uriloader/external-protocol-service;1"]
                    .getService(Components.interfaces.nsIExternalProtocolService));
              var nsURI = (Components
                    .classes["@mozilla.org/network/io-service;1"]
                    .getService(Components.interfaces.nsIIOService)
                    .newURI(aURI, aCharset, null));
              externalLoader.loadURI(nsURI, null);
            } else if (where == "current") {
              this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
              this.mCurrentTab.viewForNextPlaylist = aMediaListView;
            } else {
              // eek! unknown target
            }
          ]]>
        </body>
      </method>

      <method name="loadMediaList">
        <parameter name="aMediaList"/>
        <parameter name="aEvent"/>
        <parameter name="aDefaultLocation"/>
        <parameter name="aMediaListView"/>
        <body>
          <![CDATA[
            var uri = 'chrome://songbird/content/xul/playlist_test2.xul?';
            if (aMediaList.guid != aMediaList.library.guid) {
              uri = uri + aMediaList.guid;
            } else {
              uri = uri + 'library,' + aMediaList.guid;
            }
            this.loadURI(uri, null, null, aEvent, aDefaultLocation, aMediaListView);
          ]]>
        </body>
      </method>

      <field name="_prefsService">
        Components.classes["@mozilla.org/preferences-service;1"].
                getService(Components.interfaces.nsIPrefBranch);
      </field>

      <field name="_servicepane">null</field>
      <property name="servicepane">
        <getter><![CDATA[
          if (!this._servicepane) {
            this._servicepane =
                document.getElementById(this.getAttribute('servicepane'));
          }
          return this._servicepane;
        ]]></getter>
      </property>
      
      
      <property name="playlist">
        <getter><![CDATA[
          return this.currentOuterPlaylist;
        ]]></getter>
      </property>


      <!-- Get the playlist element from within the document in the current tab.
           Returns null if no playlist element is available 
        -->
      <property name="currentInnerPlaylist" readonly="true"
                onget="return this.mCurrentTab.innerPlaylist" />
      
      <!-- get the web playlist for the current tab -->
      <property name="currentOuterPlaylist" readonly="true"
                onget="return this.mCurrentTab.outerPlaylist" />
      
      <!-- get the current page playlist if one exists or the current web
           playlist if that's all we have -->
      <property name="currentPlaylist" readonly="true">
        <getter><![CDATA[
          var pl = this.currentInnerPlaylist;
          if (!pl && this.currentOuterPlaylistShowing) {
            pl = this.currentOuterPlaylist;
          }
          return pl;
        ]]></getter>
      </property>
      
      <!-- control the visibility of the web playlist on the current tab -->
      <property name="currentOuterPlaylistShowing"
                onget="return this.mCurrentTab.outerPlaylistShowing"
                onset="this.mCurrentTab.outerPlaylistShowing = val" />
            
      <property name="playlistTree" readonly="true">
        <getter><![CDATA[
          var pl = this.currentPlaylist;
          if (pl) {
            return pl.tree;
          } else {
            return null;
          }
        ]]></getter>
      </property>
      
      
      


      <field name="_loading">SB_NewDataRemote("faceplate.loading", null)</field>
      <property name="loading"
                onget="return this._loading.boolValue"
                onset="this._loading.boolValue = val;" />
      
      <property name="showWebPlaylist">
        <getter><![CDATA[
          // the value is taken from the current tab
          return this.currentOuterPlaylistShowing;
        ]]></getter>
        <setter><![CDATA[
          // boolify the value that is passed in
        
          var value = (val)?true:false;
          this.currentOuterPlaylistShowing = value;
        ]]></setter>
      </property>

      <!-- These should match the values in sbLibraryManager.h -->
      <field name="PREF_WEB_LIBRARY">"songbird.library.web"</field>
      <field name="PREF_DOWNLOAD_LIBRARY">"songbird.library.download"</field>
      
      <field name="_downloadList">null</field>
      <property name="downloadList">
        <getter><![CDATA[
          if (this._downloadList) {
            return this._downloadList;
          }
          
          var guid = this._getUnicodeStringPref(this.PREF_DOWNLOAD_LIBRARY);
          
          var libraryManager =
            Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                      .getService(Components.interfaces.sbILibraryManager);
          var mainLibrary = libraryManager.mainLibrary;

          return this._downloadList = mainLibrary.getMediaItem(guid);
        ]]></getter>
      </property>
      
      <field name="_webLibrary">null</field>
      <property name="webLibrary">
        <getter><![CDATA[
          if (this._webLibrary) {
            return this._webLibrary;
          }
          
          var guid = this._getUnicodeStringPref(this.PREF_WEB_LIBRARY);
          
          var libraryManager =
            Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                      .getService(Components.interfaces.sbILibraryManager);

          return this._webLibrary = libraryManager.getLibrary(guid);
        ]]></getter>
      </property>
      
      <method name="getTabForView">
        <parameter name="aView" />
        <body><![CDATA[
          var parent = {}, page = {};
          var viewMap =
              Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
              .getService(Components.interfaces.sbIMediaListViewMap);
          viewMap.getContext(aView, parent, page );
          
          // find the tab
          var tab = null;
          var browser = null;
          for (var i=0; i<this.browsers.length; i++) {
            // iterate through the browsers
            browser = this.browsers[i];
            if (browser == parent.value) {
              tab = this.tabContainer.childNodes[i];
              break;
            }
          }
          
          // if we found a tab, lets see if the history entry we got back
          if (tab) {
            var history = browser.webNavigation.sessionHistory;
            var entry = history.getEntryAtIndex(history.index, false);
            page.value.QueryInterface(Components.interfaces.nsIHistoryEntry);
            
            // if the current history entry for the tab is the same as the
            // history entry we got back from the view map then the tab should
            // be currently showing the view map. Right?
            if (page.value == entry) {
              return tab;
            }
          }
          return null;
        ]]></body>
      </method>

      <!-- implementation of nsIWebProgressListener -->
      <method name="onLocationChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aLocation" />
        <body><![CDATA[
          try {
            // for some reason we need to do this dance to get scrollbars to
            // show up
            var nsIScrollable = Components.interfaces.nsIScrollable;
            var scrollable = this.webNavigation.QueryInterface(nsIScrollable);        
            scrollable.setDefaultScrollbarPreferences(nsIScrollable.ScrollOrientation_Y,
                                                      nsIScrollable.Scrollbar_Auto);
            scrollable.setDefaultScrollbarPreferences(nsIScrollable.ScrollOrientation_X,
                                                      nsIScrollable.Scrollbar_Auto);
          
            if (this.webNavigation.sessionHistory) {
              SBDataSetBoolValue('browser.cangoback', this.webNavigation.canGoBack);
              SBDataSetBoolValue('browser.cangofwd', this.webNavigation.canGoForward);
            }
            
            // Clear the playlist tree variable so we are not confused.
            //this.playlistTree = null;
            theLibraryPlaylist = null;
            // hack, to let play buttons find the visible playlist if needed
            document.__CURRENTPLAYLIST__ = null;
            
            // Clear the playlist tree variable so we are not confused.
            //this.playlistTree = null;
            theLibraryPlaylist = null;
            // hack, to let play buttons find the visible playlist if needed
            document.__CURRENTPLAYLIST__ = null;
            
            // Nothing in the status text
            theStatusText.stringValue = "";
            
            // set the context-menu based on the chromeyness of the location
            if (aLocation.scheme == 'chrome') {

              //XXXAus: Disable bookmarking for chrome URI's to prevent
              //stale bookmarks. See bug #4009.
              SBDataSetBoolValue('browser.canbookmark', false);
              
              this.mCurrentBrowser.contextMenu = null;
              
            } else {
            
              //XXXAus: Enable bookmarking for all other URI schemes.
              //See bug #4009.
              SBDataSetBoolValue('browser.canbookmark', true);
              
              this.mCurrentBrowser.contextMenu = this.getAttribute('contentcontextmenu');
              
            }
          }
          catch ( err )
          {
            alert( "sb-tabbrowser::onLocationChange\n\n" + err );
          }
        ]]></body>
      </method>
      
      <method name="onProgressChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aCurSelfProgress" />
        <parameter name="aMaxSelfProgress" />
        <parameter name="aCurTotalProgress" />
        <parameter name="aMaxTotalProgress" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>
      
      <method name="onSecurityChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>

      <method name="onStateChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aStatus" />
        <body><![CDATA[
          const nsIWebProgressListener =
            Components.interfaces.nsIWebProgressListener;
      
          if (aState & nsIWebProgressListener.STATE_START) {
            // Start the spinner if necessary
            this.loading = true;
          }
          else if (aState & nsIWebProgressListener.STATE_STOP) {
            // Stop the spinner if necessary
            this.loading = false;
          }
        ]]></body>
      </method>

      <method name="onStatusChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aMessage" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>
      
      
      <!-- a bunch of methods from browser_xbl_temp.js / songbird_hack.js.
           I'm not convinced they belong here, but till we refactor a couple
           more things there's nowhere better for them to go. -->
      <method name="playExternalUrl">
        <parameter name="the_url" />
        <parameter name="tryweb" />
        <body><![CDATA[
          //SB_LOG("songbird_hack.js", "playExternalUrl: " + the_url);
          var PPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);
          // figure out if the url is in the webplaylist
          if (tryweb && theWebPlaylist && !theWebPlaylist.hidden) 
          {
            var row = theWebPlaylist.findRowIdByUrl(the_url);
            if (row != -1) 
            {
              // if so, play the ref, from that entry's index
              PPS.playRef("NC:webplaylist_webplaylist", row);
            }
          } else {
            // otherwise, play the url as external (added to the db, plays the library from that point on)
            PPS.playAndImportURL(the_url); // if the url is already in the lib, it is not added twice
          }
        ]]></body>
      </method>
      
      <method name="handleMediaURL">
        <parameter name="aURL" />
        <parameter name="aShouldBeginPlayback" />
        <parameter name="forcePlaylist" />
        <body><![CDATA[
          var retval = false;
          try
          {
            var ioService =
              Components.classes["@mozilla.org/network/io-service;1"]
                        .getService(Components.interfaces.nsIIOService);
            var uri;
            try {
              uri = ioService.newURI(aURL, null, null);
            }
            catch(e) {
            }

            // Stick playlists in the service pane (for now).
            if ( uri && (forcePlaylist || gPPS.isPlaylistURL( uri.spec )) )
            {
              var library = null;
              var scheme = uri.scheme;
              
              if ( scheme != "file" && 
                   scheme != "resource" && 
                   scheme != "chrome" &&
                   scheme != "jar" ) {
                library = SBGetWebLibrary();
              }
              else {
                library = Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                          .getService(Components.interfaces.sbILibraryManager).mainLibrary;
              }

              // Check to see if this playlist already exists
              var propertyArray =
                Components.classes["@songbirdnest.com/Songbird/Properties/MutablePropertyArray;1"]
                          .createInstance(Components.interfaces.sbIMutablePropertyArray);
              propertyArray.appendProperty(SBProperties.isList, "1");
              propertyArray.appendProperty(SBProperties.originURL, uri.spec);

              var getFirstListener = {
                item: null,
                onEnumerationBegin: function() {
                  return true;
                },
                onEnumeratedItem: function(list, item) {
                  this.item = item;
                  return false;
                },
                onEnumerationEnd: function() {
                  return true;
                }
              };

              library.enumerateItemsByProperties(propertyArray,
                                                 getFirstListener,
                                                 Components.interfaces.sbIMediaList.ENUMERATIONTYPE_LOCKING);

              // If we found a matching list, clear it, otherwise create it
              var mediaList;
              if (getFirstListener.item) {
                mediaList = getFirstListener.item;
                mediaList.clear();
              }
              else {
                mediaList = library.createMediaList("simple");
                mediaList.name = gPPS.convertURLToDisplayName(aURL);
                mediaList.setProperty("http://songbirdnest.com/data/1.0#originURL", uri.spec);
              }

              var playlistReaderManager =
                Components.classes["@songbirdnest.com/Songbird/PlaylistReaderManager;1"]
                          .getService(Components.interfaces.sbIPlaylistReaderManager);
              var playlistReaderListener =
                Components.classes["@songbirdnest.com/Songbird/PlaylistReaderListener;1"]
                          .createInstance(Components.interfaces.sbIPlaylistReaderListener);

              // Create this closure here to prevent this object from getting garbage
              // collected too soon.  The playlist reader uses the nsIWebBrowserPersist
              // component that does _not_ addref this listener :(
              var playlist_observer = {
                observe: function ( aSubject, aTopic, aData ) {
                  if (aTopic.indexOf("error") != -1) {
                    var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
                                                  .getService(Components.interfaces.nsIPromptService);
                    promptService.alert(null,
                                        "Playlist Error",
                                        "Unable to read playlist file - please try again later.");
                  }
                  else {
                    var array =
                      Components.classes["@mozilla.org/array;1"]
                                .createInstance(Components.interfaces.nsIMutableArray);
                    for (var i = 0; i < mediaList.length; i++) {
                      array.appendElement(mediaList.getItemByIndex(i), false);
                    }

                    // Send the items in the new media list to the metadata scanner
                    var metadataJobManager =
                      Components.classes["@songbirdnest.com/Songbird/MetadataJobManager;1"]
                                .getService(Components.interfaces.sbIMetadataJobManager);
                    var metadataJob = metadataJobManager.newJob(array, 5);
                  }
                }
              };

              playlistReaderListener.playWhenLoaded = aShouldBeginPlayback;
              playlistReaderListener.observer = playlist_observer;
              playlistReaderListener.mediaMimetypesOnly = true;
              playlistReaderManager.originalURI = uri;
              playlistReaderManager.loadPlaylist(uri, mediaList, null, false, playlistReaderListener);
              retval = true;
            }
            // Everything else gets played directly.
            else if ( gPPS.isMediaURL( aURL ) )
            {
              this.playExternalUrl(aURL, true);
              retval = true;
            }
          }
          catch ( err )
          {
            alert("sb-tabbrowser::handleMediaURL(" + aURL + "); " + err );
          }
          return retval;
        ]]></body>
      </method>

      <method name="onRemoteAPI">
        <parameter name="event" />
        <body><![CDATA[
          // todo: 
          //       hook up an action to do when the user clicks through, probably launch prepanel

          try {
            var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"]
                     .getService(Components.interfaces.nsIStringBundleService);
            var songbirdStrings = sbs.createBundle(
                               "chrome://songbird/locale/songbird.properties");
            var brandingStrings = sbs.createBundle(
                                  "chrome://branding/locale/brand.properties");
          } catch (e) { return; }

          var notificationName = "remoteapi-called";
          var message = "Web Page has accessed Songbird Directly";
          var buttonLabel = "Preferences";
          var buttonAccessKey = "P";
          try {
            message = songbirdStrings
                                .GetStringFromName("rapi.access.message.text");
            buttonLabel = songbirdStrings
                                .GetStringFromName("rapi.access.button.label");
            buttonAccessKey = songbirdStrings
                            .GetStringFromName("rapi.access.button.accessKey");
            var iconURL = brandingStrings
                                     .GetStringFromName("rapi.access.iconURL");
          } catch (e) { }

          var buttons = [{ label: buttonLabel,
                           accessKey: buttonAccessKey,
                           popup: null,    // point to a popup xul widget
                           callback: function() { 
                                          SBOpenPreferences("paneRemoteAPI"); }
                        }];

          var browser = event.currentTarget
                             .gBrowser.getBrowserForDocument(event.target);
          var notificationBox = browser.parentNode;
          var notification = notificationBox
                                   .getNotificationWithValue(notificationName);
          if (!notification) {
            // if there isn't a notfication object, make one and append it
            const priority = notificationBox.PRIORITY_WARNING_MEDIUM;
            notificationBox.appendNotification( message,
                                                notificationName,
                                                iconURL,
                                                priority,
                                                buttons);
          } else {
            // if there is a notification object set it's text.
            // this has the side effect of showing it if it was dismissed
            notification.message = message;
          }
        ]]></body>
      </method>
      
      <!-- sbITabBrowser -->
      <method name="getTabForDocument">
        <parameter name="aDocument" />
        <body><![CDATA[
          var numTabs = this.mTabContainer.childNodes.length;
          for ( var index = 0; index < numTabs; index++ ) {
            if ( this.mTabContainer
                     .childNodes[index]
                     .linkedBrowser
                     .contentDocument == aDocument ) {
              return this.mTabContainer.childNodes[index];
            }
          }
          return null;
        ]]></body>
      </method>
      
      <!-- context menu handler -->
      <method name="onHTMLContextMenu">
        <parameter name="target" />
        <body><![CDATA[
          if ( this.theHTMLContextURL ) {
            var v = target.getAttribute( "id" );
            switch ( v ) {
              case "html.context.open":
                // can be track or playlist
                // try dealing with media, might just be web content.
                if ( !this.handleMediaURL(this.theHTMLContextURL, true, false) )
                {
                  // should we add the referrer?
                  this.loadURI(this.theHTMLContextURL, null, null);
                }
              break;
              case "html.context.opentab":
                // can be track or playlist
                // try dealing with media, might just be web content.
                if ( !this.handleMediaURL(this.theHTMLContextURL, true, false) )
                {
                  // should we add the referrer?
                  this.loadOneTab(this.theHTMLContextURL, null, null, null, null, null);
                }
                break;
              case "html.context.openexternal":
                  var externalLoader = (Components
                           .classes["@mozilla.org/uriloader/external-protocol-service;1"]
                          .getService(Components.interfaces.nsIExternalProtocolService));
                  var nsURI = (Components
                          .classes["@mozilla.org/network/io-service;1"]
                          .getService(Components.interfaces.nsIIOService)
                          .newURI(this.theHTMLContextURL, null, null));
                  externalLoader.loadURI(nsURI, null);
              break;
              case "html.context.play":
                // can be track or playlist
                this.handleMediaURL(this.theHTMLContextURL, true, false);
              break;
              case "html.context.add":
                gPPS.importURL(this.theHTMLContextURL);
              break;
              case "html.context.playlist":
                // Add playlists to the service pane (force it as a playlist)
                this.handleMediaURL(this.theHTMLContextURL, false, true);
              break;
              case "html.context.copytoclipboard":
                var clipboard = Components.classes["@mozilla.org/widget/clipboardhelper;1"].getService(Components.interfaces.nsIClipboardHelper);
                clipboard.copyString(this.theHTMLContextURL);
              break;
            }
            this.theHTMLContextURL = null; // clear it because now we're done.
          }
        ]]></body>
      </method>
      
      <field name="_popupShowing">false</field>
      <method name="onContextPopupShowing">
        <parameter name="popup" />
        <parameter name="event" />
        <body><![CDATA[
          this._popupShowing = false;
          
          var XLINK_NS = 'http://www.w3.org/1999/xlink';
          
          this.theHTMLContextURL = '';
          
          // are we on a link?
          var onLink = false;
          var elem = document.popupNode; // the node that triggered the popup
          // walk up the DOM looking for a link of some sort
          while (elem) {
            if(elem.nodeType == Node.ELEMENT_NODE) {
              if (elem instanceof HTMLAnchorElement && elem.href ||
                  elem instanceof HTMLAreaElement ||
                  elem instanceof HTMLLinkElement ||
                  elem.getAttribute(XLINK_NS, 'type') == 'simple') {
                onLink = true;
                break;
              }
            }
            elem = elem.parentNode;
          }
          if (elem && onLink) {
            // looks like we've got something
            if (elem.href) {
              // it's some kind of HTML link
              this.theHTMLContextURL = elem.href;
            } else if (elem.hasAttributeNS(XLINK_NS, 'href')) {
              // it's an XLink link
              var xlink_href = elem.getAttributeNS(XLINK_NS, 'href');
              if (!xlink_href || !xlink_href.match(/\S/)) {
                // no link - fail
                onLink = false;
              }
              // use the IO service to make the URL absolute
              var ioService = Components.classes["@mozilla.org/network/io-service;1"]
                .getService(Components.interfaces.nsIIOService);
              var baseURI  = ioService.newURI(elem.baseURI, null, null);
              onLink = true;
              this.theHTMLContextURL = ioService.newURI(baseURI.resolve(xlink_href), null, null).spec;
            } else {
              // we shouldn't get here, but if we do that thing we thought was a link isn't
              onLink = false;
            }
            
          }
          
          if (this.theHTMLContextURL) {
            // Disable "Add" if the url isn't media or is already there.
            document.getElementById("html.context.add").setAttribute("disabled",
              SBUrlExistsInDatabase(this.theHTMLContextURL) || 
              !gPPS.isMediaURL(this.theHTMLContextURL));
            // allow the popup to be shown
            this._popupShowing = true;
            
          }

          return this._popupShowing; // should show
        ]]></body>
      </method>
      
      <method name="onContextPopupHiding">
        <parameter name="popup"/>
        <body><![CDATA[
          this._popupShowing = false;
        ]]></body>
      </method>
      
      <!-- this method extracts the target url of click event targetted at html -->
      <method name="GetHREFFromEvent">
        <parameter name="evt" />
        <body><![CDATA[
          var the_href = "";
          try
          {
            var node = evt.target;
            while ( node ) // Walk up from the event target to find the A? 
            {
              if ( node.href )
              {
                the_href = node.href;
                break;
              }
              node = node.parentNode;
            }
          }
          catch ( err )
          {
            alert( err );
          }
          return the_href;
        ]]></body>
      </method>
      
      <field name="theHTMLContextURL">null</field>
      
      <!-- override navigation methods from tabbrowser for fun and profit -->
      <!-- I'm not convinced these are actually required -->
      <method name="goBack">
        <body><![CDATA[
          // Disable the "add to playlist" button until we see that there is anything to add.
          SBDataSetBoolValue("browser.canplaylist", false);
          this.showWebPlaylist = false;
          return this.mCurrentBrowser.goBack();
        ]]></body>
      </method>
      <method name="goForward">
        <body><![CDATA[
          // Disable the "add to playlist" button until we see that there is anything to add.
          SBDataSetBoolValue("browser.canplaylist", false);
          this.showWebPlaylist = false;
          return this.mCurrentBrowser.goForward();
        ]]></body>
      </method>
      <method name="reload">
        <body><![CDATA[
          return this.mCurrentBrowser.reload();
        ]]></body>
      </method>
      <method name="stop">
        <body><![CDATA[
          return this.mCurrentBrowser.stop();
        ]]></body>
      </method>
      <property name="homePage">
        <getter><![CDATA[
          var browserHome = Application.prefs.get("browser.startup.homepage");
          if (!browserHome) {
            browserHome = Application.prefs.get("songbird.url.birdhouse");
            if (!browserHome) {
              throw new Error("Cannot find 'songbird.url.birdhouse' preference");
            }
            Application.prefs.setValue("browser.startup.homepage",
                                       browserHome.value);
          }
          return browserHome.value;
        ]]></getter>
        <setter><![CDATA[
          Application.prefs.setValue("browser.startup.homepage", val);
        ]]></setter>
      </property>
      <method name="goHome">
        <body><![CDATA[
          this.loadURI(this.homePage, null, null);
        ]]></body>
      </method>
      
      <method name="_getUnicodeStringPref">
        <parameter name="prefKey"/>
        <body><![CDATA[
          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefBranch2);
          return prefs.getComplexValue(prefKey, Components.interfaces.nsISupportsString);
        ]]></body>
      </method>

    </implementation>
    
    <handlers>
      <handler event="click"><![CDATA[
        // inspired by contentAreaClick in ffox browser.js
        if (!event.isTrusted || event.getPreventDefault()) {
          return true;
        }
                
        if (this._popupShowing || event.button == 2) {
          // if we're showing a popup or about to show one, let's do nothing
          return true;
        }
        
        var target = event.target;
        var linkNode = null;
        
        if (target instanceof HTMLAnchorElement ||
            target instanceof HTMLAreaElement ||
            target instanceof HTMLLinkElement) {
          if (target.hasAttribute("href")) {
            linkNode = target;
          }
     
          // backwards compat - use the outermost link node
          var parent = target.parentNode;
          while (parent) {
            if (parent instanceof HTMLAnchorElement ||
                parent instanceof HTMLAreaElement ||
                parent instanceof HTMLLinkElement) {
                if (parent.hasAttribute("href")) {
                  linkNode = parent;
                }
            }
            parent = parent.parentNode;
          }
        } else {
          linkNode = event.originalTarget;
          while (linkNode && !(linkNode instanceof HTMLAnchorElement)) {
            linkNode = linkNode.parentNode;
          }
          // <a> cannot be nested.  So if we find an anchor without an
          // href, there is no useful <a> around the target
          if (linkNode && !linkNode.hasAttribute("href")) {
            linkNode = null;
          }
        }

        var wrapper = null;
        var href = null;
        var target = null;
        if (linkNode) {
          href = linkNode.href;
          if (linkNode.hasAttribute('target')) {
            target = linkNode.getAttribute('target');
          }
        } else {
          // Try simple XLink
          var realHref, baseURI;
          linkNode = target;
          while (linkNode) {
            if (linkNode.nodeType == Node.ELEMENT_NODE) {
              wrapper = linkNode;
     
              realHref = wrapper.getAttributeNS("http://www.w3.org/1999/xlink", "href");
              if (realHref) {
                href = realHref;
                baseURI = wrapper.baseURI
              }
            }
            linkNode = linkNode.parentNode;
          }
          if (href) {
            var ioService = Components.classes["@mozilla.org/network/io-service;1"]
                .getService(Components.interfaces.nsIIOService);
            var base = ioService.newURI(baseURI, null, null);
            href = ioService.newURI(base.resolve(href), null, null).spec;
          }
        }
        
        if (href) {
          // get the document that this event originated in
          var doc = event.target.ownerDocument;
          
          var secMan = Components.classes["@mozilla.org/scriptsecuritymanager;1"]
              .getService(Components.interfaces.nsIScriptSecurityManager);
          secMan.checkLoadURIStrWithPrincipal(doc.nodePrincipal, href,
              Components.interfaces.nsIScriptSecurityManager.STANDARD);
          
          // get the referrer if we can
          var referrer = doc ? doc.documentURIObject : null;
          
          var where = 'current';
          if (target == '_blank' || target == '_new') {
            where = 'tab';
          }
          
          var pps = 
            Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"]
                      .getService(Components.interfaces.sbIPlaylistPlayback);
          if (pps.isMediaURL(href)) {
            where = 'current';
          }
          
          // we need to handle playlists specially
          if (pps.isPlaylistURL(href)) {
            this.handleMediaURL(href);
            event.stopPropagation();
            event.preventDefault();
            return true;
          }
          
          this.loadURI(href, referrer, null, event, where);
          event.stopPropagation();

          // We're supposed to return false if this was a normal vanilla link
          // click.
          if (event.button == 0 && !event.ctrlKey && !event.shiftKey &&
              !event.altKey && !event.metaKey) {
            return false;
          }
        }
        return true;
      ]]></handler>
      <handler event="mouseover"><![CDATA[
        // we only care about these events when they occur in the content doc
        if (event.target.ownerDocument != this.contentDocument) {
          return;
        }
        
        var url = this.GetHREFFromEvent(event);
        if (!url) {
          return;
        }
        theStatusText.stringValue = url;
        if (gPPS.isMediaURL(url) || gPPS.isPlaylistURL(url)) {
          theStatusStyle.stringValue = "font-weight: bold;";
        } else {
          theStatusStyle.stringValue = "font-weight: normal;";
        }
      ]]></handler>
      <handler event="mouseout"><![CDATA[
        // we only care about these events when they occur in the content doc
        if (event.target.ownerDocument != this.contentDocument) {
          return;
        }
        
        var url = this.GetHREFFromEvent(event);
        if (!url) {
          return;
        }
        
        theStatusText.stringValue = '';
      ]]></handler>
    </handlers>
  </binding>


  <!-- these are from globalBindings.xml -->
  <binding id="tabbrowser-tab" extends="chrome://songbird/content/bindings/tabbrowser.xml#tabbrowser-tab">
    <content closetabtext="&tabs.closeTab;" mousethrough="never">
      <xul:hbox class="tab-image-left" xbl:inherits="selected"/>
      <xul:hbox flex="1" class="tab-image-middle" align="center" xbl:inherits="selected">
        <xul:stack class="tab-icon">
          <xul:image xbl:inherits="validate,src=image" class="tab-icon-image"/>
          <xul:image class="tab-extra-status"/>
        </xul:stack>
        <xul:label flex="1" xbl:inherits="value=label,crop,accesskey" crop="right" class="tab-text"/>
      </xul:hbox>
      <xul:toolbarbutton anonid="close-button" class="tab-close-button" tabindex="-1"/>
      <xul:hbox class="tab-image-right" xbl:inherits="selected"/>
    </content>
    <implementation implements="nsIWebProgressListener,sbITabBrowserTab">
      <constructor><![CDATA[
        // right after all the constructors run...
        var self = this;
        window.setTimeout(function () { self.createOuterPlaylist(); }, 0);
        this._hrefLoop = null;
        this._onplaylistplay = { 
          _that: null, 
          handleEvent: function( event ) { this._that.onPlaylistPlay(event); } 
        }; this._onplaylistplay._that = this;
        
        this._progressFilter =
          Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
                    .createInstance(Components.interfaces.nsIWebProgress);
      ]]></constructor>
     <destructor><![CDATA[
        this.closeBalloonTip();
        if (this.previousInnerPlaylist) {
          this.previousInnerPlaylist.removeEventListener("playlist-play", this._onplaylistplay, true);
          this.previousInnerPlaylist.removeEventListener("playlist-editor", this.onPlaylistEditor, true);
          this.previousInnerPlaylist = null;
        }
        
        // Clear the progress filter.
        this._progressFilter.removeProgressListener(this);
        this.linkedBrowser.removeProgressListener(this._progressFilter);
     ]]></destructor>
      
      <field name="_progressFilter">null</field>
      
      <field name="_webLibraryCache">null</field>
      <property name="_webLibrary">
        <getter><![CDATA[
          if (this._webLibraryCache) {
            return this._webLibraryCache;
          }
          
          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefBranch2);
          var guid = prefs.getComplexValue("songbird.library.web",
                                           Components.interfaces.nsISupportsString);
          
          var libraryManager =
            Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                      .getService(Components.interfaces.sbILibraryManager);

          return (this._webLibraryCache = libraryManager.getLibrary(guid));
        ]]></getter>
      </property>
      
      <field name="_downloadListCache">null</field>
      <property name="_downloadList">
        <getter><![CDATA[
          if (this._downloadListCache) {
            return this._downloadListCache;
          }
          
          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefBranch2);
          var guid = prefs.getComplexValue("songbird.library.download",
                                           Components.interfaces.nsISupportsString);
          
          var libraryManager =
            Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                      .getService(Components.interfaces.sbILibraryManager);
          
          var mainLibrary = libraryManager.mainLibrary;

          return (this._downloadListCache = mainLibrary.getMediaItem(guid));
        ]]></getter>
      </property>

      <method name="createOuterPlaylist">
        <body><![CDATA[
          /* from mainwin.xul:
            <sb-smart-splitter id="playlist_web_split" hidden="true" state="open" resizebefore="closest" resizeafter="closest" target="after" collapse="after">
              <grippy/>
            </sb-smart-splitter>
            
            
            <vbox id="playlist_web_vbox" height="200" hidden="true" minheight="0" _resize_height="200">
              <playlist 
                id="playlist_web" 
                height="105"
                flex="1"
                hidden="true"
                enableColumnDrag="true"
                persist="columnSpec"
                editable="true"
                minheight="0"
                columnSpec="http://songbirdnest.com/data/1.0#ordinal 20 a " +
                           "http://songbirdnest.com/data/1.0#trackName 395 " +
                           "http://songbirdnest.com/data/1.0#duration 50 " +
                           "http://songbirdnest.com/data/1.0#artistName 222 " +
                           "http://songbirdnest.com/data/1.0#albumName 222 " +
                           "http://songbirdnest.com/data/1.0#genre 70");
                _resize_height="105"
              />
            </vbox>
          */
          
          // get the notification box around the browser
          var nbox = this.linkedBrowser.parentNode;
          
          
          // make the splitter
          this._splitter = document.createElement('sb-smart-splitter');
          this._splitter.setAttribute('class', 'playlist_web_split');
          this._splitter.setAttribute('hidden', 'true');
          this._splitter.setAttribute('state', 'open');
          this._splitter.setAttribute('resizebefore', 'closest');
          this._splitter.setAttribute('resizeafter', 'closest');
          this._splitter.setAttribute('target', 'after');
          this._splitter.setAttribute('collapse', 'after');
          this._splitter.appendChild(document.createElement('grippy'));
          

          // SCARY HACK!  See Bug 3504. 
          //
          // For whatever reason, hiding and then showing an
          // element in this context causes it to reappear
          // above its previous sibling.
          //
          // The Dom stays the same, but visually the
          // element moves.
          //
          // Fortunately adding a hidden box prevents this
          // behaviour.  
          //
          // Awesome.
          
          var hack = document.createElement('vbox');
          hack.setAttribute('hidden', 'true');
          nbox.appendChild(hack);     
          
          nbox.appendChild(this._splitter);               

          hack = document.createElement('vbox');
          hack.setAttribute('hidden', 'true');
          nbox.appendChild(hack);
          
          // make the playlist
          this._playlist = document.createElement('playlist');
          this._playlist.setAttribute('class', 'playlist_web');
          this._playlist.setAttribute('height', '200');
          this._playlist.setAttribute('hidden', 'true');
          this._playlist.setAttribute('enableColumnDrag', 'true');
          this._playlist.setAttribute('persist', 'columnSpec');
          this._playlist.setAttribute('editable', 'true');
          this._playlist.setAttribute('minheight', '0');
          this._playlist.setAttribute('columnSpec',
              SBProperties.ordinal + ' 20 a ' +
              SBProperties.trackName + ' 395 ' +
              SBProperties.duration + ' 50 ' +
              SBProperties.artistName + ' 222 ' +
              SBProperties.albumName + ' 222 ' +
              SBProperties.genre + ' 70');

          // add some events, eh?
          this._playlist.addEventListener("playlist-play", this._onplaylistplay, true);
          this._playlist.addEventListener("playlist-editor", this.onPlaylistEditor, true);
          // FIXME: remove the event listener on the destructor, I guess
          
          // wire up the browser progress filter
          this._progressFilter.addProgressListener(this, /* ignored */ null);
          this.linkedBrowser.addProgressListener(this._progressFilter,
            Components.interfaces.nsIWebProgress.NOTIFY_ALL);

          nbox.appendChild(this._playlist);

          this.outerPlaylistShowing = false;
        ]]></body>
      </method>
      
      <!-- sbITabBrowserTab -->
      <property name="outerPlaylist" readonly="true">
        <getter><![CDATA[
          return this._playlist;
        ]]></getter>
      </property>

      <method name="getPlaylist">
        <body><![CDATA[
          if ( this.innerPlaylist ) {
            return this.innerPlaylist;
          } else {
            return this._playlist;
          }
        ]]></body>
      </method>

      <!-- sbITabBrowserTab -->  
      <method name="hideOuterPlaylist">
        <body><![CDATA[
          this.outerPlaylistShowing = false;
        ]]></body>
      </method>

      <!-- sbITabBrowserTab -->  
      <method name="showOuterPlaylist">
        <body><![CDATA[
          this.outerPlaylistShowing = true;
        ]]></body>
      </method>
      
      <property name="outerPlaylistShowing">
        <getter><![CDATA[
          if (!this._playlist) return false;
          return (!this._playlist.hasAttribute("hidden") ||
                  this._playlist.getAttribute("hidden") == 'false');
        ]]></getter>
        <setter><![CDATA[
          if (!this._playlist) return;
          dump('\n\n\nsetting outerWebPlaylistShowing to: '+val+'\n\n\n\n');
          this._playlist.hidden = !val;
          this._splitter.hidden = !val;

          if (!val) {
            // if the balloontip for the webplaylist is shown, close it
            this.closeBalloonTip();
          } else {
            // open the balloontip if needed
            this.openBalloonTip();
          }
        ]]></setter>
      </property>

      
      <!-- sbITabBrowserTab -->
      <property name="innerPlaylist" readonly="true">
        <getter><![CDATA[
          if (this.linkedBrowser.currentURI.scheme != 'chrome') {
            // only chrome urls can supply a playlist
            return null;
          }
          // Get the document from the current browser tab
          var playlistDocument = this.linkedBrowser.contentDocument;
          if (playlistDocument == null) {
            return null;
          }
          
          // Get the playlist element from within the current tab      
          // TODO change this
          var playlist = playlistDocument.getElementById("playlist_test");
          if (playlist == null) {
            return null;
          }
          
          // Remove security wrappers
          if (playlist.wrappedJSObject) {
            playlist = playlist.wrappedJSObject;
          }
          
          return playlist;
        ]]></getter>
      </property>

      <!-- sbITabBrowserTab -->  
      <field name="_shouldScan">true</field>

      <!-- sbITabBrowserTab -->  
      <method name="enableScan">
        <body><![CDATA[
          this._shouldScan = true;
        ]]></body>
      </method>

      <!-- sbITabBrowserTab -->  
      <method name="disableScan">
        <body><![CDATA[
          this._shouldScan = false;
        ]]></body>
      </method>

      <field name="scanProgress">-1</field>
    
      <!-- sbITabBrowserTab -->  
      <method name="clearOuterPlaylist">
        <body><![CDATA[
          // hide the outer playlist
          CancelAsyncWebDocument(this._hrefLoop);
          this._hrefLoop = null;
          this.outerPlaylistShowing = false;
          this.scanProgress = -1;
        ]]></body>
      </method>

      <method name="scanWebPage">
        <body><![CDATA[
          if (!SBDataGetBoolValue('webplaylist.enabled')) {
            return;
          }

          // check to see if scanning has been disabled
          if (!this._shouldScan)
            return;

          // Only scrape http(s) and file pages
          var scheme = this.linkedBrowser.currentURI.scheme;
          if (scheme != 'http' && scheme != 'https' && scheme != 'file') {
            this.outerPlaylistShowing = false;
            return;
          }

          // Now all I have to do is find something resembling a usefully unique key.
          var browser = this.linkedBrowser;
          var history = browser.webNavigation.sessionHistory;
          var entry = history.getEntryAtIndex( history.index, false );
          
          // See if we're supposed to be restoring a view or making a new one
          var viewMap =
            Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
                      .getService(Components.interfaces.sbIMediaListViewMap);
          var view = viewMap.getView(browser, entry);
          
          var skipScan = view ? true : false;
          
          if (!view) {
            var mediaList =
              this._getWebMediaListForURL(this.linkedBrowser.currentURI.spec);
            view = mediaList.createView();
            if ( browser && entry && view instanceof Components.interfaces.sbIMediaListView )
              viewMap.setView(browser, entry, view);
          }

          // Otherwise, don't show the web playlist until we see some tracks.
          this.outerPlaylistShowing = false;
          
          // Bind the Web Playlist UI element to the subscribed playlist
          SBWebPlaylistCommands.m_Playlist = this.outerPlaylist;
          this.outerPlaylist.outerWindow = window;
          this.outerPlaylist.bind(view, SBWebPlaylistCommands,
                                  SBDataGetIntValue("browser.playlist.height"),
                                  SBDataGetBoolValue("browser.playlist.collapsed"));

          // If we're restoring a view, don't do anything else
          if (skipScan) {
            // Only show it if there's something to see.
            if (view.length) {
              this.outerPlaylistShowing = true;
            }
            else {
              // Remove empty media lists.
              var library = view.mediaList.library;
              library.remove(view.mediaList);
            }
            return;
          }

          // scrape the document.
          var context = {
            tab: this,
            pt: 0,
            get progressTotal() {
              return this.pt;
            },
            set progressTotal(p) {
              this.pt = p;
              this.setProgress();
            },
            pc: 0,
            get progressCurrent() {
              return this.pc;
            },
            set progressCurrent(p) {
              this.pc = p;
              this.setProgress();
            },
            setProgress: function setProgress() {
              this.tab.scanProgress = (1.0*this.pc)/this.pt;
            },
            sp: false,
            get showPlaylist() {
              return this.sp;
            },
            set showPlaylist(s) {
              this.tab.outerPlaylistShowing = s;
              this.sp = s;
            }
          };
          this.scanProgress = 0;
          this._hrefLoop = AsyncWebDocument(this.linkedBrowser.contentDocument,
                                            view, this._hrefLoop, context);
        ]]></body>
      </method>
      
      <field name="viewForNextPlaylist">null</field>      

      <method name="setUpInnerPlaylist">
        <body><![CDATA[ try {
          var playlist = this.innerPlaylist;
          playlist.outerWindow = window;
          if ( playlist.mediaListView ) // New API
          {
            var viewMap =
              Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
                        .getService(Components.interfaces.sbIMediaListViewMap);
                        
            // Now all I have to do is find something resembling a usefully unique key.
            var browser = this.linkedBrowser;
            var history = browser.webNavigation.sessionHistory;
            var entry = history.getEntryAtIndex( history.index, false );
            
            // someone wants us to apply a view
            if (this.viewForNextPlaylist) {
              playlist.bind(this.viewForNextPlaylist, playlist.commands);
              // save this mapping I guess 
              if ( browser && entry && this.viewForNextPlaylist instanceof Components.interfaces.sbIMediaListView )
                viewMap.setView(browser, entry, this.viewForNextPlaylist);
              this.viewForNextPlaylist = null;
            } else {
              // Is there something to restore?
              var restore = viewMap.getView( browser, entry );
              if ( restore == null )
              {
                // Save the current view if there is nothing to restore
                if ( browser && entry && playlist.mediaListView instanceof Components.interfaces.sbIMediaListView )
                  viewMap.setView( browser, entry, playlist.mediaListView );
                playlist.refreshCommands();
              }
              else
              {
                // Otherwise, restore it.
                var commands = playlist.commands;

                // Must use setTimeout() here to prevent the playlist from
                // binding while the page is still loading
                setTimeout(function() {
                  playlist.bind( restore.clone(), commands );
                }, 0);
              }
            }
          }
          
          // add some events, eh?
          if (this.previousInnerPlaylist) {
            this.previousInnerPlaylist.removeEventListener("playlist-play", this._onplaylistplay, true);
            this.previousInnerPlaylist.removeEventListener("playlist-editor", this.onPlaylistEditor, true);
            this.previousInnerPlaylist = null;
          }
          playlist.addEventListener("playlist-play", this._onplaylistplay, true);
          playlist.addEventListener("playlist-editor", this.onPlaylistEditor, true);
          this.previousInnerPlaylist = playlist;
          
          // Wait until after the bind call?
          if ( playlist.ref == "" )
          {
            return;
          }
          
          //
          // THE RETURN ABOVE IS ALWAYS HIT!!  THE CODE BELOW WON'T RUN!!
          //
          
          // Drag and Drop tracker object
          playlist.setDnDSourceTracker(sbDnDSourceTracker);

          // Remember some values
          theLibraryPlaylist = playlist;
          this.playlistTree = playlist = playlist.tree;
          SBDataSetStringValue('playlist.ref', playlist.getAttribute( "ref" )); // is this set yet?
  
          // Set the current selection
          theLibraryPlaylist.syncPlaylistIndex(false);
  
          // And remember that we did this
          installed_listener = true;
          } catch( e ) { alert( "tabbrowser::setUpInnerPlaylist\n\n" + e ); }]]></body>
      </method>
      
      <field name="_swappedPlaylistView">null</field>
      
      <method name="switchToWebPlaylistView">
        <body><![CDATA[
          var view;
          if (this._swappedPlaylistView) {
            view = this._swappedPlaylistView;
            this._swappedPlaylistView = null;
          }
          else {
            // This code should never run unless someone calls this function
            // manually outside of the SBDownloadCommands object.

            dump("*** WARNING: switchToWebPlaylistView called with no " +
                 "swappedPlaylistView!\n");

            var mediaList =
              this._getWebMediaListForURL(this.linkedBrowser.currentURI.spec);
            view = mediaList.createView();
          }

          this.outerPlaylist.bind(view, SBWebPlaylistCommands,
                                  SBDataGetIntValue("browser.playlist.height"),
                                  SBDataGetBoolValue("browser.playlist.collapsed"));
        ]]></body>
      </method>

      <method name="switchToDownloadView">
        <body><![CDATA[
          // Make sure the download device has been added to the commands object.
          if (!SBDownloadCommands.m_Device) {
            var deviceManager =
              Components.classes["@songbirdnest.com/Songbird/DeviceManager;1"]
                        .getService(Components.interfaces.sbIDeviceManager);
            
            downloadDevice =
              deviceManager.getDeviceByCategory("Songbird Download Device");
            
            SBDownloadCommands.m_Device = downloadDevice;
          }
          
          // Save this for later if we swap back.
          this._swappedPlaylistView = this.outerPlaylist.mediaListView;
          
          var view = this._downloadList.createView();
          
          this.outerPlaylist.bind(view, SBDownloadCommands,
                                  SBDataGetIntValue("browser.playlist.height"),
                                  SBDataGetBoolValue("browser.playlist.collapsed"));
        ]]></body>
        </method>
        
        <method name="_getWebMediaListForURL">
          <parameter name="aURL"/>
          <body><![CDATA[
            var listener = {
              foundList: null,
              onEnumerationBegin: function onEnumerationBegin(list) {
                return true;
              },
              onEnumeratedItem: function onEnumeratedItem(list, item) {
                if (!(item instanceof Components.interfaces.sbIMediaList)) {
                  throw new Error("Given an item, not a list!");
                }
                this.foundList = item;
                return false;
              },
              onEnumerationEnd: function onEnumerationEnd(list) {
                return;
              }
            };
            
            var propArray =
              Components.classes["@songbirdnest.com/Songbird/Properties/MutablePropertyArray;1"]
                        .createInstance(Components.interfaces.sbIMutablePropertyArray);
            propArray.appendProperty(SBProperties.originPage, aURL);
            propArray.appendProperty(SBProperties.isList, "1");
            
            var webLibrary = this._webLibrary;
            webLibrary.enumerateItemsByProperties(propArray, listener,
                                                  Components.interfaces.sbIMediaList.ENUMERATIONTYPE_SNAPSHOT);
            
            if (listener.foundList) {
              return listener.foundList;
            }
            
            // Make a new list and set the originPage property.
            var newList = webLibrary.createMediaList("simple");
            
            newList.setProperty(SBProperties.originPage, aURL);
            
            // XXXben Do this for now because the new AddToPlaylist code sweeps
            //        all non-hidden media lists from *all* libraries.
            newList.setProperty(SBProperties.hidden, "1");
            
            return newList;
          ]]></body>
        </method>

      <!-- Used to save the URL that is loading so that we can properly match
           the web progress messages -->
      <field name="_loadingURL">""</field>

      <!-- nsIWebProgressListener implementation -->
      <method name="onLocationChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aLocation" />
        <body><![CDATA[
          // if this location change isn't on the top-level window, ignore it
          if (aWebProgress.DOMWindow != aWebProgress.DOMWindow.parent) {
            return;
          }
          
          // see if the notification box is up, remove it if so.
          // removing it with removeNotification(notification) causes all
          // subsequent notifications to not show up.
          var notificationBox = this.linkedBrowser.parentNode;
          if (notificationBox.getNotificationWithValue("remoteapi-called")) {
            notificationBox.removeAllNotifications(true);
          }

          // set the loadingURI so we know in onStateChange when to  cause a
          // scan of the web page to populate the web playlist. Do it
          // here and not in onStateChange because the STATE_START message has
          // the wrong document URI when using the back button (and probably
          // when going from site to site).
          

          this._loadingURL = aLocation.spec;
          this.clearOuterPlaylist();
          this._shouldScan = true;
        ]]></body>
      </method>
      
      <method name="onProgressChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aCurSelfProgress" />
        <parameter name="aMaxSelfProgress" />
        <parameter name="aCurTotalProgress" />
        <parameter name="aMaxTotalProgress" />
        <body><![CDATA[ ]]></body>
      </method>
      
      <method name="onSecurityChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <body><![CDATA[ ]]></body>
      </method>

      <method name="onStateChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aStatus" />
        <body><![CDATA[
          // if this state change isn't on the top-level window, ignore it
          if (aWebProgress.DOMWindow != aWebProgress.DOMWindow.parent ||
              !(aState & Components.interfaces.nsIWebProgressListener.STATE_IS_WINDOW)) {
            return;
          }
          
          const nsIWebProgressListener =
            Components.interfaces.nsIWebProgressListener;
          if (aState & nsIWebProgressListener.STATE_STOP) {
            if (!(this.linkedBrowser.contentDocument && 
                  this.linkedBrowser.contentDocument.documentURI == this._loadingURL)) {
              return;
            }
            this._loadingURL = "";
            
            if (this.innerPlaylist) {
              this.setUpInnerPlaylist();
            } else {
              this.scanWebPage();
            }
          }
        ]]></body>
      </method>

      <method name="onStatusChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aMessage" />
        <body><![CDATA[ ]]></body>
      </method>
      
      <method name="onPlaylistEditor">
        <parameter name="evt"/>
        <body>
        <![CDATA[ 
          var playlist = evt.target;
          if ( playlist.wrappedJSObject )
            playlist = playlist.wrappedJSObject;
          
            var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
                              .getService(Components.interfaces.nsIWindowMediator);
            var theTE = wm.getMostRecentWindow("track_editor");
            if (theTE) {
              theTE.focus();
            } else {
              const TEURL = "chrome://songbird/content/xul/trackeditor.xul";
              const TEFEATURES = "chrome,dialog=no,resizable=no";
              SBOpenWindow(TEURL, "track_editor", TEFEATURES, playlist); 
            }
        ]]>
        </body>
      </method>
      
      <method name="onPlaylistPlay">
        <parameter name="evt"/>
        <body>
        <![CDATA[ 
          var target = evt.target;
          if ( target.wrappedJSObject )
          {
            target = target.wrappedJSObject;
          }
          this.playPlaylistIndex( target.tree.currentIndex, target );
        ]]>
        </body>
      </method>
      
      <method name="playPlaylistIndex">
        <parameter name="index"/>
        <parameter name="playlist"/>
        <body>
        <![CDATA[ 
          try
          {
            if (!playlist) playlist = gBrowser.currentPlaylist;
            if (!playlist) return;
            
            if (index < 0) {
              // if no track is selected start playing from the first one
              index = 0;
            }
            
            var PPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);
            if (index < playlist.mediaListView.length) {
              PPS.playView(playlist.mediaListView, index);
            }
          }
          catch ( err )
          {
            alert( err );
          }
        ]]>
        </body>
      </method>
    
      <method name="openBalloonTip">
        <body><![CDATA[
          if (!SBDataGetBoolValue("balloontip.firstwebplaylist.shown")) {
            this.balloontip = new BalloonTip;
            var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"].getService(Components.interfaces.nsIStringBundleService);
            var songbirdStrings = sbs.createBundle("chrome://songbird/locale/songbird.properties");
            var title = "Found media."
            var text = "Songbird has found the following playable tracks."
            try {
              title = songbirdStrings.GetStringFromName("balloontip.firstwebplaylist.title");
              text = songbirdStrings.GetStringFromName("balloontip.firstwebplaylist.text");
            } catch (e) { }
            this.balloontip.showText(text, this._playlist, title, 'balloon-icon-songbird', null, -1);
            SBDataSetBoolValue("balloontip.firstwebplaylist.shown", true);
          }
        ]]></body>
      </method>
      
      <method name="closeBalloonTip">
        <body><![CDATA[
          if (this.balloontip) {
            this.balloontip.closeTip();
            this.balloontip = null;
          }
        ]]></body>
      </method>

      <!-- tab dnd helpers -->
      <method name="canDrop">
        <parameter name="event"></parameter>
        <parameter name="session"></parameter>
        <body><![CDATA[
          var canDrop = false;

          var playlist = this.innerPlaylist;
          if (playlist) {
            canDrop = playlist.canDrop(event, session);
          } else {
            canDrop = false;
          }          
          return canDrop;
        ]]></body>
      </method>
      <field name="_dragTimeout">350</field>
      <field name="_dragTimer">null</field>

      <method name="logStringMessage">
        <parameter name="aString"/>
        <body>
          <![CDATA[
            var message = "*** " + aString + "\n";
            var consoleService =
              Components.classes["@mozilla.org/consoleservice;1"]
                        .getService(Components.interfaces.nsIConsoleService);
            consoleService.logStringMessage(message);
            dump(message);
          ]]>
        </body>
      </method>

    </implementation>
    
    <handlers>
      <handler event="TabClose"><![CDATA[
        // When we drop the tab, release all of the associated views stored in the map.
        Components.classes["@songbirdnest.com/Songbird/library/MediaListViewMap;1"]
                  .getService(Components.interfaces.sbIMediaListViewMap)
                  .releaseViews(event.target.linkedBrowser);
      ]]></handler>

      <handler event="dragenter"><![CDATA[
        var dragService = Components.classes["@mozilla.org/widget/dragservice;1"]
           .getService(Components.interfaces.nsIDragService);
        var session = dragService.getCurrentSession();

        session.canDrop = this.canDrop(event, session);
        
        if (session.canDrop && !this._dragTimer && this._dragTimeout) {
          (function(tab) {
            tab._dragTimer = setTimeout(function() {
              tab._dragTimer = null;
              
              // set up an interval callback to check if the drag has completed
              // and restore the original tab when it's done
              if (!gBrowser._springLoadedTab) {
                gBrowser._springLoadedTab = {
                  tab: gBrowser.mTabContainer.selectedItem,
                  interval: setInterval(function() {
                    if (!dragService.getCurrentSession()) {
                      // the drag is over, clear the timer, clear the state
                      // restore the tab
                      gBrowser.mTabContainer.selectedItem =
                          gBrowser._springLoadedTab.tab;
                      clearInterval(gBrowser._springLoadedTab.interval);
                      gBrowser._springLoadedTab = null;
                    }
                  }, 500)
                }
              }
              
              gBrowser.mTabContainer.selectedItem = tab;
            }, tab._dragTimeout);
          })(this);
        }
        
      ]]></handler>
      <handler event="dragleave"><![CDATA[
        if (this._dragTimer) {
          clearTimeout(this._dragTimer);
          this._dragTimer = null;
        }
      ]]></handler>
      <handler event="dragdrop"><![CDATA[
        var dragService = Components.classes["@mozilla.org/widget/dragservice;1"]
           .getService(Components.interfaces.nsIDragService);
        var session = dragService.getCurrentSession();
        
        if (this.canDrop(event, session)) {
          var playlist = this.innerPlaylist;
          playlist._dropOnTree(playlist.mediaListView.length,
                               Components.interfaces.DROP_AFTER);
        }
      ]]></handler>
    </handlers>
  </binding>
  
   <binding id="tabbrowser-tabs"  
            extends="chrome://songbird/content/bindings/tabbrowser.xml#tabbrowser-tabs">
    <content>
      <xul:stack flex="1" class="tabs-stack">
        <xul:vbox>
          <xul:spacer flex="1"/>
          <xul:hbox class="tabs-bottom" align="center"/>
        </xul:vbox>
        <xul:vbox>
          <xul:hbox>
            <xul:stack>
              <xul:spacer class="tabs-left"/>
            </xul:stack>
            <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1" style="min-width: 1px;" class="tabbrowser-arrowscrollbox">
              <children/>
            </xul:arrowscrollbox>
            <xul:stack align="center" pack="end">
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035 
              -->
              <xul:hbox style="position: relative;">
                <xul:hbox flex="1" class="tabs-alltabs-box" 
                          anonid="alltabs-box"/>
              </xul:hbox>
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035 
              -->
              <xul:hbox style="position: relative;">
                <xul:hbox flex="1" class="tabs-alltabs-box-animate" 
                          anonid="alltabs-box-animate"/>
              </xul:hbox>
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035 
              -->
              <xul:hbox style="position: relative;">
                <xul:toolbarbutton class="tabs-alltabs-button"
                                   type="menu"
                                   anonid="alltabs-button"
                                   tooltipstring="&tabs.listAllTabs;">
                  <xul:menupopup class="tabs-alltabs-popup"
                                 anonid="alltabs-popup" position="after_end"/>
                </xul:toolbarbutton>
              </xul:hbox>
            </xul:stack>
            <xul:hbox class="tabs-closebutton-box" align="center" pack="end" anonid="tabstrip-closebutton">
              <xul:toolbarbutton class="close-button tabs-closebutton"/>
            </xul:hbox>
          </xul:hbox>
          <xul:spacer class="tabs-bottom-spacer"/>
        </xul:vbox>
      </xul:stack>
    </content>
  </binding>

</bindings>
