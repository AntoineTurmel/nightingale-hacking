<?xml version="1.0"?>
<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl">

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="sb-tabbrowser" extends="chrome://songbird/content/bindings/tabbrowser.xml#tabbrowser">
    <implementation implements="nsIWebProgressListener">
      <constructor><![CDATA[
        this.addProgressListener(this,
            Components.interfaces.nsIWebProgress.NOTIFY_LOCATION |
            Components.interfaces.nsIWebProgress.NOTIFY_STATE_ALL);
        /* FIXME: how should this work?
        this._progressFilter.addProgressListener(this,
            Components.interfaces.nsIProgressListener.NOTIFY_ALL);
        this.addProgressListener(this._progressFilter);
        */
        this.loading = false;
      ]]></constructor>
      <destructor><![CDATA[
        this.removeProgressListener(this);
      ]]></destructor>
      
      <field name="_progressFilter">
        Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
            .createInstance(Components.interfaces.nsIWebProgress)
      </field>

      <field name="_servicepane">null</field>
      <property name="servicepane">
        <getter><![CDATA[
          if (!this._servicepane) {
            this._servicepane =
                document.getElementById(this.getAttribute('servicepane'));
          }
          return this._servicepane;
        ]]></getter>
      </property>
      
      
      <field name="_search">null</field>
      <property name="search">
        <getter><![CDATA[
          if (!this._search) {
            this._search =
                document.getElementById(this.getAttribute('search'));
          }
          return this._search;
        ]]></getter>
      </property>
      
      <field name="_playlist">null</field>
      <property name="playlist">
        <getter><![CDATA[
          if (!this._playlist) {
            this._playlist =
                document.getElementById(this.getAttribute('playlist'));
          }
          return this._playlist;
        ]]></getter>
      </property>
      
      <field name="_loading">SB_NewDataRemote("faceplate.loading", null)</field>
      <property name="loading"
                onget="return this._loading.boolValue"
                onset="this._loading.boolValue = val;" />
      
      <field name="mainpane_listener_set">false</field>
      
      <property name="showWebPlaylist">
        <getter><![CDATA[
          // the value is stored in a data remote
          return SBDataGetBoolValue('browser.playlist.show');
        ]]></getter>
        <setter><![CDATA[
          // boolify the value that's passed in
          var value = (val)?true:false;
          // set the value in the data remote
          SBDataSetBoolValue('browser.playlist.show', value);
          
          if (!value) {
            // if we're hiding the web playlist then unhook it from the UI
            if (this.playlist) {
              this.playlist.datasources = "";
              this.playlist.ref = "";
            }
          }
        ]]></setter>
      </property>
      
      <method name="_loaded">
        <body><![CDATA[
        dump('running _loaded\n');
          try {
            if (!this.mainpane_listener_set)
            {

              //
              //
              // HORRIBLE SECURITY HACK TO GET THE PLAYLIST TREE AND INJECT FUN EVENT HANDLERS 
              //
              //
              var installed_listener = false;
              var playlist = this.contentDocument?this.contentDocument.getElementById( "playlist_test" ):null;
              if (playlist) {
                // Crack the security if necessary
                if ( playlist.wrappedJSObject )
                  playlist = playlist.wrappedJSObject;
        
                // Wait until after the bind call?
                if ( playlist.ref == "" )
                {
                  // Try again in 250 ms?
                  //setTimeout(this._loaded, 250);
                  return;
                }
        
                // hack, to let play buttons find the visible playlist if needed
                document.__CURRENTPLAYLIST__ = playlist;
        
                // Drag and Drop tracker object
                playlist.setDnDSourceTracker(sbDnDSourceTracker);
        
                // Events on the playlist object itself.
                playlist.addEventListener("playlist-edit", onPlaylistEdit, true);
                playlist.addEventListener("playlist-editor", onPlaylistEditor, true);
                playlist.addEventListener("playlist-play", onPlaylistPlay, true);
                playlist.addEventListener("playlist-burntocd", onPlaylistBurnToCD, true);
                playlist.addEventListener("playlist-noplaylist", onPlaylistNoPlaylist, true);
                playlist.addEventListener("playlist-filterchange", onPlaylistFilterChange, true);
                playlist.addEventListener("command", onPlaylistContextMenu, false );  // don't force it!
        
                // Remember some values
                theLibraryPlaylist = playlist;
                thePlaylistTree = playlist = playlist.tree;
                SBDataSetStringValue('playlist.ref', playlist.getAttribute( "ref" )); // is this set yet?
        
                // Set the current selection
                theLibraryPlaylist.syncPlaylistIndex(false);
        
                // And remember that we did this
                installed_listener = true;
        
                this.mainpane_listener_set = true;
                
                if (document.__JUMPTO__) {
                  document.__JUMPTO__.syncJumpTo();
                }
              }
              else {
                thePlaylistTree = null;
                theLibraryPlaylist = null;
                // hack, to let play buttons find the visible playlist if needed
                document.__CURRENTPLAYLIST__ = null;
              }
        
              // Should the webplaylist scan and listener binding be performed?
              var enableWebPlaylist = SBDataGetBoolValue("webplaylist.enabled");
              
              // If we have not installed a playlist listener, and the web playlist
              // is enabled, install the link url listener.
              if ( !installed_listener && enableWebPlaylist) {
                // wait until the document exists to see if there are any A tags
                if (!this.contentDocument) {
                  //setTimeout(this._loaded, 2500);
                  return;
                } else if (this.contentDocument.getElementsByTagName('A').length != 0 ) {
                  var playlist_guid = WEB_PLAYLIST_CONTEXT;
                  var playlist_table = WEB_PLAYLIST_TABLE;
                  // BIG HACK to show the subscribed playlist
                  var cur_url = SBDataGetStringValue( "browser.uri" );
                  var aPlaylistManager = new sbIPlaylistManager();
                  var queryObj = new sbIDatabaseQuery();
                  queryObj.setAsyncQuery(false);
                  queryObj.setDatabaseGUID("songbird");      
                  aPlaylistManager.getDynamicPlaylistList(queryObj);
                  var resObj = queryObj.getResultObject();
                  var i, rows = resObj.getRowCount();
                  for ( i = 0; i < rows; i++ ) {
                    if ( cur_url == resObj.getRowCellByColumn( i, "description" ) ) {
                      var table = resObj.getRowCellByColumn( i, "name" );
                      // Bind the Web Playlist UI element to the subscribed playlist instead of scraping.
                      theWebPlaylist.bind( "songbird", table, null, SBDefaultCommands, SBDataGetIntValue( "browser.playlist.height" ), SBDataGetBoolValue( "browser.playlist.collapsed" ) );
                      // Show/hide them
                      this.showWebPlaylist = true;
                      playlist_guid = "songbird";
                      playlist_table = table;
                    }
                  }
                  // scrape the document.
                  AsyncWebDocument(this.contentDocument, playlist_guid, playlist_table );
                } 
        
        
                // XXXlone - we need this to happen so that the playlist gets initialized if it wasn't ready yet but is coming up soon 
                // unfortunately, if the page is not going to be a playlist, but is a document with no A element, we'll keep hitting this code
                // and rerun this function every 2.5s, forever. We need to detect that a page is a not a playlist in the process of being loaded 
                // so that we can avoid issuing a setTimeout(onMainPaneLoad, 2500) in this case, but ONLY in this case.
                else {
                  var tb = this;
                  //setTimeout(function(){tb._loaded()}, 2500 );
                  return;
                }
                // XXXlone - end case where page is going to be a playlist but contentDocument does not yet contains a playlist
        
                this.mainpane_listener_set = true;
              }
            }
          } catch( err ) {
            dump(err.toSource()+'\n');
            alert( 'sb-tabbrowser::_loaded: '+err );
          }
        ]]></body>
      </method>

      
      <!-- implementation of nsIWebProgressListener -->
      <method name="onLocationChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aLocation" />
        <body><![CDATA[
        

          
        
          try {
            // for some reason we need to do this dance to get scrollbars to
            // show up
            var nsIScrollable = Components.interfaces.nsIScrollable;
            var scrollable = this.webNavigation.QueryInterface(nsIScrollable);        
            scrollable.setDefaultScrollbarPreferences(nsIScrollable.ScrollOrientation_Y,
                                                      nsIScrollable.Scrollbar_Auto);
            scrollable.setDefaultScrollbarPreferences(nsIScrollable.ScrollOrientation_X,
                                                      nsIScrollable.Scrollbar_Auto);
          
            var cur_uri = aLocation.asciiSpec;
            // save url for reload on next servicetree init
            //SBDataSetStringValue("servicetree.selected_url", cur_uri);  
            // Set the value in the text box (shown or not)

            if (aRequest && aRequest.name) {
              // Set the box
              SBDataSetStringValue('browser.uri', cur_uri);
              if (this.servicepane) {
                var url = this.servicepane.getURLName(cur_uri);
                if (!url) {
                  url = cur_uri;
                }
                SBDataSetStringValue('browser.url.text', url);
                var image = this.servicepane.getURLImage(cur_uri);
                if (image && image.length) {
                  SBDataSetStringValue('browser.url.image', image);
                }
              }
              
              // Set the buttons based on the session history.
              if (this.webNavigation.sessionHistory) {
                // Check the buttons
                SBDataSetBoolValue('browser.cangoback',
                                   this.webNavigation.canGoBack);
                SBDataSetBoolValue('browser.cangoforward',
                                   this.webNavigation.canGoForward);
              }
            }
            
            // Clear the playlist tree variable so we are not confused.
            thePlaylistTree = null;
            theLibraryPlaylist = null;
            // hack, to let play buttons find the visible playlist if needed
            document.__CURRENTPLAYLIST__ = null;
            
            // Clear the tracking variable
            this.mainpane_listener_set = false;
            
            // Disable the "add to playlist" button until we see that there is anything to add.
            SBDataSetBoolValue('browser.canplaylist', false);
            this.showWebPlaylist = false;
      
            // Clear the playlist tree variable so we are not confused.
            thePlaylistTree = null;
            theLibraryPlaylist = null;
            // hack, to let play buttons find the visible playlist if needed
            document.__CURRENTPLAYLIST__ = null;
            
            // Nothing in the status text
            theStatusText.stringValue = "";
            
            this.search.loadSearchStringForCurrentUrl();
          }
          catch ( err )
          {
            alert( "sb-tabbrowser::onLocationChange\n\n" + err );
          }
        ]]></body>
      </method>
      
      <method name="onProgressChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aCurSelfProgress" />
        <parameter name="aMaxSelfProgress" />
        <parameter name="aCurTotalProgress" />
        <parameter name="aMaxTotalProgress" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>
      
      <method name="onSecurityChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>

      <method name="onStateChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aStatus" />
        <body><![CDATA[
          const nsIWebProgressListener =
            Components.interfaces.nsIWebProgressListener;
      
          if (aState & nsIWebProgressListener.STATE_START) {
            // Start the spinner if necessary
            this.loading = true;
            
            // cancel the previous page scan
            CancelAsyncWebDocument();

          }
          else if (aState & nsIWebProgressListener.STATE_STOP) {
            // Stop the spinner if necessary
            this.loading = false;
      
            // Notfiy that the page is done loading
            this._loaded();
          }
        ]]></body>
      </method>

      <method name="onStatusChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aMessage" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>
      
      
      <!-- a bunch of methods from browser_xbl_temp.js / songbird_hack.js.
           I'm not convinced they belong here, but till we refactor a couple
           more things there's nowhere better for them to go. -->
      <method name="playExternalUrl">
        <parameter name="the_url" />
        <parameter name="tryweb" />
        <body><![CDATA[
          //SB_LOG("songbird_hack.js", "playExternalUrl: " + the_url);
          var PPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);
          // figure out if the url is in the webplaylist
          if (tryweb && theWebPlaylist && !theWebPlaylist.hidden) 
          {
            var row = theWebPlaylist.findRowIdByUrl(the_url);
            if (row != -1) 
            {
              // if so, play the ref, from that entry's index
              PPS.playRef("NC:webplaylist_webplaylist", row);
            }
          } else {
            // otherwise, play the url as external (added to the db, plays the library from that point on)
            PPS.playAndImportURL(the_url); // if the url is already in the lib, it is not added twice
            if (document.__SEARCHWIDGET__) document.__SEARCHWIDGET__.loadSearchStringForCurrentUrl();
          }
        ]]></body>
      </method>
      
      <method name="handleMediaURL">
        <parameter name="aURL" />
        <parameter name="aShouldBeginPlayback" />
        <parameter name="forcePlaylist" />
        <body><![CDATA[
          var retval = false;
          try
          {
            // Stick playlists in the service pane (for now).
            if ( forcePlaylist || gPPS.isPlaylistURL( aURL ) )
            {
              var playlistReader = Components.classes["@songbirdnest.com/Songbird/PlaylistReaderManager;1"]
                                   .createInstance(Components.interfaces.sbIPlaylistReaderManager);
              var playlistReaderListener = Components.classes["@songbirdnest.com/Songbird/PlaylistReaderListener;1"]
                                   .createInstance(Components.interfaces.sbIPlaylistReaderListener);
        
              // if we can find it in the service pane already then we shouldn't add it again.
              var queryObj = new sbIDatabaseQuery();
              queryObj.setDatabaseGUID("songbird");
              var playlistManager = new sbIPlaylistManager();
              playlistManager.getAllPlaylistList( queryObj );
              var resultset = queryObj.getResultObject();
              for ( var index = 0; index < resultset.getRowCount(); index++ )
              {
                // if we match don't add it, just play it.
                if ( aURL == resultset.getRowCellByColumn( index, "description" ) )
                {
                  gPPS.playTable(resultset.getRowCellByColumn(index, "service_uuid"),
                                 resultset.getRowCellByColumn(index, "name"),
                                 0);
                  return true;
                }
              }
        
              // Create this closure here to prevent this object from getting garbage
              // collected too soon.  The playlist reader uses the nsIWebBrowserPersist
              // component that does _not_ addref this listener :(
              var playlist_observer = {
                observe: function ( aSubject, aTopic, aData ) {
                  if (aTopic.indexOf("error") != -1) {
                    var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
                                                  .getService(Components.interfaces.nsIPromptService);
                    promptService.alert(null,
                                        "Playlist Error",
                                        "Unable to read playlist file - please try again later.");
                  }
                  else {
                    SBScanServiceTreeNewEntryStart();
                  }
                }
              };
        
              SBScanServiceTreeNewEntryEditable();
        
              playlistReaderListener.playWhenLoaded = aShouldBeginPlayback;
              playlistReaderListener.observer = playlist_observer;
              playlistReaderListener.mediaMimetypesOnly = true;
              playlistReader.autoLoad( aURL,
                                       "songbird", 
                                       gPPS.convertURLToDisplayName( aURL ),
                                       "http",
                                       aURL,
                                       "", 
                                       playlistReaderListener );
              retval = true;
            }
            // Everything else gets played directly.
            else if ( gPPS.isMediaURL( aURL ) )
            {
              this.playExternalUrl(aURL, true);
              retval = true;
            }
          }
          catch ( err )
          {
            alert("sb-tabbrowser::handleMediaURL(" + aURL + "); " + err );
          }
          return retval;
        ]]></body>
      </method>
      
      
      <!-- context menu handler -->
      <method name="onHTMLContextMenu">
        <parameter name="target" />
        <body><![CDATA[
          if ( this.theHTMLContextURL ) {
            var v = target.getAttribute( "id" );
            switch ( v ) {
              case "html.context.open":
                // can be track or playlist
                // try dealing with media, might just be web content.
                if ( !this.handleMediaURL(this.theHTMLContextURL, true, false) )
                {
                  gServicePane.loadURL( this.theHTMLContextURL );
                }
              break;
              case "html.context.openexternal":
                  var externalLoader = (Components
                           .classes["@mozilla.org/uriloader/external-protocol-service;1"]
                          .getService(Components.interfaces.nsIExternalProtocolService));
                  var nsURI = (Components
                          .classes["@mozilla.org/network/io-service;1"]
                          .getService(Components.interfaces.nsIIOService)
                          .newURI(this.theHTMLContextURL, null, null));
                  externalLoader.loadURI(nsURI, null);
              break;
              case "html.context.play":
                // can be track or playlist
                this.handleMediaURL(this.theHTMLContextURL, true, false);
              break;
              case "html.context.add":
                gPPS.importURL(this.theHTMLContextURL);
              break;
              case "html.context.playlist":
                // Add playlists to the service pane (force it as a playlist)
                this.handleMediaURL(this.theHTMLContextURL, false, true);
              break;
              case "html.context.copytoclipboard":
                var clipboard = Components.classes["@mozilla.org/widget/clipboardhelper;1"].getService(Components.interfaces.nsIClipboardHelper);
                clipboard.copyString(this.theHTMLContextURL);
              break;
            }
            this.theHTMLContextURL = null; // clear it because now we're done.
          }
        ]]></body>
      </method>
      
      <!-- this method extracts the target url of click event targetted at html -->
      <method name="GetHREFFromEvent">
        <parameter name="evt" />
        <body><![CDATA[
          var the_href = "";
          try
          {
            var node = evt.target;
            while ( node ) // Walk up from the event target to find the A? 
            {
              if ( node.href )
              {
                the_href = node.href;
                break;
              }
              node = node.parentNode;
            }
          }
          catch ( err )
          {
            alert( err );
          }
          return the_href;
        ]]></body>
      </method>
      
      <field name="theHTMLContextURL">null</field>
      <!-- used in async_webplaylist.js -->
      <method name="onLinkOver">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a contextual on a media url and attempt to play it
          var the_url = this.GetHREFFromEvent( evt )
          theStatusText.stringValue = the_url;
          if ( gPPS.isMediaURL( the_url ) || gPPS.isPlaylistURL( the_url ) )
          {
            theStatusStyle.stringValue = "font-weight: bold;";
          }
          else
          {
            theStatusStyle.stringValue = "font-weight: normal;";
          }
        ]]></body>
      </method>
      <!-- used in async_webplaylist.js -->
      <method name="onLinkOut">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a contextual on a media url and attempt to play it
          theStatusText.stringValue = "";
        ]]></body>
      </method>
      <!-- used in async_webplaylist.js -->
      <method name="onLinkContext">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a contextual on a media url and attempt to play it
          try
          {
            var theHTMLPopup = document.getElementById( "html_context_menu" );
            this.theHTMLContextURL = this.GetHREFFromEvent( evt );
            
            // Disable "Add" if the url isn't media or is already there.
            var disabled = "true";
            if ( gPPS.isMediaURL( this.theHTMLContextURL ) && ! SBUrlExistsInDatabase( this.theHTMLContextURL ) )
            {
              disabled = "false"
            }
            document.getElementById( "html.context.add" ).setAttribute( "disabled", disabled );
            
            theHTMLPopup.showPopup(this, this.boxObject.screenX + evt.clientX + 5,
                                   this.boxObject.screenY + evt.clientY,
                                   "context", null, null );
          }
          catch ( err )
          {
            alert( err );
          }
        ]]></body>
      </method>
      <!-- used in async_webplaylist.js -->
      <method name="onMediaClick">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a click on a media url and attempt to play it
          this.handleMediaURL(this.GetHREFFromEvent(evt), true, false);
          evt.stopPropagation();
          evt.preventDefault();
        ]]></body>
      </method>
    </implementation>
    
    <handlers>
      <handler event="click" phase="capturing"><![CDATA[
        // Catches links with target=_blank and opens them with the default browser.
        if (event.target && event.button == 0 && event.target.tagName == "A") {
              
          var is_media = gPPS.isMediaURL( event.target.href );
          var is_playlist = gPPS.isPlaylistURL( event.target.href );
          if (!is_media && !is_playlist && (event.target.target == "_blank" || event.target.target == "_new")) {
            var externalLoader = (Components
                  .classes["@mozilla.org/uriloader/external-protocol-service;1"]
                  .getService(Components.interfaces.nsIExternalProtocolService));
            var nsURI = (Components
                  .classes["@mozilla.org/network/io-service;1"]
                  .getService(Components.interfaces.nsIIOService)
                  .newURI(event.target.href, null, null));
            externalLoader.loadURI(nsURI, null);
      
            // Kill the event since we've handled it
            event.preventDefault();
          }
        }
      ]]></handler>
    </handlers>
  </binding>


</bindings>
