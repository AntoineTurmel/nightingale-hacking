<?xml version="1.0"?>
<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl"
[
<!ENTITY % songbirdDTD SYSTEM "chrome://songbird/locale/songbird.dtd">
%songbirdDTD;
]
>
<!--
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
-->

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="sb-tabbrowser" extends="chrome://songbird/content/bindings/tabbrowser.xml#tabbrowser">
    <implementation implements="nsIWebProgressListener">
      <constructor><![CDATA[
        this.addProgressListener(this,
            Components.interfaces.nsIWebProgress.NOTIFY_LOCATION |
            Components.interfaces.nsIWebProgress.NOTIFY_STATE_ALL);
        /* FIXME: how should this work?
        this._progressFilter.addProgressListener(this,
            Components.interfaces.nsIProgressListener.NOTIFY_ALL);
        this.addProgressListener(this._progressFilter);
        */
        this.loading = false;
        
        /* we need to track when events change */
        this.tabChangeEventListener = {
          tabbrowser: this,
          timer_period: 200, // fire after 1/5th of a second
          timer: null,
          handleEvent: function(event) {
            if (event.attrName == 'selectedIndex' &&
                event.prevValue != event.newValue &&
                !this.timer) {
              this.timer = Components.classes['@mozilla.org/timer;1']
                  .createInstance(Components.interfaces.nsITimer);
              this.timer.initWithCallback(this, this.timer_period,
                  Components.interfaces.nsITimer.TYPE_ONE_SHOT);
              
            }
          },
          notify: function(timer) {
            this.tabbrowser._loaded();
            this.timer = null;
          },
        };
        this.mTabBox.addEventListener("DOMAttrModified",
            this.tabChangeEventListener, false);
        
        this.webNavigation.sessionHistory =
            Components.classes["@mozilla.org/browser/shistory;1"]
            .createInstance(Components.interfaces.nsISHistory);
        this.browsers[0].removeAttribute("disablehistory");
        
      ]]></constructor>
      <destructor><![CDATA[
        this.closeBalloonTip();
        this.removeProgressListener(this);
        if (this.tabChangeEventListener) {
          if (this.tabChangeEventListener.timer) {
            this.tabChangeEventListener.timer.cancel();
          }
          this.mTabBox.removeEventListener("DOMAttrModified",
              this.tabChangeEventListener, false);
        }
      ]]></destructor>
      

      <!-- the public interface for loading URLs.
           this overrides the implementation in tabbrowser.xml#tabbrowser
           it takes the existing aURI, aReferrerURI and aCharset arguments
           and optionally an aEvent handler
           -->
      <method name="loadURI">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aEvent"/>
        <parameter name="aDefaultLocation"/>
        <body>
          <![CDATA[
            var where = aDefaultLocation?aDefaultLocation:'current';
            if (aEvent) {
              // if an event as supplied infer where we want to load this URI
              //
              var isMac = window.navigator.platform.match(/^Mac/) == 'Mac';
              var middleButton = aEvent?(aEvent.button == 1):false;
              var modifierKey = aEvent?(isMac?aEvent.metaKey:aEvent.ctrlKey):false;
              
              if (middleButton || modifierKey) {
                where = "tab";
              }
            }
            
            // make sure the referrer is an nsIURI
            if (aReferrerURI == '') {
              aReferrerURI = null;
            } else {
              if (typeof(aReferrerURI) == 'string') {
                aReferrerURI = (Components
                    .classes["@mozilla.org/network/io-service;1"]
                    .getService(Components.interfaces.nsIIOService)
                    .newURI(aReferrerURI, aCharset, null));
              }
            }
            
            
            // Policy goes here
            
            // check to see if tabs are allowed
            if (where == 'tab' &&
                !this._prefsService.getBoolPref('browser.tabs.enabled')) {
              where = 'current';
            }
            
            // Now, actually open the URI
            if (where == "tab") {
              this.loadOneTab(aURI, aReferrerURI, aCharset, null, null, null);
            } else if (where == "external") {
              var externalLoader = (Components
                    .classes["@mozilla.org/uriloader/external-protocol-service;1"]
                    .getService(Components.interfaces.nsIExternalProtocolService));
              var nsURI = (Components
                    .classes["@mozilla.org/network/io-service;1"]
                    .getService(Components.interfaces.nsIIOService)
                    .newURI(aURI, aCharset, null));
              externalLoader.loadURI(nsURI, null);
            } else if (where == "current") {
              this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
            } else {
              // eek! unknown target
            }
          ]]>
        </body>
      </method>
      
      
      <field name="_progressFilter">
        Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
            .createInstance(Components.interfaces.nsIWebProgress)
      </field>
      
      <field name="_prefsService">
        Components.classes["@mozilla.org/preferences-service;1"].
                getService(Components.interfaces.nsIPrefBranch);
      </field>

      <field name="_servicepane">null</field>
      <property name="servicepane">
        <getter><![CDATA[
          if (!this._servicepane) {
            this._servicepane =
                document.getElementById(this.getAttribute('servicepane'));
          }
          return this._servicepane;
        ]]></getter>
      </property>
      
      
      <field name="_playlist">null</field>
      <property name="playlist">
        <getter><![CDATA[
          if (!this._playlist) {
            this._playlist =
                document.getElementById(this.getAttribute('playlist'));
          }
          return this._playlist;
        ]]></getter>
      </property>


      <!-- Get the playlist element from within the document in the current tab.
           Returns null if no playlist element is available 
        -->
      <property name="currentBrowserPlaylist" readonly="true">
        <getter><![CDATA[

          // Get the document from the current browser tab
          var playlistDocument = this.mCurrentBrowser.contentDocument;
          if (playlistDocument == null) {
            return null;
          }
          
          // Get the playlist element from within the current tab      
          // TODO change this
          var playlist = playlistDocument.getElementById("playlist_test");
          if (playlist == null) {
            return null;
          }
          
          // Remove security wrappers
          if (playlist.wrappedJSObject) {
            playlist = playlist.wrappedJSObject;
          }
              
          return playlist;
        ]]></getter>
      </property>


      <field name="_loading">SB_NewDataRemote("faceplate.loading", null)</field>
      <property name="loading"
                onget="return this._loading.boolValue"
                onset="this._loading.boolValue = val;" />
      
      <field name="mainpane_listener_set">false</field>
      
      <property name="showWebPlaylist">
        <getter><![CDATA[
          // the value is stored in a data remote
          return SBDataGetBoolValue('browser.playlist.show');
        ]]></getter>
        <setter><![CDATA[
          // boolify the value that's passed in
          var value = (val)?true:false;
          // set the value in the data remote
          SBDataSetBoolValue('browser.playlist.show', value);
          
          if (!value) {
            // if the balloontip for the webplaylist is shown, close it
            this.closeBalloonTip();
            // if we're hiding the web playlist then unhook it from the UI
            if (this.playlist) {
              this.playlist.datasources = "";
              this.playlist.ref = "";
            }
          } else {
            // open the balloontip if needed
            this.openBalloonTip();
          }
        ]]></setter>
      </property>
      
      <!-- replacing thePlaylistTree with gBrowser.playlistTree -->
      <field name="playlistTree">null</field>
      
      <!-- These should match the values in sbLibraryManager.h -->
      <field name="PREF_WEB_LIBRARY">"songbird.library.web"</field>
      <field name="PREF_DOWNLOAD_LIBRARY">"songbird.library.download"</field>
      
      <field name="_downloadLibrary">null</field>
      <property name="downloadLibrary">
        <getter><![CDATA[
          if (this._downloadLibrary) {
            return this._downloadLibrary;
          }
          
          var guid = this._getUnicodeStringPref(this.PREF_DOWNLOAD_LIBRARY);
          
          var libraryManager =
            Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                      .getService(Components.interfaces.sbILibraryManager);

          return this._downloadLibrary = libraryManager.getLibrary(guid);
        ]]></getter>
      </property>
      
      <field name="_webLibrary">null</field>
      <property name="webLibrary">
        <getter><![CDATA[
          if (this._webLibrary) {
            return this._webLibrary;
          }
          
          var guid = this._getUnicodeStringPref(this.PREF_WEB_LIBRARY);
          
          var libraryManager =
            Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                      .getService(Components.interfaces.sbILibraryManager);

          return this._webLibrary = libraryManager.getLibrary(guid);
        ]]></getter>
      </property>

      <method name="_loaded">
        <body><![CDATA[
        dump('running _loaded\n');
          try {
            if (!this.mainpane_listener_set)
            {

              //
              //
              // HORRIBLE SECURITY HACK TO GET THE PLAYLIST TREE AND INJECT FUN EVENT HANDLERS 
              //
              //
              var installed_listener = false;
              var playlist = this.contentDocument?this.contentDocument.getElementById( "playlist_test" ):null;
              if (playlist) {
                // Crack the security if necessary
                if ( playlist.wrappedJSObject )
                  playlist = playlist.wrappedJSObject;
        
                // Wait until after the bind call?
                if ( playlist.ref == "" )
                {
                  // Try again in 250 ms?
                  //setTimeout(this._loaded, 250);
                  return;
                }
        
                // hack, to let play buttons find the visible playlist if needed
                document.__CURRENTPLAYLIST__ = playlist;
        
                // Drag and Drop tracker object
                playlist.setDnDSourceTracker(sbDnDSourceTracker);
        
                // Events on the playlist object itself.
                playlist.addEventListener("playlist-editor", onPlaylistEditor, true);
                playlist.addEventListener("playlist-play", onPlaylistPlay, true);
                playlist.addEventListener("playlist-burntocd", onPlaylistBurnToCD, true);
                playlist.addEventListener("playlist-noplaylist", onPlaylistNoPlaylist, true);
                playlist.addEventListener("playlist-filterchange", onPlaylistFilterChange, true);
        
                // TODO: Do we not want to remove these listeners at some point?
        
                // Remember some values
                theLibraryPlaylist = playlist;
                this.playlistTree = playlist = playlist.tree;
                SBDataSetStringValue('playlist.ref', playlist.getAttribute( "ref" )); // is this set yet?
        
                // Set the current selection
                theLibraryPlaylist.syncPlaylistIndex(false);
        
                // And remember that we did this
                installed_listener = true;
        
                this.mainpane_listener_set = true;
                
                if (document.__JUMPTO__) {
                  document.__JUMPTO__.syncJumpTo();
                }
              }
              else {
                this.playlistTree = null;
                theLibraryPlaylist = null;
                // hack, to let play buttons find the visible playlist if needed
                document.__CURRENTPLAYLIST__ = null;
              }
        
              // Should the webplaylist scan and listener binding be performed?
              var enableWebPlaylist = SBDataGetBoolValue("webplaylist.enabled");
              
              // If we have not installed a playlist listener, and the web playlist
              // is enabled, install the link url listener.
              if ( !installed_listener && enableWebPlaylist) {
                // wait until the document exists to see if there are any A tags
                if (!this.contentDocument) {
                  //setTimeout(this._loaded, 2500);
                  return;
                } else if (this.contentDocument.getElementsByTagName('A').length != 0 ) {

                  // Set the filter to the current URI.
                  var propArray =
                    Components.classes["@songbirdnest.com/Songbird/Properties/PropertyArray;1"]
                              .createInstance(Components.interfaces.sbIPropertyArray);
                  propArray.appendProperty("http://songbirdnest.com/data/1.0#originUrl",
                                           this.currentURI.spec);
                                             
                  // Create the view.
                  var view = this.webLibrary.createView();
                  view.setFilters(propArray);

                  // Bind the Web Playlist UI element to the subscribed playlist.
                  SBWebPlaylistCommands.m_Playlist = theWebPlaylist;
                  theWebPlaylist.bind(view, SBWebPlaylistCommands,
                                      SBDataGetIntValue("browser.playlist.height"),
                                      SBDataGetBoolValue("browser.playlist.collapsed"));

                  // scrape the document.
                  AsyncWebDocument(this.contentDocument, view);
                } 
        
        
                // XXXlone - we need this to happen so that the playlist gets initialized if it wasn't ready yet but is coming up soon 
                // unfortunately, if the page is not going to be a playlist, but is a document with no A element, we'll keep hitting this code
                // and rerun this function every 2.5s, forever. We need to detect that a page is a not a playlist in the process of being loaded 
                // so that we can avoid issuing a setTimeout(onMainPaneLoad, 2500) in this case, but ONLY in this case.
                else {
                  var tb = this;
                  //setTimeout(function(){tb._loaded()}, 2500 );
                  return;
                }
                // XXXlone - end case where page is going to be a playlist but contentDocument does not yet contains a playlist
        
                this.mainpane_listener_set = true;
              }
            }
          } catch( err ) {
            dump(err.toSource()+'\n');
            alert( 'sb-tabbrowser::_loaded: '+err );
          }
        ]]></body>
      </method>
      
      <!-- implementation of nsIWebProgressListener -->
      <method name="onLocationChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aLocation" />
        <body><![CDATA[
          try {
            // for some reason we need to do this dance to get scrollbars to
            // show up
            var nsIScrollable = Components.interfaces.nsIScrollable;
            var scrollable = this.webNavigation.QueryInterface(nsIScrollable);        
            scrollable.setDefaultScrollbarPreferences(nsIScrollable.ScrollOrientation_Y,
                                                      nsIScrollable.Scrollbar_Auto);
            scrollable.setDefaultScrollbarPreferences(nsIScrollable.ScrollOrientation_X,
                                                      nsIScrollable.Scrollbar_Auto);
          
            if (this.webNavigation.sessionHistory) {
              SBDataSetBoolValue('browser.cangoback', this.webNavigation.canGoBack);
              SBDataSetBoolValue('browser.cangofwd', this.webNavigation.canGoForward);
            }
            
            // Clear the playlist tree variable so we are not confused.
            this.playlistTree = null;
            theLibraryPlaylist = null;
            // hack, to let play buttons find the visible playlist if needed
            document.__CURRENTPLAYLIST__ = null;
            
            // Clear the tracking variable
            this.mainpane_listener_set = false;
            
            // Disable the "add to playlist" button until we see that there is anything to add.
            SBDataSetBoolValue('browser.canplaylist', false);
            this.showWebPlaylist = false;
      
            // Clear the playlist tree variable so we are not confused.
            this.playlistTree = null;
            theLibraryPlaylist = null;
            // hack, to let play buttons find the visible playlist if needed
            document.__CURRENTPLAYLIST__ = null;
            
            // Nothing in the status text
            theStatusText.stringValue = "";
            
            // set the context-menu based on the chromeyness of the location
            if (aLocation.scheme == 'chrome') {
              this.mCurrentBrowser.contextMenu = null;
            } else {
              this.mCurrentBrowser.contextMenu = this.getAttribute('contentcontextmenu');
            }
          }
          catch ( err )
          {
            alert( "sb-tabbrowser::onLocationChange\n\n" + err );
          }
        ]]></body>
      </method>
      
      <method name="onProgressChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aCurSelfProgress" />
        <parameter name="aMaxSelfProgress" />
        <parameter name="aCurTotalProgress" />
        <parameter name="aMaxTotalProgress" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>
      
      <method name="onSecurityChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>

      <method name="onStateChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aStatus" />
        <body><![CDATA[
          const nsIWebProgressListener =
            Components.interfaces.nsIWebProgressListener;
      
          if (aState & nsIWebProgressListener.STATE_START) {
            // Start the spinner if necessary
            this.loading = true;
            
            // cancel the previous page scan
            CancelAsyncWebDocument();

          }
          else if (aState & nsIWebProgressListener.STATE_STOP) {
            // Stop the spinner if necessary
            this.loading = false;
      
            // Notfiy that the page is done loading
            this._loaded();
          }
        ]]></body>
      </method>

      <method name="onStatusChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aState" />
        <parameter name="aMessage" />
        <body><![CDATA[
        /* NOTE: This is not called change the constructor above if you want this event */
        ]]></body>
      </method>
      
      
      <!-- a bunch of methods from browser_xbl_temp.js / songbird_hack.js.
           I'm not convinced they belong here, but till we refactor a couple
           more things there's nowhere better for them to go. -->
      <method name="playExternalUrl">
        <parameter name="the_url" />
        <parameter name="tryweb" />
        <body><![CDATA[
          //SB_LOG("songbird_hack.js", "playExternalUrl: " + the_url);
          var PPS = Components.classes["@songbirdnest.com/Songbird/PlaylistPlayback;1"].getService(Components.interfaces.sbIPlaylistPlayback);
          // figure out if the url is in the webplaylist
          if (tryweb && theWebPlaylist && !theWebPlaylist.hidden) 
          {
            var row = theWebPlaylist.findRowIdByUrl(the_url);
            if (row != -1) 
            {
              // if so, play the ref, from that entry's index
              PPS.playRef("NC:webplaylist_webplaylist", row);
            }
          } else {
            // otherwise, play the url as external (added to the db, plays the library from that point on)
            PPS.playAndImportURL(the_url); // if the url is already in the lib, it is not added twice
          }
        ]]></body>
      </method>
      
      <method name="handleMediaURL">
        <parameter name="aURL" />
        <parameter name="aShouldBeginPlayback" />
        <parameter name="forcePlaylist" />
        <body><![CDATA[
          var retval = false;
          try
          {
            // Stick playlists in the service pane (for now).
            if ( forcePlaylist || gPPS.isPlaylistURL( aURL ) )
            {
              var playlistReader = Components.classes["@songbirdnest.com/Songbird/PlaylistReaderManager;1"]
                                   .createInstance(Components.interfaces.sbIPlaylistReaderManager);
              var playlistReaderListener = Components.classes["@songbirdnest.com/Songbird/PlaylistReaderListener;1"]
                                   .createInstance(Components.interfaces.sbIPlaylistReaderListener);
        
              // if we can find it in the service pane already then we shouldn't add it again.
              var queryObj = new sbIDatabaseQuery();
              queryObj.setDatabaseGUID("songbird");
              var playlistManager = new sbIPlaylistManager();
              playlistManager.getAllPlaylistList( queryObj );
              var resultset = queryObj.getResultObject();
              for ( var index = 0; index < resultset.getRowCount(); index++ )
              {
                // if we match don't add it, just play it.
                if ( aURL == resultset.getRowCellByColumn( index, "description" ) )
                {
                  gPPS.playTable(resultset.getRowCellByColumn(index, "service_uuid"),
                                 resultset.getRowCellByColumn(index, "name"),
                                 0);
                  return true;
                }
              }
        
              // Create this closure here to prevent this object from getting garbage
              // collected too soon.  The playlist reader uses the nsIWebBrowserPersist
              // component that does _not_ addref this listener :(
              var playlist_observer = {
                observe: function ( aSubject, aTopic, aData ) {
                  if (aTopic.indexOf("error") != -1) {
                    var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
                                                  .getService(Components.interfaces.nsIPromptService);
                    promptService.alert(null,
                                        "Playlist Error",
                                        "Unable to read playlist file - please try again later.");
                  }
                  else {
                    SBScanServiceTreeNewEntryStart();
                  }
                }
              };
        
              SBScanServiceTreeNewEntryEditable();
        
              playlistReaderListener.playWhenLoaded = aShouldBeginPlayback;
              playlistReaderListener.observer = playlist_observer;
              playlistReaderListener.mediaMimetypesOnly = true;
              playlistReader.autoLoad( aURL,
                                       "songbird", 
                                       gPPS.convertURLToDisplayName( aURL ),
                                       "http",
                                       aURL,
                                       "", 
                                       playlistReaderListener );
              retval = true;
            }
            // Everything else gets played directly.
            else if ( gPPS.isMediaURL( aURL ) )
            {
              this.playExternalUrl(aURL, true);
              retval = true;
            }
          }
          catch ( err )
          {
            alert("sb-tabbrowser::handleMediaURL(" + aURL + "); " + err );
          }
          return retval;
        ]]></body>
      </method>
      
      
      <!-- context menu handler -->
      <method name="onHTMLContextMenu">
        <parameter name="target" />
        <body><![CDATA[
          if ( this.theHTMLContextURL ) {
            var v = target.getAttribute( "id" );
            switch ( v ) {
              case "html.context.open":
                // can be track or playlist
                // try dealing with media, might just be web content.
                if ( !this.handleMediaURL(this.theHTMLContextURL, true, false) )
                {
                  // should we add the referrer?
                  this.loadURI(this.theHTMLContextURL, null, null);
                }
              break;
              case "html.context.opentab":
                // can be track or playlist
                // try dealing with media, might just be web content.
                if ( !this.handleMediaURL(this.theHTMLContextURL, true, false) )
                {
                  // should we add the referrer?
                  this.loadOneTab(this.theHTMLContextURL, null, null, null, null, null);
                }
                break;
              case "html.context.openexternal":
                  var externalLoader = (Components
                           .classes["@mozilla.org/uriloader/external-protocol-service;1"]
                          .getService(Components.interfaces.nsIExternalProtocolService));
                  var nsURI = (Components
                          .classes["@mozilla.org/network/io-service;1"]
                          .getService(Components.interfaces.nsIIOService)
                          .newURI(this.theHTMLContextURL, null, null));
                  externalLoader.loadURI(nsURI, null);
              break;
              case "html.context.play":
                // can be track or playlist
                this.handleMediaURL(this.theHTMLContextURL, true, false);
              break;
              case "html.context.add":
                gPPS.importURL(this.theHTMLContextURL);
              break;
              case "html.context.playlist":
                // Add playlists to the service pane (force it as a playlist)
                this.handleMediaURL(this.theHTMLContextURL, false, true);
              break;
              case "html.context.copytoclipboard":
                var clipboard = Components.classes["@mozilla.org/widget/clipboardhelper;1"].getService(Components.interfaces.nsIClipboardHelper);
                clipboard.copyString(this.theHTMLContextURL);
              break;
            }
            this.theHTMLContextURL = null; // clear it because now we're done.
          }
        ]]></body>
      </method>
      
      <!-- this method extracts the target url of click event targetted at html -->
      <method name="GetHREFFromEvent">
        <parameter name="evt" />
        <body><![CDATA[
          var the_href = "";
          try
          {
            var node = evt.target;
            while ( node ) // Walk up from the event target to find the A? 
            {
              if ( node.href )
              {
                the_href = node.href;
                break;
              }
              node = node.parentNode;
            }
          }
          catch ( err )
          {
            alert( err );
          }
          return the_href;
        ]]></body>
      </method>
      
      <field name="theHTMLContextURL">null</field>
      <!-- used in async_webplaylist.js -->
      <method name="onLinkOver">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a contextual on a media url and attempt to play it
          var the_url = this.GetHREFFromEvent( evt )
          theStatusText.stringValue = the_url;
          if ( gPPS.isMediaURL( the_url ) || gPPS.isPlaylistURL( the_url ) )
          {
            theStatusStyle.stringValue = "font-weight: bold;";
          }
          else
          {
            theStatusStyle.stringValue = "font-weight: normal;";
          }
        ]]></body>
      </method>
      <!-- used in async_webplaylist.js -->
      <method name="onLinkOut">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a contextual on a media url and attempt to play it
          theStatusText.stringValue = "";
        ]]></body>
      </method>
      <!-- used in async_webplaylist.js -->
      <method name="onLinkContext">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a contextual on a media url and attempt to play it
          try
          {
            var theHTMLPopup = document.getElementById( "html_context_menu" );
            this.theHTMLContextURL = this.GetHREFFromEvent( evt );
            
            // Disable "Add" if the url isn't media or is already there.
            var disabled = "true";
            if ( gPPS.isMediaURL( this.theHTMLContextURL ) && ! SBUrlExistsInDatabase( this.theHTMLContextURL ) )
            {
              disabled = "false"
            }
            document.getElementById( "html.context.add" ).setAttribute( "disabled", disabled );
            
            theHTMLPopup.showPopup(this, this.boxObject.screenX + evt.clientX + 5,
                                   this.boxObject.screenY + evt.clientY,
                                   "context", null, null );
          }
          catch ( err )
          {
            alert( err );
          }
        ]]></body>
      </method>
      <!-- used in async_webplaylist.js -->
      <method name="onMediaClick">
        <parameter name="evt" />
        <body><![CDATA[
          // Catch a click on a media url and attempt to play it
          this.handleMediaURL(this.GetHREFFromEvent(evt), true, false);
          evt.stopPropagation();
          evt.preventDefault();
        ]]></body>
      </method>
      
      
      <!-- override navigation methods from tabbrowser for fun and profit -->
      <!-- I'm not convinced these are actually required -->
      <method name="goBack">
        <body><![CDATA[
          // Disable the "add to playlist" button until we see that there is anything to add.
          SBDataSetBoolValue("browser.canplaylist", false);
          this.showWebPlaylist = false;
          this.mainpane_listener_set = false;
          return this.mCurrentBrowser.goBack();
        ]]></body>
      </method>
      <method name="goForward">
        <body><![CDATA[
          // Disable the "add to playlist" button until we see that there is anything to add.
          SBDataSetBoolValue("browser.canplaylist", false);
          this.showWebPlaylist = false;
          this.mainpane_listener_set = false;
          return this.mCurrentBrowser.goForward();
        ]]></body>
      </method>
      <method name="reload">
        <body><![CDATA[
          this.mainpane_listener_set = false;
          return this.mCurrentBrowser.reload();
        ]]></body>
      </method>
      <method name="stop">
        <body><![CDATA[
          return this.mCurrentBrowser.stop();
          this.mainpane_listener_set = false;
        ]]></body>
      </method>
      <property name="homePage">
        <getter><![CDATA[
          var homepage = null;
          var defaultHomepage = "http://www.songbirdnest.com/birdhouse/";
          
          try {
            if (this._prefsService.getPrefType("browser.startup.homepage") == prefs.PREF_STRING) {
              homepage = this._prefsService.getCharPref("browser.startup.homepage");
            }
          } catch (e) { }
          
          if (homepage == null || homepage == '') {
            homepage = "http://www.songbirdnest.com/birdhouse/";
          }
          
          return homepage
        ]]></getter>
        <setter><![CDATA[
          this._prefsService.setCharPref("browser.startup.homepage", val);
        ]]></setter>
      </property>
      <method name="goHome">
        <body><![CDATA[
          this.loadURI(this.homePage, null, null);
        ]]></body>
      </method>

      <method name="onBrowserPlaylist">
        <body><![CDATA[
          metrics_inc("player", "urlslurp", null);

          var webLibrary = this.webLibrary;
          if (this.playlistTree) {
            this.loadURI("chrome://songbird/content/xul/playlist_test2.xul?" +
                         "library," + webLibrary.guid, null, null);
            return;
          }

          var view;
          if (!theWebPlaylist.library.equals(webLibrary)) {
            view = webLibrary.createView();
            
            SBWebPlaylistCommands.m_Playlist = theWebPlaylist;
            theWebPlaylist.bind(view, SBWebPlaylistCommands,
                                SBDataGetIntValue("browser.playlist.height"),
                                SBDataGetBoolValue("browser.playlist.collapsed"));
          }
          else {
            view = theWebPlaylist.mediaListView;
          }
          
          // Set the filter to the current URL.
          var propArray =
            Components.classes["@songbirdnest.com/Songbird/Properties/PropertyArray;1"]
                      .createInstance(Components.interfaces.sbIPropertyArray);
          propArray.appendProperty("http://songbirdnest.com/data/1.0#originUrl",
                                   window.location.href);
                                     
          view.setFilters(propArray);

          this.showWebPlaylist = true;
        ]]></body>
      </method>

      <method name="onBrowserDownload">
        <body><![CDATA[
          metrics_inc("player", "downloads", null);
          
          var downloadLibrary = this.downloadLibrary;
          if (this.playlistTree) {
            var downloadLibraryGUID = downloadLibrary.guid;
            this.loadURI("chrome://songbird/content/xul/playlist_test2.xul?" +
                         "library," + downloadLibraryGUID, null, null);
            return;
          }

          // Make sure the download device has been added to the commands object.
          if (!SBDownloadCommands.m_Device) {
            var deviceManager =
              Components.classes["@songbirdnest.com/Songbird/DeviceManager;1"]
                        .getService(Components.interfaces.sbIDeviceManager);
            
            downloadDevice =
              deviceManager.getDeviceByCategory("Songbird Download Device");
            SBDownloadCommands.m_Device = downloadDevice;
          }

          if (!theWebPlaylist.library.equals(downloadLibrary)) {
            var view = downloadLibrary.createView();

            theWebPlaylist.bind(view, SBDownloadCommands,
                                SBDataGetIntValue("browser.playlist.height"),
                                SBDataGetBoolValue("browser.playlist.collapsed"));
          }

          this.showWebPlaylist = true;

        ]]></body>
        </method>

      <method name="openBalloonTip">
        <body><![CDATA[
          if (!SBDataGetBoolValue("balloontip.firstwebplaylist.shown")) {
            this.balloontip = new BalloonTip;
            var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"].getService(Components.interfaces.nsIStringBundleService);
            var songbirdStrings = sbs.createBundle("chrome://songbird/locale/songbird.properties");
            var title = "Found media."
            var text = "Songbird has found the following playable tracks."
            try {
              title = songbirdStrings.GetStringFromName("balloontip.firstwebplaylist.title");
              text = songbirdStrings.GetStringFromName("balloontip.firstwebplaylist.text");
            } catch (e) { }
            this.balloontip.showText(text, this.playlist, title, 'balloon-icon-songbird', null, -1);
            SBDataSetBoolValue("balloontip.firstwebplaylist.shown", true);
          }
        ]]></body>
      </method>
      
      <method name="closeBalloonTip">
        <body><![CDATA[
          if (this.balloontip) {
            this.balloontip.closeTip();
            this.balloontip = null;
          }
        ]]></body>
      </method>
      
      <method name="_getUnicodeStringPref">
        <parameter name="prefKey"/>
        <body><![CDATA[
          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefBranch2);
          return prefs.getComplexValue(prefKey, Components.interfaces.nsISupportsString);
        ]]></body>
      </method>

    </implementation>
    
    <handlers>
      <handler event="click"><![CDATA[
        // inspired by contentAreaClick in ffox browser.js
        if (!event.isTrusted || event.getPreventDefault()) {
          return true;
        }
        
        var target = event.target;
        var linkNode = null;
        
        if (target instanceof HTMLAnchorElement ||
            target instanceof HTMLAreaElement ||
            target instanceof HTMLLinkElement) {
          if (target.hasAttribute("href")) {
            linkNode = target;
          }
     
          // backwards compat - use the outermost link node
          var parent = target.parentNode;
          while (parent) {
            if (parent instanceof HTMLAnchorElement ||
                parent instanceof HTMLAreaElement ||
                parent instanceof HTMLLinkElement) {
                if (parent.hasAttribute("href")) {
                  linkNode = parent;
                }
            }
            parent = parent.parentNode;
          }
        } else {
          linkNode = event.originalTarget;
          while (linkNode && !(linkNode instanceof HTMLAnchorElement)) {
            linkNode = linkNode.parentNode;
          }
          // <a> cannot be nested.  So if we find an anchor without an
          // href, there is no useful <a> around the target
          if (linkNode && !linkNode.hasAttribute("href")) {
            linkNode = null;
          }
        }
        
        
        var wrapper = null;
        var href = null;
        var target = null;
        if (linkNode) {
          href = linkNode.href;
          if (linkNode.hasAttribute('target')) {
            target = linkNode.getAttribute('target');
          }
        } else {
          // Try simple XLink
          var realHref, baseURI;
          linkNode = target;
          while (linkNode) {
            if (linkNode.nodeType == Node.ELEMENT_NODE) {
              wrapper = linkNode;
     
              realHref = wrapper.getAttributeNS("http://www.w3.org/1999/xlink", "href");
              if (realHref) {
                href = realHref;
                baseURI = wrapper.baseURI
              }
            }
            linkNode = linkNode.parentNode;
          }
          if (href) {
            var ioService = Components.classes["@mozilla.org/network/io-service;1"]
                .getService(Components.interfaces.nsIIOService);
            var base = ioService.newURI(baseURI, null, null);
            href = ioService.newURI(base.resolve(href), null, null).spec;
          }
        }
        
        if (href) {
          // get the document that this event originated in
          var doc = event.target.ownerDocument;
          
          var secMan = Components.classes["@mozilla.org/scriptsecuritymanager;1"]
              .getService(Components.interfaces.nsIScriptSecurityManager);
          secMan.checkLoadURIStrWithPrincipal(doc.nodePrincipal, href,
              Components.interfaces.nsIScriptSecurityManager.STANDARD);
          
          // get the referrer if we can
          var referrer = doc ? doc.documentURIObject : null;
          
          var where = 'current';
          if (target == '_blank' || target == '_new') {
            where = 'tab';
          }
          
          this.loadURI(href, referrer, null, event, where);
          event.stopPropagation();
        }
        return true;
      ]]></handler>
    </handlers>
  </binding>


  <!-- these are from globalBindings.xml -->
  <binding id="tabbrowser-tab" extends="chrome://songbird/content/bindings/tabbrowser.xml#tabbrowser-tab">
    <content closetabtext="&tabs.closeTab;">
      <xul:hbox class="tab-image-left" xbl:inherits="selected"/>
      <xul:hbox flex="1" class="tab-image-middle" align="center" xbl:inherits="selected">
        <xul:stack class="tab-icon">
          <xul:image xbl:inherits="validate,src=image" class="tab-icon-image"/>
          <xul:image class="tab-extra-status"/>
        </xul:stack>
        <xul:label flex="1" xbl:inherits="value=label,crop,accesskey" crop="right" class="tab-text"/>
      </xul:hbox>
      <xul:toolbarbutton anonid="close-button" class="tab-close-button" tabindex="-1"/>
      <xul:hbox class="tab-image-right" xbl:inherits="selected"/>
    </content>
  </binding>
  
   <binding id="tabbrowser-tabs"  
            extends="chrome://songbird/content/bindings/tabbrowser.xml#tabbrowser-tabs">
    <content>
      <xul:stack flex="1" class="tabs-stack">
        <xul:vbox>
          <xul:spacer flex="1"/>
          <xul:hbox class="tabs-bottom" align="center"/>
        </xul:vbox>
        <xul:vbox>
          <xul:hbox>
            <xul:stack>
              <xul:spacer class="tabs-left"/>
            </xul:stack>
            <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1" style="min-width: 1px;" class="tabbrowser-arrowscrollbox">
              <children/>
            </xul:arrowscrollbox>
            <xul:stack align="center" pack="end">
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035 
              -->
              <xul:hbox style="position: relative;">
                <xul:hbox flex="1" class="tabs-alltabs-box" 
                          anonid="alltabs-box"/>
              </xul:hbox>
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035 
              -->
              <xul:hbox style="position: relative;">
                <xul:hbox flex="1" class="tabs-alltabs-box-animate" 
                          anonid="alltabs-box-animate"/>
              </xul:hbox>
              <!-- XXXsspitzer hack
                   this extra hbox with position: relative
                   is needed to work around two bugs.
                   see bugs #346307 and #346035 
              -->
              <xul:hbox style="position: relative;">
                <xul:toolbarbutton class="tabs-alltabs-button"
                                   type="menu"
                                   anonid="alltabs-button"
                                   tooltipstring="&tabs.listAllTabs;">
                  <xul:menupopup class="tabs-alltabs-popup"
                                 anonid="alltabs-popup" position="after_end"/>
                </xul:toolbarbutton>
              </xul:hbox>
            </xul:stack>
            <xul:hbox class="tabs-closebutton-box" align="center" pack="end" anonid="tabstrip-closebutton">
              <xul:toolbarbutton class="close-button tabs-closebutton"/>
            </xul:hbox>
          </xul:hbox>
          <xul:spacer class="tabs-bottom-spacer"/>
        </xul:vbox>
      </xul:stack>
    </content>
  </binding>

</bindings>
