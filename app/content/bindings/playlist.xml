<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
//
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
//
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
//
// Software distributed under the License is distributed
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either
// express or implied. See the GPL for the specific language
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
//
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE window SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="playlist">
    <content mousethrough="never">
      <stack flex="1" xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
        <vbox sbid="loading_box" pack="end" align="right" flex="1" >
          <vbox id="loading_box"  flex="1">
            <label id="loading_text" flex="1" value=""/>
          </vbox>
        </vbox>
        <vbox id="sb-playlist" flex="1"  style="margin: 0px;padding: 0px;">
          <!-- Playlist Filters -->
          <hbox 
            id="sb-playlist-filters" 
            sbid="filter_parent" 
            class="sb-playlist-filters" 
            style="min-height: 60px;" 
            flex="1" 
            hidden="false">
          </hbox>

          <sb-smart-splitter
            id="sb-playlist-splitter"
            sbid="filter_splitter"
            class="playlist-splitter"
            state="open"
            orient="vertical"
            collapse="before"
            resizebefore="closest"
            resizeafter="closest"
            hidden="true"
            metricscategory="app"
            metricsid="collapse.library"
            applydefault="true"
          >
            <grippy/>
          </sb-smart-splitter>

          <!--
            onscroll="onPlaylistScroll( event );"
            -->
          <!-- Playlist Tree -->
          <tree
            xbl:inherits="enableColumnDrag=enableColumnDrag,hidecolumnpicker=hidecolumnpicker"
            id="sb-playlist-tree"
            sbid="sb-playlist-tree"
            class="sb-playlist-tree"
            flex="3"
            onselect="_onPlaylistSelectClick(event);"
            onclick="_onPlaylistClick(event);"
            oncontextmenu="_onPlaylistContextClick(event);"
            onkeypress="_onPlaylistKeypress(event);"
            ondraggesture="_onDragGesture(event);"
            ondragover="_onDragOver(event);"
            ondragdrop="_onDragDrop(event);"
            onmousemove="_onMouseMove(event);"
            onmouseout="_onMouseMove(event);"
            onmouseup="_onMouseUp(event);"
            editable="true"
          >
            <treecols sbid="treecols"/>
            <treechildren/>
          </tree>

          <!-- Playlist Toolbar -->
          <sb-commands-toolbar id="sb-playlist-tree-toolbar" sbid="playlist_toolbar" commandtype="mediaitem" metricscategory="playlist.toolbar"/>
          <sb-commands-shortcuts id="sb-playlist-tree-shortcuts" sbid="playlist_shortcuts" commandtype="mediaitem" metricscategory="playlist.shortcut"/>

          <!-- Popupset -->
          <popupset>
            <!-- Context Popup -->
            <popup
              id="sb-playlist-popup"
              sbid="sb-playlist-popup"
              class="sb-playlist-popup"
              onpopupshown="onPopupShown( event );"
              onpopuphidden="onPopupHidden( event );"
            >
              <sb-commands-menuitems sbid="playlist_popup_commands" commandtype="mediaitem" metricscategory="playlist.context"/>
              <menuseparator id="playlist_context_before" sbid="playlist_context_before"/>
              <xul:menu id="playlist_context_search" label="&playlist.context.search;">
                <xul:menupopup id="playlist_context_search_popup" type="search" label="" searchterm="" />
              </xul:menu>   
              <xul:menu id="playlist_context_lyrics" label="&playlist.context.lyrics;">
                <xul:menupopup id="playlist_context_lyrics_popup" type="search" label="" searchterm="" enginetags="lyrics" />
              </xul:menu>              
              <children/>
            </popup>
          </popupset>
        </vbox>
        </stack>
        </content>

    <implementation
      implements="nsISupportsWeakReference,sbIPlaylistWidget,sbIMediaListViewTreeViewObserver"
      type="application/x-javascript"
      name="songbird_playlist"
    >

      <constructor>
<![CDATA[
  this._destroyed = false;
  if (typeof(SBProperties) == "undefined") {
    Components.utils.import("resource://app/components/sbProperties.jsm");
    if (!SBProperties)
      throw new Error("Import of sbProperties module failed");
  }

  // Attach event handler closures
  var self = this;

  // Attach a attribute modified event handler to the treecols element.  This
  // allows us to be notified when the user drags a column (the "dragging"
  // attribute on a child element is set and it then removed) or when one is
  // resized (the width attribute changes) or when a column is hidden/shown
  // (the "hidden" attribute changes).  Save the column spec attributes when\
  // this happens.
  this._onColumnMutationClosure = function(event) {
    self._onColumnMutation(event);
  };
  this._treecols.addEventListener("DOMAttrModified",
                                  this._onColumnMutationClosure,
                                  false);

  // Install our special keyNavigate function. The signature must match the
  // keyNavigate method in tree.xml.
  this.tree.keyNavigate = this._treeKeyNavigate;
  
  // Load the drag and drop helper, if needed
  if (typeof(nsDragAndDrop) == "undefined") {
    var jsLoader = this._Cc["@mozilla.org/moz/jssubscript-loader;1"]
                           .getService(this._Ci.mozIJSSubScriptLoader);
    jsLoader.loadSubScript("chrome://global/content/nsDragAndDrop.js", null);
  }

  // Some strings
  this._str_tracksaddedto =
    this._getString("library.tracksaddedto", "tracks added to");
  this._str_trackaddedto =
    this._getString("library.trackaddedto", "track added to");
  this._str_notracksaddedto =
    this._getString("library.notracksaddedto", "No tracks added to");
  this._str_trackalreadypresent =
    this._getString("library.trackalreadypresent", "track already present");
  this._str_tracksalreadypresent =
    this._getString("library.tracksalreadypresent", "tracks already present");

  // Add a capturing listener so we can swallow the mousedown for clickable
  // properties, preventing row selection
  this._onMouseDownClosure = function(event) {
    self._onMouseDown(event);
  };
  this.addEventListener("mousedown",
                        this._onMouseDownClosure,
                        true);

]]>
      </constructor>

      <destructor>
        this.destroy();
      </destructor>

      <!-- The media list view this playlist is showing -->
      <field name="_mediaListView">null</field>
      <property name="mediaListView">
        <getter>
          <![CDATA[
            return this._mediaListView;
          ]]>
        </getter>
        <setter>
          <![CDATA[
            return this._mediaListView = val;
          ]]>
        </setter>
      </property>

      <!-- The outer window, set from the outside -->
      <field name="_outerWindow">null</field>
      <property name="outerWindow">
        <getter>
          <![CDATA[
            return this._outerWindow;
          ]]>
        </getter>
        <setter>
          <![CDATA[
            this._outerWindow = val;
            return val;
          ]]>
        </setter>
      </property>

      <!-- sbIPlaylistWidget -->
      <method name="getListView">
        <body> <![CDATA[
          return this.mediaListView;
        ]]> </body>
      </method>

      <!-- The anonymous xul tree element -->
      <field name="tree" readonly="true">
        document.getAnonymousElementByAttribute(this, "sbid", "sb-playlist-tree");
      </field>
      
      <!-- XXXben This is here to fix a bug where 'this.tree.view' will return
                  null even when the tree actually has a view. Remove once that
                  works as expected. -->
      <!-- Get the tree's view -->
      <field name="_treeView">null</field>
      <property name="treeView">
        <getter>
        <![CDATA[
          return this.tree.view || this._treeView;
        ]]>
        </getter>
        
        <setter>
        <![CDATA[
          return this.tree.view = this._treeView = val;
        ]]>
        </setter>
      </property>

      <property name="mediaList" readonly="true">
        <getter>
        <![CDATA[
          if (this.mediaListView)
            return this.mediaListView.mediaList;
          return null;
        ]]>
        </getter>
      </property>

      <property name="library" readonly="true">
        <getter>
        <![CDATA[
          if (this.mediaListView)
            return this.mediaListView.mediaList.library;
          return null;
        ]]>
        </getter>
      </property>

      <property name="description" readonly="true">
        <getter>
        <![CDATA[
          /*
          if (this.mediaListView)
            return this.mediaListView.mediaList.name;
          */
          return "";
        ]]>
        </getter>
      </property>

      <property name="usedefaultcommands">
        <getter>
          <![CDATA[
            return (this.getAttribute("usedefaultcommands") != "false");
          ]]>
        </getter>
        <setter>
          <![CDATA[
            this.setAttribute("usedefaultcommands", val);
            if (this._commandmenuitems) this._commandmenuitems.usedefault = val;
            if (this._toolbar) this._toolbar.usedefault = val;
            if (this._shortcuts) this._shortcuts.usedefault = val;
          ]]>
        </setter>
      </property>

      <!-- Holds the text value of the cell that was right clicked -->
      <field name="context_term">""</field>

      <!-- Store the last clicked row and column so we know which cell to edit
           when we are asked to start an edit -->
      <field name="edit_row">0;</field>
      <field name="edit_col">0;</field>

      <!-- Stores the last click event, to be passed to the remote API
           (this is a sbIPlaylistClickEvent) -->
      <field name="_lastClickEvent">null</field>
      <property name="lastClickEvent">
        <getter>
        <![CDATA[
          if (!this._lastClickEvent)
            return null;
          var obj = {
            QueryInterface: function lastEventInfo_QI(aIID) {
              if (aIID.equals(Components.interfaces.nsISupports) ||
                  aIID.equals(Components.interfaces.nsIDOMMouseEvent) ||
                  aIID.equals(Components.interfaces.sbIPlaylistClickEvent)
                 )
              {
                return this;
              }
              throw Components.results.NS_ERROR_NO_INTERFACE;
            }
          };
          const props = ["property", "item", "ctrlKey", "shiftKey",
                         "altKey", "metaKey", "button"];
          for each (var i in props) {
            obj[i] = this._lastClickEvent[i];
          }
          return obj;
        ]]>
        </getter>
      </property>

      <!-- Last click time and row index.  This is used to time the slow click
           to inline edit -->
      <field name="_lastClickIndex">0</field>
      <field name="_lastClickTimestamp">0</field>

      <!-- Sortcuts for various anonymous elements -->
      <field name="_context_popup" readonly="true">
        document.getAnonymousElementByAttribute(this, "sbid", "sb-playlist-popup");
      </field>
      <field name="_loading_box" readonly="true">
        document.getAnonymousElementByAttribute(this, "sbid", "loading_box");
      </field>
      <field name="_treecols" readonly="true">
        document.getAnonymousElementByAttribute(this, "sbid", "treecols");
      </field>
      <field name="_toolbar">
        document.getAnonymousElementByAttribute(this, 'sbid', 'playlist_toolbar');
      </field>
      <field name="_shortcuts">
        document.getAnonymousElementByAttribute(this, 'sbid', 'playlist_shortcuts');
      </field>
      <field name="_commandmenuitems">
        document.getAnonymousElementByAttribute(this, 'sbid', 'playlist_popup_commands');
      </field>

      <field name="_toolbarbuttons">new Array();</field>
      <field name="_menuitems">new Array();</field>

      <!-- Cached reference to the Songbird string bundle -->
      <field name="_stringbundle">null;</field>
      
      <!-- Internal and external storage of the given commands? -->
      <field name="_commands">null;</field>
      <field name="commands">null;</field>

      <!-- Coordinates of the last shown content menu popup -->
      <field name="_context_x">-1</field>
      <field name="_context_y">-1</field>

      <!-- Array of the splitters between each filter list -->
      <field name="_splitters">new Array();</field>

      <!-- Used to implement draggable smart splitters -->
      <field name="_down">0</field>
      <field name="_lastpos">0</field>
      <field name="_columnSpecIsDirty">false</field>

      <!-- Where the columnSpec came from. Possible values:
        0: undefined
        1: "contentSpec" property on the medialist
        2: "defaultColumnSpec" property on the medialist
        3: "defaultColumnSpec" property on the medialist library
        4: "contentSpec" property on the medialist library
        5: XUL "columnSpec" attribute
        6: Our last-ditch hardcoded list
      -->
      <field name="_columnSpecOrigin">0</field>

      <!-- Track mouse down for sending mouse state to the tree view -->
      <field name="_lastMouseDownRow">-1</field>
      <field name="_lastMouseDownColumn">null</field>

      <!-- Drag and Drop flavors -->
      <field name="_TYPE_X_SB_TRANSFER_MEDIA_ITEM"  readonly="true">
        "application/x-sb-transfer-media-item"
      </field>
      <field name="_TYPE_X_SB_TRANSFER_MEDIA_LIST"  readonly="true">
        "application/x-sb-transfer-media-list"
      </field>
      <field name="_TYPE_X_SB_TRANSFER_MEDIA_ITEMS"  readonly="true">
        "application/x-sb-transfer-media-items"
      </field>

      <field name="_Cc"     readonly="true">Components.classes</field>
      <field name="_Ci"     readonly="true">Components.interfaces</field>
      <field name="_Cr"     readonly="true">Components.results</field>
      <field name="_XUL_NS" readonly="true">
        "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
      </field>
      <field name="_pm"     readonly="true">
        this._Cc["@songbirdnest.com/Songbird/Properties/PropertyManager;1"]
        .getService(this._Ci.sbIPropertyManager)
      </field>

      <!-- Helper property to get and set the search query that is 
           filtering this playlist.
        -->
      <property name="searchFilter" >
        <getter>
<![CDATA[
  // Attempt to get the search filter on the playlist
  if (this.mediaListView && this.mediaListView.currentSearch) {
    var properties = this.mediaListView.currentSearch;
    if (properties.length > 0) {
      var terms = [];
      var property = null;
      var previousProperty = null;
      for (var i = 0; i < properties.length; i++) {
        property = properties.getPropertyAt(i);
        // Continue adding terms until we get to the next property
        if (previousProperty && property.name != previousProperty.name) {
          break;
        }
        terms.push(property.value);
        previousProperty = property;
      }
      return terms.join(" ");
    }
  }
  return "";
]]>
        </getter>
        <setter>
<![CDATA[
  if (!this.mediaListView || !this.mediaListView.cascadeFilterSet) 
  {
    throw("Playlist: Unable to set searchFilter. No mediaListView or cascadeFilterSet.");
  }
  
  // Attempt to set the search filter on the playlist
  var filters = this.mediaListView.cascadeFilterSet;
  
  // The search is always the first filter in the cascade set
  if (val == "" || val == null) {
    filters.set(0, [], 0);
  }
  else {
    var valArray = val.split(" ");
    filters.set(0, valArray, valArray.length);
  }
  return val;  
]]>
        </setter>        
      </property>      
      
      
      <!-- Expose the human readable name of this playlist
           Note: mediaList.name always returns "" at the moment?
        -->
      <property name="displayName" readonly="true">
        <getter>
<![CDATA[
  // Attempt to get the search filter on the playlist
  if (this.mediaListView && this.mediaListView.mediaList) {
    return this.mediaListView.mediaList.name;
  } 
  return "";
]]>
        </getter>
      </property>       

      <!-- sbIPlaylistWidget - Initialization and Control -->
      <method name="bind">
        <parameter name="mediaListView"/>
        <parameter name="commands"/>
        <parameter name="resize"/>
        <parameter name="collapse"/>
        <body>
<![CDATA[
  this.mediaListView = mediaListView;
  this.treeView = mediaListView.treeView;

  this.isSortable = mediaListView.mediaList.getProperty(SBProperties.isSortable);

  // Set up the columns
  this._setupColumns();

  // Attach our observer
  var mediaListViewTreeView =
    this.treeView.QueryInterface(this._Ci.sbIMediaListViewTreeView);

  mediaListViewTreeView.observer = this;

  // Create whatever filters we think we need.
  this._generateFilters();

  if (this._toolbar) this._toolbar.outerWindow = this._outerWindow;
  if (this._commandmenuitems) this._commandmenuitems.outerWindow = this._outerWindow;
  if (this._shortcuts) this._shortcuts.outerWindow = this._outerWindow;

  // Clear out the old commands and add the new ones
  this._toolbar.hidden = true;
  this.setCommands(commands);

  // If boolean true, read from the XUL file.
  if (resize == true) {
    resize = this.getAttribute("resize_height");
  }

  // If an integer
  if (parseInt(resize) > 0) {
    this.height = resize;
  }
]]>
        </body>
      </method>

      <method name="destroy">
        <body>
<![CDATA[
  if (!this._destroyed) {
    if (this._columnSpecIsDirty) {
      this._saveColumnSpec();
    }

    // only removes the commands elements
    this.removeCommands(); 
    // actually removes any reference to command objects
    this._toolbar.destroy();
    this._shortcuts.destroy();
    this._commandmenuitems.destroy();

    // Remove event listeners
    this._treecols.removeEventListener("DOMAttrModified",
                                      this._onColumnMutationClosure,
                                        false);

    this.removeEventListener("mousedown",
                            this._onMouseDownClosure,
                            true);

    for (var s = 0; s < this._splitters.length; s++) {
      this._splitters[s].removeEventListener("mousemove", this._onFilterSplitterMove, true);
      this._splitters[s].removeEventListener("mousedown", this._onFilterSplitterDown, true);
      this._splitters[s].removeEventListener("mouseup", this._onFilterSplitterUp, true);
    }

    // Break the cycle between ourselves and the tree view
    if (this.treeView) {
      var mediaListViewTreeView =
        this.treeView.QueryInterface(this._Ci.sbIMediaListViewTreeView);
      mediaListViewTreeView.observer = null;
    }
    this.treeView = null;
    this.mediaListView = null;

    var e = document.createEvent("Events");
    e.initEvent("playlist-destroy", false, true);
    this.dispatchEvent(e);
    this._destroyed = true;
  }
]]>
        </body>
      </method>

    <method name="_generateFilters">
      <body>
<![CDATA[    
  // Hide the playlist splitter
  var psplitter =
    document.getAnonymousElementByAttribute(this, "sbid", "filter_splitter");
  psplitter.setAttribute("hidden","true");

  // Get and empty the parent    
  var parent =
    document.getAnonymousElementByAttribute(this, "sbid", "filter_parent");
  this._removeAllChildren(parent);
  this._splitters = [];
  
  if (this.getAttribute("hidefilters") != "true") {
    // Create the filters based upon the cascadeFilterSet data.
    var cfs = this.mediaListView.cascadeFilterSet;
    var length = cfs.length;
    var filters = [];
    for (var i = 0; i < length; i++) {
      // If this is a search then keep going.
      if (cfs.isSearch(i)) {
        continue;
      }
    
      // And start creating the filter
      var filterlist = document.createElementNS(this._XUL_NS, "sb-filterlist");
      filterlist.setAttribute("enableColumnDrag", "false");
      //filterlist.setAttribute("hidecolumnpicker", "true");
      filterlist.setAttribute("flex", "1");
      
      parent.appendChild(filterlist);
      filterlist.bind(cfs, i);
      filters.push(filterlist);
      
      if (i < length - 1) {
        var splitter = document.createElement("sb-smart-splitter");
        splitter.setAttribute("id", "filter_splitter" );
        splitter.setAttribute("stateid", "filter_splitter_" + cfs.getProperty(i) + this.mediaListView.mediaList.guid );
        splitter.setAttribute("state", "open");
        splitter.setAttribute("resizebefore", "closest");
        splitter.setAttribute("resizeafter", "closest");
        splitter.setAttribute("collapse", "before");

        var grippy = document.createElement( "grippy" );
        splitter.appendChild(grippy);
        // do not appendChild now, wait until all filterlists have been created (see below)
        this._splitters.push(splitter);
      }
    }
    // once the filterlists have been created, insert the splitters are their appropriate spot.
    // we do this now rather than during the filter creation loop because the splitters
    // need to be able to find their before/after targets on construction (so as to be able
    // to reload their positions correctly), so if we did do appendChild in the previous loop,
    // the after target would never be found, and the positions would be wrong
    for (var s=0;s<this._splitters.length;s++) {
      var splitter = this._splitters[s];
      parent.insertBefore(splitter, filters[s+1]);
      splitter.addEventListener("mousemove", this._onFilterSplitterMove, true);
      splitter.addEventListener("mousedown", this._onFilterSplitterDown, true);
      splitter.addEventListener("mouseup", this._onFilterSplitterUp, true);
    }
  }
  
  // If we didn't actually add any filters then hide the filter box.
  if (!parent.firstChild) {
    parent.setAttribute("hidden", "true");
  } else {
    // Once we know we have at least one filter, show the playlist splitter. 
    psplitter.removeAttribute("hidden");
  }
]]>
      </body>
    </method>

    <method name="removeSelectedTracks">
      <body>
<![CDATA[
  var mediaListViewTreeView =
    this.treeView.QueryInterface(this._Ci.sbIMediaListViewTreeView);
  mediaListViewTreeView.removeSelectedMediaItems();
]]>
      </body>
    </method>

      <method name="startCellEditing">
        <parameter name="row"/>
        <parameter name="col"/>
        <body>
<![CDATA[
  if (row == null) 
    row = this.edit_row;
  if (col == null) 
    col = this.edit_col;
  if (row >= 0 && col.index >= 0)
    this.tree.startEditing(row, col);
]]>
        </body>
      </method>

      <method name="_onColumnMutation">
        <parameter name="event"/>
        <body>
<![CDATA[
  if((event.attrName == "dragging" && event.newValue == "") ||
     event.attrName == "width" || event.attrName == "hidden") {
    this._columnSpecIsDirty = true;
  }
]]>
        </body>
      </method>

      <method name="_setupColumns">
        <body>
<![CDATA[
  // Make sure this is set back to our default (undefined) value.
  this._columnSpecOrigin = 0;
  
  // Our new "column spec" is a whitespace separated string that looks like
  // this:
  // 
  // "propertyName [20] [a] propertyName [40] [d]"
  //
  // The width and sort direction are optional.
  
  // Try to get this info from 3 places, in this order:
  // 
  // 1. In the "columnSpec" property for the medialist.
  // 2. In the "defaultColumnSpec" property for the medialist.
  // 3. Hardcoded (or persisted) in XUL on the "columnSpec" attribute.
  // 4. A fun hardcoded list as a last resort.
  
  var columnMap = [];
  var medialist = this.mediaListView.mediaList;
  columnMap =
    this._getColumnMap(medialist.getProperty(SBProperties.columnSpec), 1);
  if (!columnMap.length) {
    columnMap =
      this._getColumnMap(medialist.getProperty(SBProperties.defaultColumnSpec),
                         2);
  }
  
  if (!columnMap.length) {
    columnMap =
      this._getColumnMap(medialist.library.getProperty(SBProperties.defaultColumnSpec),
                         3);
  }
  
  if (!columnMap.length) {
    columnMap =
      this._getColumnMap(medialist.library.getProperty(SBProperties.columnSpec),
                         4);
  }
  
  if (!columnMap.length) {
    columnMap = this._getColumnMap(this.getAttribute("columnSpec"), 5);
  }
  
  if (!columnMap.length) {
    columnMap =
      this._parseColumnSpec(SBProperties.ordinal + " 55 " +
                            SBProperties.trackName + " 350 " +
                            SBProperties.duration + " 50 " +
                            SBProperties.artistName + " 222 a " +
                            SBProperties.albumName + " 222 " +
                            SBProperties.genre + " 70");
    this._columnSpecOrigin = 6;
  }
  
  if (!columnMap.length) {
    throw new Error("Couldn't get columnMap!");
  }

  this._removeAllChildren(this._treecols);

  // Get the list of columns from the property manager and add them to the
  // tree
  var numColumns = columnMap.length;

  // Add the columns that have saved settings, keeping track of which column
  // were added
  var alreadyAdded = {};
  var addedColumns = 0;
  var ordinal = 0;
  var sortProperty;
  var sortDirection;
  columnMap.forEach(
    function(columnInfo) {
      var propertyInfo = this._pm.getPropertyInfo(columnInfo.property);
      if(propertyInfo.userViewable) {
        if (!sortProperty && columnInfo.sort) {
          sortProperty = columnInfo.property;
          sortDirection = columnInfo.sort;
        }
        this._appendColumn(propertyInfo,
                          false,
                          columnInfo.width,
                          ordinal);
        alreadyAdded[columnInfo.property] = true;
        addedColumns++;
        ordinal += 2;
      }
    },
    this);

  // Add the rest of the columns from the property manager.  Note if there was
  // any saved column info, add these additional columns as hidden, otherwise
  // show them
  var propEnumerator = this._pm.propertyNames;
  while (propEnumerator.hasMore()) {
    var propertyName = propEnumerator.getNext();
    if (!alreadyAdded[propertyName]) {
      var propertyInfo = this._pm.getPropertyInfo(propertyName);
      if(propertyInfo.userViewable) {
        this._appendColumn(propertyInfo,
                          columnMap.length,
                          null,
                          ordinal);
        addedColumns++;
        ordinal += 2;
      }
    }
  }

  if (!sortProperty) {
    sortProperty = SBProperties.ordinal;
    sortDirection = "ascending";
  }

  if (this.isSortable == "1" && this.tree.view) {
    var ldtv = this.tree.view.QueryInterface(this._Ci.sbILocalDatabaseTreeView);
    ldtv.setSort(sortProperty, sortDirection == "ascending");
  }

  if (this.tree.columns) {
    this.tree.columns.invalidateColumns();
  }
]]>
        </body>
      </method>

      <method name="_getColumnMap">
        <parameter name="columnSpec"/>
        <parameter name="columnSpecOrigin"/>
        <body>
          <![CDATA[
            var columnMap = [];

            if (columnSpec) {
              try {
                columnMap = this._parseColumnSpec(columnSpec);
                this._columnSpecOrigin = columnSpecOrigin;
              }
              catch (e) {
                this._reportError("Failed to parse columnSpec(" + columnSpecOrigin + "): \"" + columnSpec + "\"", e);
              }
            }

            return columnMap;
          ]]>
        </body>
      </method>

      <method name="_parseColumnSpec">
        <parameter name="spec"/>
        <body>
          <![CDATA[

            // strip leading and trailing whitespace.
            var strippedSpec = spec.match(/^\s*(.*?)\s*$/);
            if (!strippedSpec.length > 0)
              throw new Error("RegEx failed to match string");

            // split based on whitespace.
            var tokens = strippedSpec[1].split(/\s+/);
            
            var columns = [];
            var columnIndex = -1;
            var seenSort = false;
            
            for (var index = 0; index < tokens.length; index++) {
              var token = tokens[index];
              if (!token)
                throw new Error("Zero-length token");
              
              if (isNaN(parseInt(token))) {
                if (token.length == 1 && (token == "a" || token == "d")) {
                  // This is a sort specifier
                  if (columnIndex < 0) {
                    throw new Error("You passed in a bunk string!");
                  }
                  // Multiple sorts will be ignored!
                  if (!seenSort) {
                    var column = columns[columnIndex];                    
                    column.sort = token == "a" ? "ascending" : "descending";
                    seenSort = true;
                  }
                }
                else {
                  // This is a property name.
                  columns[++columnIndex] = { property: token, sort: null };
                }
              }
              else {
                // This is a width specifier
                if (columnIndex < 0) {
                  throw new Error("You passed in a bunk string!");
                }
                var column = columns[columnIndex];
                column.width = token;
              }
            }
            
            return columns;
          ]]>
        </body>
      </method>

      <!-- sbIPlaylistWidget -->
      <method name="getColumnCount">
        <body>
<![CDATA[
  // Get the number of visible columns
  return this._getVisibleColumnArray().length;
]]>
        </body>
      </method>

      <!-- sbIPlaylistWidget -->
      <method name="clearColumns">
        <body>
<![CDATA[
  // Hide all visible columns
  this._getVisibleColumnArray().forEach(function(column) {
    column.element.setAttribute("hidden", "true");
  });
  this._columnSpecIsDirty = true;
]]>
        </body>
      </method>

      <!-- sbIPlaylistWidget -->  
      <method name="appendColumn">
        <parameter name="aPropertyID"/>
        <parameter name="aWidth"/>
        <body>
<![CDATA[
  this.insertColumnBefore(aPropertyID, "", aWidth);
  this._columnSpecIsDirty = true;
]]>
        </body>
      </method>


      <!-- sbIPlaylistWidget -->
      <method name="insertColumnBefore">
        <parameter name="aPropertyID"/>
        <parameter name="aBeforePropertyID"/>
        <parameter name="aWidth"/>
        <body>
<![CDATA[
  // Find some important indexes
  var columnIndex       = -1;
  var beforeColumnIndex = -1;
  var lastVisibleIndex  = -1;

  var columns = this._getSortedColumnArray();
  for (var i = 0; i < columns.length; i++) {
    var col = columns[i];
    var bind = col.element.getAttribute("bind");
    if (bind == aPropertyID) {
      columnIndex = i;
    }
    if (aBeforePropertyID && bind == aBeforePropertyID) {
      beforeColumnIndex = i;
    }
    if (col.element.getAttribute("hidden") == "false") {
      lastVisibleIndex = i;
    }
  }

  // If the column or the before column was not found, throw
  if (columnIndex < 0 || (aBeforePropertyID && beforeColumnIndex < 0)) {
    throw this._Cr.NS_ERROR_INVALID_ARG;
  }

  var mover;

  // If no columns are visible, just move this column to the front
  if (lastVisibleIndex < 0) {
    mover = this._moveColumnBefore(columns, columnIndex, 0);
  }
  else {
    // If a before column was specified, splice the mover into the array
    // before that column
    if (aBeforePropertyID) {
      mover = this._moveColumnBefore(columns, columnIndex, beforeColumnIndex);
    }
    else {
      // If no before column was specified, splice the mover into the array
      // after the last visible column
      if (lastVisibleIndex < columns.length) {
        mover = this._moveColumnBefore(columns, columnIndex, lastVisibleIndex + 1);
      }
      else {
        mover = this._moveLast(columns, columnIndex);
      }
    }
  }

  mover.element.setAttribute("hidden", "false");

  // set the width if it isn't already set and we got one passed in
  var width = mover.element.getAttribute("width");
  if ( aWidth && width == "" ) {
    mover.element.setAttribute("width", aWidth);
  }
  this._columnSpecIsDirty = true;
]]>
        </body>
      </method>

      <method name="_moveColumnBefore">
        <parameter name="aColumns"/>
        <parameter name="aFromIndex"/>
        <parameter name="aToIndex"/>
        <body>
<![CDATA[
  var mover = aColumns.splice(aFromIndex, 1)[0];
  if (aFromIndex < aToIndex) {
    aToIndex--;
  }
  aColumns.splice(aToIndex, 0, mover);

  aColumns.forEach(function(column, i) {
    column.element.setAttribute("ordinal", (i * 2) + 1);
  });

  return mover;
]]>
        </body>
      </method>

      <method name="_moveColumnLast">
        <parameter name="aColumns"/>
        <parameter name="aFromIndex"/>
        <body>
<![CDATA[
  var mover = aColumns.splice(aFromIndex, 1)[0];
  aColumns.push(mover);

  aColumns.forEach(function(column, i) {
    column.element.setAttribute("ordinal", (i * 2) + 1);
  });

  return mover;
]]>
        </body>
      </method>

      <!-- sbIPlaylistWidget -->
      <method name="removeColumn">
        <parameter name="aPropertyID"/>
        <body>
<![CDATA[
  // Find some important indexes
  var columnIndex       = -1;
  var firstHiddenIndex  = -1;

  var columns = this._getSortedColumnArray();
  for (var i = 0; i < columns.length; i++) {
    var col = columns[i];
    if (col.element.getAttribute("bind") == aPropertyID) {
      columnIndex = i;
    }
    if (firstHiddenIndex < 0 && col.element.getAttribute("hidden") == "true") {
      firstHiddenIndex = i;
    }
  }

  if (columnIndex < 0) {
    throw this._Cr.NS_ERROR_INVALID_ARG;
  }

  var mover;
  if (firstHiddenIndex < 0) {
    mover = this._moveColumnLast(columns, columnIndex);
  }
  else {
    mover = this._moveColumnBefore(columns, columnIndex, firstHiddenIndex);
  }
  mover.element.setAttribute("hidden", "true");
  this._columnSpecIsDirty = true;
]]>
        </body>
      </method>

      <!-- sbIPlaylistWidget -->
      <method name="getColumnPropertyIDByIndex">
        <parameter name="aIndex"/>
        <body>
<![CDATA[
  var columns = this._getVisibleColumnArray();
  if (aIndex < 0 || aIndex >= columns.length) {
    throw this._Cr.NS_ERROR_INVALID_ARG;
  }
  return columns[aIndex].element.getAttribute("bind");
]]>
        </body>
      </method>

      <!-- sbIPlaylistWidget -->
      <method name="setSortColumn">
        <parameter name="aPropertyID"/>
        <parameter name="aIsAscending"/>
        <body>
<![CDATA[
  var ldtv = this.tree.view.QueryInterface(this._Ci.sbILocalDatabaseTreeView);
  ldtv.setSort(aPropertyID, aIsAscending);
]]>
        </body>
      </method>

      <method name="_getVisibleColumnArray">
        <body>
<![CDATA[
  var columns = this.tree.columns;
  var a = [];
  for (var i = 0; i < columns.length; i++) {
    var column = columns.getColumnAt(i);
    if (column.element.getAttribute("hidden") != "true") {
      a.push(column);
    }
  }

  a.sort(function(a, b) {
    var o1 = parseInt(a.element.getAttribute("ordinal"));
    var o2 = parseInt(b.element.getAttribute("ordinal"));
    return o1 - o2;
  });
  return a;
]]>
        </body>
      </method>

      <method name="_getSortedColumnArray">
        <body>
<![CDATA[
  var columns = this.tree.columns;
  var a = [];
  for (var i = 0; i < columns.length; i++) {
    a.push(columns.getColumnAt(i));
  }

  a.sort(function(a, b) {
    var o1 = parseInt(a.element.getAttribute("ordinal"));
    var o2 = parseInt(b.element.getAttribute("ordinal"));
    return o1 - o2;
  });
  return a;
]]>
        </body>
      </method>

      <method name="_appendColumn">
        <parameter name="propertyInfo"/>
        <parameter name="isHidden"/>
        <parameter name="width"/>
        <parameter name="ordinal"/>
        <body>
<![CDATA[
  var treecol = document.createElementNS(this._XUL_NS, "treecol");
  treecol.setAttribute("bind", propertyInfo.name);
  treecol.setAttribute("label", propertyInfo.displayName);
  treecol.setAttribute("flex", "1");
  if (width) {
    treecol.setAttribute("width", width);
  }

  if (isHidden) {
    treecol.setAttribute("hidden", "true");
  }

  treecol.setAttribute("ordinal", ordinal);

  if (propertyInfo instanceof this._Ci.sbITreeViewPropertyInfo) {
    var tvpi = propertyInfo.QueryInterface(this._Ci.sbITreeViewPropertyInfo);
    switch (tvpi.columnType) {
      case "progressmeter":
        treecol.setAttribute("type", "progressmeter");
        break;
      case "checkbox":
        treecol.setAttribute("type", "checkbox");
        treecol.setAttribute("editable", "true");
        break;
      default:
        // Don't do anything, so this will be "text".
        break;
    }
  }

  this._treecols.appendChild(treecol);
  var splitter = document.createElementNS(this._XUL_NS, "splitter");
  splitter.setAttribute("class", "tree-splitter");
  splitter.setAttribute("ordinal", ordinal + 1);
  
  this._treecols.appendChild(splitter);
  if (this.tree.columns) {
    this.tree.columns.invalidateColumns();
  }
]]>
        </body>
      </method>

      <method name="_saveColumnSpec">
        <body>
<![CDATA[
  var columns = [];

  var treecolList = this._treecols.getElementsByTagNameNS(this._XUL_NS,
                                                          "treecol");

  // Gather the column information for the columns that are not hidden
  for (var i = 0; i < treecolList.length; i++) {
    var col = treecolList[i];
    if (col.getAttribute("hidden") != "true") {
      var columnInfo = { property: col.getAttribute("bind"),
                         ordinal:  col.getAttribute("ordinal"),
                         width:    col.width };

      var sortActive = col.getAttribute("sortActive");
      if (sortActive) {
        var sortDirection = col.getAttribute("sortDirection");
        var sortKey;
        if (sortDirection == "ascending") {
          sortKey = "a";
        }
        else if (sortDirection == "descending") {
          sortKey = "d";
        }
        if (sortKey) {
          columnInfo.sort = sortKey;
        }
      }
      
      columns.push(columnInfo);
    }
  }

  // Sort the column list by ordinal
  columns.sort(function(a, b) { return a.ordinal - b.ordinal; });

  var columnSpec = "";
  var first = true;
  
  function writeColumnInfo(columnInfo) {
    var newString;
    if (first) {
      newString = "";
      first = false;
    }
    else {
      newString = " ";
    }
    
    newString += columnInfo.property;
    if (columnInfo.width) {
      newString += " " + columnInfo.width;
    }
    if (columnInfo.sort) {
      newString += " " + columnInfo.sort;
    }
    columnSpec += newString;
  }
  
  columns.forEach(writeColumnInfo);
  
  // Sanity check, don't write a bad string.
  try {
    var parsedColumns = this._parseColumnSpec(columnSpec);
  }
  catch (e) {
    this._reportError('Almost wrote bad columnSpec: "' + columnSpec + '"', e);
    return;
  }

  if (!columnSpec) {
    throw new Error("No columns enumerated");
  }

  var mediaList = this.mediaListView.mediaList;
  mediaList.setProperty(SBProperties.columnSpec, columnSpec);

  // Write the column spec to the default column spec for this list's library
  // only if the list is not actually the library
  if (mediaList instanceof this._Ci.sbILibrary) {
    return;
  }

  // The download playlist should not modify the default column spec
  var ddh = this._Cc["@songbirdnest.com/Songbird/DownloadDeviceHelper;1"]
                    .getService(this._Ci.sbIDownloadDeviceHelper);
  if (ddh.downloadMediaList.equals(mediaList)) {
    return;
  }

  mediaList.library.setProperty(SBProperties.defaultColumnSpec, columnSpec);
]]>
        </body>
      </method>

      <method name="refreshCommands">
        <parameter name="stateonly"/>
        <body>
<![CDATA[
  this._toolbar.outerWindow = this._outerWindow;
  this._commandmenuitems.outerWindow = this._outerWindow;
  this._shortcuts.outerWindow = this._outerWindow;
  this._toolbar.refreshCommands(stateonly);
  this._commandmenuitems.refreshCommands(stateonly);
  this._shortcuts.refreshCommands(stateonly);
]]>
        </body>
      </method>
      
      <method name="setCommands">
        <parameter name="commands"/>
        <body>
        <![CDATA[
          // Out with the old
          this.removeCommands(); 
          if (this.getAttribute("hidecommands") != "true") {
              // In with the new
              this._commands = this.commands = commands;
              this._toolbar.hidden = true;
              this._toolbar.bind(this.mediaListView.mediaList, this, commands);
              this._commandmenuitems.bind(this.mediaListView.mediaList, this, commands);
              this._shortcuts.bind(this.mediaListView.mediaList, this, commands);
          }
        ]]>
        </body>
      </method>

      <method name="removeCommands">
        <body>
<![CDATA[
  this._commands = this.commands = null;
  this._toolbar.removeCommands();
  this._commandmenuitems.removeCommands();
  this._shortcuts.removeCommands();
]]>
        </body>
      </method>

      <method name="_onFilterSplitterMove">
        <parameter name="event"/>
        <body>
<![CDATA[
  var state = this.getAttribute( "state" );
  if (state != "collapsed" && this._down && this._lastPos) {
    if (event.screenX > this._lastPos) { this.setAttribute("collapse", "after"); }
    if (event.screenX < this._lastPos) { this.setAttribute("collapse", "before"); }
  }
  this._lastPos = event.screenX;
]]>
        </body>
      </method>

      <method name="_onFilterSplitterUp">
        <body>
<![CDATA[
  this._down = 0;
  this._lastPos = null;
]]>
        </body>
      </method>

      <method name="_onFilterSplitterDown">
        <body>
<![CDATA[
  this._down = 1;
]]>
        </body>
      </method>

      <!-- Removes all children of the given DOM node -->
      <method name="_removeAllChildren">
        <parameter name="parentNode"/>
        <body>
<![CDATA[
  // Bail out if there are no children
  if (!parentNode.hasChildNodes())
    return;

  // Loop through and remove all the children
  var childNodes = parentNode.childNodes;
  var childCount = childNodes.length;
  for(var index = 0; index < childCount; index++) {
    var child = childNodes.item(0);
    parentNode.removeChild(child);
  }
]]>
        </body>
      </method>

      <!-- Event yellers -->

      <method name="sendPlayEvent">
        <body>
          <![CDATA[
      try
      {
        var e = document.createEvent("Events");
        e.initEvent("playlist-play", false, true);
        this.dispatchEvent(e);
      }
      catch( err )
      {
        alert( "playlist.xml - sendPlayEvent - " + err )
      }
      ]]>
        </body>
      </method>

      <method name="sendSelChangeEvent">
        <body>
          <![CDATA[
      try
      {
        var e = document.createEvent("Events");
        e.initEvent("playlist-selchange", false, true);
        this.dispatchEvent(e);
      }
      catch( err )
      {
        alert( "playlist.xml - sendPlayEvent - " + err )
      }
      ]]>
        </body>
      </method>

      <method name="sendEscEvent">
        <body>
          <![CDATA[
          try
          {
            var e = document.createEvent("Events");
            e.initEvent("playlist-esc", false, true);
            this.dispatchEvent(e);
          }
          catch( err )
          {
            alert( "playlist.xml - sendEscEvent - " + err )
          }
          ]]>
        </body>
      </method>

      <method name="sendEditorEvent">
        <body>
          <![CDATA[
          try
          {
            var e = document.createEvent("Events");
            e.initEvent("playlist-editor", false, true);
            this.dispatchEvent(e);
          }
          catch( err )
          {
            alert( "playlist.xml - sendEditorEvent - " + err )
          }
          ]]>
        </body>
      </method>

      <method name="sendBurnToCDEvent">
        <body>
          <![CDATA[
          try
          {
            var e = document.createEvent("Events");
            e.initEvent("playlist-burntocd", false, true);
            this.dispatchEvent(e);
          }
          catch( err )
          {
            alert( "playlist.xml - sendBurnToCDEvent - " + err )
          }
          ]]>
        </body>
      </method>

      <!-- Tree event listeners -->

      <method name="_onPlaylistDblClick">
        <parameter name="evt"/>
        <body>
         <![CDATA[
          // Check to see that the user double clicked on a row
          var row = {};
          var col = {};
          var obj = {};
          var b = this.tree.treeBoxObject;
          b.getCellAt(evt.clientX, evt.clientY, row, col, obj);

          if (row.value >= 0) {
            this.sendPlayEvent();
          }
         ]]>
        </body>
      </method>

      <method name="onFilterDblClick">
        <parameter name="evt"/>
        <body>
          <![CDATA[
          try
          {
            if( this.pointInTreeRows( evt.target.tree, evt.clientX, evt.clientY ) )
            {
              var playlist = evt.target.playlist;

              if ( playlist )
              {
                document.__PlaylistXBL_DragObjectDown__ = playlist; // YUCK YUCK YUCK YUCK (note the absence of "f")
                var txt = "document.__PlaylistXBL_DragObjectDown__.tree.view.selection.currentIndex = 0;"
                txt += "document.__PlaylistXBL_DragObjectDown__.tree.view.selection.select( 0 );"
                txt += "document.__PlaylistXBL_DragObjectDown__.sendPlayEvent();"
                // Play it in awhile, after the tree updates.
                setTimeout( txt, 250 );
              }
            }
          }
          catch( err )
          {
            alert( "playlist.xml - onFilterDblClick - " + err );
          }
        ]]>
        </body>
      </method>

      <method name="_onPlaylistKeypress">
        <parameter name="evt"/>
        <body>
<![CDATA[
  // XXXAus: Useful for debugging, don't remove.
  //dump("charcode = " + evt.charCode + " - keycode = " + evt.keyCode + "\n");
  
  // Handle Ctrl-a
  var isKeyValid = (evt.charCode == 'a'.charCodeAt(0));
  var isDarwin = (getPlatformString() == "Darwin");

if ( ( isDarwin && isKeyValid && evt.metaKey ) ||
       ( !isDarwin && isKeyValid && evt.ctrlKey)) {

    // Prevent the default and stop propagation since
    // we are handling this event completely.
    // See bug #491 and #4546
    evt.preventDefault();
    evt.stopPropagation();
    
    this.treeView.selection.selectAll();

    return;
  }

  switch (evt.keyCode) {
    // Handle escape.
    case evt.DOM_VK_ESCAPE:
      this.sendEscEvent();
      break;

    default:
      break;
  }
]]>
        </body>
      </method>

      <method name="_onPlaylistContextClick">
        <parameter name="evt"/>
        <body>
<![CDATA[
  // If there is no actual commands, do not allow the context menu to pop.
  if (!this._commandmenuitems.hasCommands()) {
    return;
  }


  const COLUMN_TITLE = "title";
  const CONTEXT_IDS = ["playlist_context_before",
                       "playlist_context_search",
                       "playlist_context_lyrics"];


  // Small helper to loop through a list of the ids for the context
  // menu items and show or hide each element.
  //
  // aShow - a boolean specifying if items are to be shown or
  //           hidden. Defaults to true.
  function showContextItems(aShow) {
    if (aShow === undefined)
      aShow = true;

    var items = CONTEXT_IDS;
    var count = items.length;
    for (var index = 0; index < count; index++) {
      var id = items[index];
      var item = document.getElementById(id);
      if (!item)
        continue;

      var isHidden = item.hasAttribute("hidden");

      if (aShow && isHidden) {
        item.removeAttribute("hidden");
      }
      else if (!aShow && !isHidden) {
        item.setAttribute("hidden", "true");
      }
    }
  }

  var tree = this.tree;
  if (tree.currentIndex < 0)
    return;

  // First, get the row and column clicked.
  var childElement = {}, rowObject = {}, columnObject = {};
  tree.treeBoxObject.getCellAt(evt.clientX, evt.clientY, rowObject,
                               columnObject, childElement);

  // Bail if we got a bad result
  if (rowObject.value == -1)
    return;

  // Store the last clicked cell
  this.edit_row = rowObject.value;
  this.edit_col = columnObject.value;

  var cellText =
    tree.view.getCellText(rowObject.value, columnObject.value);

  // XXX: What to do here?
  if (!cellText) {
    // If we couldn't get text from the cell then we'll try to pull it
    // out another way
    var titleColumn = tree.columns.getNamedColumn(COLUMN_TITLE);
    if (titleColumn)
      cellText = tree.view.getCellText(tree.currentIndex, titleColumn);
  }

  // Make sure that everyone knows about our context
  this.context_term = cellText;
  SBDataSetStringValue("playlist.context.term", cellText);

  if (cellText) {

    var searchHeader = this._getString("playlist_context_searchheader", "Search");
    var lyricsHeader = this._getString("playlist_context_lyricsheader", "Lyrics");

    var searchMenu =
      document.getAnonymousElementByAttribute(this, 'id', 'playlist_context_search_popup');
    searchMenu.setAttribute("label", searchHeader + ": " + cellText);
    searchMenu.setAttribute("searchterm", cellText);

    var lyricsMenu =
      document.getAnonymousElementByAttribute(this, 'id', 'playlist_context_lyrics_popup');
    lyricsMenu.setAttribute("label", lyricsHeader + ": " + cellText);
    lyricsMenu.setAttribute("searchterm", cellText);

    // Make sure that the search and lyrics menus are visible
    showContextItems(true);
  }
  else {
    // We couldn't get any context, so hide the search and lyrics
    // menu items.
    showContextItems(false);
  }

  // HEY LOOK!  WE CAN TRUST THE EVENT DATA!!!  WOW!!!!!
  this._context_x = evt.screenX;
  this._context_y = evt.screenY;
  
  // XXXlone -- there is still a bug when opening the context menu in webplaylists 
  // inside tabs, when another tab has a playlist opened inside a browser (for instance, 
  // it is showing the library)... wtf.
  
  //dump("this._context_x = " + this._context_x + "\n");
  //dump("this._context_y = " + this._context_y + "\n");
  
  document.popupNode = null;
  
  this._context_popup.showPopup(tree, this._context_x, this._context_y,
                                "context", null, null, null);

  //dump("this._context_popup.boxObject.screenX = " + this._context_popup.boxObject.screenX + "\n");
  //dump("this._context_popup.boxObject.screenY = " + this._context_popup.boxObject.screenY + "\n");
]]>
        </body>
      </method>

      <method name="_onPlaylistSelectClick">
        <parameter name="evt"/>
        <body>
<![CDATA[
  this.treeView.selectionChanged();
  this.refreshCommands(true);
  this.sendSelChangeEvent();
]]>
        </body>
      </method>

    <method name="_onPlaylistClick">
      <parameter name="evt"/>
      <body>
<![CDATA[
  var bo = this.tree.treeBoxObject;
  try
  {
    if ( evt.button == 0 )
    {
      var obj = {}, row = {}, col = {};
      bo.getCellAt( evt.clientX, evt.clientY, row, col, obj );

      if (obj.value)
      {
        // If this clickable cell is disabled, just return
        var props = this._Cc["@mozilla.org/supports-array;1"]
                            .createInstance(this._Ci.nsISupportsArray);
        this.tree.view.getCellProperties(row.value, col.value, props);
        for (var i = 0; i < props.Count(); i++) {
          var atom = props.QueryElementAt(i, this._Ci.nsIAtom);
          if (atom.equals("disabled")) {
            return;
          }
        }

        var property = col.value.element.getAttribute("bind");
        var item = this.mediaListView.getItemByIndex(row.value);

        function fireEvent(aElement) {
          var event = document.createEvent("Events");
          event.initEvent("PlaylistCellClick", true, true);
          event.property = property;
          event.item     = item;
          event.row      = row.value;
          event.column   = col.value;
          aElement._lastClickEvent = { property: property, item: item, __proto__: evt };
          aElement.dispatchEvent(event);
          aElement._lastClickEvent = null;
        }

        var info = this._pm.getPropertyInfo(property);
        if (info instanceof this._Ci.sbIClickablePropertyInfo) {
          var clickable =
            info.QueryInterface(this._Ci.sbIClickablePropertyInfo);

          var coords = this._getCellCoords(evt, row.value, col.value);

          var oldValue = item.getProperty(property);

          // Should this click register?
          var hit = clickable.hitTest(oldValue,
                                      obj.value,
                                      coords.cellWidth,
                                      coords.cellHeight,
                                      coords.x,
                                      coords.y);
          if (!hit) {
            return;
          }

          // Special case for the download button propery.  If it is clicked,
          // start the download
          if (property == SBProperties.downloadButton) {
            this._downloadItem(item);
            evt.stopPropagation();
            return;
          }

          // Fire the click event
          fireEvent(this);

          // Get and assign the new value to the property
          try {
            var value = clickable.getValueForClick(oldValue,
                                                   coords.cellWidth,
                                                   coords.cellHeight,
                                                   coords.x,
                                                   coords.y);
            this.tree.view.setCellValue(row.value, col.value, value);
          }
          catch(e if e.result == this._Cr.NS_ERROR_NOT_IMPLEMENTED) {
            // It is ok for this not to be implenented
          }
          evt.stopPropagation();
        }
        else if (this.tree.currentIndex != -1 &&
                 this.treeView.isEditable(row.value, col.value))
        {
          // Remember the row and column
          this.edit_row = row.value;
          this.edit_col = col.value;
          if ( this.tree.currentIndex == this._lastClickIndex  )
          {
            var delay = evt.timeStamp - this._lastClickTimestamp;
            if ( delay > 1000 && delay < 2000 )
            {
              // Oooh, don't do this in the middle of an event chain.  No, sir!
              var params = { that: this, row: this.edit_row, col: this.edit_col };
              setTimeout( function( p ) { p.that.startCellEditing( p.row, p.col ); }, 0, params );
            }
          }
        }
        else {
          // Else just fire the event
          fireEvent(this);
        }
      }
    }
    this._lastClickIndex = this.tree.currentIndex;
    this._lastClickTimestamp = evt.timeStamp;
  }
  catch( err )
  {
    alert( "playlist.xml - onPlaylistClick - " + err );
  }
]]>
      </body>
    </method>

    <method name="_onMouseMove">
      <parameter name="evt"/>
      <body>
<![CDATA[
  var obj = {}, row = {}, col = {};
  var bo = this.tree.treeBoxObject;
  bo.getCellAt(evt.clientX, evt.clientY, row, col, obj);
  if (!obj.value) {
    return;
  }

  // Register a hover on all clickable properties that pass the hit test, or
  // all other cells
  var shouldHover = false;

  var property = col.value.element.getAttribute("bind");
  var propertyInfo = this._pm.getPropertyInfo(property);
  if (propertyInfo instanceof this._Ci.sbIClickablePropertyInfo) {
    var cpi = propertyInfo.QueryInterface(this._Ci.sbIClickablePropertyInfo);

    var coords = this._getCellCoords(evt, row.value, col.value);

    var item = this.mediaListView.getItemByIndex(row.value);
    var oldValue = item.getProperty(property);

    // Should this hover register?
    var hit = cpi.hitTest(oldValue,
                          obj.value,
                          coords.cellWidth,
                          coords.cellHeight,
                          coords.x,
                          coords.y);

    if (hit) {
      shouldHover = true;
    }
  }
  else {
    shouldHover = true;
  }

  var view = this.treeView;
  if (shouldHover) {

    // Set the state only if this cell is not the last mouse down cell
    if (!(row.value == this._lastMouseDownRow &&
        col.value == this._lastMouseDownColumn)) {
      view.setMouseState(row.value,
                         col.value,
                         this._Ci.sbILocalDatabaseTreeView.MOUSE_STATE_HOVER);
      this._lastMouseDownRow    = -1;
      this._lastMouseDownColumn = null;
    }
  }
  else {
    view.setMouseState(-1,
                       null,
                       this._Ci.sbILocalDatabaseTreeView.MOUSE_STATE_NONE);
  }
]]>
      </body>
    </method>

    <method name="_onMouseDown">
      <parameter name="evt"/>
      <body>
<![CDATA[
  var obj = {}, row = {}, col = {};
  var bo = this.tree.treeBoxObject;
  bo.getCellAt(evt.clientX, evt.clientY, row, col, obj);
  if (!obj.value) {
    return;
  }

  this._lastMouseDownRow    = row.value;
  this._lastMouseDownColumn = col.value;

  var view = this.treeView;

  // Register a mouse down on all clickable cells that pass the hit test or
  // all other cells

  var property = col.value.element.getAttribute("bind");
  var propertyInfo = this._pm.getPropertyInfo(property);
  if (propertyInfo instanceof this._Ci.sbIClickablePropertyInfo) {
    var cpi = propertyInfo.QueryInterface(this._Ci.sbIClickablePropertyInfo);

    var coords = this._getCellCoords(evt, row.value, col.value);

    var item = this.mediaListView.getItemByIndex(row.value);
    var oldValue = item.getProperty(property);

    // Should this click register?
    var hit = cpi.hitTest(oldValue,
                          obj.value,
                          coords.cellWidth,
                          coords.cellHeight,
                          coords.x,
                          coords.y);
    if (hit) {
      view.setMouseState(row.value,
                         col.value,
                         this._Ci.sbILocalDatabaseTreeView.MOUSE_STATE_DOWN);
      if (cpi.suppressSelect) {
        evt.stopPropagation();
      }
    }
  }
  else {
    view.setMouseState(row.value,
                       col.value,
                       this._Ci.sbILocalDatabaseTreeView.MOUSE_STATE_DOWN);
  }
]]>
      </body>
    </method>

    <method name="_onMouseUp">
      <parameter name="evt"/>
      <body>
<![CDATA[
  var obj = {}, row = {}, col = {};
  var bo = this.tree.treeBoxObject;
  bo.getCellAt(evt.clientX, evt.clientY, row, col, obj);

  if (obj.value) {
    var view = this.treeView;
    if (row.value == this._lastMouseDownRow &&
        col.value == this._lastMouseDownColumn) {
      view.setMouseState(row.value,
                         col.value,
                         this._Ci.sbILocalDatabaseTreeView.MOUSE_STATE_HOVER);
    }
    else {
      view.setMouseState(-1,
                         null,
                         this._Ci.sbILocalDatabaseTreeView.MOUSE_STATE_NONE);
    }
  }

  this._lastMouseDownRow    = -1;
  this._lastMouseDownColumn = null;
]]>
      </body>
    </method>

    <method name="_getCellCoords">
      <parameter name="evt"/>
      <parameter name="row"/>
      <parameter name="col"/>
      <body>
<![CDATA[
  // Compute the X and Y coordinates within the cell
  var bo = this.tree.treeBoxObject;
  var cellX = {};
  var cellY = {};
  var cellWidth  = {};
  var cellHeight = {};
  bo.getCoordsForCellItem(row,
                          col,
                          "cell",
                          cellX,
                          cellY,
                          cellWidth,
                          cellHeight);

  var bodyBox = this.tree.getElementsByTagName("treechildren")[0];
  var x = evt.screenX - bodyBox.boxObject.screenX - cellX.value;
  var y = evt.screenY - bodyBox.boxObject.screenY - cellY.value;
  return {x: x, y: y, cellWidth: cellWidth, cellHeight: cellHeight};
]]>
      </body>
    </method>

    <method name="onPopupShown">
      <parameter name="evt"/>
      <body>
        <![CDATA[
          try
          {
            this._commandmenuitems.setDeferRefresh();
          }
          catch( err )
          {
            alert( "playlist.xml - onPopupShown - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="onPopupHidden">
      <parameter name="evt"/>
      <body>
        <![CDATA[
          try
          {
            this._commandmenuitems.clearDeferRefresh();
          }
          catch( err )
          {
            alert( "playlist.xml - onPopupHidden - " + err );
          }
        ]]>
      </body>
    </method>

    <method name="_addItem">
      <parameter name="source"/>
      <parameter name="item"/>
      <parameter name="row"/>
      <parameter name="orientation"/>
      <body>
<![CDATA[
  var ml = this.mediaListView.mediaList;
  var oldLength = ml.length;

  var sort = this.mediaListView.currentSort;
  var isAscending = sort.getPropertyAt(0).value == "a";

  // If this is a descending sort, we need to flip around the row and the
  // orientation because the underlying media list we are modifying always has
  // an ascending sort.
  if (!isAscending) {
    row = this.mediaListView.length - (row + 1);
    if (orientation == this._Ci.sbIMediaListViewTreeViewObserver.DROP_BEFORE) {
      orientation = this._Ci.sbIMediaListViewTreeViewObserver.DROP_AFTER;
    }
    else if (orientation == this._Ci.sbIMediaListViewTreeViewObserver.DROP_AFTER) {
      orientation = this._Ci.sbIMediaListViewTreeViewObserver.DROP_BEFORE;
    }
  }

  // If this media lists supports ordering, insert the item where it was
  // dropped
  var doInsert = false;
  var isOrderable = ml instanceof this._Ci.sbIOrderableMediaList;
  if (isOrderable && oldLength > 0 && row >= 0 ) {
    if (orientation == this._Ci.sbIMediaListViewTreeViewObserver.DROP_BEFORE) {
      doInsert = true;
    }
    else {
      if (row + 1 < oldLength) {
        row++;
        doInsert = true;
      }
    }
  }

  if (source.equals(ml)) {
    var index = this.tree.view.selection.currentIndex;
    if (!isAscending) {
      index = this.mediaListView.length - (index + 1);
    }

    if (doInsert) {
      ml.moveBefore(index, row);
    }
    else {
      // Moving items within a list that is not orderable does nothing
      if (isOrderable) {
        ml.moveLast(index);
      }
    }
  }
  else {
    if (doInsert) {
      ml.insertBefore(row, item);
    }
    else {
      ml.add(item);
    }

    var added = ml.length - oldLength;
    this._reportAddedTracks(added, 1 - added);
  }
]]>
      </body>
    </method>

    <method name="_addItems">
      <parameter name="source"/>
      <parameter name="enumerator"/>
      <parameter name="count"/>
      <parameter name="row"/>
      <parameter name="orientation"/>
      <body>
<![CDATA[
  var ml = this.mediaListView.mediaList;
  var oldLength = ml.length;

  var sort = this.mediaListView.currentSort;
  var isAscending = sort.getPropertyAt(0).value == "a";

  // If this is a descending sort, we need to flip around the row and the
  // orientation because the underlying media list we are modifying always has
  // an ascending sort.
  if (!isAscending) {
    row = this.mediaListView.length - (row + 1);
    if (orientation == this._Ci.sbIMediaListViewTreeViewObserver.DROP_BEFORE) {
      orientation = this._Ci.sbIMediaListViewTreeViewObserver.DROP_AFTER;
    }
    else if (orientation == this._Ci.sbIMediaListViewTreeViewObserver.DROP_AFTER) {
      orientation = this._Ci.sbIMediaListViewTreeViewObserver.DROP_BEFORE;
    }
  }

  // If this media lists supports ordering, insert the item where it was
  // dropped
  var doInsert = false;
  var isOrderable = ml instanceof this._Ci.sbIOrderableMediaList;
  if (isOrderable && oldLength > 0 && row >= 0 ) {
    if (orientation == this._Ci.sbIMediaListViewTreeViewObserver.DROP_BEFORE) {
      doInsert = true;
    }
    else {
      if (row + 1 < oldLength) {
        row++;
        doInsert = true;
      }
    }
  }

  if (source.equals(ml)) {
    // Find the indexes of all the selected rows
    var indexes = [];
    var viewLength = this.mediaListView.length;
    while (enumerator.hasMoreElements()) {
      var index = enumerator.getNext().index;
      if (!isAscending) {
        index = viewLength - (index + 1);
      }
      indexes.push(index);
    }

    if (!isAscending) {
      indexes.reverse();
    }

    if (doInsert) {
      ml.moveSomeBefore(indexes, indexes.length, row);
    }
    else {
      // Moving items within a list that is not orderable does nothing
      if (isOrderable) {
        ml.moveSomeLast(indexes, indexes.length);
      }
    }
  }
  else {
    // Create an enumerator that wraps the enumerator we were handed since
    // the enumerator we get hands back sbIIndexedMediaItem, not just plain
    // 'ol sbIMediaItems

    var self = this;
    var unwrapper = {
      hasMoreElements : function() {
        return enumerator.hasMoreElements();
      },
      getNext : function() {
        return enumerator.getNext().mediaItem;
      },
      QueryInterface : function(iid) {
        if (iid.equals(self._Ci.nsISimpleEnumerator) ||
            iid.equals(self._Ci.nsISupports))
          return this;
        throw self._Cr.NS_NOINTERFACE;
      }
    }
    if (doInsert) {
      ml.insertSomeBefore(row, unwrapper);
    }
    else {
      ml.addSome(unwrapper);
    }

    var added = ml.length - oldLength;
    this._reportAddedTracks(added, count - added);
  }
]]>
      </body>
    </method>

    <method name="_addExternalFiles">
      <parameter name="dataarray"/>
      <parameter name="row"/>
      <parameter name="orientation"/>
      <body>
      <![CDATA[

        var ml = this.mediaListView.mediaList;
        var library = ml.library;
        var oldLength = ml.length;
        var badEntries = 0;
        
        var ioService = Components.classes["@mozilla.org/network/io-service;1"]
          .getService(Components.interfaces.nsIIOService);

        var items = Components.classes["@mozilla.org/array;1"]
          .createInstance(Components.interfaces.nsIMutableArray);
        var n=0;

        for (var i = 0;i<dataarray.length;i++) {
          var item = dataarray[i][0];
          var datalen = dataarray[i][1];

          var prettyName;
          var url;
          
          if (item instanceof this._Ci.nsIFile) {

            //XXXAus: We probably want to make this scan for media and insert at the correct
            //position in the future, instead of just importing.
                        
            //Skip over directories. The default drop handler will get them for us.
            if(item.isDirectory()) {
              badEntries++;
              continue;
            }
            
            var ioService = Components.classes["@mozilla.org/network/io-service;1"]
                            .getService(Components.interfaces.nsIIOService);
            var fileHandler = ioService.getProtocolHandler("file")
                              .QueryInterface(Components.interfaces.nsIFileProtocolHandler);
            url = fileHandler.getURLSpecFromFile(item);
          } else if (item instanceof this._Ci.nsISupportsString) {
            url = item.QueryInterface(Components.interfaces.nsISupportsString);
            if (url) url = url.toString();
            if (url.toLowerCase().indexOf("http://") < 0) {
              badEntries++;
              continue;
            }
          } else {
            url = ''+item;
            if (url.toLowerCase().indexOf("http://") < 0) {
              badEntries++;
              continue;
            }
          }

          var separator = url.indexOf("\n");
          if (separator != -1) 
          {
            prettyName = url.substr(separator+1);
            url = url.substr(0,separator);
          }

          // Hardcode, skip adding .xpi and .jar files
          if ( /\.(xpi|jar)$/i.test(url) ) {
            badEntries++;
            continue;
          }

          if (getPlatformString() == "Windows_NT") url = url.toLowerCase();

          // skip import of the item if it exists in this library
          var item = this.getFirstItemByProperty(library, "http://songbirdnest.com/data/1.0#contentURL", url);
          if (!item) {
          
            var uri = null;
            try {
              uri = ioService.newURI(url, null, null);
            }
            catch (e) {
              log(e);
              uri = null;
            }
                
            if (!uri) {
              badEntries++;
              continue;
            }
            
            try {
              item = library.createMediaItem(uri);
            }
            catch(e) {
              log(e);
              item = null;
            }
            
            if(!item) {
              badEntries++;
              continue;
            }
            
            var metadataJobMgr = Components.classes["@songbirdnest.com/Songbird/MetadataJobManager;1"]
              .getService(Components.interfaces.sbIMetadataJobManager);
            
            items.appendElement(item, false);
            n++;
          }
          
          if (item) {
            if (ml instanceof this._Ci.sbIOrderableMediaList) {
              var doInsert = false;
              if (orientation == this._Ci.sbIMediaListViewTreeViewObserver.DROP_BEFORE) {
                doInsert = true;
              } else {
                if (row + 1 < oldLength) {
                  row++;
                  doInsert = true;
                }
              }
              if (row >= 0 && doInsert) {
                ml.insertBefore(row, item);
              } else {
                ml.add(item);
              }
            }
          }
        }

        var added = ml.length - oldLength;
        var dups = dataarray.length - added - badEntries;
        
        if (added || dups)
          this._reportAddedTracks(added, dups);
          
        if (n > 0) {
          metadataJobMgr.newJob(items, 5);
          // XXX lone> todo: select items and ensure visible (bug 3879)
        }
        
        ]]>
      </body>
    </method>
    
    <method name="getFirstItemByProperty">
      <parameter name="aMediaList"/>
      <parameter name="aProperty"/>
      <parameter name="aValue"/>
      <body>
        <![CDATA[
          var listener = {
            item: null,
            onEnumerationBegin: function() {
              return true;
            },
            onEnumeratedItem: function(list, item) {
              this.item = item;
              return false;
            },
            onEnumerationEnd: function() {
              return true;
            }
          };
          aMediaList.enumerateItemsByProperty(aProperty,
                                              aValue,
                                              listener,
                                              this._Ci.sbIMediaList.ENUMERATIONTYPE_LOCKING);
          return listener.item;
        ]]>
      </body>
    </method>

    <method name="_reportAddedTracks">
      <parameter name="countAdded"/>
      <parameter name="countAlreadyPresent"/>
      <parameter name="addedToStringOverride"/>
      <body>
<![CDATA[
  var msg = countAdded + " ";

  // Start message with 'xxx added to'... except for 0 ('no tracks added')
  switch (countAdded) {
    case 0:  msg = this._str_notracksaddedto;  break;
    case 1:  msg += this._str_trackaddedto;    break;
    default: msg += this._str_tracksaddedto;   break;
  }

  // Append media list name
  var name = "";
  //XXXlone> HACK, this allows the playlist to report songs dropped for another playlist
  if (addedToStringOverride) {
    name = addedToStringOverride;
  } else {
    try {
      name = this.mediaListView.mediaList.name;
    }
    catch(e) {
      // No name, leave it blank
    }
  }
  
  msg += " " + name;

  // Append the message about already present items (if any)
  if (countAlreadyPresent > 0) {
    msg += " (" + countAlreadyPresent + " ";
    if (countAlreadyPresent == 1) {
      msg += this._str_trackalreadypresent;
    }
    else {
      msg += this._str_tracksalreadypresent;
    }
    msg += ")";
  }

  SBDataSetStringValue("faceplate.status.override.text", "");
  SBDataSetStringValue("faceplate.status.override.text", msg);
  SBDataSetStringValue("faceplate.status.override.style", "font-weight: bold;");
]]>
      </body>
    </method>

    <method name="_pointInTreeRows">
      <parameter name="tree"/>
      <parameter name="mouseX"/>
      <parameter name="mouseY"/>
        <body>
<![CDATA[
  // Make sure the user actually double clicked on a tree cell.
  // Previously this used getCellAt() on the tree, however, it was
  // unreliable.  This code compares the mouse position with the box
  // object of the contaier of the tree's rows (which excludes the
  // column headers and scroll bar)
  var treeRows = document.getAnonymousElementByAttribute(tree, "class", "tree-rows");
  if(!treeRows) {
      return false;
  }
  var treeBodyBox = document.getAnonymousElementByAttribute(treeRows, "class", "tree-bodybox");
  if(!treeBodyBox) {
      return false;
  }
  var bo = treeBodyBox.boxObject;
  if(mouseX >= bo.x && mouseX <= (bo.x + bo.width) &&
     mouseY >= bo.y && mouseY <= (bo.y + bo.height)) {
     return true;
  }
  return false;
]]>
        </body>
      </method>

      <method name="deselectAll">
        <body>
        <![CDATA[
          this.treeView.selection.clearSelection();
        ]]>
        </body>
      </method>

      <method name="_getString">
        <parameter name="name"/>
        <parameter name="defaultValue"/>
        <body>
<![CDATA[
  if (!this._stringbundle) {
    var src = "chrome://songbird/locale/songbird.properties";
    var stringBundleService = this._Cc["@mozilla.org/intl/stringbundle;1"]
                                  .getService(this._Ci.nsIStringBundleService);
    this._stringbundle = stringBundleService.createBundle(src);
  }

  try {
    return this._stringbundle.GetStringFromName(name);
  }
  catch(e) {
    return defaultValue;
  }
]]>
        </body>
      </method>

      <method name="_di">
        <parameter name="o"/>
        <body>
<![CDATA[
 for(var i in this._Ci) {
   try {
     o.QueryInterface(this._Ci[i]);
     dump(i + "\n");
   }
   catch(e) {
   }
 }
]]>
        </body>
      </method>

    <method name="_downloadItem">
      <parameter name="item"/>
      <body>
<![CDATA[
  var ddh = this._Cc["@songbirdnest.com/Songbird/DownloadDeviceHelper;1"]
                    .getService(this._Ci.sbIDownloadDeviceHelper);
  ddh.downloadItem(item);
]]>
        </body>
      </method>

      <!-- Drag and Drop -->
      <method name="_onDragGesture">
        <parameter name="event"/>
        <body>
<![CDATA[
  if (event.target.localName == "treechildren") {
    nsDragAndDrop.startDrag(event, this);
  }
]]>
        </body>
      </method>

      <method name="_onDragOver">
        <parameter name="event"/>
        <body>
<![CDATA[
  if (event.target.localName == "treechildren") {
    nsDragAndDrop.dragOver(event, this);
  }
]]>
        </body>
      </method>

      <method name="_onDragDrop">
        <parameter name="event"/>
        <body>
<![CDATA[
  // Note that drop is handled by the tree observer.  This is so we can know
  // what row and orientation the drop happened at.
  event.stopPropagation();
]]>
        </body>
      </method>

      <method name="_dropOnTree">
        <parameter name="row"/>
        <parameter name="orientation"/>
        <body>
<![CDATA[
  // Note that this is called by our tree observer
  var dnd = this._Cc["@songbirdnest.com/Songbird/DndSourceTracker;1"]
                    .getService(this._Ci.sbIDndSourceTracker);

  var data = this._getTransferDataForFlavor(this._TYPE_X_SB_TRANSFER_MEDIA_ITEM);
  if (data) {
    var context = dnd.getSourceSupports(data)
                     .QueryInterface(this._Ci.sbISingleItemTransferContext);
    this._addItem(context.source, context.item, row, orientation);
    return;
  }

  data = this._getTransferDataForFlavor(this._TYPE_X_SB_TRANSFER_MEDIA_LIST);
  if (data) {
    var context = dnd.getSourceSupports(data)
                     .QueryInterface(this._Ci.sbISingleListTransferContext);
    this._addItem(context.source, context.list, row, orientation);
    return;
  }

  data = this._getTransferDataForFlavor(this._TYPE_X_SB_TRANSFER_MEDIA_ITEMS);
  if (data) {
    var context = dnd.getSourceSupports(data)
                     .QueryInterface(this._Ci.sbIMultipleItemTransferContext);
    this._addItems(context.source, context.items, context.count, row, orientation);
    return;
  }
  
  var array = [];
  data = this._getTransferDataForFlavor("application/x-moz-file", array);
  if (data) {
    this._addExternalFiles(array, row, orientation);
    return;
  }
  
  data = this._getTransferDataForFlavor("text/x-moz-url", array);
  if (data) {
    this._addExternalFiles(array, row, orientation);
    return;
  }
  
  data = this._getTransferDataForFlavor("text/unicode", array);
  if (data) {
    this._addExternalFiles(array, row, orientation);
    return;
  }

  data = this._getTransferDataForFlavor("text/plain", array);
  if (data) {
    this._addExternalFiles(array, row, orientation);
    return;
  }
  
]]>
        </body>
      </method>

      <method name="_getTransferDataForFlavor">
        <parameter name="flavor"/>
        <parameter name="array"/>
        <body>
<![CDATA[
  var dragService = this._Cc["@mozilla.org/widget/dragservice;1"]
                            .getService(this._Ci.nsIDragService);
  var session = dragService.getCurrentSession();

  var nitems = session.numDropItems;
  var r = null;

  if (session.isDataFlavorSupported(flavor)) {

    for (var i=0;i<nitems;i++) {
      var transfer = this._Cc["@mozilla.org/widget/transferable;1"]
                            .createInstance(this._Ci.nsITransferable);

      transfer.addDataFlavor(flavor);
      session.getData(transfer, i);
      var data = {};
      var length = {};
      transfer.getTransferData(flavor, data, length);
      if (!r) r = data.value;
      if (array) array.push([data.value, length.value]);
    }
  }

  return r;
]]>
        </body>
      </method>

      <method name="onDragStart">
        <parameter name="event"/>
        <parameter name="xferData"/>
        <parameter name="dragAction"/> 
        <body>
<![CDATA[
  try {
    var treeView = this.treeView;

    var ml = this.mediaListView.mediaList;
    var numRows = treeView.selectionCount;
    if (numRows == 0) {
      // Nothing selected, dont drag
      throw this._Cr.NS_OK;
    }

    var dnd = this._Cc["@songbirdnest.com/Songbird/DndSourceTracker;1"]
                      .getService(this._Ci.sbIDndSourceTracker);
    dnd.reset();

    xferData.data = new TransferDataSet();
    var data = new TransferData();

    // If only one item is selected, send two flavors
    var self = this;
    if (numRows == 1) {
      var item = treeView.currentMediaItem;
      if (!item) {
        throw this._Cr.NS_OK;
      }

      if (item instanceof this._Ci.sbIMediaList) {
        // If this is a list, send it as both a media item and a media list
        var context = this._getSingleListTransferContext(item, ml);
        var handle = dnd.registerSource(context);
        data.addDataForFlavour(this._TYPE_X_SB_TRANSFER_MEDIA_ITEM, handle);
        data.addDataForFlavour(this._TYPE_X_SB_TRANSFER_MEDIA_LIST, handle);
      }
      else {
        // If this is just a media item, send it only as a media item
        var context = this._getSingleItemTransferContext(item, ml);
        var handle = dnd.registerSource(context);
        data.addDataForFlavour(this._TYPE_X_SB_TRANSFER_MEDIA_ITEM, handle);
      }

    }
    else {
      // We are sending more than one item.  We dont know (or care to find
      // out) if all of the items to be sent are actually lists, so send
      // as items

      // initialize the context to have items
      var context = this._getMultipleItemTransferContext(ml, numRows, treeView);
      context.reset();

      var handle = dnd.registerSource(context);
      data.addDataForFlavour(this._TYPE_X_SB_TRANSFER_MEDIA_ITEMS, handle);
    }

    // Add the url of the item as well
    // XXX: Probably want to make sure that this is a local file that exists
    // before providing this flavor
    //data.addDataForFlavour("text/x-moz-url", item.contentSrc);

    xferData.data.push(data);

    dragAction.action = this._Ci.nsIDragService.DRAGDROP_ACTION_COPY;
  }
  catch(e) {
    // The drag and drop helper swallows exceptions, so report them and
    // rethrow
    if (e.result != this._Cr.NS_OK) {
      Components.utils.reportError(e);
    }
    throw e;
  }
]]>
        </body>
      </method>

      <method name="_getSingleListTransferContext">
        <parameter name="item"/>
        <parameter name="ml"/>
        <body>
<![CDATA[
  function sbSingleListTransferContext(item, ml) {
    this.item   = item;
    this.list   = item;
    this.source = ml;
    this.count  = 1;
  }
  sbSingleListTransferContext.prototype = {
    QueryInterface : function(iid) {
      if (iid.equals(Components.interfaces.sbISingleItemTransferContext) ||
          iid.equals(Components.interfaces.sbISingleListTransferContext) ||
          iid.equals(Components.interfaces.nsISupports))
        return this;
      throw Components.results.NS_NOINTERFACE;
    }
  }
  return new sbSingleListTransferContext(item, ml);
]]>
        </body>
      </method>

      <method name="_getSingleItemTransferContext">
        <parameter name="item"/>
        <parameter name="ml"/>
        <body>
<![CDATA[
  function sbSingleItemTransferContext(item, ml) {
    this.item   = item;
    this.source = ml;
    this.count  = 1;
  }
  sbSingleItemTransferContext.prototype = {
    QueryInterface : function(iid) {
      if (iid.equals(Components.interfaces.sbISingleItemTransferContext) ||
          iid.equals(Components.interfaces.nsISupports))
        return this;
      throw Components.results.NS_NOINTERFACE;
    }
  }
  return new sbSingleItemTransferContext(item, ml);
]]>
        </body>
      </method>

      <method name="_getMultipleItemTransferContext">
        <parameter name="ml"/>
        <parameter name="numRows"/>
        <parameter name="treeView"/>
        <body>
<![CDATA[
  function sbMultipleItemTransferContext(ml, numRows, treeView) {
    this.items     = null;
    this.source    = ml;
    this.count     = numRows;
    this._treeView = treeView;
  }
  sbMultipleItemTransferContext.prototype = {
    reset: function() {
      // fetch a new enumerator (reset it)
      this.items = this._treeView.selectedMediaItems;
    },
    QueryInterface : function(iid) {
      if (iid.equals(Components.interfaces.sbIMultipleItemTransferContext) ||
          iid.equals(Components.interfaces._Ci.nsISupports))
        return this;
      throw Components.results.NS_NOINTERFACE;
    }
  }
  return new sbMultipleItemTransferContext(ml, numRows, treeView);
]]>
        </body>
      </method>

      <method name="canDrop">
        <parameter name="event"/>
        <parameter name="session"/>
        <body>
<![CDATA[
  if (session.isDataFlavorSupported(this._TYPE_X_SB_TRANSFER_MEDIA_ITEM) ||
      session.isDataFlavorSupported(this._TYPE_X_SB_TRANSFER_MEDIA_LIST) ||
      session.isDataFlavorSupported(this._TYPE_X_SB_TRANSFER_MEDIA_ITEMS) ||
      session.isDataFlavorSupported("application/x-moz-file") ||
      session.isDataFlavorSupported("text/unicode") ||
      session.isDataFlavorSupported("text/plain") ||
      session.isDataFlavorSupported("text/x-moz-url")) {
    return true;
  }
  else {
    return false;
  }
]]>
        </body>
      </method>

      <method name="onDragOver">
        <parameter name="event"/>
        <parameter name="flavor"/>
        <parameter name="session"/>
        <body>
<![CDATA[
]]>
        </body>
      </method>
      
      <method name="getSupportedFlavours">
        <body>
<![CDATA[
  var flavorSet = new FlavourSet();
  flavorSet.appendFlavour(this._TYPE_X_SB_MEDIAITEM);
  flavorSet.appendFlavour(this._TYPE_X_SB_MEDIAITEM_ENUMERATOR);
  flavorSet.appendFlavour("application/x-moz-file", "nsIFile");
  flavorSet.appendFlavour("text/x-moz-url");
  flavorSet.appendFlavour("text/unicode");
  return flavorSet;
]]>
        </body>
      </method>

      <method name="_treeKeyNavigate">
        <parameter name="event"/>
        <body><![CDATA[
          // Watch out, 'this' here refers to the tree (_incrementalString and
          // _lastKeyTime are members of the tree).

          var key = String.fromCharCode(event.charCode).toLowerCase();
          if (event.timeStamp - this._lastKeyTime > 500)
            this._incrementalString = key;
          else
            this._incrementalString += key;
          this._lastKeyTime = event.timeStamp;

          var incrementalString = this._incrementalString;

          // Grab our special interface for the lookup.
          var view =
            this.view.QueryInterface(Components.interfaces.sbIMediaListViewTreeView);

          var currentIndex = this.currentIndex;
          var start = 1;

          if (incrementalString.length > 1) {
            start = 0;

            if (currentIndex < 0) {
              currentIndex = 0;
            }
          }

          var index =
            view.getNextRowIndexForKeyNavigation(incrementalString,
                                                 currentIndex + start);

          if (index == -1) {
            index = view.getNextRowIndexForKeyNavigation(incrementalString, 0);
          }
          return index;

        ]]></body>
      </method>

      <!-- sbIPlaylistWidget -->
      <method name="rescanCommands">
        <body>
          // push our usedefaultcommands state because the RemoteAPI only has
          // access to attributes right now and this needs to get to commands
          if (this._commandmenuitems) {
            this._commandmenuitems.usedefault = this.usedefaultcommands;
            this._commandmenuitems.rescanCommands();
          }
          if (this._toolbar) {
            this._toolbar.usedefault = this.usedefaultcommands;
            this._toolbar.rescanCommands();
          }
          if (this._shortcuts) {
            this._shortcuts.usedefault = this.usedefaultcommands;
            this._shortcuts.rescanCommands();
          }
        </body>
      </method>
      
      <method name="_reportError">
        <parameter name="message"/>
        <parameter name="error"/>
        <body>
          <![CDATA[
            dump("*** ERROR: " + message + "\n");
            Components.utils.reportError(message);
            if (error) {
              Components.utils.reportError(error);
            }
          ]]>
        </body>
      </method>

      <method name="_logMessage">
        <parameter name="message"/>
        <body>
          <![CDATA[
            dump("*** " + message + "\n");
            var consoleService =
              Components.classes["@mozilla.org/consoleservice;1"]
                        .getService(Components.interfaces.nsIConsoleService);
            consoleService.logStringMessage(message);
          ]]>
        </body>
      </method>

      <method name="canDrop">
        <parameter name="aIndex"/>
        <parameter name="aOrientation"/>
        <body>
<![CDATA[
  return true;
]]>
        </body>
      </method>

      <method name="drop">
        <parameter name="aIndex"/>
        <parameter name="aOrientation"/>
        <body>
<![CDATA[
  this._dropOnTree(aIndex, aOrientation);
]]>
        </body>
      </method>

      <method name="cycleHeader">
        <parameter name="aCol"/>
        <body>
<![CDATA[
  this._columnSpecIsDirty = true;
]]>
        </body>
      </method>

    </implementation>

    <handlers>
      <handler event="click" clickcount="2" phase="capturing">
        <![CDATA[
          this._onPlaylistDblClick(event);
          event.stopPropagation();
          event.preventDefault();
        ]]>
      </handler>
    </handlers>

  </binding>

</bindings>
