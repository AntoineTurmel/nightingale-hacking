<?xml version="1.0"?>
<!DOCTYPE bindings SYSTEM "chrome://songbird/locale/songbird.dtd">
<!--
/*
//
// BEGIN SONGBIRD GPL
//
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2008 POTI, Inc.
// http://songbirdnest.com
//
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
//
// Software distributed under the License is distributed
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either
// express or implied. See the GPL for the specific language
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
//
// END SONGBIRD GPL
//
 */
-->

<!--
  an addon pane is a place where extensions (and potentially web content) can
  add content for display in a frame, similar to Firefox's sidebar / web panels.
-->
<!--
  WARNING: if you want to remove (or even move) this element dynamically via DOM,
  call destroy() before you do so.
-->

<xbl:bindings
    xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <xbl:binding id="sb-displaypane">
    <!-- a single display pane (with associated title bar) -->
    <xbl:content>
      <vbox flex="1">
        <hbox>
          <hbox class="sb-displaypane-header" flex="1">
            <vbox pack="center">
              <!-- the extra vbox is to make sure the height of the image does not
                   affect the height of the other elements (in particular, the
                   menu button) -->
              <image anonid="icon" class="favicon"/>
            </vbox>
            <label anonid="header" default="&menu.displaypane.title.default;"
                   class="sb-displaypane-label" flex="1"/>
          </hbox>
          <button type="menu" mousethrough="never" class="sb-displaypane-menubutton">
            <menupopup onpopupshowing="return document.getBindingParent(this).buildMenu(event)"
                       anonid="menu">
              <menuitem label="&menu.displaypane.hide;"
                        anonid="menuitem_hide"/>
              <menuseparator/>
              <menuitem label="&menu.displaypane.not-available;"
                        disabled="true" anonid="items_none"/>
              <menuitem label="&menu.displaypane.recommended;"
                        disabled="true" anonid="items_recommended"/>
              <dummy anonid="items_recommended_start"/>
              <dummy anonid="items_recommended_end"/>
              <menu label="&menu.displaypane.other;" anonid="items_all">
                <menupopup anonid="items_all">
                  <dummy anonid="items_all_start"/>
                  <dummy anonid="items_all_end"/>
                </menupopup>
              </menu>
              <menuseparator/>
              <!--
              <menu label="&menu.displaypane.title;">
                <menupopup anonid="title_popup">
                  <menuitem label="&menu.displaypane.title.show;" type="radio" value=""/>
                  <menuitem label="&menu.displaypane.title.auto;" type="radio"/>
                  <menuitem label="&menu.displaypane.title.hide;" type="radio"/>
                </menupopup>
              </menu>
              <menuseparator/>
              -->
              <menuitem label="&menu.displaypane.get;" oncommand="onMenu(this)"
                        value="songbird.url.addons"/>
            </menupopup>
          </button>
        </hbox>
        <browser anonid="content" flex="1" type="chrome" disablehistory="true"
                 xbl:inherits="orient"/>
      </vbox>
    </xbl:content>
    
    <xbl:implementation implements="sbIDisplayPaneInstantiator">
      <xbl:constructor><![CDATA[
      try{
        this._lastURL = Components.classes["@songbirdnest.com/Songbird/DataRemote;1"]
                                  .createInstance(Components.interfaces.sbIDataRemote);
	// if the stateid attribute doesn't exist, fall back to id.
	// (and if that fails too, use contentGroup)
	var stateid = this.getAttribute("stateid") ||
	              this.id ||
		      this.contentGroup;
        this._lastURL.init("displayPanes." + stateid + ".lastURL", null);

        // do not register until our browser is ready
        var paneMgr = Components.classes["@songbirdnest.com/Songbird/DisplayPane/Manager;1"]
                                .getService(Components.interfaces.sbIDisplayPaneManager);
        setTimeout(function(self) {
          paneMgr.registerInstantiator(self);
        }, 0, this);

        // load the last opened URL
        var paneLoaded = false;
        if (this._lastURL.stringValue) {
          var paneinfo = paneMgr.getPaneInfo(this._lastURL.stringValue);
          if (paneinfo) {
            // hide the pane as soon as possible if the url is about:blank
            if (paneinfo.contentUrl == "about:blank") {
              this._hidden = true;
            }
            setTimeout(function(self){
              // need to give the <browser> time to initialize
              self._internalLoadURL(paneinfo);
            }, 0, this);
            paneLoaded = true;
          }
        } else {
          // hide the pane as soon as possible if we dont have a lasturl to load
          this._hidden = true;
        }

        if (!paneLoaded) {
          if ("undefined" != typeof(OverlayLoader)) {
            // if the extension is being registered via windowtype overlays, it
            // can show up later.  Wait for that to happen and try again.
            if (OverlayLoader.loadCompleted) {
              // over loads are done; nothing we can do.
              this.hide();
            } else {
              // there are more overlays to load; wait for them to be done
              var self = this;
              document.addEventListener("sb-overlay-load", function() {
                document.removeEventListener("sb-overlay-load", arguments.callee, false);
                var paneinfo = paneMgr.getPaneInfo(self._lastURL.stringValue);
                if (paneinfo) {
                  self._internalLoadURL(paneinfo);
                } else {
                  // still nothing
                  self.hide();
                }
              }, false);
            }
          } else {
            // there's no overlay loader, so there's no more chance for us to do anything
            this.hide();
          }
        }
      } catch(e) {
        Components.utils.reportError(e);
      }
      ]]></xbl:constructor>
      <xbl:destructor><![CDATA[
        this.destroy();
      ]]></xbl:destructor>
      <xbl:property name="contentGroup" readonly="true">
        <xbl:getter><![CDATA[
          return this.getAttribute("contentgroup");
        ]]></xbl:getter>
      </xbl:property>
      <xbl:property name="contentUrl" readonly="true">
        <xbl:getter><![CDATA[
          var elem = document.getAnonymousElementByAttribute(this, "anonid", "content");
          if (!elem || !elem.currentURI)
            return null;
          return elem.currentURI.spec;
        ]]></xbl:getter>
      </xbl:property>
      <xbl:property name="contentTitle">
        <xbl:getter><![CDATA[
          var elem = document.getAnonymousElementByAttribute(this, "anonid", "header");
          return elem.value;
        ]]></xbl:getter>
        <xbl:setter><![CDATA[
          var elem = document.getAnonymousElementByAttribute(this, "anonid", "header");
          return elem.value = val;
        ]]></xbl:setter>
      </xbl:property>
      <xbl:property name="contentIcon">
        <xbl:getter><![CDATA[
          var elem = document.getAnonymousElementByAttribute(this, "anonid", "icon");
          return elem.src;
        ]]></xbl:getter>
        <xbl:setter><![CDATA[
          var elem = document.getAnonymousElementByAttribute(this, "anonid", "icon");
          elem.collapsed = (val.length < 1);
          return elem.src = val;
        ]]></xbl:setter>
      </xbl:property>
      <xbl:property name="popup" readonly="true">
        <xbl:getter><![CDATA[
          this.buildMenu();
          var popup = document.getAnonymousElementByAttribute(this, "anonid", "menu");
          popup = popup.cloneNode(true);
          popup.removeAttribute("onpopupshowing");
          return popup;
        ]]></xbl:getter>
      </xbl:property>
      <xbl:property name="collapsed">
        <xbl:getter><![CDATA[
          return this.hasAttribute("collapsed");
        ]]></xbl:getter>
        <xbl:setter><![CDATA[
          if (val) {
            this.setAttribute("collapsed", true);
          } else {
            this.removeAttribute("collapsed");
            if (this._hidden)
              this._hidden = false;
          }
          return val;
        ]]></xbl:setter>
      </xbl:property>
      <xbl:property name="_splitter">
        <xbl:getter><![CDATA[
          if (!this.hasAttribute("splitter"))
            return null;
          return document.getElementById(this.getAttribute("splitter"));
        ]]></xbl:getter>
      </xbl:property>      <xbl:property name="_hidden">
        <xbl:getter><![CDATA[
          var splitter = this._splitter;
          if (!splitter)
            return false;
          return splitter.hasAttribute("collapsed");
        ]]></xbl:getter>
        <xbl:setter><![CDATA[
          var splitter = this._splitter;
          if (splitter) {
            if (val) {
              splitter.setAttribute("collapsed", true);
            } else {
              splitter.removeAttribute("collapsed");
            }
          }
          document.getAnonymousElementByAttribute(this, "anonid", "menuitem_hide")
                  .collapsed = val;
          document.getAnonymousElementByAttribute(this, "anonid", "menuitem_hide")
                  .nextSibling.collapsed = val;
          if (val != this.collapsed)
            this.collapsed = val;
          // remember to clear the pane so we don't load it on next start
          try {
            this._getElem("content").loadURI("about:blank", null, null);
          } catch (e) {
            /* don't really care */
          }
          this._lastURL.stringValue = "";
          return val;
        ]]></xbl:setter>
      </xbl:property>
      <xbl:method name="buildMenu">
        <xbl:parameter name="aEvent"/>
        <xbl:body><![CDATA[
        try{
          // eagerly build the whole menu, since we need to loop through the whole
          // list anyway

          if (aEvent && aEvent.originalTarget.getAttribute("anonid") != "menu") {
            // this is a sub-menu even bubbling up
            return true;
          }
          
          // set the static commands
          this._getElem("menuitem_hide").setAttribute("oncommand",
                                                      "document.getElementById('" + this.id + "').hide()");
          
          var startRecommend = this._getElem("items_recommended_start");
          var endRecommend = this._getElem("items_recommended_end");
          var startAll = this._getElem("items_all_start");
          var endAll = this._getElem("items_all_end");
          
          // remove the previously made items
          while (startRecommend.nextSibling && startRecommend.nextSibling != endRecommend) {
            startRecommend.parentNode.removeChild(startRecommend.nextSibling);
          }
          while (startAll.nextSibling && startAll.nextSibling != endAll) {
            startAll.parentNode.removeChild(startAll.nextSibling);
          }
          
          // find the items
          var paneMgr = Components.classes["@songbirdnest.com/Songbird/DisplayPane/Manager;1"]
                                  .getService(Components.interfaces.sbIDisplayPaneManager);
          var recommended = [];
          var all = [];
          var enumerator = paneMgr.contentList;
          var contentGroup = this.contentGroup.toUpperCase();
          while (enumerator.hasMoreElements()) {
            var item = enumerator.getNext();
            item.QueryInterface(Components.interfaces.sbIDisplayPaneContentInfo);
            var isRecommended = false;
            var itemGroups = item.suggestedContentGroups.toUpperCase();
            if (itemGroups.split(";").indexOf(contentGroup) != -1) {
              recommended.push(item);
            } else {
              all.push(item);
            }
          }
          
          // sort by title
          function addonPaneSorter(x, y) {
            if (x.contentTitle < y.contentTitle) return -1;
            if (y.contentTitle < x.contentTitle) return 1;
            return 0;
          }
          
          // actually generate the menu items
          function buildList(aEndMarker, aArray, aBinding, aHeader) {
            aArray.sort(addonPaneSorter);
            for each (var item in aArray) {
              var elem = document.createElement("menuitem");
              elem.setAttribute("label", item.contentTitle);
              elem.setAttribute("url", item.contentUrl);
              elem.setAttribute("type", "radio")
              if (item.contentUrl == aBinding.contentUrl) {
                elem.setAttribute("checked", true);
              }
              // since the menu item can be cloned, we embed an oncommand
              // that carries enough information to call this binding again
              // with the menu item being used.  This is unfortunately quite ugly.
              var oncommand = function(aEvent, aId) {
                var binding = document.getElementById(aId);
                var menuitem = aEvent.target;
                var paneMgr = Components.classes["@songbirdnest.com/Songbird/DisplayPane/Manager;1"]
                                        .getService(Components.interfaces.sbIDisplayPaneManager);
                var paneinfo = paneMgr.getPaneInfo(menuitem.getAttribute("url"));
                binding.loadContent(paneinfo);
              }
              elem.setAttribute("oncommand",
                                "(" + uneval(oncommand) + ")(event, '" + aBinding.id + "')");
              aEndMarker.parentNode.insertBefore(elem, aEndMarker);
            }
            aBinding._getElem(aHeader).collapsed = (aArray.length < 1);
          }
          buildList(endRecommend, recommended, this, "items_recommended");
          buildList(endAll, all, this, "items_all");
	  // show the "None" header if we have exactly zero items
	  this._getElem("items_none").collapsed = (recommended.length + all.length > 0);
        } catch(e) {
          Components.utils.reportError(e);
        }
        ]]></xbl:body>
      </xbl:method>
      <xbl:method name="loadContent">
        <xbl:parameter name="aPaneInfo"/>
        <xbl:body><![CDATA[
        try{
          if (this.contentUrl == aPaneInfo.contentUrl) {
            this.collapsed = false;
            return;
          }
          this._internalLoadURL(aPaneInfo);
          
          // XXX Mook: getComputedStyle for -moz-box-orient lies, see BMO 216838
          // and yes, xul attributes override CSS :(
          var orient = getComputedStyle(this, "").MozBoxOrient;
          if (this.hasAttribute("orient"))
            orient = this.getAttribute("orient");
          if (orient == "vertical") {
            this.width = aPaneInfo.defaultWidth;
            this.collapsed = false;
          } else {
            this.height = aPaneInfo.defaultHeight;
            this.collapsed = false;
          }
        } catch(e) {
          Components.utils.reportError(e);
        }
        ]]></xbl:body>
      </xbl:method>
      <xbl:method name="_internalLoadURL">
        <!-- this loads a content URL without sizing anything -->
        <xbl:parameter name="aPaneInfo"/>
        <xbl:body><![CDATA[
        try{
          this._hidden = (aPaneInfo.contentUrl == "about:blank");
          this._getElem("content").loadURI(aPaneInfo.contentUrl, null, null);
          var header = this._getElem("header");
          this.contentTitle = aPaneInfo.contentTitle || header.getAttribute("default");
          this.contentIcon = aPaneInfo.contentIcon;
          
          // save the last loaded URL
          this._lastURL.stringValue = aPaneInfo.contentUrl;
        } catch(e) {
          Components.utils.reportError(e);
        }
        ]]></xbl:body>
      </xbl:method>
      <xbl:method name="hide">
        <xbl:body><![CDATA[
          this._hidden = true;
        ]]></xbl:body>
      </xbl:method>
      <xbl:method name="_getElem">
        <xbl:parameter name="aId"/>
        <xbl:body><![CDATA[
          return document.getAnonymousElementByAttribute(this, "anonid", aId);
        ]]></xbl:body>
      </xbl:method>
      <xbl:method name="destroy">
        <xbl:body><![CDATA[
          var paneMgr = Components.classes["@songbirdnest.com/Songbird/DisplayPane/Manager;1"]
                                  .getService(Components.interfaces.sbIDisplayPaneManager);
          paneMgr.unregisterInstantiator(this);
        ]]></xbl:body>
      </xbl:method>
    </xbl:implementation>
    
    <xbl:handlers>
    </xbl:handlers>
  </xbl:binding>
  <xbl:binding id="sb-displaypane-menuitems">
    <!-- the placeholder for the menu items in the view menu -->
    <xbl:implementation implements="nsIDOMEventListener">
      <xbl:constructor><![CDATA[
        this._items = [];
        this.parentNode.addEventListener("popupshowing", this, false);
        this.handleEvent(null);
      ]]></xbl:constructor>
      <xbl:method name="handleEvent">
        <xbl:parameter name="aEvent"/>
        <xbl:body><![CDATA[
        try{
          if (aEvent && aEvent.originalTarget != this.parentNode) {
            // this was being bubbled up; ignore
            return;
          }
          var item;
          while ((item = this._items.pop())) {
            this.parentNode.removeChild(item);
          }
            
          var paneMgr = Components.classes["@songbirdnest.com/Songbird/DisplayPane/Manager;1"]
                                  .getService(Components.interfaces.sbIDisplayPaneManager);
          var enumerator = paneMgr.instantiatorsList;
          if (enumerator.hasMoreElements()) {
          
            // do we really need a separator?
            var sib = this.previousSibling;
            do {
              if (sib == null || sib.localName == "menuseparator") {
                // no separator required
                break;
              }
              if (sib.localName == "menuitem") {
                // insert a separator between elements
                var sep = document.createElement("menuseparator");
                this.parentNode.insertBefore(sep, this);
                this._items.push(sep);
                break;
              
              }
            } while(sib = sib.previousSibling);
            
          }
          while (enumerator.hasMoreElements()) {
            var instantiator = enumerator.getNext();
            instantiator.QueryInterface(Components.interfaces.sbIDisplayPaneInstantiator);
            instantiator.QueryInterface(Components.interfaces.nsIDOMXULElement);
            item = document.createElement("menu");
            var label = instantiator.contentGroup;
            if (instantiator.hasAttribute("label")) {
              label = instantiator.getAttribute("label");
            }
            item.setAttribute("label", label);
            item.setAttribute("target", instantiator.id);
            item.className = "menu-iconic displaypane-topmenu";

            var popup = instantiator.popup;
            item.appendChild(document.importNode(popup, true));
            this.parentNode.insertBefore(item, this);
            this._items.push(item);
          }
        } catch(e) {
          Components.utils.reportError(e);
        }
        ]]></xbl:body>
      </xbl:method>
    </xbl:implementation>
  </xbl:binding>
</xbl:bindings>
