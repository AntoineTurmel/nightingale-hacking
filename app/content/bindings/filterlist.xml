<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright© 2006 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the “GPL”).
// 
// Software distributed under the License is distributed 
// on an “AS IS” basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="filterlist">
    <content>
      <xul:tree 
        xbl:inherits="enableColumnDrag=enableColumnDrag,hidecolumnpicker=hidecolumnpicker" 
        id="filter_tree" 
        ref="" 
        datasources="" 
        flags="dont-build-content"
        flex="1" 
      >
      </xul:tree>
    </content>

   <implementation type="application/x-javascript" implements="nsIXULBuilderListener">

    <constructor>
      this.tree.builder.addListener(this);
      var src = "chrome://songbird/locale/songbird.properties";
      var stringBundleService = Components.classes["@mozilla.org/intl/stringbundle;1"].getService(Components.interfaces.nsIStringBundleService);
      var stringbundle = stringBundleService.createBundle( src );
      this.oneitem = "item";
      this.manyitems = "items";
      this.noitem = "no items";
      try {
        this.oneitem = stringbundle.GetStringFromName( "library.oneitem" );
        this.manyitems = stringbundle.GetStringFromName( "library.manyitems" );
        this.noitem = stringbundle.GetStringFromName( "library.noitem" );
      } catch (e) {
        /* we have defaults */
      }
    </constructor>

    <destructor>
      this.tree.builder.removeListener(this);
    </destructor>

    <field name="tree">document.getAnonymousElementByAttribute(this, 'id', 'filter_tree');</field>
    <field name="source">null</field>
    <field name="playlist">null</field>
    <field name="builder">this.tree.builder</field>
    <field name="column"></field>
    <field name="ref_pl"></field>
    <field name="index">0</field>
    <field name="rebuildPending">false</field>
    <field name="savedCurrentIndex">0</field>
    <field name="savedShiftSelectPivot">-1</field>

    <property name="ref">
      <getter>
        return this.tree.getAttribute("ref");
      </getter>
      <setter>
        return this.tree.setAttribute("ref", val);
      </setter>
    </property>

    <property name="datasources">
      <getter>
        return this.tree.getAttribute("datasources");
      </getter>
      <setter>
        return this.tree.setAttribute("datasources", val);
      </setter>
    </property>

    <!--
      Concatenate all of the selections into a semicolon delimited filter string
    -->
    <property name="filterString">
      <getter>
      <![CDATA[
      var rangeCount = this.tree.view.selection.getRangeCount();

      var filter_string = "";

      var column = this.tree.columns.getColumnAt(0);
      for ( var i=0; column != null && i < rangeCount; i++ )
      {
        var start = {};
        var end = {};
        this.tree.view.selection.getRangeAt( i, start, end );
        for( var c = start.value; c <= end.value; c++ )
        {
          // Check for stupid things.
          if ( c >= this.tree.view.rowCount )
            break; // WTF?
          // Zero is "All" which is always an empty filter string
          if( c == 0 )
            return "";
          filter_string += ";" + this.tree.view.getCellText( c, column );
        }
      }
      return filter_string;
      ]]>
      </getter>
      <setter>
      <![CDATA[
      var tvs = this.tree.view.selection;
      try {
        tvs.selectEventsSuppressed = true;
        tvs.clearSelection();

        if (val != null) {
          var selection = val.split(";");
          var column = this.tree.columns.getColumnAt(0);

          // Build an array of tree indexes that are going to be selected
          var indexList = [];
          selection.forEach(function(value) {
            var i = this.findCell(column, value);
            if(i > 0) {
              indexList.push(i);
            }
          }, this);

          if(indexList.length > 0) {
            tvs.currentIndex = this.savedCurrentIndex;

            // If there is a saved shift select pivot and the selection is
            // continuous, use rangedSelect() to select the rows, which will
            // restore the shift select pivot
            var didRangedSelect = false;
            if(this.savedShiftSelectPivot >= 0) {

              // You need a sort function to sort numerically
              indexList.sort(function(a, b) {
               return a - b
              });
              var first = indexList[0];
              var last  = indexList[indexList.length - 1];
              if(last - first + 1 == indexList.length) {

                // rangedSelect() sets the shift select pivot to the first row
                // in the selection.  Reverse the parameters to restore the saved
                // shift select pivot properly.  If the data has moved away from
                // the saved shift select pivot, revert to a normal selection.
                if(this.savedShiftSelectPivot == last) {
                  tvs.rangedSelect(last, first, true);
                  didRangedSelect = true;
                }
                else if(this.savedShiftSelectPivot == first) {
                  tvs.rangedSelect(first, last, true);
                  didRangedSelect = true;
                }
              }
            }

            // If we didn't do a ranged select, do a normal selection
            if(!didRangedSelect) {
              indexList.forEach(function(idx) {
                tvs.toggleSelect(idx);
              }, this);
            }

          }
          else {
            // Nothing was selected so select the "All" row
            tvs.toggleSelect(0);
            tvs.currentIndex = 0;
          }
        }
      }
      finally {
        tvs.selectEventsSuppressed = false;
      }
      ]]>
      </setter>
    </property>

    <!-- Dynamic Columns/Template -->

    <method name="loadcolumn">
      <body>
      try
      {
        if (this.source == null || this.ref == null) 
          return;
          
        this.removeColumns();
        this.removeTemplate(); 
        this.addNewContent(this.source, this.ref);
      }
      catch( err )
      {
        alert( err );
      }
      </body>
    </method>

    <method name="addNewContent">
      <parameter name="source"/>
      <parameter name="ref"/>
      <body>
        <![CDATA[

          // Columns nodes parent
          var columns_node = document.createElement("treecols");

          // Template nodes parents
          var template_node = document.createElement("template");

          var rule_node = document.createElement("rule");

          var treechildren_node = document.createElement("treechildren");
          treechildren_node.setAttribute("flex", "1");

          var treeitem_node = document.createElement("treeitem");
          treeitem_node.setAttribute("uri", "rdf:*");

          var treerow_node = document.createElement("treerow");

          // Fill in the necessary information for the tree column.
          var name = "" + this.column;
          if ( name.length )
          {
            var this_column_node = document.createElement("treecol");
            this_column_node.setAttribute("id", name);

            // Try to load the data
            var src = "chrome://songbird/locale/songbird.properties";
            var stringBundleService =
                Components.classes["@mozilla.org/intl/stringbundle;1"]
                .getService(Components.interfaces.nsIStringBundleService);
                
            var bundle = stringBundleService.createBundle( src );
            var human_name = name;
            var meta_name = name;
            try
            {
              meta_name = bundle.GetStringFromName( "metadata." + name );
            }
            catch( err )
            {
            }
            if ( meta_name && meta_name.length )
            {
              human_name = meta_name;
            }

            // This is not good, we should get the properties of each column from the db too !

            this_column_node.setAttribute("label", human_name);
            this_column_node.__filterlist_original_label__ = human_name;
            this_column_node.setAttribute("flex", "1");
            this_column_node.setAttribute("fixed", "false");
//            this_column_node.setAttribute("sortActive", "true");
//            this_column_node.setAttribute("sortDirection","ascending");
//            this_column_node.setAttribute("sort", "rdf:http://home.netscape.com/NC-rdf#" + name);

            columns_node.appendChild(this_column_node);

            var treecell_node = document.createElement("treecell");
            treecell_node.setAttribute("label", "rdf:http://home.netscape.com/NC-rdf#"+name);
            treerow_node.appendChild(treecell_node);
          }

          // Now add columns and template node hierarchy to the tree
          this.tree.insertBefore(columns_node, null);

          treeitem_node.appendChild(treerow_node); 
          treechildren_node.appendChild(treeitem_node);
          rule_node.appendChild(treechildren_node);
          template_node.appendChild(rule_node);
          this.tree.appendChild(template_node);
        ]]>
      </body>
    </method> 

    <!-- Selection/Filter handling -->

    <method name="onFilterListSelect">
      <body>
        <![CDATA[
          // Ignore select events while we're rebuilding
          if(this.rebuildPending) {
            return;
          }

          if (this.source == null) { alert("<filterlist/>: source is null"); return; }
          
          var filter_string = this.filterString;

          this.source.setFilter( this.ref_pl, this.index, filter_string, this.ref, this.column );
          this.source.executeFeed( this.ref_pl );

          // Fire an event, in case someone wants it          
          var e = document.createEvent("Events");
          e.initEvent("filterlist-filterchange", false, true);
          this.dispatchEvent(e);
        ]]>
      </body>
    </method> 

    <!-- Tree Manipulation Functions -->

    <method name="removeColumns">
      <body>
          this.removeChildByName("treecols");
      </body>
    </method>

    <method name="removeTemplate">
      <body>
          this.removeChildByName("template");
      </body>
    </method>

    <method name="removeChildByName">
      <parameter name="childname"/>
      <body>
        <![CDATA[
          var n = this.tree.childNodes.length;
          for (var i=0;i<this.tree.childNodes.length;i++) {
            var node = this.tree.childNodes.item(i);
            if (node.tagName == childname ||
                node.tagName == "xul:"+childname) {
              this.tree.removeChild(node);
              i--;
            }
          }
        ]]>
      </body>
    </method>
    
    <!-- Selection restore -->
    <method name="findCell">
      <parameter name="column"/>
      <parameter name="value"/>
      <body>
        <![CDATA[
          try
          {
            var n = this.tree.view.rowCount;
            for( var c = 0; c < n; c++ )
            {
              var cell = this.tree.view.getCellText( c, column );
              if (cell == value) return c;
            }
          }
          catch( err )
          {
            alert( err );
          }
          return -1;
        ]]>
      </body>
    </method>

    <!-- nsIXULBuilderListener implementation -->

    <method name="willRebuild">
      <param name="builder"/>
      <body>
        if (this.ref != null) this.loadcolumn();
        this.rebuildPending = true;
        this.savedCurrentIndex = this.tree.view.selection.currentIndex;
        this.savedShiftSelectPivot = this.tree.view.selection.shiftSelectPivot;
      </body>
    </method>

    <method name="didRebuild">
      <param name="builder"/>
      <body>
        <![CDATA[
        if (this.tree.view.rowCount > 0) {
          var column = this.tree.columns.getColumnAt(0);
          if (column != null) {
            var label = column.element.__filterlist_original_label__;
            if ( this.source.getRefColumnCount( this.ref ) > 0 ) {
              label += " (" + (this.tree.view.rowCount-1) + " ";
              if (this.tree.view.rowCount > 2) label += this.manyitems; // > 2 because we subtract 1 for 'All'
              else label += this.oneitem;
              label += ")";
            } else label += " (" + this.noitem + ")";
            column.element.setAttribute("label", label);
          }
        }
        var requestedFilterString = this.source.getFilter(this.ref_pl, this.index);;
        this.filterString = requestedFilterString;
        this.rebuildPending = false;

        // If the filter string is non-empty but "All" is selected, none of the
        // filter items exist any more.  Call onFilterListSelect() to update
        // the filter results to "All"
        if(requestedFilterString != "" && this.tree.view.selection.isSelected(0)) {
          this.onFilterListSelect();
        }
        ]]>
      </body>
    </method>

   </implementation> 

    <handlers>
      <handler event="select">
        this.onFilterListSelect();
      </handler>
    </handlers>

  </binding>

</bindings>
