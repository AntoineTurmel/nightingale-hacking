<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright© 2006 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the “GPL”).
// 
// Software distributed under the License is distributed 
// on an “AS IS” basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="filterlist">
    <content>
      <xul:tree 
        xbl:inherits="enableColumnDrag=enableColumnDrag,hidecolumnpicker=hidecolumnpicker" 
        id="filter_tree" 
        ref="" 
        datasources="" 
        flags="dont-build-content"
        flex="1" 
      >
      </xul:tree>
    </content>

   <implementation type="application/x-javascript" implements="nsIXULBuilderListener">

    <constructor>
      this.tree.builder.addListener(this);
      var src = "chrome://songbird/locale/songbird.properties";
      var stringBundleService = Components.classes["@mozilla.org/intl/stringbundle;1"].getService(Components.interfaces.nsIStringBundleService);
      var stringbundle = stringBundleService.createBundle( src );
      this.oneitem = "item";
      this.manyitems = "items";
      this.noitem = "no item";
      try {
        this.oneitem = stringbundle.GetStringFromName( "library.oneitem" );
        this.manyitems = stringbundle.GetStringFromName( "library.manyitems" );
        this.noitem = stringbundle.GetStringFromName( "library.noitem" );
      } catch (e) {
        /* we have defaults */
      }
    </constructor>

    <destructor>
      this.tree.builder.removeListener(this);
    </destructor>

    <field name="tree">document.getAnonymousElementByAttribute(this, 'id', 'filter_tree');</field>
    <field name="source">null</field>
    <field name="playlist">null</field>
    <field name="builder">this.tree.builder</field>
    <field name="column"></field>
    <field name="ref_pl"></field>
    <field name="index">0</field>
    <field name="rebuildPending">false</field>
    <field name="needsSelectionReset">false</field>

    <property name="ref">
      <getter>
        return this.tree.getAttribute("ref");
      </getter>
      <setter>
        return this.tree.setAttribute("ref", val);
      </setter>
    </property>

    <property name="datasources">
      <getter>
        return this.tree.getAttribute("datasources");
      </getter>
      <setter>
        return this.tree.setAttribute("datasources", val);
      </setter>
    </property>

    <!--
      Concatenate all of the selections into a semicolon delimited filter string
      Returns value of empty string means ALL, null means nothing selected
    -->
    <property name="filterString">
      <getter>
      <![CDATA[
      var rangeCount = this.tree.view.selection.getRangeCount();
      if ( rangeCount == 0 )
        return null;

      var filter_string = "";

      var column = this.tree.columns.getColumnAt(0);
      for ( var i=0; column != null && i < rangeCount; i++ )
      {
        var start = {};
        var end = {};
        this.tree.view.selection.getRangeAt( i, start, end );
        for( var c = start.value; c <= end.value; c++ )
        {
          // Check for stupid things.
          if ( c >= this.tree.view.rowCount )
            break; // WTF?
          // Zero is "All" which is always an empty filter string
          if( c == 0 )
            return "";
          filter_string += ";" + this.tree.view.getCellText( c, column );
        }
      }
      return filter_string;
      ]]>
      </getter>
      <setter>
      <![CDATA[
      try {
        this.tree.view.selection.selectEventsSuppressed = true;
        var any_items = false; // Are there any items to find?
        var any_found = false; // Did we find any?
        var selection_string = val
        if (selection_string != null) {
          var selection = selection_string.split(";");
          var column = this.tree.columns.getColumnAt(0);
          while (selection.length > 0) {
            var value = selection.pop();
            if (value != "" && value != null) {
              any_items = true;
              var vindex = this.findCell(column, value);
              if (vindex != -1) {
                any_found = true;
                this.tree.view.selection.rangedSelect(vindex, vindex, true);
              }
            }
          }
        }
        // If we weren't able to restore any of our previous selection
        if ( any_items && ! any_found ) { 
          // Reset the selection to "All" when you're back to a place where
          // setting the selection would do anything.
          this.needsSelectionReset = true;
        } // This can happen when we delete all the tracks of a filter
      }
      finally {
        this.tree.view.selection.selectEventsSuppressed = false;
      }
      ]]>
      </setter>
    </property>

    <!-- Dynamic Columns/Template -->

    <method name="loadcolumn">
      <body>
      try
      {
        if (this.source == null || this.ref == null) 
          return;
          
        this.removeColumns();
        this.removeTemplate(); 
        this.addNewContent(this.source, this.ref);
      }
      catch( err )
      {
        alert( err );
      }
      </body>
    </method>

    <method name="addNewContent">
      <parameter name="source"/>
      <parameter name="ref"/>
      <body>
        <![CDATA[

          // Columns nodes parent
          var columns_node = document.createElement("treecols");

          // Template nodes parents
          var template_node = document.createElement("template");

          var rule_node = document.createElement("rule");

          var treechildren_node = document.createElement("treechildren");
          treechildren_node.setAttribute("flex", "1");

          var treeitem_node = document.createElement("treeitem");
          treeitem_node.setAttribute("uri", "rdf:*");

          var treerow_node = document.createElement("treerow");

          // Fill in the necessary information for the tree column.
          var name = "" + this.column;
          if ( name.length )
          {
            var this_column_node = document.createElement("treecol");
            this_column_node.setAttribute("id", name);

            // Try to load the data
            var src = "chrome://songbird/locale/songbird.properties";
            var stringBundleService =
                Components.classes["@mozilla.org/intl/stringbundle;1"]
                .getService(Components.interfaces.nsIStringBundleService);
                
            var bundle = stringBundleService.createBundle( src );
            var human_name = name;
            var meta_name = name;
            try
            {
              meta_name = bundle.GetStringFromName( "metadata." + name );
            }
            catch( err )
            {
            }
            if ( meta_name && meta_name.length )
            {
              human_name = meta_name;
            }

            // This is not good, we should get the properties of each column from the db too !

            this_column_node.setAttribute("label", human_name);
            this_column_node.__filterlist_original_label__ = human_name;
            this_column_node.setAttribute("flex", "1");
            this_column_node.setAttribute("fixed", "false");
//            this_column_node.setAttribute("sortActive", "true");
//            this_column_node.setAttribute("sortDirection","ascending");
//            this_column_node.setAttribute("sort", "rdf:http://home.netscape.com/NC-rdf#" + name);

            columns_node.appendChild(this_column_node);

            var treecell_node = document.createElement("treecell");
            treecell_node.setAttribute("label", "rdf:http://home.netscape.com/NC-rdf#"+name);
            treerow_node.appendChild(treecell_node);
          }

          // Now add columns and template node hierarchy to the tree
          this.tree.insertBefore(columns_node, null);

          treeitem_node.appendChild(treerow_node); 
          treechildren_node.appendChild(treeitem_node);
          rule_node.appendChild(treechildren_node);
          template_node.appendChild(rule_node);
          this.tree.appendChild(template_node);
        ]]>
      </body>
    </method> 

    <!-- Selection/Filter handling -->

    <method name="onFilterListSelect">
      <body>
        <![CDATA[
          // Ignore select events while we're rebuilding
          if(this.rebuildPending) {
            return;
          }

          if (this.source == null) { alert("<filterlist/>: source is null"); return; }
          
          var filter_string = this.filterString;
          var current_filter_string =  this.source.getFilter(this.ref_pl, this.index);

          this.source.setFilter( this.ref_pl, this.index, filter_string, this.ref, this.column );
          this.source.executeFeed( this.ref_pl );

          // Fire an event, in case someone wants it          
          var e = document.createEvent("Events");
          e.initEvent("filterlist-filterchange", false, true);
          this.dispatchEvent(e);
        ]]>
      </body>
    </method> 

    <!-- Tree Manipulation Functions -->

    <method name="removeColumns">
      <body>
          this.removeChildByName("treecols");
      </body>
    </method>

    <method name="removeTemplate">
      <body>
          this.removeChildByName("template");
      </body>
    </method>

    <method name="removeChildByName">
      <parameter name="childname"/>
      <body>
        <![CDATA[
          var n = this.tree.childNodes.length;
          for (var i=0;i<this.tree.childNodes.length;i++) {
            var node = this.tree.childNodes.item(i);
            if (node.tagName == childname ||
                node.tagName == "xul:"+childname) {
              this.tree.removeChild(node);
              i--;
            }
          }
        ]]>
      </body>
    </method>
    
    <!-- Selection restore -->
    <method name="findCell">
      <parameter name="column"/>
      <parameter name="value"/>
      <body>
        <![CDATA[
          try
          {
            var n = this.tree.view.rowCount;
            for( var c = 0; c < n; c++ )
            {
              var cell = this.tree.view.getCellText( c, column );
              if (cell == value) return c;
            }
          }
          catch( err )
          {
            alert( err );
          }
          return -1;
        ]]>
      </body>
    </method>

    <!-- nsIXULBuilderListener implementation -->

    <method name="willRebuild">
      <param name="builder"/>
      <body>
        if (this.ref != null) this.loadcolumn();
        this.rebuildPending = true;
      </body>
    </method>

    <method name="didRebuild">
      <param name="builder"/>
      <body>
        if (this.tree.view.rowCount > 0) {
          var column = this.tree.columns.getColumnAt(0);
          if (column != null) {
            var label = column.element.__filterlist_original_label__;
            if ( this.source.getRefColumnCount( this.ref ) > 0 ) {
              label += " (" + (this.tree.view.rowCount-1) + " ";
              if (this.tree.view.rowCount > 2) label += this.manyitems; // > 2 because we subtract 1 for 'All'
              else label += this.oneitem;
              label += ")";
            } else label += " (" + this.noitem + ")";
            column.element.setAttribute("label", label);
          }
        }
        this.filterString = this.source.getFilter(this.ref_pl, this.index);
        this.rebuildPending = false;
        
        // When we set filterString, it might detect that it can't restore any of its
        // previous selected items, so it will set this variable here to force the
        // selection to "All" after we are allowed to respond to selection events.
        if ( this.needsSelectionReset ) {
          // This'll make us have to rebuild.  Better not loop!
          this.tree.view.selection.rangedSelect(0, 0, true);
          this.needsSelectionReset = false;
        }
      </body>
    </method>

   </implementation> 

    <handlers>
      <handler event="select">
        this.onFilterListSelect();
      </handler>
    </handlers>

  </binding>

</bindings>
