<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright© 2006 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the “GPL”).
// 
// Software distributed under the License is distributed 
// on an “AS IS” basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="filterlist">
    <content>
      <xul:tree 
        xbl:inherits="enableColumnDrag=enableColumnDrag,hidecolumnpicker=hidecolumnpicker" 
        id="filter_tree" 
        ref="" 
        datasources="" 
        flags="dont-build-content"
        flex="1" 
        onselect="onFilterListSelect(event);"
      >
      </xul:tree>
    </content>

   <implementation type="application/x-javascript" implements="nsIXULBuilderListener">

    <constructor>
      this.tree.builder.addListener(this);
    </constructor>

    <destructor>
      this.tree.builder.removeListener(this);
    </destructor>

    <field name="tree">document.getAnonymousElementByAttribute(this, 'id', 'filter_tree');</field>
    <field name="source">null</field>
    <field name="playlist">null</field>
    <field name="builder">this.tree.builder</field>
    <field name="column"></field>
    <field name="ref_pl"></field>
    <field name="index">0</field>
    <field name="_disable_selevent">false</field>

    <property name="ref">
      <getter>
        return this.tree.getAttribute("ref");
      </getter>
      <setter>
        return this.tree.setAttribute("ref", val);
      </setter>
    </property>

    <property name="datasources">
      <getter>
        return this.tree.getAttribute("datasources");
      </getter>
      <setter>
        return this.tree.setAttribute("datasources", val);
      </setter>
    </property>

    <!-- Dynamic Columns/Template -->

    <method name="loadcolumn">
      <body>
      try
      {
        if (this.source == null) { /*alert("<playlist/>: source is null");*/ return; }
//        // Don't nuke the columns if there's no current query result.  Yipe.
//        var result = this.source.GetQueryResult( this.ref ); 
//        if ( result.GetColumnCount() )
        {
          this.removeColumns();
          this.removeTemplate(); 
          this.addNewContent(this.source, this.ref);
        }
      }
      catch( err )
      {
        alert( err );
      }
      </body>
    </method>

    <method name="addNewContent">
      <parameter name="source"/>
      <parameter name="ref"/>
      <body>
        <![CDATA[

          // Columns nodes parent
          var columns_node = document.createElement("treecols");

          // Template nodes parents
          var template_node = document.createElement("template");

          var rule_node = document.createElement("rule");

          var treechildren_node = document.createElement("treechildren");
          treechildren_node.setAttribute("flex", "1");

          var treeitem_node = document.createElement("treeitem");
          treeitem_node.setAttribute("uri", "rdf:*");

          var treerow_node = document.createElement("treerow");

          // Go through all the columns on the table and create nodes accordingly
          var result = source.GetQueryResult( ref );
          
          if ( !result )
          {
//            alert( "List " + ref + " has no resultset available?!" );
            return;
          } 

          var name = "";
          if ( this.column )
          {
            name = this.column;
          }
          else if ( result.GetColumnCount() ) 
          {
            this.column = result.GetColumnName( 0 );
            name = this.column;
          }
          
          if ( name.length )
          {
            var this_column_node = document.createElement("treecol");
            this_column_node.setAttribute("id", name);

            // Try to load the data
            var src = "chrome://songbird/locale/songbird.properties";
            var stringBundleService =
                Components.classes["@mozilla.org/intl/stringbundle;1"]
                .getService(Components.interfaces.nsIStringBundleService);
                
            var bundle = stringBundleService.createBundle( src );
            var human_name = name;
            var meta_name = name;
            try
            {
              meta_name = bundle.GetStringFromName( "metadata." + name );
            }
            catch( err )
            {
            }
            if ( meta_name && meta_name.length )
            {
              human_name = meta_name;
            }

            // This is not good, we should get the properties of each column from the db too !

            this_column_node.setAttribute("label", human_name);
            this_column_node.__filterlist_original_label__ = human_name;
            this_column_node.setAttribute("flex", "1");
            this_column_node.setAttribute("fixed", "false");
//            this_column_node.setAttribute("sortActive", "true");
//            this_column_node.setAttribute("sortDirection","ascending");
//            this_column_node.setAttribute("sort", "rdf:http://home.netscape.com/NC-rdf#" + name);

            columns_node.appendChild(this_column_node);

            var treecell_node = document.createElement("treecell");
            treecell_node.setAttribute("label", "rdf:http://home.netscape.com/NC-rdf#"+name);
            treerow_node.appendChild(treecell_node);
          }

          // Now add columns and template node hierarchy to the tree
          this.tree.insertBefore(columns_node, null);

          treeitem_node.appendChild(treerow_node); 
          treechildren_node.appendChild(treeitem_node);
          rule_node.appendChild(treechildren_node);
          template_node.appendChild(rule_node);
          this.tree.appendChild(template_node);
        ]]>
      </body>
    </method> 

    <!-- Selection/Filter handling -->

    <method name="onFilterListSelect">
      <parameter name="event"/>
      <body>
        <![CDATA[
          try
          {
            if (this._disable_selevent) { return; }
            if (this.source == null) { alert("<filterlist/>: source is null"); return; }

            // Concatenate all of the selections into a semicolon delimited filter string
            var filter_string = "";      
            var rangeCount = this.tree.view.selection.getRangeCount();
            var column = this.tree.columns.getColumnAt(0);
            var anything_besides_zero = false;
            var including_zero = false;
            for ( var i=0; column != null && i < rangeCount; i++ )
            {
              var start = {};
              var end = {};
              this.tree.view.selection.getRangeAt( i, start, end );
              for( var c = start.value; c <= end.value; c++ )
              {
                // Check for stupid things.
                if ( c >= this.tree.view.rowCount )
                  return; // WTF?
                filter_string += ";" + this.tree.view.getCellText( c, column );
                // Zero is "All"
                if ( c != 0 )
                  anything_besides_zero = true;
                else
                  including_zero = true;
              }
            }
            // If there isn't anything selected or we've selected 'All'
            if ( ! anything_besides_zero || including_zero )
            {
              // Reset the filter
              filter_string = "";
            }
            // If there's anything else selected along with 'All'
            if ( anything_besides_zero && including_zero )
            {
              // Select only 'All'
              this.tree.view.selection.rangedSelect(0, 0, false);
            }
            
            if ( rangeCount )
            {
              // Set the filter and relaunch the queries
              this.source.SetFilter( this.ref_pl, this.index, filter_string, this.ref, this.column );
              this.source.FeedFilters( this.ref_pl );

              // Fire an event, in case someone wants it          
              var e = document.createEvent("Events");
              e.initEvent("filterlist-filterchange", false, true);
              this.dispatchEvent(e);
            }
          }
          catch( err )
          {
            alert( err );
          }
        ]]>
      </body>
    </method> 

    <!-- Tree Manipulation Functions -->

    <method name="removeColumns">
      <body>
          this.removeChildByName("treecols");
      </body>
    </method>

    <method name="removeTemplate">
      <body>
          this.removeChildByName("template");
      </body>
    </method>

    <method name="removeChildByName">
      <parameter name="childname"/>
      <body>
        <![CDATA[
          var n = this.tree.childNodes.length;
          for (var i=0;i<this.tree.childNodes.length;i++) {
            var node = this.tree.childNodes.item(i);
            if (node.tagName == childname ||
                node.tagName == "xul:"+childname) {
              this.tree.removeChild(node);
              i--;
            }
          }
        ]]>
      </body>
    </method>
    
    <!-- Selection restore -->
    <method name="findCell">
      <parameter name="column"/>
      <parameter name="value"/>
      <body>
        <![CDATA[
          try
          {
            var n = this.tree.view.rowCount;
            for( var c = 0; c < n; c++ )
            {
              var cell = this.tree.view.getCellText( c, column );
              if (cell == value) return c;
            }
          }
          catch( err )
          {
            alert( err );
          }
          return -1;
        ]]>
      </body>
    </method>

    <method name="selectAtLeastAll">
      <body>
        <![CDATA[
          try
          {
            if (this.tree.columns && this.tree.columns.count > 0 && this.tree.view.rowCount > 0) {
              this._disable_selevent = true;
              if (this.tree.view.selection.count == 0) {
                this.tree.view.selection.rangedSelect(0, 0, true);
              }
            }
          }
          catch( err )
          {
            alert( err );
          }
          finally 
          {
            this._disable_selevent = false;
          }
        ]]>
      </body>
    </method>
    
    <method name="reselectFilter">
      <body>
        <![CDATA[
          try
          {
            var any_items = false; // Are there any items to find?
            var any_found = false; // Did we find any?
            if (this.source != null) {
              var selection_string = this.source.GetFilter(this.ref_pl, this.index);
              if (selection_string != null) {
                var selection = selection_string.split(";");
                this._disable_selevent = true;
                var column = this.tree.columns.getColumnAt(0);
                while (selection.length > 0) {
                  var value = selection.pop();
                  if (value != "" && value != null) {
                    any_items = true;
                    var vindex = this.findCell(column, value);
                    if (vindex != -1) {
                      any_found = true;
                      this.tree.view.selection.rangedSelect(vindex, vindex, true);
                    }
                  }
                }
              }
            }
            if ( any_items && ! any_found ) { // If we weren't able to restore any of our previous selection
              if (this.tree.view.selection.count == 0) { // Select the "All," without blocking the filtering action
                var prev = this._disable_selevent;
                this._disable_selevent = false;
                this.tree.view.selection.rangedSelect(0, 0, true);
                this._disable_selevent = prev;
              }
            } // This can happen when we delete all the tracks of a filter
          }
          catch( err )
          {
            alert( err );
          }
          finally 
          {
            this._disable_selevent = false;
          }
        ]]>

      </body>
    </method>

    <!-- nsIXULBuilderListener implementation -->

    <method name="willRebuild">
      <param name="builder"/>
      <body>
        if (this.ref != null) this.loadcolumn(); 
      </body>
    </method>

    <method name="didRebuild">
      <param name="builder"/>
      <body>
        if (this.tree.view.rowCount > 0) {
          var column = this.tree.columns.getColumnAt(0);
          if (column != null) {
            var label = column.element.__filterlist_original_label__;
            if ( this.source.GetRefColumnCount( this.ref ) > 0 ) {
              label += " (" + (this.tree.view.rowCount-1) + " item";
              if (this.tree.view.rowCount > 1) label += "s";
              label += ")";
            } else label += " (no item)";
            column.element.setAttribute("label", label);
          }
        }
        this.reselectFilter();
        this.selectAtLeastAll();
      </body>
    </method>

   </implementation> 
 
  </binding>

</bindings>
